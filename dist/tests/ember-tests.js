(function() {
/*!
 * @overview  Ember - JavaScript Application Framework
 * @copyright Copyright 2011 Tilde Inc. and contributors
 *            Portions Copyright 2006-2011 Strobe Inc.
 *            Portions Copyright 2008-2011 Apple Inc. All rights reserved.
 * @license   Licensed under MIT license
 *            See https://raw.github.com/emberjs/ember.js/master/LICENSE
 * @version   5.7.0-alpha.1.canary+5c193293
 */

/* eslint-disable no-var */
/* globals global globalThis self */
/* eslint-disable-next-line no-unused-vars */
var define, require;

(function () {
  var globalObj =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : null;

  if (globalObj === null) {
    throw new Error('unable to locate global object');
  }

  if (typeof globalObj.define === 'function' && typeof globalObj.require === 'function') {
    define = globalObj.define;
    require = globalObj.require;

    return;
  }

  var registry = Object.create(null);
  var seen = Object.create(null);

  function missingModule(name, referrerName) {
    if (referrerName) {
      throw new Error('Could not find module ' + name + ' required by: ' + referrerName);
    } else {
      throw new Error('Could not find module ' + name);
    }
  }

  function internalRequire(_name, referrerName) {
    var name = _name;
    var mod = registry[name];

    if (!mod) {
      name = name + '/index';
      mod = registry[name];
    }

    var exports = seen[name];

    if (exports !== undefined) {
      return exports;
    }

    exports = seen[name] = {};

    if (!mod) {
      missingModule(_name, referrerName);
    }

    var deps = mod.deps;
    var callback = mod.callback;
    var reified = new Array(deps.length);

    for (var i = 0; i < deps.length; i++) {
      if (deps[i] === 'exports') {
        reified[i] = exports;
      } else if (deps[i] === 'require') {
        reified[i] = require;
      } else {
        reified[i] = require(deps[i], name);
      }
    }

    callback.apply(this, reified);

    return exports;
  }

  require = function (name) {
    return internalRequire(name, null);
  };

  define = function (name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  // setup `require` module
  require['default'] = require;

  require.has = function registryHas(moduleName) {
    return Boolean(registry[moduleName]) || Boolean(registry[moduleName + '/index']);
  };

  require._eak_seen = require.entries = registry;
})();

define("@ember/-internals/container/tests/container_test", ["@ember/-internals/owner", "@ember/service", "@ember/-internals/container", "internal-test-helpers"], function (_owner, _service, _container, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Container.lookup', class extends _internalTestHelpers.AbstractTestCase {
    ['@test lookup returns a fresh instance if singleton: false is passed as an option'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      let postController1 = container.lookup('controller:post');
      let postController2 = container.lookup('controller:post', {
        singleton: false
      });
      let postController3 = container.lookup('controller:post', {
        singleton: false
      });
      let postController4 = container.lookup('controller:post');
      assert.equal(postController1.toString(), postController4.toString(), 'Singleton factories looked up normally return the same value');
      assert.notEqual(postController1.toString(), postController2.toString(), 'Singleton factories are not equal to factories looked up with singleton: false');
      assert.notEqual(postController2.toString(), postController3.toString(), 'Two factories looked up with singleton: false are not equal');
      assert.notEqual(postController3.toString(), postController4.toString(), 'A singleton factory looked up after a factory called with singleton: false is not equal');
      assert.ok(postController1 instanceof PostController, 'All instances are instances of the registered factory');
      assert.ok(postController2 instanceof PostController, 'All instances are instances of the registered factory');
      assert.ok(postController3 instanceof PostController, 'All instances are instances of the registered factory');
      assert.ok(postController4 instanceof PostController, 'All instances are instances of the registered factory');
    }
    ['@test lookup returns a fresh instance if singleton: false is passed as an option to lookup'](assert) {
      class TestFactory {
        constructor(opts) {
          Object.assign(this, opts);
        }
        static create(opts) {
          return new this(opts);
        }
      }
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('thing:test/obj', TestFactory);
      let instance1 = container.lookup('thing:test/obj');
      let instance2 = container.lookup('thing:test/obj', {
        singleton: false
      });
      let instance3 = container.lookup('thing:test/obj', {
        singleton: false
      });
      let instance4 = container.lookup('thing:test/obj');
      assert.ok(instance1 === instance4, 'factories looked up up without singleton: false are the same instance');
      assert.ok(instance1 !== instance2, 'factories looked up with singleton: false are a different instance');
      assert.ok(instance2 !== instance3, 'factories looked up with singleton: false are a different instance');
      assert.ok(instance3 !== instance4, 'factories looked up after a call to singleton: false is a different instance');
      assert.ok(instance1 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance2 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance3 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance4 instanceof TestFactory, 'All instances are instances of the registered factory');
    }
    ['@test lookup returns a fresh instance if singleton: false is passed as an option to register'](assert) {
      class TestFactory {
        constructor(opts) {
          Object.assign(this, opts);
        }
        static create(opts) {
          return new this(opts);
        }
      }
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('thing:test/obj', TestFactory, {
        singleton: false
      });
      let instance1 = container.lookup('thing:test/obj');
      let instance2 = container.lookup('thing:test/obj');
      let instance3 = container.lookup('thing:test/obj');
      assert.ok(instance1 !== instance2, 'each lookup is a different instance');
      assert.ok(instance2 !== instance3, 'each lookup is a different instance');
      assert.ok(instance1 !== instance3, 'each lookup is a different instance');
      assert.ok(instance1 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance2 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance3 instanceof TestFactory, 'All instances are instances of the registered factory');
    }
    ['@test lookup returns a singleton instance if singleton: true is passed as an option even if registered as singleton: false'](assert) {
      class TestFactory {
        constructor(opts) {
          Object.assign(this, opts);
        }
        static create(opts) {
          return new this(opts);
        }
      }
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('thing:test/obj', TestFactory, {
        singleton: false
      });
      let instance1 = container.lookup('thing:test/obj');
      let instance2 = container.lookup('thing:test/obj', {
        singleton: true
      });
      let instance3 = container.lookup('thing:test/obj', {
        singleton: true
      });
      let instance4 = container.lookup('thing:test/obj');
      assert.ok(instance1 !== instance2, 'each lookup is a different instance');
      assert.ok(instance2 === instance3, 'each singleton: true lookup is the same instance');
      assert.ok(instance3 !== instance4, 'each lookup is a different instance');
      assert.ok(instance1 !== instance4, 'each lookup is a different instance');
      assert.ok(instance1 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance2 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance3 instanceof TestFactory, 'All instances are instances of the registered factory');
      assert.ok(instance4 instanceof TestFactory, 'All instances are instances of the registered factory');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Container', class extends _internalTestHelpers.AbstractTestCase {
    ['@test A registered factory returns the same instance each time'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      let postController = container.lookup('controller:post');
      assert.ok(postController instanceof PostController, 'The lookup is an instance of the factory');
      assert.equal(postController, container.lookup('controller:post'));
    }
    ['@test A non-singleton instance is never cached'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostView = (0, _internalTestHelpers.factory)();
      registry.register('view:post', PostView, {
        singleton: false
      });
      let postView1 = container.lookup('view:post');
      let postView2 = container.lookup('view:post');
      assert.ok(postView1 !== postView2, 'Non-singletons are not cached');
    }
    ['@test A non-instantiated property is not instantiated'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let template = function () {};
      registry.register('template:foo', template, {
        instantiate: false
      });
      assert.equal(container.lookup('template:foo'), template);
    }
    ['@test A failed lookup returns undefined'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      assert.equal(container.lookup('doesnot:exist'), undefined);
    }
    ['@test An invalid factory throws an error']() {
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('controller:foo', {});
      expectAssertion(() => {
        container.lookup('controller:foo');
      }, /Failed to create an instance of 'controller:foo'/);
    }
    ['@test The container returns same value each time even if the value is falsey'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('falsy:value', null, {
        instantiate: false
      });
      assert.strictEqual(container.lookup('falsy:value'), container.lookup('falsy:value'));
    }
    ['@test The container can use a registry hook to resolve factories lazily'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.resolver = {
        resolve(fullName) {
          if (fullName === 'controller:post') {
            return PostController;
          }
        }
      };
      let postController = container.lookup('controller:post');
      assert.ok(postController instanceof PostController, 'The correct factory was provided');
    }
    ['@test The container normalizes names before resolving'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.normalizeFullName = function () {
        return 'controller:post';
      };
      registry.register('controller:post', PostController);
      let postController = container.lookup('controller:normalized');
      assert.ok(postController instanceof PostController, 'Normalizes the name before resolving');
    }
    ['@test The container normalizes names when looking factory up'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.normalizeFullName = function () {
        return 'controller:post';
      };
      registry.register('controller:post', PostController);
      let fact = container.factoryFor('controller:normalized');
      let factInstance = fact.create();
      assert.ok(factInstance instanceof PostController, 'Normalizes the name');
    }
    ['@test Options can be registered that should be applied to a given factory'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostView = (0, _internalTestHelpers.factory)();
      registry.resolver = {
        resolve(fullName) {
          if (fullName === 'view:post') {
            return PostView;
          }
        }
      };
      registry.options('view:post', {
        instantiate: true,
        singleton: false
      });
      let postView1 = container.lookup('view:post');
      let postView2 = container.lookup('view:post');
      assert.ok(postView1 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView2 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView1 !== postView2, 'The two lookups are different');
    }
    ['@test Options can be registered that should be applied to all factories for a given type'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostView = (0, _internalTestHelpers.factory)();
      registry.resolver = {
        resolve(fullName) {
          if (fullName === 'view:post') {
            return PostView;
          }
        }
      };
      registry.optionsForType('view', {
        singleton: false
      });
      let postView1 = container.lookup('view:post');
      let postView2 = container.lookup('view:post');
      assert.ok(postView1 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView2 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView1 !== postView2, 'The two lookups are different');
    }
    ['@test Factory resolves are cached'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      let resolveWasCalled = [];
      registry.resolve = function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      };
      assert.deepEqual(resolveWasCalled, []);
      container.factoryFor('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
      container.factoryFor('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
    }
    ['@test factory for non extendables (MODEL) resolves are cached'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = (0, _internalTestHelpers.factory)();
      let resolveWasCalled = [];
      registry.resolve = function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      };
      assert.deepEqual(resolveWasCalled, []);
      container.factoryFor('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
      container.factoryFor('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
    }
    ['@test factory for non extendables resolves are cached'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let PostController = {};
      let resolveWasCalled = [];
      registry.resolve = function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      };
      assert.deepEqual(resolveWasCalled, []);
      container.factoryFor('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
      container.factoryFor('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
    }
    ["@test A factory's lazy injections are validated when first instantiated"]() {
      let registry = new _container.Registry();
      let container = registry.container();
      let Apple = (0, _internalTestHelpers.factory)();
      let Orange = (0, _internalTestHelpers.factory)();
      Apple.reopenClass({
        _lazyInjections() {
          return [{
            specifier: 'orange:main'
          }, {
            specifier: 'banana:main'
          }];
        }
      });
      registry.register('apple:main', Apple);
      registry.register('orange:main', Orange);
      expectAssertion(() => {
        container.lookup('apple:main');
      }, /Attempting to inject an unknown injection: 'banana:main'/);
    }
    ['@test Lazy injection validations are cached'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.expect(1);
      let registry = new _container.Registry();
      let container = registry.container();
      let Apple = (0, _internalTestHelpers.factory)();
      let Orange = (0, _internalTestHelpers.factory)();
      Apple.reopenClass({
        _lazyInjections: () => {
          assert.ok(true, 'should call lazy injection method');
          return [{
            specifier: 'orange:main'
          }];
        }
      });
      registry.register('apple:main', Apple);
      registry.register('orange:main', Orange);
      container.lookup('apple:main');
      container.lookup('apple:main');
    }
    ['@test An object with its owner pre-set should be returned from ownerInjection'](assert) {
      let owner = {};
      let registry = new _container.Registry();
      let container = registry.container({
        owner
      });
      let result = container.ownerInjection();
      assert.equal((0, _owner.getOwner)(result), owner, 'owner is properly included');
    }
    ['@test ownerInjection should be usable to create a service for testing'](assert) {
      assert.expect(0);
      let owner = {};
      let registry = new _container.Registry();
      let container = registry.container({
        owner
      });
      let result = container.ownerInjection();
      _service.default.create(result);
    }
    ['@test #factoryFor class is registered class'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      let factoryManager = container.factoryFor('component:foo-bar');
      assert.deepEqual(factoryManager.class, Component, 'No double extend');
    }
    ['@test #factoryFor must supply a fullname']() {
      let registry = new _container.Registry();
      let container = registry.container();
      expectAssertion(() => {
        container.factoryFor('chad-bar');
      }, /fullName must be a proper full name/);
    }
    ['@test #factoryFor returns a factory manager'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      let factoryManager = container.factoryFor('component:foo-bar');
      assert.ok(factoryManager.create);
      assert.ok(factoryManager.class);
    }
    ['@test #factoryFor returns a cached factory manager for the same type'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      registry.register('component:baz-bar', Component);
      let factoryManager1 = container.factoryFor('component:foo-bar');
      let factoryManager2 = container.factoryFor('component:foo-bar');
      let factoryManager3 = container.factoryFor('component:baz-bar');
      assert.equal(factoryManager1, factoryManager2, 'cache hit');
      assert.notEqual(factoryManager1, factoryManager3, 'cache miss');
    }
    ['@test #factoryFor class returns the factory function'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      let factoryManager = container.factoryFor('component:foo-bar');
      assert.deepEqual(factoryManager.class, Component, 'No double extend');
    }
    ['@test #factoryFor instance have a common parent'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      let factoryManager1 = container.factoryFor('component:foo-bar');
      let factoryManager2 = container.factoryFor('component:foo-bar');
      let instance1 = factoryManager1.create({
        foo: 'foo'
      });
      let instance2 = factoryManager2.create({
        bar: 'bar'
      });
      assert.deepEqual(instance1.constructor, instance2.constructor);
    }
    ['@test can properly reset cache'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      let factory1 = container.factoryFor('component:foo-bar');
      let factory2 = container.factoryFor('component:foo-bar');
      let instance1 = container.lookup('component:foo-bar');
      let instance2 = container.lookup('component:foo-bar');
      assert.equal(instance1, instance2);
      assert.equal(factory1, factory2);
      container.reset();
      let factory3 = container.factoryFor('component:foo-bar');
      let instance3 = container.lookup('component:foo-bar');
      assert.notEqual(instance1, instance3);
      assert.notEqual(factory1, factory3);
    }
    ["@test assert when calling lookup after destroy on a container"](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('service:foo', (0, _internalTestHelpers.factory)());
      let instance = container.lookup('service:foo');
      assert.ok(instance, 'precond lookup successful');
      (0, _internalTestHelpers.runTask)(() => {
        container.destroy();
        container.finalizeDestroy();
      });
      assert.throws(() => {
        container.lookup('service:foo');
      }, "Cannot call `.lookup('service:foo')` after the owner has been destroyed");
    }
    ["@test assert when calling factoryFor after destroy on a container"](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('service:foo', (0, _internalTestHelpers.factory)());
      let instance = container.lookup('service:foo');
      assert.ok(instance, 'precond lookup successful');
      (0, _internalTestHelpers.runTask)(() => {
        container.destroy();
        container.finalizeDestroy();
      });
      assert.throws(() => {
        container.factoryFor('service:foo');
      }, "Cannot call `.factoryFor('service:foo')` after the owner has been destroyed");
    }

    // this is skipped until templates and the glimmer environment do not require `OWNER` to be
    // passed in as constructor args
    ['@skip #factoryFor does not add properties to the object being instantiated'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      class Component {
        static create(options) {
          let instance = new this();
          Object.assign(instance, options);
          return instance;
        }
      }
      registry.register('component:foo-bar', Component);
      let componentFactory = container.factoryFor('component:foo-bar');
      let instance = componentFactory.create();

      // note: _guid and isDestroyed are being set in the `factory` constructor
      // not via registry/container shenanigans
      assert.deepEqual(Object.keys(instance), []);
    }
    '@test instantiating via container.lookup during destruction enqueues destruction'(assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      let otherInstance;
      class Service extends (0, _internalTestHelpers.factory)() {
        destroy() {
          otherInstance = container.lookup('service:other');
          assert.ok(otherInstance.isDestroyed, 'service:other was destroyed');
        }
      }
      registry.register('service:foo', Service);
      registry.register('service:other', (0, _internalTestHelpers.factory)());
      let instance = container.lookup('service:foo');
      assert.ok(instance, 'precond lookup successful');
      (0, _internalTestHelpers.runTask)(() => {
        container.destroy();
        container.finalizeDestroy();
      });
    }
    '@test instantiating via container.factoryFor().create() after destruction throws an error'(assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      registry.register('service:foo', (0, _internalTestHelpers.factory)());
      registry.register('service:other', (0, _internalTestHelpers.factory)());
      let Factory = container.factoryFor('service:other');
      (0, _internalTestHelpers.runTask)(() => {
        container.destroy();
        container.finalizeDestroy();
      });
      assert.throws(() => {
        Factory.create();
      }, /Cannot create new instances after the owner has been destroyed \(you attempted to create service:other\)/);
    }
  });
});
define("@ember/-internals/container/tests/owner_test", ["@ember/-internals/owner", "internal-test-helpers"], function (_owner, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Owner', class extends _internalTestHelpers.AbstractTestCase {
    ['@test An owner can be set with `setOwner` and retrieved with `getOwner`'](assert) {
      let owner = {};
      let obj = {};
      assert.strictEqual((0, _owner.getOwner)(obj), undefined, 'owner has not been set');
      (0, _owner.setOwner)(obj, owner);
      assert.strictEqual((0, _owner.getOwner)(obj), owner, 'owner has been set');
    }
  });
});
define("@ember/-internals/container/tests/registry_test", ["@ember/-internals/container", "internal-test-helpers"], function (_container, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Registry', class extends _internalTestHelpers.AbstractTestCase {
    ['@test A registered factory is returned from resolve'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      let PostControllerFactory = registry.resolve('controller:post');
      assert.ok(PostControllerFactory, 'factory is returned');
      assert.ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
    }
    ['@test The registered factory returned from resolve is the same factory each time'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      assert.deepEqual(registry.resolve('controller:post'), registry.resolve('controller:post'), 'The return of resolve is always the same');
    }
    ['@test The registered value returned from resolve is the same value each time even if the value is falsy'](assert) {
      let registry = new _container.Registry();
      registry.register('falsy:value', null, {
        instantiate: false
      });
      assert.strictEqual(registry.resolve('falsy:value'), registry.resolve('falsy:value'), 'The return of resolve is always the same');
    }
    ['@test The value returned from resolver is the same value as the original value even if the value is falsy'](assert) {
      let resolver = {
        resolve(fullName) {
          if (fullName === 'falsy:value') {
            return null;
          }
        }
      };
      let registry = new _container.Registry({
        resolver
      });
      assert.strictEqual(registry.resolve('falsy:value'), null);
    }
    ['@test A registered factory returns true for `has` if an item is registered'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      assert.equal(registry.has('controller:post'), true, 'The `has` method returned true for registered factories');
      assert.equal(registry.has('controller:posts'), false, 'The `has` method returned false for unregistered factories');
    }
    ['@test The registry can take a hook to resolve factories lazily'](assert) {
      let PostController = (0, _internalTestHelpers.factory)();
      let resolver = {
        resolve(fullName) {
          if (fullName === 'controller:post') {
            return PostController;
          }
        }
      };
      let registry = new _container.Registry({
        resolver
      });
      assert.strictEqual(registry.resolve('controller:post'), PostController, 'The correct factory was provided');
    }
    ['@test The registry respects the resolver hook for `has`'](assert) {
      let PostController = (0, _internalTestHelpers.factory)();
      let resolver = {
        resolve(fullName) {
          if (fullName === 'controller:post') {
            return PostController;
          }
        }
      };
      let registry = new _container.Registry({
        resolver
      });
      assert.ok(registry.has('controller:post'), 'the `has` method uses the resolver hook');
    }
    ['@test The registry normalizes names when resolving'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.normalizeFullName = function () {
        return 'controller:post';
      };
      registry.register('controller:post', PostController);
      let type = registry.resolve('controller:normalized');
      assert.strictEqual(type, PostController, 'Normalizes the name when resolving');
    }
    ['@test The registry normalizes names when checking if the factory is registered'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.normalizeFullName = function (fullName) {
        return fullName === 'controller:normalized' ? 'controller:post' : fullName;
      };
      registry.register('controller:post', PostController);
      let isPresent = registry.has('controller:normalized');
      assert.equal(isPresent, true, 'Normalizes the name when checking if the factory or instance is present');
    }
    ['@test cannot register an `undefined` factory']() {
      let registry = new _container.Registry();
      expectAssertion(() => {
        registry.register('controller:apple', undefined);
      }, '');
    }
    ['@test can re-register a factory'](assert) {
      let registry = new _container.Registry();
      let FirstApple = (0, _internalTestHelpers.factory)('first');
      let SecondApple = (0, _internalTestHelpers.factory)('second');
      registry.register('controller:apple', FirstApple);
      registry.register('controller:apple', SecondApple);
      assert.ok(registry.resolve('controller:apple').create() instanceof SecondApple);
    }
    ['@test cannot re-register a factory if it has been resolved'](assert) {
      let registry = new _container.Registry();
      let FirstApple = (0, _internalTestHelpers.factory)('first');
      let SecondApple = (0, _internalTestHelpers.factory)('second');
      registry.register('controller:apple', FirstApple);
      assert.strictEqual(registry.resolve('controller:apple'), FirstApple);
      expectAssertion(function () {
        registry.register('controller:apple', SecondApple);
      }, /Cannot re-register: 'controller:apple', as it has already been resolved\./);
      assert.strictEqual(registry.resolve('controller:apple'), FirstApple);
    }
    ['@test registry.has should not error for invalid fullNames'](assert) {
      let registry = new _container.Registry();
      assert.ok(!registry.has('foo:bar:baz'));
    }
    ['@test once resolved, always return the same result'](assert) {
      let registry = new _container.Registry();
      registry.resolver = {
        resolve() {
          return 'bar';
        }
      };
      let Bar = registry.resolve('models:bar');
      registry.resolver = {
        resolve() {
          return 'not bar';
        }
      };
      assert.equal(registry.resolve('models:bar'), Bar);
    }
    ['@test factory resolves are cached'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      let resolveWasCalled = [];
      registry.resolver = {
        resolve(fullName) {
          resolveWasCalled.push(fullName);
          return PostController;
        }
      };
      assert.deepEqual(resolveWasCalled, []);
      registry.resolve('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
      registry.resolve('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
    }
    ['@test factory for non extendables (MODEL) resolves are cached'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      let resolveWasCalled = [];
      registry.resolver = {
        resolve(fullName) {
          resolveWasCalled.push(fullName);
          return PostController;
        }
      };
      assert.deepEqual(resolveWasCalled, []);
      registry.resolve('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
      registry.resolve('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
    }
    ['@test factory for non extendables resolves are cached'](assert) {
      let registry = new _container.Registry();
      let PostController = {};
      let resolveWasCalled = [];
      registry.resolver = {
        resolve(fullName) {
          resolveWasCalled.push(fullName);
          return PostController;
        }
      };
      assert.deepEqual(resolveWasCalled, []);
      registry.resolve('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
      registry.resolve('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
    }
    ['@test registry.container creates a container'](assert) {
      let registry = new _container.Registry();
      let PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      let container = registry.container();
      let postController = container.lookup('controller:post');
      assert.ok(postController instanceof PostController, 'The lookup is an instance of the registered factory');
    }
    ['@test `describe` will be handled by the resolver, then by the fallback registry, if available'](assert) {
      let fallback = {
        describe(fullName) {
          return fullName + "-fallback";
        }
      };
      let resolver = {
        lookupDescription(fullName) {
          return fullName + "-resolver";
        }
      };
      let registry = new _container.Registry({
        fallback,
        resolver
      });
      assert.equal(registry.describe('controller:post'), 'controller:post-resolver', '`describe` handled by the resolver first.');
      registry.resolver = null;
      assert.equal(registry.describe('controller:post'), 'controller:post-fallback', '`describe` handled by fallback registry next.');
      registry.fallback = null;
      assert.equal(registry.describe('controller:post'), 'controller:post', '`describe` by default returns argument.');
    }
    ['@test `normalizeFullName` will be handled by the resolver, then by the fallback registry, if available'](assert) {
      let fallback = {
        normalizeFullName(fullName) {
          return fullName + "-fallback";
        }
      };
      let resolver = {
        normalize(fullName) {
          return fullName + "-resolver";
        }
      };
      let registry = new _container.Registry({
        fallback,
        resolver
      });
      assert.equal(registry.normalizeFullName('controller:post'), 'controller:post-resolver', '`normalizeFullName` handled by the resolver first.');
      registry.resolver = null;
      assert.equal(registry.normalizeFullName('controller:post'), 'controller:post-fallback', '`normalizeFullName` handled by fallback registry next.');
      registry.fallback = null;
      assert.equal(registry.normalizeFullName('controller:post'), 'controller:post', '`normalizeFullName` by default returns argument.');
    }
    ['@test `makeToString` will be handled by the resolver, then by the fallback registry, if available'](assert) {
      let fallback = {
        makeToString(fullName) {
          return fullName + "-fallback";
        }
      };
      let resolver = {
        makeToString(fullName) {
          return fullName + "-resolver";
        }
      };
      let registry = new _container.Registry({
        fallback,
        resolver
      });
      assert.equal(registry.makeToString('controller:post'), 'controller:post-resolver', '`makeToString` handled by the resolver first.');
      registry.resolver = null;
      assert.equal(registry.makeToString('controller:post'), 'controller:post-fallback', '`makeToString` handled by fallback registry next.');
      registry.fallback = null;
      assert.equal(registry.makeToString('controller:post'), 'controller:post', '`makeToString` by default returns argument.');
    }
    ['@test `resolve` can be handled by a fallback registry'](assert) {
      let fallback = new _container.Registry();
      let registry = new _container.Registry({
        fallback: fallback
      });
      let PostController = (0, _internalTestHelpers.factory)();
      fallback.register('controller:post', PostController);
      let PostControllerFactory = registry.resolve('controller:post');
      assert.ok(PostControllerFactory, 'factory is returned');
      assert.ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
    }
    ['@test `has` can be handled by a fallback registry'](assert) {
      let fallback = new _container.Registry();
      let registry = new _container.Registry({
        fallback: fallback
      });
      let PostController = (0, _internalTestHelpers.factory)();
      fallback.register('controller:post', PostController);
      assert.equal(registry.has('controller:post'), true, 'Fallback registry is checked for registration');
    }
    ['@test `knownForType` contains keys for each item of a given type'](assert) {
      let registry = new _container.Registry();
      registry.register('foo:bar-baz', 'baz');
      registry.register('foo:qux-fez', 'fez');
      let found = registry.knownForType('foo');
      assert.deepEqual(found, {
        'foo:bar-baz': true,
        'foo:qux-fez': true
      });
    }
    ['@test `knownForType` includes fallback registry results'](assert) {
      let fallback = new _container.Registry();
      let registry = new _container.Registry({
        fallback: fallback
      });
      registry.register('foo:bar-baz', 'baz');
      registry.register('foo:qux-fez', 'fez');
      fallback.register('foo:zurp-zorp', 'zorp');
      let found = registry.knownForType('foo');
      assert.deepEqual(found, {
        'foo:bar-baz': true,
        'foo:qux-fez': true,
        'foo:zurp-zorp': true
      });
    }
    ['@test `knownForType` is called on the resolver if present'](assert) {
      assert.expect(3);
      let resolver = {
        knownForType(type) {
          assert.ok(true, 'knownForType called on the resolver');
          assert.equal(type, 'foo', 'the type was passed through');
          return {
            'foo:yorp': true
          };
        }
      };
      let registry = new _container.Registry({
        resolver
      });
      registry.register('foo:bar-baz', 'baz');
      let found = registry.knownForType('foo');
      assert.deepEqual(found, {
        'foo:yorp': true,
        'foo:bar-baz': true
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Registry privatize', class extends _internalTestHelpers.AbstractTestCase {
    ['@test valid format'](assert) {
      let privatized = (0, _container.privatize)(['secret:factory']);
      let matched = privatized.match(/^([^:]+):([^:]+)-(\d+)$/);
      assert.ok(matched, 'privatized format was recognized');
      assert.equal(matched[1], 'secret');
      assert.equal(matched[2], 'factory');
      assert.ok(/^\d+$/.test(matched[3]));
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/application/actions-test", ["internal-test-helpers", "@ember/controller", "@ember/debug", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _controller, _debug, _helpers) {
  "use strict";

  const originalDebug = (0, _debug.getDebugFunction)('debug');
  const noop = function () {};
  (0, _internalTestHelpers.moduleFor)('Application test: actions', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      (0, _debug.setDebugFunction)('debug', noop);
      super(...arguments);
    }
    teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    }
    ['@test actions in top level template application template target application controller'](assert) {
      assert.expect(1);
      this.add('controller:application', _controller.default.extend({
        actions: {
          handleIt() {
            assert.ok(true, 'controller received action properly');
          }
        }
      }));
      this.addTemplate('application', '<button id="handle-it" {{action "handleIt"}}>Click!</button>');
      return this.visit('/').then(() => {
        (0, _internalTestHelpers.runTask)(() => this.$('#handle-it').click());
      });
    }
    ['@test actions in nested outlet template target their controller'](assert) {
      assert.expect(1);
      this.add('controller:application', _controller.default.extend({
        actions: {
          handleIt() {
            assert.ok(false, 'application controller should not have received action!');
          }
        }
      }));
      this.add('controller:index', _controller.default.extend({
        actions: {
          handleIt() {
            assert.ok(true, 'controller received action properly');
          }
        }
      }));
      this.addTemplate('index', '<button id="handle-it" {{action "handleIt"}}>Click!</button>');
      return this.visit('/').then(() => {
        (0, _internalTestHelpers.runTask)(() => this.$('#handle-it').click());
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Rendering test: non-interactive actions', class extends _internalTestHelpers.RenderingTestCase {
    getBootOptions() {
      return {
        isInteractive: false
      };
    }
    ["@test doesn't attatch actions"](assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            fire() {
              assert.ok(false);
            }
          }
        }),
        template: "<button {{action 'fire'}}>Fire!</button>"
      });
      this.render('{{foo-bar tagName=""}}');
      this.assertHTML('<button>Fire!</button>');
      this.$('button').click();
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/application/debug-render-tree-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/-internals/glimmer", "@ember/routing/route", "@ember/controller", "@ember/debug", "@ember/engine", "@glimmer/manager", "@glimmer/runtime", "@glimmer/util", "ember-template-compiler", "internal-test-helpers/lib/run"], function (_emberBabel, _internalTestHelpers, _environment, _glimmer, _route, _controller, _debug, _engine, _manager, _runtime, _util, _emberTemplateCompiler, _run) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13;
  function compileTemplate(templateSource, options) {
    return (0, _emberTemplateCompiler.compile)(templateSource, options);
  }
  function isExpectedFunc(expected) {
    return typeof expected === 'function';
  }
  if (_environment.ENV._DEBUG_RENDER_TREE) {
    (0, _internalTestHelpers.moduleFor)('Application test: debug render tree', class extends _internalTestHelpers.ApplicationTestCase {
      constructor(assert) {
        super(assert);
        this._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
        _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
      }
      teardown() {
        super.teardown();
        _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      }
      async '@test routes'() {
        this.addTemplate('index', 'Index');
        this.addTemplate('foo', 'Foo {{outlet}}');
        this.addTemplate('foo.index', 'index');
        this.addTemplate('foo.inner', '{{@model}}');
        this.addTemplate('bar', 'Bar {{outlet}}');
        this.addTemplate('bar.index', 'index');
        this.addTemplate('bar.inner', '{{@model}}');
        this.router.map(function () {
          this.route('foo', function () {
            this.route('inner', {
              path: '/:model'
            });
          });
          this.route('foo', function () {
            this.route('inner', {
              path: '/:model'
            });
          });
        });
        class PassThroughRoute extends _route.default {
          model(_ref) {
            let {
              model
            } = _ref;
            return model;
          }
        }
        this.add('route:foo.inner', PassThroughRoute);
        this.add('route:bar.inner', PassThroughRoute);
        await this.visit('/');
        this.assertRenderTree([this.outlet({
          type: 'route-template',
          name: 'index',
          args: {
            positional: [],
            named: {
              model: undefined
            }
          },
          instance: this.controllerFor('index'),
          template: 'my-app/templates/index.hbs',
          bounds: this.elementBounds(this.element),
          children: []
        })]);
        await this.visit('/foo');
        this.assertRenderTree([this.outlet({
          type: 'route-template',
          name: 'foo',
          args: {
            positional: [],
            named: {
              model: undefined
            }
          },
          instance: this.controllerFor('foo'),
          template: 'my-app/templates/foo.hbs',
          bounds: this.elementBounds(this.element),
          children: [this.outlet({
            type: 'route-template',
            name: 'foo.index',
            args: {
              positional: [],
              named: {
                model: undefined
              }
            },
            instance: this.controllerFor('foo.index'),
            template: 'my-app/templates/foo/index.hbs',
            bounds: this.nodeBounds(this.element.lastChild),
            children: []
          })]
        })]);
        await this.visit('/foo/wow');
        this.assertRenderTree([this.outlet({
          type: 'route-template',
          name: 'foo',
          args: {
            positional: [],
            named: {
              model: undefined
            }
          },
          instance: this.controllerFor('foo'),
          template: 'my-app/templates/foo.hbs',
          bounds: this.elementBounds(this.element),
          children: [this.outlet({
            type: 'route-template',
            name: 'foo.inner',
            args: {
              positional: [],
              named: {
                model: 'wow'
              }
            },
            instance: this.controllerFor('foo.inner'),
            template: 'my-app/templates/foo/inner.hbs',
            bounds: this.nodeBounds(this.element.lastChild),
            children: []
          })]
        })]);
        await this.visit('/foo/zomg');
        this.assertRenderTree([this.outlet({
          type: 'route-template',
          name: 'foo',
          args: {
            positional: [],
            named: {
              model: undefined
            }
          },
          instance: this.controllerFor('foo'),
          template: 'my-app/templates/foo.hbs',
          bounds: this.elementBounds(this.element),
          children: [this.outlet({
            type: 'route-template',
            name: 'foo.inner',
            args: {
              positional: [],
              named: {
                model: 'zomg'
              }
            },
            instance: this.controllerFor('foo.inner'),
            template: 'my-app/templates/foo/inner.hbs',
            bounds: this.nodeBounds(this.element.lastChild),
            children: []
          })]
        })]);
      }
      async '@test {{mount}}'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <div id=\"static\">{{mount \"foo\"}}</div>\n            <div id=\"dynamic\">{{mount this.engineName}}</div>\n            {{#if this.showMore}}\n              <div id=\"static-with-model\">{{mount \"foo\" model=this.engineModel}}</div>\n              <div id=\"dynamic-with-model\">{{mount this.engineName model=this.engineModel}}</div>\n            {{/if}}\n          "]))));
        this.add('engine:foo', class extends _engine.default {
          constructor() {
            super(...arguments);
            this.isFooEngine = true;
            this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
          }
          init(properties) {
            super.init(properties);
            this.register('template:application', compileTemplate((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n                    {{#if @model}}\n                      <InspectModel @model={{@model}} />\n                    {{/if}}\n                  "]))), {
              moduleName: 'foo/templates/application.hbs'
            }));
            this.register('template:components/inspect-model', compileTemplate('{{@model}}', {
              moduleName: 'foo/components/inspect-model.hbs'
            }));
          }
          buildInstance(options) {
            let instance = super.buildInstance(options);
            instance['isFooEngineInstance'] = true;
            return instance;
          }
        });
        this.add('engine:bar', class extends _engine.default {
          constructor() {
            super(...arguments);
            this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
          }
          init(properties) {
            super.init(properties);
            this.register('template:application', compileTemplate((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n                    {{#if @model}}\n                      <InspectModel @model={{@model}} />\n                    {{/if}}\n                  "]))), {
              moduleName: 'bar/templates/application.hbs'
            }));
            this.register('template:components/inspect-model', compileTemplate('{{@model}}', {
              moduleName: 'bar/components/inspect-model.hbs'
            }));
          }
          buildInstance(options) {
            let instance = super.buildInstance(options);
            instance['isBarEngineInstance'] = true;
            return instance;
          }
        });
        await this.visit('/');
        this.assertRenderTree([{
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static')[0]),
            children: []
          }]
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('engineName', 'bar');
        });
        this.assertRenderTree([{
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static')[0]),
            children: []
          }]
        }, {
          type: 'engine',
          name: 'bar',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isBarEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#dynamic')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'bar/templates/application.hbs',
            bounds: this.elementBounds(this.$('#dynamic')[0]),
            children: []
          }]
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('engineName', undefined);
        });
        this.assertRenderTree([{
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static')[0]),
            children: []
          }]
        }]);
        let model = {
          toString() {
            return 'some model';
          }
        };
        (0, _run.runTask)(() => {
          this.controllerFor('application').setProperties({
            showMore: true,
            engineModel: model
          });
        });
        this.assertRenderTree([{
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static')[0]),
            children: []
          }]
        }, {
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {
              model
            }
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static-with-model')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model
              }
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static-with-model')[0]),
            children: [{
              type: 'component',
              name: 'inspect-model',
              args: {
                positional: [],
                named: {
                  model
                }
              },
              instance: null,
              template: 'foo/components/inspect-model.hbs',
              bounds: this.nodeBounds(this.$('#static-with-model')[0].lastChild),
              children: []
            }]
          }]
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('engineName', 'bar');
        });
        this.assertRenderTree([{
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static')[0]),
            children: []
          }]
        }, {
          type: 'engine',
          name: 'bar',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isBarEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#dynamic')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'bar/templates/application.hbs',
            bounds: this.elementBounds(this.$('#dynamic')[0]),
            children: []
          }]
        }, {
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {
              model
            }
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static-with-model')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model
              }
            },
            instance: instance => instance.toString() === '(generated application controller)',
            bounds: this.elementBounds(this.$('#static-with-model')[0]),
            template: 'foo/templates/application.hbs',
            children: [{
              type: 'component',
              name: 'inspect-model',
              args: {
                positional: [],
                named: {
                  model
                }
              },
              instance: null,
              template: 'foo/components/inspect-model.hbs',
              bounds: this.nodeBounds(this.$('#static-with-model')[0].lastChild),
              children: []
            }]
          }]
        }, {
          type: 'engine',
          name: 'bar',
          args: {
            positional: [],
            named: {
              model
            }
          },
          instance: instance => instance['isBarEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#dynamic-with-model')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model
              }
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'bar/templates/application.hbs',
            bounds: this.elementBounds(this.$('#dynamic-with-model')[0]),
            children: [{
              type: 'component',
              name: 'inspect-model',
              args: {
                positional: [],
                named: {
                  model
                }
              },
              instance: null,
              template: 'bar/components/inspect-model.hbs',
              bounds: this.nodeBounds(this.$('#dynamic-with-model')[0].lastChild),
              children: []
            }]
          }]
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').setProperties({
            showMore: false,
            engineName: undefined
          });
        });
        this.assertRenderTree([{
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance => instance['isFooEngineInstance'] === true,
          template: null,
          bounds: this.elementBounds(this.$('#static')[0]),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {}
            },
            instance: instance => instance.toString() === '(generated application controller)',
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.$('#static')[0]),
            children: []
          }]
        }]);
      }
      async '@test routable engine'() {
        this.addTemplate('index', 'Index');
        let instance;
        this.add('engine:foo', class extends _engine.default {
          constructor() {
            super(...arguments);
            this.isFooEngine = true;
            this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
          }
          init(properties) {
            super.init(properties);
            this.register('template:application', compileTemplate((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n                    {{outlet}}\n\n                    {{#if this.message}}\n                      <Hello @message={{this.message}} />\n                    {{/if}}\n                  "]))), {
              moduleName: 'foo/templates/application.hbs'
            }));
            this.register('template:index', compileTemplate('Foo', {
              moduleName: 'foo/templates/index.hbs'
            }));
            this.register('template:components/hello', compileTemplate('<span>Hello {{@message}}</span>', {
              moduleName: 'foo/components/hello.hbs'
            }));
          }
          buildInstance(options) {
            return instance = super.buildInstance(options);
          }
        });
        this.router.map(function () {
          this.mount('foo');
        });
        this.add('route-map:foo', function () {});
        await this.visit('/');
        this.assertRenderTree([this.outlet({
          type: 'route-template',
          name: 'index',
          args: {
            positional: [],
            named: {
              model: undefined
            }
          },
          instance: this.controllerFor('index'),
          template: 'my-app/templates/index.hbs',
          bounds: this.elementBounds(this.element),
          children: []
        })]);
        await this.visit('/foo');
        this.assertRenderTree([this.outlet({
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance,
          template: null,
          bounds: this.elementBounds(this.element),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model: undefined
              }
            },
            instance: instance.lookup('controller:application'),
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.element),
            children: [this.outlet({
              type: 'route-template',
              name: 'index',
              args: {
                positional: [],
                named: {
                  model: undefined
                }
              },
              instance: instance.lookup('controller:index'),
              template: 'foo/templates/index.hbs',
              bounds: this.nodeBounds(this.element.firstChild),
              children: []
            })]
          }]
        })]);
        (0, _run.runTask)(() => {
          let controller = instance.lookup('controller:application');
          (false && !(controller instanceof _controller.default) && (0, _debug.assert)('Expected an instance of controller', controller instanceof _controller.default));
          controller.set('message', 'World');
        });
        this.assertRenderTree([this.outlet({
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance,
          template: null,
          bounds: this.elementBounds(this.element),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model: undefined
              }
            },
            instance: instance.lookup('controller:application'),
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.element),
            children: [this.outlet({
              type: 'route-template',
              name: 'index',
              args: {
                positional: [],
                named: {
                  model: undefined
                }
              },
              instance: instance.lookup('controller:index'),
              template: 'foo/templates/index.hbs',
              bounds: this.nodeBounds(this.element.firstChild),
              children: []
            }), {
              type: 'component',
              name: 'hello',
              args: {
                positional: [],
                named: {
                  message: 'World'
                }
              },
              instance: null,
              template: 'foo/components/hello.hbs',
              bounds: this.nodeBounds(this.element.lastChild),
              children: []
            }]
          }]
        })]);
        (0, _run.runTask)(() => {
          let controller = instance.lookup('controller:application');
          (false && !(controller instanceof _controller.default) && (0, _debug.assert)('Expected an instance of controller', controller instanceof _controller.default));
          controller.set('message', undefined);
        });
        this.assertRenderTree([this.outlet({
          type: 'engine',
          name: 'foo',
          args: {
            positional: [],
            named: {}
          },
          instance: instance,
          template: null,
          bounds: this.elementBounds(this.element),
          children: [{
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model: undefined
              }
            },
            instance: instance.lookup('controller:application'),
            template: 'foo/templates/application.hbs',
            bounds: this.elementBounds(this.element),
            children: [this.outlet({
              type: 'route-template',
              name: 'index',
              args: {
                positional: [],
                named: {
                  model: undefined
                }
              },
              instance: instance.lookup('controller:index'),
              template: 'foo/templates/index.hbs',
              bounds: this.nodeBounds(this.element.firstChild),
              children: []
            })]
          }]
        })]);
        await this.visit('/');
        this.assertRenderTree([this.outlet({
          type: 'route-template',
          name: 'index',
          args: {
            positional: [],
            named: {
              model: undefined
            }
          },
          instance: this.controllerFor('index'),
          template: 'my-app/templates/index.hbs',
          bounds: this.elementBounds(this.element),
          children: []
        })]);
      }
      async '@test template-only components'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <HelloWorld @name=\"first\" />\n\n            {{#if this.showSecond}}\n              <HelloWorld @name=\"second\" />\n            {{/if}}\n          "]))));
        this.addComponent('hello-world', {
          ComponentClass: null,
          template: '{{@name}}'
        });
        await this.visit('/');
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'second'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      async '@feature(EMBER_GLIMMER_SET_COMPONENT_TEMPLATE) templateOnlyComponent()'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <HelloWorld @name=\"first\" />\n\n            {{#if this.showSecond}}\n              <HelloWorld @name=\"second\" />\n            {{/if}}\n          "]))));
        this.addComponent('hello-world', {
          ComponentClass: (0, _runtime.templateOnlyComponent)(),
          template: '{{@name}}'
        });
        await this.visit('/');
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'second'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      async '@feature(EMBER_GLIMMER_SET_COMPONENT_TEMPLATE) templateOnlyComponent() + setComponentTemplate()'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <HelloWorld @name=\"first\" />\n\n            {{#if this.showSecond}}\n              <HelloWorld @name=\"second\" />\n            {{/if}}\n          "]))));
        this.addComponent('hello-world', {
          ComponentClass: (0, _manager.setComponentTemplate)(compileTemplate('{{@name}}', {
            moduleName: 'my-app/components/hello-world.hbs'
          }), (0, _runtime.templateOnlyComponent)())
        });
        await this.visit('/');
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'second'
            }
          },
          instance: null,
          template: 'my-app/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: null,
          template: 'my-app/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      async '@test classic components'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <HelloWorld @name=\"first\" />\n\n            {{#if this.showSecond}}\n              <HelloWorld @name=\"second\" />\n            {{/if}}\n          "]))));
        this.addComponent('hello-world', {
          ComponentClass: class extends _glimmer.Component {},
          template: 'Hello World'
        });
        await this.visit('/');
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: instance => instance['name'] === 'first',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: instance => instance['name'] === 'first',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'second'
            }
          },
          instance: instance => instance['name'] === 'second',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: instance => instance['name'] === 'first',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      async '@test custom components'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <HelloWorld @name=\"first\" />\n\n            {{#if this.showSecond}}\n              <HelloWorld @name=\"second\" />\n            {{/if}}\n          "]))));
        this.addComponent('hello-world', {
          ComponentClass: (0, _glimmer.setComponentManager)(_owner => {
            return {
              capabilities: (0, _manager.componentCapabilities)('3.13', {}),
              createComponent(_, _ref2) {
                let {
                  named: {
                    name
                  }
                } = _ref2;
                return {
                  name
                };
              },
              getContext(instances) {
                return instances;
              }
            };
          }, {}),
          template: 'Hello World'
        });
        await this.visit('/');
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: instance => instance['name'] === 'first',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: instance => instance['name'] === 'first',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'second'
            }
          },
          instance: instance => instance['name'] === 'second',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'hello-world',
          args: {
            positional: [],
            named: {
              name: 'first'
            }
          },
          instance: instance => instance['name'] === 'first',
          template: 'my-app/templates/components/hello-world.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      async '@test <Input> components'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <Input @type=\"text\" @value=\"first\" />\n\n            {{#if this.showSecond}}\n              <Input @type=\"checkbox\" @checked={{false}} />\n            {{/if}}\n          "]))));
        await this.visit('/');
        let target = this.controllerFor('application');
        let inputToString = /<Input:ember[0-9]+>/;
        this.assertRenderTree([{
          type: 'component',
          name: 'input',
          args: {
            positional: [],
            named: {
              type: 'text',
              value: 'first'
            }
          },
          instance: instance => inputToString.test(instance.toString()),
          template: 'packages/@ember/-internals/glimmer/lib/templates/input.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => target.set('showSecond', true));
        this.assertRenderTree([{
          type: 'component',
          name: 'input',
          args: {
            positional: [],
            named: {
              type: 'text',
              value: 'first'
            }
          },
          instance: instance => inputToString.test(instance.toString()),
          template: 'packages/@ember/-internals/glimmer/lib/templates/input.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'input',
          args: {
            positional: [],
            named: {
              type: 'checkbox',
              checked: false
            }
          },
          instance: instance => inputToString.test(instance.toString()),
          template: 'packages/@ember/-internals/glimmer/lib/templates/input.hbs',
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => target.set('showSecond', false));
        this.assertRenderTree([{
          type: 'component',
          name: 'input',
          args: {
            positional: [],
            named: {
              type: 'text',
              value: 'first'
            }
          },
          instance: instance => inputToString.test(instance.toString()),
          template: 'packages/@ember/-internals/glimmer/lib/templates/input.hbs',
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      async '@test <Textarea> components'() {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <Textarea @value=\"first\" />\n\n            {{#if this.showSecond}}\n              <Textarea @value=\"second\" />\n            {{/if}}\n          "]))));
        await this.visit('/');
        let textareaNode = (value, node) => {
          return {
            type: 'component',
            name: 'textarea',
            args: {
              positional: [],
              named: {
                value
              }
            },
            instance: instance => instance['value'] === value,
            bounds: this.nodeBounds(node),
            template: 'packages/@ember/-internals/glimmer/lib/templates/textarea.hbs',
            children: []
          };
        };
        this.assertRenderTree([textareaNode('first', this.element.firstChild)]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([textareaNode('first', this.element.firstChild), textareaNode('second', this.element.lastChild)]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([textareaNode('first', this.element.firstChild)]);
      }
      async '@test <LinkTo> components'() {
        this.router.map(function () {
          this.route('foo');
          this.route('bar');
        });
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <LinkTo @route=\"foo\">Foo</LinkTo>\n\n            {{#if this.showSecond}}\n              <LinkTo @route=\"bar\">Bar</LinkTo>\n            {{/if}}\n          "]))));
        await this.visit('/');
        let template = "packages/@ember/-internals/glimmer/lib/templates/link-to.hbs";
        this.assertRenderTree([{
          type: 'component',
          name: 'link-to',
          args: {
            positional: [],
            named: {
              route: 'foo'
            }
          },
          instance: instance => instance['route'] === 'foo',
          template,
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', true);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'link-to',
          args: {
            positional: [],
            named: {
              route: 'foo'
            }
          },
          instance: instance => instance['route'] === 'foo',
          template,
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }, {
          type: 'component',
          name: 'link-to',
          args: {
            positional: [],
            named: {
              route: 'bar'
            }
          },
          instance: instance => instance['route'] === 'bar',
          template,
          bounds: this.nodeBounds(this.element.lastChild),
          children: []
        }]);
        (0, _run.runTask)(() => {
          this.controllerFor('application').set('showSecond', false);
        });
        this.assertRenderTree([{
          type: 'component',
          name: 'link-to',
          args: {
            positional: [],
            named: {
              route: 'foo'
            }
          },
          instance: instance => instance['route'] === 'foo',
          template,
          bounds: this.nodeBounds(this.element.firstChild),
          children: []
        }]);
      }
      get owner() {
        return this.applicationInstance;
      }
      outlet(nodeOrName, node) {
        let name;
        if (typeof nodeOrName === 'string') {
          name = nodeOrName;
          node = node;
        } else {
          name = 'main';
          node = nodeOrName;
        }
        return {
          type: 'outlet',
          name,
          instance: undefined,
          args: {
            positional: [],
            named: {}
          },
          template: null,
          bounds: node.bounds,
          children: [node]
        };
      }
      nodeBounds(node) {
        return {
          parentElement: (0, _util.expect)(node == null ? void 0 : node.parentNode, 'BUG: detached node'),
          firstNode: node,
          lastNode: node
        };
      }
      elementBounds(element) {
        return {
          parentElement: element,
          firstNode: element.firstChild,
          lastNode: element.lastChild
        };
      }
      assertRenderTree(expected) {
        let outlet = 'packages/@ember/-internals/glimmer/lib/templates/outlet.hbs';
        let actual = (0, _debug.captureRenderTree)(this.owner);
        let wrapped = [this.outlet({
          type: 'route-template',
          name: '-top-level',
          args: {
            positional: [],
            named: {}
          },
          instance: undefined,
          template: outlet,
          bounds: _environment.ENV._APPLICATION_TEMPLATE_WRAPPER ? this.nodeBounds(this.element) : this.elementBounds(this.element),
          children: [this.outlet({
            type: 'route-template',
            name: 'application',
            args: {
              positional: [],
              named: {
                model: undefined
              }
            },
            instance: this.controllerFor('application'),
            template: this.owner.hasRegistration('template:application') ? 'my-app/templates/application.hbs' : outlet,
            bounds: this.elementBounds(this.element),
            children: expected
          })]
        })];
        this.assertRenderNodes(actual, wrapped, 'root');
      }
      assertRenderNodes(actual, expected, path) {
        this.assert.strictEqual(actual.length, expected.length, "Expecting " + expected.length + " render nodes at " + path + ", got " + actual.length + ".\n");
        if (actual.length === expected.length) {
          let byTypeAndName = (a, b) => {
            if (a.type > b.type) {
              return 1;
            } else if (a.type < b.type) {
              return -1;
            } else if (a.name > b.name) {
              return 1;
            } else if (a.name < b.name) {
              return -1;
            } else {
              return 0;
            }
          };
          actual = actual.sort(byTypeAndName);
          expected = expected.sort(byTypeAndName);
          for (let i = 0; i < actual.length; i++) {
            let actualVal = actual[i];
            let expectedVal = expected[i];
            (false && !(actualVal && expectedVal) && (0, _debug.assert)('has actualVal and expectedVal', actualVal && expectedVal));
            this.assertRenderNode(actualVal, expectedVal, actualVal.type + ":" + actualVal.name);
          }
        } else {
          this.assert.deepEqual(actual, [], path);
        }
      }
      assertRenderNode(actual, expected, path) {
        this.assertProperty(actual.type, expected.type, false, path + " (type)");
        this.assertProperty(actual.name, expected.name, false, path + " (name)");
        this.assertProperty(actual.args, expected.args, true, path + " (args)");
        this.assertProperty(actual.instance, expected.instance, false, path + " (instance)");
        this.assertProperty(actual.template, expected.template, false, path + " (template)");
        this.assertProperty(actual.bounds, expected.bounds, true, path + " (bounds)");
        if (Array.isArray(expected.children)) {
          this.assertRenderNodes(actual.children, expected.children, path);
        } else {
          this.assertProperty(actual.children, expected.children, false, path + " (children)");
        }
      }
      assertProperty(actual, expected, deep, path) {
        if (isExpectedFunc(expected)) {
          this.assert.ok(expected(actual), "Matching " + path + ", got " + actual);
        } else if (deep) {
          this.assert.deepEqual(actual, expected, "Matching " + path);
        } else {
          this.assert.strictEqual(actual, expected, "Matching " + path);
        }
      }
      async '@test cleans up correctly after errors'(assert) {
        this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject13 || (_templateObject13 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <HelloWorld @name=\"first\" />\n          "]))));
        this.addComponent('hello-world', {
          ComponentClass: class extends _glimmer.Component {
            constructor(owner) {
              super(owner);
              throw new Error('oops!');
            }
          },
          template: '{{@name}}'
        });
        await assert.rejects(this.visit('/'), /oops!/);
        assert.deepEqual((0, _debug.captureRenderTree)(this.owner), [], 'there was no output');
      }
    });
  }
});
define("@ember/-internals/glimmer/tests/integration/application/engine-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/routing/route", "@ember/-internals/runtime", "@ember/controller", "@ember/engine", "@ember/runloop", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _glimmer, _route, _runtime, _controller, _engine, _runloop, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;
  (0, _internalTestHelpers.moduleFor)('Application test: engine rendering', class extends _internalTestHelpers.ApplicationTestCase {
    get routerOptions() {
      return {
        location: 'none',
        setupRouter() {
          this._super(...arguments);
          let getRoute = this._routerMicrolib.getRoute;
          this._enginePromises = Object.create(null);
          this._resolvedEngines = Object.create(null);
          this._routerMicrolib.getRoute = name => {
            let engineInfo = this._engineInfoByRoute[name];
            if (!engineInfo) {
              return getRoute(name);
            }
            let engineName = engineInfo.name;
            if (this._resolvedEngines[engineName]) {
              return getRoute(name);
            }
            let enginePromise = this._enginePromises[engineName];
            if (!enginePromise) {
              enginePromise = new _runtime.RSVP.Promise(resolve => {
                setTimeout(() => {
                  this._resolvedEngines[engineName] = true;
                  resolve();
                }, 1);
              });
              this._enginePromises[engineName] = enginePromise;
            }
            return enginePromise.then(() => getRoute(name));
          };
        }
      };
    }
    setupAppAndRoutableEngine(hooks) {
      if (hooks === void 0) {
        hooks = [];
      }
      let self = this;
      this.addTemplate('application', 'Application{{outlet}}');
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {
        this.route('post', function () {
          this.route('comments');
          this.route('likes');
        });
        this.route('category', {
          path: 'category/:id'
        });
        this.route('author', {
          path: 'author/:id'
        });
      });
      this.add('route:application', _route.default.extend({
        model() {
          hooks.push('application - application');
        }
      }));
      this.add('engine:blog', _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('controller:application', _controller.default.extend({
            queryParams: ['lang'],
            lang: ''
          }));
          this.register('controller:category', _controller.default.extend({
            queryParams: ['type']
          }));
          this.register('controller:authorKtrl', _controller.default.extend({
            queryParams: ['official']
          }));
          this.register('template:application', (0, _helpers.compile)('Engine{{this.lang}}{{outlet}}'));
          this.register('route:application', _route.default.extend({
            model() {
              hooks.push('engine - application');
            }
          }));
          this.register('route:author', _route.default.extend({
            controllerName: 'authorKtrl'
          }));
          if (self._additionalEngineRegistrations) {
            self._additionalEngineRegistrations.call(this);
          }
        }
      }));
    }
    setupAppAndRoutelessEngine(hooks) {
      this.setupRoutelessEngine(hooks);
      this.add('engine:chat-engine', _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('Engine'));
          this.register('controller:application', _controller.default.extend({
            init() {
              this._super(...arguments);
              hooks.push('engine - application');
            }
          }));
        }
      }));
    }
    setupRoutelessEngine(hooks) {
      this.addTemplate('application', 'Application{{mount "chat-engine"}}');
      this.add('route:application', _route.default.extend({
        model() {
          hooks.push('application - application');
        }
      }));
    }
    additionalEngineRegistrations(callback) {
      this._additionalEngineRegistrations = callback;
    }
    stringsEndWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    ['@test sharing a template between engine and application has separate refinements']() {
      this.assert.expect(1);
      let sharedTemplate = (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <h1>{{this.contextType}}</h1>\n      {{ambiguous-curlies}}\n\n      {{outlet}}\n    "]))));
      this.add('template:application', sharedTemplate);
      this.add('controller:application', _controller.default.extend({
        contextType: 'Application',
        'ambiguous-curlies': 'Controller Data!'
      }));
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {});
      this.add('engine:blog', _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('controller:application', _controller.default.extend({
            contextType: 'Engine'
          }));
          this.register('template:application', sharedTemplate);
          this.register('template:components/ambiguous-curlies', (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <p>Component!</p>\n      "])))));
        }
      }));
      return this.visit('/blog').then(() => {
        this.assertText('ApplicationEngineComponent!');
      });
    }
    ['@test sharing a layout between engine and application has separate refinements']() {
      this.assert.expect(1);
      let sharedLayout = (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{ambiguous-curlies}}\n      "]))));
      let sharedComponent = _glimmer.Component.extend({
        layout: sharedLayout
      });
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <h1>Application</h1>\n          {{my-component ambiguous-curlies=\"Local Data!\"}}\n          {{outlet}}\n        "]))));
      this.add('component:my-component', sharedComponent);
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {});
      this.add('engine:blog', _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n                <h1>Engine</h1>\n                {{my-component}}\n                {{outlet}}\n              "])))));
          this.register('component:my-component', sharedComponent);
          this.register('template:components/ambiguous-curlies', (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n                <p>Component!</p>\n              "])))));
        }
      }));
      return this.visit('/blog').then(() => {
        this.assertText('ApplicationEngineComponent!');
      });
    }
    ['@test visit() with `shouldRender: true` returns a promise that resolves when application and engine templates have rendered'](assert) {
      assert.expect(2);
      let hooks = [];
      this.setupAppAndRoutableEngine(hooks);
      return this.visit('/blog', {
        shouldRender: true
      }).then(() => {
        this.assertText('ApplicationEngine');
        this.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected model hooks were fired');
      });
    }
    ['@test visit() with `shouldRender: false` returns a promise that resolves without rendering'](assert) {
      assert.expect(2);
      let hooks = [];
      this.setupAppAndRoutableEngine(hooks);
      return this.visit('/blog', {
        shouldRender: false
      }).then(() => {
        assert.strictEqual(document.getElementById('qunit-fixture').children.length, 0, "there are no elements in the qunit-fixture element");
        this.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected model hooks were fired');
      });
    }
    ['@test visit() with `shouldRender: true` returns a promise that resolves when application and routeless engine templates have rendered'](assert) {
      assert.expect(2);
      let hooks = [];
      this.setupAppAndRoutelessEngine(hooks);
      return this.visit('/', {
        shouldRender: true
      }).then(() => {
        this.assertText('ApplicationEngine');
        this.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    }
    ['@test deactivate should be called on Engine Routes before destruction'](assert) {
      assert.expect(3);
      this.setupAppAndRoutableEngine();
      this.add('engine:blog', _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('Engine{{outlet}}'));
          this.register('route:application', _route.default.extend({
            deactivate() {
              assert.notOk(this.isDestroyed, 'Route is not destroyed');
              assert.notOk(this.isDestroying, 'Route is not being destroyed');
            }
          }));
        }
      }));
      return this.visit('/blog').then(() => {
        this.assertText('ApplicationEngine');
      });
    }
    ['@test engine should lookup and use correct controller']() {
      this.setupAppAndRoutableEngine();
      return this.visit('/blog?lang=English').then(() => {
        this.assertText('ApplicationEngineEnglish');
      });
    }
    ['@test error substate route works for the application route of an Engine'](assert) {
      assert.expect(2);
      let errorEntered = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:application_error', _route.default.extend({
          activate() {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:application_error', (0, _helpers.compile)('Error! {{@model.message}}'));
        this.register('route:post', _route.default.extend({
          model() {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(() => {
        this.assertText('Application');
        return this.transitionTo('blog.post');
      }).then(() => {
        return errorEntered.promise;
      }).then(() => {
        this.assertText('ApplicationError! Oh, noes!');
      });
    }
    ['@test error route works for the application route of an Engine'](assert) {
      assert.expect(2);
      let errorEntered = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:error', _route.default.extend({
          activate() {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:error', (0, _helpers.compile)('Error! {{@model.message}}'));
        this.register('route:post', _route.default.extend({
          model() {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(() => {
        this.assertText('Application');
        return this.transitionTo('blog.post');
      }).then(() => {
        return errorEntered.promise;
      }).then(() => {
        this.assertText('ApplicationEngineError! Oh, noes!');
      });
    }
    ['@test error substate route works for a child route of an Engine'](assert) {
      assert.expect(2);
      let errorEntered = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:post_error', _route.default.extend({
          activate() {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:post_error', (0, _helpers.compile)('Error! {{@model.message}}'));
        this.register('route:post', _route.default.extend({
          model() {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(() => {
        this.assertText('Application');
        return this.transitionTo('blog.post');
      }).then(() => {
        return errorEntered.promise;
      }).then(() => {
        this.assertText('ApplicationEngineError! Oh, noes!');
      });
    }
    ['@test error route works for a child route of an Engine'](assert) {
      assert.expect(2);
      let errorEntered = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:post.error', _route.default.extend({
          activate() {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:post.error', (0, _helpers.compile)('Error! {{@model.message}}'));
        this.register('route:post.comments', _route.default.extend({
          model() {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(() => {
        this.assertText('Application');
        return this.transitionTo('blog.post.comments');
      }).then(() => {
        return errorEntered.promise;
      }).then(() => {
        this.assertText('ApplicationEngineError! Oh, noes!');
      });
    }
    ['@test loading substate route works for the application route of an Engine'](assert) {
      assert.expect(3);
      let done = assert.async();
      let loadingEntered = _runtime.RSVP.defer();
      let resolveLoading = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:application_loading', _route.default.extend({
          activate() {
            (0, _runloop.next)(loadingEntered.resolve);
          }
        }));
        this.register('template:application_loading', (0, _helpers.compile)('Loading'));
        this.register('template:post', (0, _helpers.compile)('Post'));
        this.register('route:post', _route.default.extend({
          model() {
            return resolveLoading.promise;
          }
        }));
      });
      return this.visit('/').then(() => {
        this.assertText('Application');
        let transition = this.transitionTo('blog.post');
        loadingEntered.promise.then(() => {
          this.assertText('ApplicationLoading');
          resolveLoading.resolve();
          return (0, _internalTestHelpers.runTaskNext)().then(() => {
            this.assertText('ApplicationEnginePost');
            done();
          });
        });
        return transition;
      });
    }
    ['@test loading route works for the application route of an Engine'](assert) {
      assert.expect(3);
      let done = assert.async();
      let loadingEntered = _runtime.RSVP.defer();
      let resolveLoading = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:loading', _route.default.extend({
          activate() {
            (0, _runloop.next)(loadingEntered.resolve);
          }
        }));
        this.register('template:loading', (0, _helpers.compile)('Loading'));
        this.register('template:post', (0, _helpers.compile)('Post'));
        this.register('route:post', _route.default.extend({
          model() {
            return resolveLoading.promise;
          }
        }));
      });
      return this.visit('/').then(() => {
        this.assertText('Application');
        let transition = this.transitionTo('blog.post');
        loadingEntered.promise.then(() => {
          this.assertText('ApplicationEngineLoading');
          resolveLoading.resolve();
          return (0, _internalTestHelpers.runTaskNext)().then(() => {
            this.assertText('ApplicationEnginePost');
            done();
          });
        });
        return transition;
      });
    }
    ['@test loading substate route works for a child route of an Engine'](assert) {
      assert.expect(3);
      let resolveLoading;
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:post', (0, _helpers.compile)('{{outlet}}'));
        this.register('template:post.comments', (0, _helpers.compile)('Comments'));
        this.register('template:post.likes_loading', (0, _helpers.compile)('Loading'));
        this.register('template:post.likes', (0, _helpers.compile)('Likes'));
        this.register('route:post.likes', _route.default.extend({
          model() {
            return new _runtime.RSVP.Promise(resolve => {
              resolveLoading = resolve;
            });
          }
        }));
      });
      return this.visit('/blog/post/comments').then(() => {
        this.assertText('ApplicationEngineComments');
        let transition = this.transitionTo('blog.post.likes');
        (0, _internalTestHelpers.runTaskNext)().then(() => {
          this.assertText('ApplicationEngineLoading');
          resolveLoading();
        });
        return transition.then(() => (0, _internalTestHelpers.runTaskNext)()).then(() => this.assertText('ApplicationEngineLikes'));
      });
    }
    ['@test loading route works for a child route of an Engine'](assert) {
      assert.expect(3);
      let done = assert.async();
      let loadingEntered = _runtime.RSVP.defer();
      let resolveLoading = _runtime.RSVP.defer();
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:post', (0, _helpers.compile)('{{outlet}}'));
        this.register('template:post.comments', (0, _helpers.compile)('Comments'));
        this.register('route:post.loading', _route.default.extend({
          activate() {
            (0, _runloop.next)(loadingEntered.resolve);
          }
        }));
        this.register('template:post.loading', (0, _helpers.compile)('Loading'));
        this.register('template:post.likes', (0, _helpers.compile)('Likes'));
        this.register('route:post.likes', _route.default.extend({
          model() {
            return resolveLoading.promise;
          }
        }));
      });
      return this.visit('/blog/post/comments').then(() => {
        this.assertText('ApplicationEngineComments');
        let transition = this.transitionTo('blog.post.likes');
        loadingEntered.promise.then(() => {
          this.assertText('ApplicationEngineLoading');
          resolveLoading.resolve();
          return (0, _internalTestHelpers.runTaskNext)().then(() => {
            this.assertText('ApplicationEngineLikes');
            done();
          });
        });
        return transition;
      });
    }
    ["@test query params don't have stickiness by default between model"](assert) {
      assert.expect(1);
      let tmpl = '<LinkTo @route="category" @model={{1337}}>Category 1337</LinkTo>';
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:category', (0, _helpers.compile)(tmpl));
      });
      return this.visit('/blog/category/1?type=news').then(() => {
        let suffix = '/blog/category/1337';
        let href = this.element.querySelector('a').href;

        // check if link ends with the suffix
        assert.ok(this.stringsEndWith(href, suffix));
      });
    }
    '@test query params only transitions work properly'(assert) {
      assert.expect(1);
      let tmpl = '<LinkTo @query={{hash type="news"}}>News</LinkTo>';
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:category', (0, _helpers.compile)(tmpl));
      });
      return this.visit('/blog/category/1').then(() => {
        let suffix = '/blog/category/1?type=news';
        let href = this.element.querySelector('a').href;

        // check if link ends with the suffix
        assert.ok(this.stringsEndWith(href, suffix));
      });
    }
    async ['@test query params in customized controllerName have stickiness by default between model'](assert) {
      assert.expect(2);
      let tmpl = '<LinkTo @route="author" @model={{1337}} class="author-1337">Author 1337</LinkTo><LinkTo @route="author" @model=1 class="author-1">Author 1</LinkTo>';
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:author', (0, _helpers.compile)(tmpl));
      });
      await this.visit('/blog/author/1?official=true');
      let suffix1 = '/blog/author/1?official=true';
      let href1 = this.element.querySelector('.author-1').href;
      let suffix1337 = '/blog/author/1337';
      let href1337 = this.element.querySelector('.author-1337').href;

      // check if link ends with the suffix
      assert.ok(this.stringsEndWith(href1, suffix1), href1 + " ends with " + suffix1);
      assert.ok(this.stringsEndWith(href1337, suffix1337), href1337 + " ends with " + suffix1337);
    }
    ['@test visit() routable engine which errors on init'](assert) {
      assert.expect(1);
      let hooks = [];
      this.additionalEngineRegistrations(function () {
        this.register('route:application', _route.default.extend({
          init() {
            throw new Error('Whoops! Something went wrong...');
          }
        }));
      });
      this.setupAppAndRoutableEngine(hooks);
      return this.visit('/', {
        shouldRender: true
      }).then(() => {
        return this.visit('/blog');
      }).catch(error => {
        assert.equal(error.message, 'Whoops! Something went wrong...');
      });
    }
    ['@test visit() with `shouldRender: true` queryParams are properly deserialized for lazy routes'](assert) {
      assert.expect(2);
      let hooks = [];
      this.setupAppAndRoutableEngine(hooks);
      this.add('engine:blog', _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('controller:application', _controller.default.extend({
            queryParams: ['lazyQueryParam']
          }));
          this.register('template:application', (0, _helpers.compile)('Engine<div class="lazy-query-param">{{this.lazyQueryParam}}</div>{{outlet}}'));
          this.register('route:application', _route.default.extend({
            queryParams: {
              lazyQueryParam: {
                defaultValue: null
              }
            },
            deserializeQueryParam() {
              hooks.push('engine - deserialize query param');
              return 'foo';
            },
            model() {
              hooks.push('engine - application');
            }
          }));
        }
      }));
      return this.visit('/blog?lazyQueryParam=bar', {
        shouldRender: true
      }).then(() => {
        assert.deepEqual(hooks, ['application - application', 'engine - deserialize query param', 'engine - application'], 'the expected hooks were fired');
        assert.strictEqual(this.element.querySelector('.lazy-query-param').innerHTML, 'foo');
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/application/helper-registration-test", ["internal-test-helpers", "@ember/controller", "@ember/service", "@ember/-internals/glimmer"], function (_internalTestHelpers, _controller, _service, _glimmer) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Helper Registration', class extends _internalTestHelpers.ApplicationTestCase {
    ['@test Unbound dashed helpers registered on the container can be late-invoked'](assert) {
      this.addTemplate('application', "<div id='wrapper'>{{x-borf}} {{x-borf 'YES'}}</div>");
      let myHelper = (0, _glimmer.helper)(params => params[0] || 'BORF');
      this.application.register('helper:x-borf', myHelper);
      return this.visit('/').then(() => {
        assert.equal(this.$('#wrapper').text(), 'BORF YES', 'The helper was invoked from the container');
      });
    }
    ['@test Bound helpers registered on the container can be late-invoked'](assert) {
      this.addTemplate('application', "<div id='wrapper'>{{x-reverse}} {{x-reverse this.foo}}</div>");
      this.add('controller:application', _controller.default.extend({
        foo: 'alex'
      }));
      this.application.register('helper:x-reverse', (0, _glimmer.helper)(function (_ref) {
        let [value] = _ref;
        return value ? value.split('').reverse().join('') : '--';
      }));
      return this.visit('/').then(() => {
        assert.equal(this.$('#wrapper').text(), '-- xela', 'The bound helper was invoked from the container');
      });
    }
    ['@test Undashed helpers registered on the container can be invoked'](assert) {
      this.addTemplate('application', "<div id='wrapper'>{{omg}}|{{yorp 'boo'}}|{{yorp 'ya'}}</div>");
      this.application.register('helper:omg', (0, _glimmer.helper)(() => 'OMG'));
      this.application.register('helper:yorp', (0, _glimmer.helper)(_ref2 => {
        let [value] = _ref2;
        return value;
      }));
      return this.visit('/').then(() => {
        assert.equal(this.$('#wrapper').text(), 'OMG|boo|ya', 'The helper was invoked from the container');
      });
    }
    ['@test Helpers can receive injections'](assert) {
      this.addTemplate('application', "<div id='wrapper'>{{full-name}}</div>");
      let serviceCalled = false;
      this.add('service:name-builder', _service.default.extend({
        build() {
          serviceCalled = true;
        }
      }));
      this.add('helper:full-name', _glimmer.Helper.extend({
        nameBuilder: (0, _service.service)('name-builder'),
        compute() {
          this.get('nameBuilder').build();
        }
      }));
      return this.visit('/').then(() => {
        assert.ok(serviceCalled, 'service was injected, method called');
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/application/hot-reload-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/service", "@ember/-internals/glimmer", "@glimmer/util"], function (_emberBabel, _internalTestHelpers, _environment, _service, _glimmer, _util) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;
  // This simuates what the template hot-reloading would do in development mode
  // to avoid regressions
  (0, _internalTestHelpers.moduleFor)('Appliation test: template hot reloading', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
      this._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
      let didCreateReloader = reloader => {
        this.reloader = reloader;
      };
      this.add('service:reloader', _service.default.extend({
        init() {
          this._super(...arguments);
          this.revisions = {};
          this.callbacks = [];
          didCreateReloader(this);
        },
        onReload(callback) {
          this.callbacks.push(callback);
        },
        revisionFor(name) {
          return this.revisions[name];
        },
        invalidate(name) {
          let revision = this.revisions[name];
          if (revision === undefined) {
            revision = 0;
          }
          this.revisions[name] = ++revision;
          this.callbacks.forEach(callback => callback());
        }
      }));
      this.add('helper:hot-reload', _glimmer.Helper.extend({
        reloader: (0, _service.service)(),
        init() {
          this._super(...arguments);
          this.reloader.onReload(() => this.recompute());
        },
        compute(_ref) {
          let [name] = _ref;
          let revision = this.reloader.revisionFor(name);
          if (revision === undefined) {
            return name;
          } else {
            return name + "--hot-reload-" + revision;
          }
        }
      }));
    }
    teardown() {
      super.teardown();
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
    }
    hotReload(name, template) {
      let reloader = (0, _util.expect)(this.reloader);
      let revision = (reloader.revisionFor(name) || 0) + 1;
      let ComponentClass = this.applicationInstance.resolveRegistration("component:" + name) || null;
      this.addComponent(name + "--hot-reload-" + revision, {
        ComponentClass,
        template
      });
      reloader.invalidate(name);
    }
    ['@test hot reloading template-only components']() {
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [{{component (hot-reload \"x-foo\") name=\"first\"}}]\n          [{{component (hot-reload \"x-foo\") name=\"second\"}}]\n          [{{component (hot-reload \"x-bar\")}}]\n        "]))));
      this.addComponent('x-foo', {
        ComponentClass: null,
        template: 'x-foo: {{@name}}'
      });
      this.addComponent('x-bar', {
        ComponentClass: null,
        template: 'x-bar'
      });
      return this.visit('/').then(() => {
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [x-foo: first]\n          [x-foo: second]\n          [x-bar]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-foo', '<h1>{{@name}}</h1>');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<h1>first</h1>]\n          [<h1>second</h1>]\n          [x-bar]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-bar', '<h2>wow</h2>');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<h1>first</h1>]\n          [<h1>second</h1>]\n          [<h2>wow</h2>]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-foo', '<strong>x-foo</strong> <em>{{@name}}</em>');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<strong>x-foo</strong> <em>first</em>]\n          [<strong>x-foo</strong> <em>second</em>]\n          [<h2>wow</h2>]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-foo', 'x-foo: {{@name}}');
          this.hotReload('x-bar', 'x-bar');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [x-foo: first]\n          [x-foo: second]\n          [x-bar]\n        "]))));
      });
    }
    ['@test hot reloading class-based components']() {
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [{{component (hot-reload \"x-foo\") name=\"first\"}}]\n          [{{component (hot-reload \"x-foo\") name=\"second\"}}]\n          [{{component (hot-reload \"x-bar\")}}]\n        "]))));
      let id = 0;
      this.addComponent('x-foo', {
        ComponentClass: _glimmer.Component.extend({
          tagName: '',
          init() {
            this._super(...arguments);
            this.set('id', id++);
          }
        }),
        template: 'x-foo: {{@name}} ({{this.id}})'
      });
      this.addComponent('x-bar', {
        ComponentClass: _glimmer.Component.extend({
          tagName: '',
          init() {
            this._super(...arguments);
            this.set('id', id++);
          }
        }),
        template: 'x-bar ({{this.id}})'
      });
      return this.visit('/').then(() => {
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [x-foo: first (0)]\n          [x-foo: second (1)]\n          [x-bar (2)]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-foo', '<h1>{{@name}} ({{this.id}})</h1>');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<h1>first (3)</h1>]\n          [<h1>second (4)</h1>]\n          [x-bar (2)]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-bar', '<h2>wow ({{this.id}})</h2>');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<h1>first (3)</h1>]\n          [<h1>second (4)</h1>]\n          [<h2>wow (5)</h2>]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-foo', '<strong>x-foo</strong> <em>{{@name}} ({{this.id}})</em>');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<strong>x-foo</strong> <em>first (6)</em>]\n          [<strong>x-foo</strong> <em>second (7)</em>]\n          [<h2>wow (5)</h2>]\n        "]))));
        (0, _internalTestHelpers.runTask)(() => {
          this.hotReload('x-foo', 'x-foo: {{@name}} ({{this.id}})');
          this.hotReload('x-bar', 'x-bar ({{this.id}})');
        });
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [x-foo: first (8)]\n          [x-foo: second (9)]\n          [x-bar (10)]\n        "]))));
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/application/rendering-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/controller", "@ember/routing/route", "@ember/service", "@ember/-internals/glimmer", "@ember/-internals/metal", "@ember/object", "@ember/-internals/glimmer/tests/utils/debug-stack", "internal-test-helpers/lib/run"], function (_emberBabel, _internalTestHelpers, _environment, _controller, _route, _service, _glimmer, _metal, _object, _debugStack, _run) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22;
  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('Application test: rendering', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
    }
    teardown() {
      super.teardown();
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
    }
    ['@test it can render the application template with a wrapper']() {
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = true;
      this.addTemplate('application', 'Hello world!');
      return this.visit('/').then(() => {
        this.assertComponentElement(this.element, {
          content: 'Hello world!'
        });
      });
    }
    ['@test it can render the application template without a wrapper']() {
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      this.addTemplate('application', 'Hello world!');
      return this.visit('/').then(() => {
        this.assertInnerHTML('Hello world!');
      });
    }
    ['@test it can access the model provided by the route via @model']() {
      this.add('route:application', _route.default.extend({
        model() {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <ul>\n          {{#each @model as |item|}}\n            <li>{{item}}</li>\n          {{/each}}\n        </ul>\n        "]))));
      return this.visit('/').then(() => {
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <ul>\n          <li>red</li>\n          <li>yellow</li>\n          <li>blue</li>\n        </ul>\n      "]))));
      });
    }
    ['@test it can access the model provided by the route via this.model']() {
      this.add('route:application', _route.default.extend({
        model() {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <ul>\n          {{#each this.model as |item|}}\n            <li>{{item}}</li>\n          {{/each}}\n        </ul>\n        "]))));
      return this.visit('/').then(() => {
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <ul>\n          <li>red</li>\n          <li>yellow</li>\n          <li>blue</li>\n        </ul>\n      "]))));
      });
    }
    async ['@test interior mutations on the model with set'](assert) {
      this.router.map(function () {
        this.route('color', {
          path: '/:color'
        });
      });
      this.add('route:color', _route.default.extend({
        model(_ref) {
          let {
            color
          } = _ref;
          return {
            color
          };
        }
      }));
      this.addTemplate('color', (0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: {{@model.color}}]\n        [this.model: {{this.model.color}}]\n        [model: {{this.model.color}}]\n        "]))));
      await this.visit('/red');
      assert.equal(this.currentURL, '/red');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: red]\n        [this.model: red]\n        [model: red]\n      "]))));
      await this.visit('/yellow');
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: yellow]\n        [this.model: yellow]\n        [model: yellow]\n      "]))));
      (0, _run.runTask)(() => {
        let {
          model
        } = this.controllerFor('color');
        (0, _object.set)(model, 'color', 'blue');
      });
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: blue]\n        [this.model: blue]\n        [model: blue]\n      "]))));
    }
    async ['@test interior mutations on the model with tracked properties'](assert) {
      var _class, _descriptor;
      let Model = (_class = class Model {
        constructor(color) {
          _initializerDefineProperty(this, "color", _descriptor, this);
          this.color = color;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "color", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class);
      this.router.map(function () {
        this.route('color', {
          path: '/:color'
        });
      });
      this.add('route:color', _route.default.extend({
        model(_ref2) {
          let {
            color
          } = _ref2;
          return new Model(color);
        }
      }));
      this.addTemplate('color', (0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: {{@model.color}}]\n        [this.model: {{this.model.color}}]\n        [model: {{this.model.color}}]\n        "]))));
      await this.visit('/red');
      assert.equal(this.currentURL, '/red');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: red]\n        [this.model: red]\n        [model: red]\n      "]))));
      await this.visit('/yellow');
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: yellow]\n        [this.model: yellow]\n        [model: yellow]\n      "]))));
      (0, _run.runTask)(() => {
        this.controllerFor('color').model.color = 'blue';
      });
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: blue]\n        [this.model: blue]\n        [model: blue]\n      "]))));
    }
    async ['@test exterior mutations on the model with set'](assert) {
      this.router.map(function () {
        this.route('color', {
          path: '/:color'
        });
      });
      this.add('route:color', _route.default.extend({
        model(_ref3) {
          let {
            color
          } = _ref3;
          return color;
        }
      }));
      this.addTemplate('color', (0, _internalTestHelpers.strip)(_templateObject13 || (_templateObject13 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: {{@model}}]\n        [this.model: {{this.model}}]\n        [model: {{this.model}}]\n        "]))));
      await this.visit('/red');
      assert.equal(this.currentURL, '/red');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject14 || (_templateObject14 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: red]\n        [this.model: red]\n        [model: red]\n      "]))));
      await this.visit('/yellow');
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject15 || (_templateObject15 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: yellow]\n        [this.model: yellow]\n        [model: yellow]\n      "]))));
      (0, _run.runTask)(() => {
        let controller = this.controllerFor('color');
        (0, _object.set)(controller, 'model', 'blue');
      });
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject16 || (_templateObject16 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: yellow]\n        [this.model: blue]\n        [model: blue]\n      "]))));
    }
    async ['@test exterior mutations on the model with tracked properties'](assert) {
      var _class3, _descriptor2;
      this.router.map(function () {
        this.route('color', {
          path: '/:color'
        });
      });
      this.add('route:color', _route.default.extend({
        model(_ref4) {
          let {
            color
          } = _ref4;
          return color;
        }
      }));
      this.add('controller:color', (_class3 = class ColorController extends _controller.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "model", _descriptor2, this);
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "model", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class3));
      this.addTemplate('color', (0, _internalTestHelpers.strip)(_templateObject17 || (_templateObject17 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: {{@model}}]\n        [this.model: {{this.model}}]\n        [model: {{this.model}}]\n        "]))));
      await this.visit('/red');
      assert.equal(this.currentURL, '/red');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject18 || (_templateObject18 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: red]\n        [this.model: red]\n        [model: red]\n      "]))));
      await this.visit('/yellow');
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject19 || (_templateObject19 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: yellow]\n        [this.model: yellow]\n        [model: yellow]\n      "]))));
      (0, _run.runTask)(() => {
        this.controllerFor('color').model = 'blue';
      });
      assert.equal(this.currentURL, '/yellow');
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject20 || (_templateObject20 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        [@model: yellow]\n        [this.model: blue]\n        [model: blue]\n      "]))));
    }
    ['@test it can render a nested route']() {
      this.router.map(function () {
        this.route('lists', function () {
          this.route('colors', function () {
            this.route('favorite');
          });
        });
      });

      // The "favorite" route will inherit the model
      this.add('route:lists.colors', _route.default.extend({
        model() {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('lists.colors.favorite', (0, _internalTestHelpers.strip)(_templateObject21 || (_templateObject21 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <ul>\n          {{#each @model as |item|}}\n            <li>{{item}}</li>\n          {{/each}}\n        </ul>\n        "]))));
      return this.visit('/lists/colors/favorite').then(() => {
        this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject22 || (_templateObject22 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <ul>\n            <li>red</li>\n            <li>yellow</li>\n            <li>blue</li>\n          </ul>\n        "]))));
      });
    }
    ['@test it should update the outlets when switching between routes']() {
      this.router.map(function () {
        this.route('a');
        this.route('b', function () {
          this.route('c');
          this.route('d');
        });
      });
      this.addTemplate('a', 'A{{outlet}}');
      this.addTemplate('b', 'B{{outlet}}');
      this.addTemplate('b.c', 'C');
      this.addTemplate('b.d', 'D');
      return this.visit('/b/c').then(() => {
        // this.assertComponentElement(this.firstChild, { content: 'BC' });
        this.assertText('BC');
        return this.visit('/a');
      }).then(() => {
        // this.assertComponentElement(this.firstChild, { content: 'A' });
        this.assertText('A');
        return this.visit('/b/d');
      }).then(() => {
        this.assertText('BD');
        // this.assertComponentElement(this.firstChild, { content: 'BD' });
      });
    }

    ['@test it should produce a stable DOM when the model changes']() {
      this.router.map(function () {
        this.route('color', {
          path: '/colors/:color'
        });
      });
      this.add('route:color', _route.default.extend({
        model(params) {
          return params.color;
        }
      }));
      this.addTemplate('color', 'color: {{@model}}');
      return this.visit('/colors/red').then(() => {
        this.assertInnerHTML('color: red');
        this.takeSnapshot();
        return this.visit('/colors/green');
      }).then(() => {
        this.assertInnerHTML('color: green');
        this.assertInvariants();
      });
    }
    ['@test it should have the right controller in scope for the route template']() {
      this.router.map(function () {
        this.route('a');
        this.route('b');
      });
      this.add('controller:a', _controller.default.extend({
        value: 'a'
      }));
      this.add('controller:b', _controller.default.extend({
        value: 'b'
      }));
      this.addTemplate('a', '{{this.value}}');
      this.addTemplate('b', '{{this.value}}');
      return this.visit('/a').then(() => {
        this.assertText('a');
        return this.visit('/b');
      }).then(() => this.assertText('b'));
    }

    // Regression test, glimmer child outlets tried to assume the first element.
    // but the if put-args clobbered the args used by did-create-element.
    // I wish there was a way to assert that the OutletComponentManager did not
    // receive a didCreateElement.
    ['@test a child outlet is always a fragment']() {
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', '{{#if true}}1{{/if}}<div>2</div>');
      return this.visit('/').then(() => {
        this.assertInnerHTML('1<div>2</div>');
      });
    }
    ['@test it allows a transition during route activate']() {
      this.router.map(function () {
        this.route('a');
      });
      this.add('route:index', _route.default.extend({
        router: (0, _service.service)(),
        activate() {
          this.router.transitionTo('a');
        }
      }));
      this.addTemplate('a', 'Hello from A!');
      return this.visit('/').then(() => {
        this.assertInnerHTML('Hello from A!');
      });
    }
    async ['@test it emits a useful backtracking re-render assertion message'](assert) {
      this.router.map(function () {
        this.route('routeWithError');
      });
      this.add('route:routeWithError', _route.default.extend({
        model() {
          return {
            name: 'Alex',
            toString() {
              return "Person (" + this.name + ")";
            }
          };
        }
      }));
      this.addTemplate('routeWithError', 'Hi {{@model.name}} <Foo @person={{@model}} />');
      let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('name', 'Person \\(Ben\\)', {
        renderTree: ['application', 'routeWithError', '@model.name']
      });
      await this.visit('/');
      this.addComponent('foo', {
        ComponentClass: _glimmer.Component.extend({
          init() {
            this._super(...arguments);
            this.set('person.name', 'Ben');
          }
        }),
        template: 'Hi {{this.person.name}} from component'
      });
      return assert.rejectsAssertion(this.visit('/routeWithError'), expectedBacktrackingMessage);
    }
    ['@test route templates with {{{undefined}}} [GH#14924] [GH#16172]']() {
      this.router.map(function () {
        this.route('first');
        this.route('second');
      });
      this.addTemplate('first', 'first');
      this.addTemplate('second', '{{{undefined}}}second');
      return this.visit('/first').then(() => {
        this.assertText('first');
        return this.visit('/second');
      }).then(() => {
        this.assertText('second');
        return this.visit('/first');
      }).then(() => {
        this.assertText('first');
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/angle-bracket-invocation-test", ["ember-babel", "internal-test-helpers", "@glimmer/manager", "@ember/-internals/environment", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _manager, _environment, _object, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
  class CustomModifierManager {
    constructor(owner) {
      this.capabilities = (0, _manager.modifierCapabilities)('3.22');
      this.owner = owner;
    }
    createModifier(factory, args) {
      return factory.create(args);
    }
    installModifier(instance, element, args) {
      instance.element = element;
      let {
        positional,
        named
      } = args;
      instance.didInsertElement(positional, named);
    }
    updateModifier(instance, args) {
      let {
        positional,
        named
      } = args;
      instance.didUpdate(positional, named);
    }
    destroyModifier(instance) {
      instance.willDestroyElement();
    }
  }
  let BaseModifier = (0, _manager.setModifierManager)(owner => {
    return new CustomModifierManager(owner);
  }, _object.default.extend({
    didInsertElement() {},
    didUpdate() {},
    willDestroyElement() {}
  }));
  (0, _internalTestHelpers.moduleFor)('AngleBracket Invocation', class extends _internalTestHelpers.RenderingTestCase {
    '@test it can resolve <XBlah /> to x-blah'() {
      this.registerComponent('x-blah', {
        template: 'hello'
      });
      this.render('<XBlah />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test it can resolve <X-Blah /> to x-blah'() {
      this.registerComponent('x-blah', {
        template: 'hello'
      });
      this.render('<X-Blah />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test it can render a basic template only component'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test it can render a basic component with template and javascript'() {
      this.registerComponent('foo-bar', {
        template: 'FIZZ BAR {{this.local}}',
        ComponentClass: _helpers.Component.extend({
          local: 'hey'
        })
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'FIZZ BAR hey'
      });
    }
    '@test it can render a single word component name'() {
      this.registerComponent('foo', {
        template: 'hello'
      });
      this.render('<Foo />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test it can not render a component name without initial capital letter'(assert) {
      this.registerComponent('div', {
        ComponentClass: _helpers.Component.extend({
          init() {
            assert.ok(false, 'should not have created component');
          }
        })
      });
      this.render('<div></div>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: ''
      });
    }
    '@test it can have a custom id and it is not bound'() {
      this.registerComponent('foo-bar', {
        template: '{{this.id}} {{this.elementId}}'
      });
      this.render('<FooBar @id={{this.customId}} />', {
        customId: 'bizz'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'customId', 'bar'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bar bizz'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'customId', 'bizz'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
    }
    '@test it can have a custom id attribute and it is bound'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar id={{this.customId}} />', {
        customId: 'bizz'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'customId', 'bar'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'customId', 'bizz'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'hello'
      });
    }
    '@test it can have a custom tagName'() {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'foo-bar'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('<FooBar></FooBar>');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    }
    '@test it can have a custom tagName from the invocation'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar @tagName="foo-bar" />');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    }
    '@test it can have custom classNames'() {
      let FooBarComponent = _helpers.Component.extend({
        classNames: ['foo', 'bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
    }
    '@test class property on components can be dynamic'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar @class={{if this.fooBar "foo-bar"}} />', {
        fooBar: true
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', false));
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', true));
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
    }
    '@test it can set custom classNames from the invocation'() {
      let FooBarComponent = _helpers.Component.extend({
        classNames: ['foo']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <FooBar @class=\"bar baz\" />\n        <FooBar @classNames=\"bar baz\" />\n        <FooBar />\n      "]))));
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
    }
    '@test it has an element'() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          instance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('<FooBar></FooBar>');
      let element1 = instance.element;
      this.assertComponentElement(element1, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let element2 = instance.element;
      this.assertComponentElement(element2, {
        content: 'hello'
      });
      this.assertSameNode(element2, element1);
    }
    '@test it has the right parentView and childViews'(assert) {
      let fooBarInstance, fooBarBazInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
        }
      });
      let FooBarBazComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarBazInstance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'foo-bar {{foo-bar-baz}}'
      });
      this.registerComponent('foo-bar-baz', {
        ComponentClass: FooBarBazComponent,
        template: 'foo-bar-baz'
      });
      this.render('<FooBar />');
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    }
    '@test it renders passed named arguments'() {
      this.registerComponent('foo-bar', {
        template: '{{@foo}}'
      });
      this.render('<FooBar @foo={{this.model.bar}} />', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.bar', 'Hello'));
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        bar: 'Hola'
      }));
      this.assertText('Hola');
    }
    '@test it reflects named arguments as properties'() {
      this.registerComponent('foo-bar', {
        template: '{{this.foo}}'
      });
      this.render('<FooBar @foo={{this.model.bar}} />', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.bar', 'Hello'));
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        bar: 'Hola'
      }));
      this.assertText('Hola');
    }
    '@test it can render a basic component with a block'() {
      this.registerComponent('foo-bar', {
        template: '{{yield}} - In component'
      });
      this.render('<FooBar>hello</FooBar>');
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
    }
    '@test it can yield internal and external properties positionally'() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        greeting: 'hello'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield this.greeting this.greetee.firstName}}'
      });
      this.render('<FooBar @greetee={{this.person}} as |greeting name|>{{name}} {{this.person.lastName}}, {{greeting}}</FooBar>', {
        person: {
          firstName: 'Joel',
          lastName: 'Kang'
        }
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'person', {
        firstName: 'Dora',
        lastName: 'the Explorer'
      }));
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'greeting', 'hola'));
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hola'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(instance, 'greeting', 'hello');
        (0, _object.set)(this.context, 'person', {
          firstName: 'Joel',
          lastName: 'Kang'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
    }
    '@test positional parameters are not allowed'() {
      let TestComponent = class extends _helpers.Component {};
      TestComponent.reopenClass({
        positionalParams: ['first', 'second']
      });
      this.registerComponent('sample-component', {
        ComponentClass: TestComponent,
        template: '{{this.first}}{{this.second}}'
      });

      // this is somewhat silly as the browser "corrects" for these as
      // attribute names, but regardless the thing we care about here is that
      // they are **not** used as positional params
      this.render('<SampleComponent one two />');
      this.assertText('');
    }
    '@test can invoke curried components with capitalized block param names'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#let (component 'foo-bar') as |Other|}}\n          <Other />\n        {{/let}}\n      "]))));
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    }
    '@test can invoke curried components with named args'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.registerComponent('test-harness', {
        template: '<@foo />'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{test-harness foo=(component 'foo-bar')}}"]))));
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    }
    '@test can invoke curried components with a path'() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.registerComponent('test-harness', {
        template: '<this.foo />'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{test-harness foo=(component 'foo-bar')}}"]))));
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    }
    '@test can not invoke curried components with an implicit `this` path'(assert) {
      assert.throws(() => {
        // attempting to compile this template will throw
        this.registerComponent('test-harness', {
          template: '<foo.bar />'
        });
      }, /Error: You used foo.bar as a tag name, but foo is not in scope/);
    }
    '@test has-block'() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#if (has-block)}}\n            Yes\n          {{else}}\n            No\n          {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <CheckBlock />\n        <CheckBlock></CheckBlock>"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    }
    '@test includes invocation specified attributes in root element ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend(),
        template: 'hello'
      });
      this.render('<FooBar data-foo={{this.foo}} data-bar={{this.bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    }
    '@test attributes without values passed at invocation are included in `...attributes` ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>hello</div>'
      });
      this.render('<FooBar data-bar />');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-bar': ''
        },
        content: 'hello'
      });
      this.assertStableRerender();
    }
    '@test attributes without values at definition are included in `...attributes` ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div data-bar ...attributes>hello</div>'
      });
      this.render('<FooBar />');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-bar': ''
        },
        content: 'hello'
      });
      this.assertStableRerender();
    }
    '@test includes invocation specified attributes in `...attributes` slot in tagless component ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>hello</div>'
      });
      this.render('<FooBar data-foo={{this.foo}} data-bar={{this.bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', undefined);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'bar', 'bar');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    }
    '@test merges attributes with `...attributes` in tagless component ("splattributes")'() {
      let instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init() {
            instance = this;
            this._super(...arguments);
            this.localProp = 'qux';
          }
        }),
        template: '<div data-derp={{this.localProp}} ...attributes>hello</div>'
      });
      this.render('<FooBar data-foo={{this.foo}} data-bar={{this.bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'qux',
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'qux',
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', undefined);
        (0, _object.set)(instance, 'localProp', 'QUZ');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'QUZ',
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'bar', 'bar');
        (0, _object.set)(instance, 'localProp', 'qux');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'qux',
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    }
    '@test merges class attribute with `...attributes` in tagless component ("splattributes")'() {
      let instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init() {
            instance = this;
            this._super(...arguments);
            this.localProp = 'qux';
          }
        }),
        template: '<div class={{this.localProp}} ...attributes>hello</div>'
      });
      this.render('<FooBar class={{this.bar}} />', {
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('qux bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('qux bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'bar', undefined);
        (0, _object.set)(instance, 'localProp', 'QUZ');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('QUZ')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'bar', 'bar');
        (0, _object.set)(instance, 'localProp', 'qux');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('qux bar')
        },
        content: 'hello'
      });
    }
    '@test merges trailing class attribute with `...attributes` in tagless component ("splattributes")'() {
      let instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init() {
            instance = this;
            this._super(...arguments);
            this.localProp = 'qux';
          }
        }),
        template: '<div ...attributes class={{this.localProp}}>hello</div>'
      });
      this.render('<FooBar class={{this.bar}} />', {
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar qux')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar qux')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'bar', undefined);
        (0, _object.set)(instance, 'localProp', 'QUZ');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('QUZ')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'bar', 'bar');
        (0, _object.set)(instance, 'localProp', 'qux');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar qux')
        },
        content: 'hello'
      });
    }
    '@test merges class attribute with `...attributes` in yielded contextual component ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{yield (hash baz=(component "foo-bar/baz"))}}'
      });
      this.registerComponent('foo-bar/baz', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div class="default-class" ...attributes>hello</div>'
      });
      this.render('<FooBar as |fb|><fb.baz class="custom-class" title="foo"></fb.baz></FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('default-class custom-class'),
          title: 'foo'
        },
        content: 'hello'
      });
    }
    '@test merges trailing class attribute with `...attributes` in yielded contextual component ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{yield (hash baz=(component "foo-bar/baz"))}}'
      });
      this.registerComponent('foo-bar/baz', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes class="default-class" >hello</div>'
      });
      this.render('<FooBar as |fb|><fb.baz class="custom-class" title="foo"></fb.baz></FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('custom-class default-class'),
          title: 'foo'
        },
        content: 'hello'
      });
    }
    '@test the attributes passed on invocation trump over the default ones on elements with `...attributes` in yielded contextual component ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{yield (hash baz=(component "foo-bar/baz"))}}'
      });
      this.registerComponent('foo-bar/baz', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div title="bar" ...attributes>hello</div>'
      });
      this.render('<FooBar as |fb|><fb.baz title="foo"></fb.baz></FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          title: 'foo'
        },
        content: 'hello'
      });
    }
    '@test can forward ...attributes to dynamic component invocation ("splattributes")'() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<XInner ...attributes>{{yield}}</XInner>'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>{{yield}}</div>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#let (component 'x-outer') as |Thing|}}\n          <Thing data-foo>Hello!</Thing>\n        {{/let}}\n      "]))));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': ''
        },
        content: 'Hello!'
      });
    }
    '@test an inner angle invocation can forward ...attributes through dynamic component invocation ("splattributes")'() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: "{{#let (component 'x-inner') as |Thing|}}<Thing ...attributes>{{yield}}</Thing>{{/let}}"
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>{{yield}}</div>'
      });
      this.render('<XOuter data-foo>Hello!</XOuter>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': ''
        },
        content: 'Hello!'
      });
    }
    '@test an inner angle invocation can forward ...attributes through static component invocation ("splattributes")'() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: "<XInner ...attributes>{{yield}}</XInner>"
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>{{yield}}</div>'
      });
      this.render('<XOuter data-foo>Hello!</XOuter>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': ''
        },
        content: 'Hello!'
      });
    }
    '@test can include `...attributes` in multiple elements in tagless component ("splattributes")'() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>hello</div><p ...attributes>world</p>'
      });
      this.render('<FooBar data-foo={{this.foo}} data-bar={{this.bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', undefined);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'bar', 'bar');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'world'
      });
    }
    '@test can yield content to contextual components invoked with angle-bracket components that receives splattributes'() {
      this.registerComponent('foo-bar/inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<h1 ...attributes>{{yield}}</h1>'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        // If <Inner> doesn't receive splattributes this test passes
        template: (0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#let (component \"foo-bar/inner\") as |Inner|}}\n            <Inner ...attributes>{{yield}}</Inner>\n            <h2>Inside the let</h2>\n          {{/let}}\n          <h3>Outside the let</h3>\n        "])))
      });
      this.render('<FooBar>Yielded content</FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'h1',
        attrs: {},
        content: 'Yielded content'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'h2',
        attrs: {},
        content: 'Inside the let'
      });
      this.assertElement(this.nthChild(2), {
        tagName: 'h3',
        attrs: {},
        content: 'Outside the let'
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('AngleBracket Invocation (splattributes)', class extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      this._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
    }
    teardown() {
      super.teardown();
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
    }
    registerComponent(name, template) {
      super.registerComponent(name, {
        template,
        ComponentClass: null
      });
    }
    '@test angle bracket invocation can pass merge ...attributes'() {
      this.registerComponent('qux', '<div data-from-qux-before ...attributes data-from-qux-after></div>');
      this.registerComponent('bar', '<Qux data-from-bar-before ...attributes data-from-bar-after />');
      this.registerComponent('foo', '<Bar data-from-foo-before ...attributes data-from-foo-after />');
      this.render('<Foo data-from-top />');
      this.assertHTML("<div\n        data-from-qux-before=\"\"\n        data-from-bar-before=\"\"\n        data-from-foo-before=\"\"\n        data-from-top=\"\"\n        data-from-foo-after=\"\"\n        data-from-bar-after=\"\"\n        data-from-qux-after=\"\"\n      ></div>");
    }
    '@test angle bracket invocation can allow invocation side to override attributes with ...attributes'() {
      this.registerComponent('qux', '<div id="qux" ...attributes />');
      this.registerComponent('bar', '<Qux id="bar" ...attributes />');
      this.registerComponent('foo', '<Bar id="foo" ...attributes />');
      this.render('<Foo id="top" />');
      this.assertHTML('<div id="top"></div>');
    }
    '@test angle bracket invocation can override invocation side attributes with ...attributes'() {
      this.registerComponent('qux', '<div ...attributes id="qux" />');
      this.registerComponent('bar', '<Qux ...attributes id="bar" />');
      this.registerComponent('foo', '<Bar ...attributes id="foo" />');
      this.render('<Foo id="top" />');
      this.assertHTML('<div id="qux"></div>');
    }
    '@test angle bracket invocation can forward classes before ...attributes to a nested component'() {
      this.registerComponent('qux', '<div class="qux" ...attributes />');
      this.registerComponent('bar', '<Qux class="bar" ...attributes />');
      this.registerComponent('foo', '<Bar class="foo" ...attributes />');
      this.render('<Foo class="top" />');
      this.assertHTML('<div class="qux bar foo top"></div>');
    }
    '@test angle bracket invocation can forward classes after ...attributes to a nested component'() {
      this.registerComponent('qux', '<div ...attributes class="qux" />');
      this.registerComponent('bar', '<Qux ...attributes class="bar" />');
      this.registerComponent('foo', '<Bar ...attributes class="foo" />');
      this.render('<Foo class="top" />');
      this.assertHTML('<div class="top foo bar qux"></div>');
    }
  });
  (0, _internalTestHelpers.moduleFor)('AngleBracket Invocation Nested Lookup', class extends _internalTestHelpers.RenderingTestCase {
    '@test it can resolve <Foo::Bar::BazBing /> to foo/bar/baz-bing'() {
      this.registerComponent('foo/bar/baz-bing', {
        template: 'hello'
      });
      this.render('<Foo::Bar::BazBing />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Element modifiers on AngleBracket components', class extends _internalTestHelpers.RenderingTestCase {
    assertNamedArgs(actual, expected, message) {
      // `actual` is likely to be a named args proxy, while the `deepEqual` below would see
      // the values as the same it would still flag as not deep equals because the constructors
      // of the two objects do not match (one is a proxy, one is Object)
      let reifiedActual = Object.assign({}, actual);
      this.assert.deepEqual(reifiedActual, expected, message);
    }
    '@test modifiers are forwarded to a single element receiving the splattributes'(assert) {
      let modifierParams = null;
      let modifierNamedArgs = null;
      let modifiedElement;
      this.registerComponent('the-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="inner-div" ...attributes>Foo</div>'
      });
      this.registerModifier('bar', BaseModifier.extend({
        didInsertElement(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        }
      }));
      this.render('<TheFoo {{bar "something" foo="else"}}/>', {});
      assert.deepEqual(modifierParams, ['something'], 'positional arguments');
      this.assertNamedArgs(modifierNamedArgs, {
        foo: 'else'
      }, 'named arguments');
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
    }
    '@test modifiers are forwarded to all the elements receiving the splattributes'(assert) {
      let elementIds = [];
      this.registerComponent('the-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="inner-one" ...attributes>Foo</div><div id="inner-two" ...attributes>Bar</div>'
      });
      let test = this;
      this.registerModifier('bar', BaseModifier.extend({
        didInsertElement(params, namedArgs) {
          assert.deepEqual(params, ['something']);
          test.assertNamedArgs(namedArgs, {
            foo: 'else'
          });
          if (this.element) {
            elementIds.push(this.element.getAttribute('id'));
          }
        }
      }));
      this.render('<TheFoo {{bar "something" foo="else"}}/>');
      assert.deepEqual(elementIds, ['inner-one', 'inner-two'], 'The modifier has been instantiated twice, once for each element with splattributes');
    }
    '@test modifiers on components accept bound arguments and track changes on the'(assert) {
      let modifierParams = null;
      let modifierNamedArgs = null;
      let modifiedElement;
      this.registerComponent('the-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="inner-div" ...attributes>Foo</div>'
      });
      this.registerModifier('bar', BaseModifier.extend({
        didInsertElement(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        },
        didUpdate(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        }
      }));
      this.render('<TheFoo {{bar this.something foo=this.foo}}/>', {
        something: 'something',
        foo: 'else'
      });
      assert.deepEqual(modifierParams, ['something']);
      this.assertNamedArgs(modifierNamedArgs, {
        foo: 'else'
      });
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        something: 'another',
        foo: 'thingy'
      }));
      assert.deepEqual(modifierParams, ['another']);
      this.assertNamedArgs(modifierNamedArgs, {
        foo: 'thingy'
      });
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
    }
    '@test modifiers on components accept `this` in both positional params and named arguments, and updates when it changes'(assert) {
      let modifierParams = null;
      let modifierNamedArgs = null;
      let modifiedElement;
      let context = {
        id: 1
      };
      let context2 = {
        id: 2
      };
      this.registerComponent('the-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="inner-div" ...attributes>Foo</div>'
      });
      this.registerModifier('bar', BaseModifier.extend({
        didInsertElement(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        },
        didUpdate(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        }
      }));
      this.render('<TheFoo {{bar "name" this foo=this}}/>', context);
      assert.equal(modifierParams[1].id, 1);
      assert.equal(modifierNamedArgs.foo.id, 1);
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, context2));
      assert.equal(modifierParams[1].id, 2);
      assert.equal(modifierNamedArgs.foo.id, 2);
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
    }
    '@test modifiers on components accept local variables in both positional params and named arguments, and updates when they change'(assert) {
      let modifierParams = null;
      let modifierNamedArgs = null;
      let modifiedElement;
      this.registerComponent('the-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="inner-div" ...attributes>Foo</div>'
      });
      this.registerModifier('bar', BaseModifier.extend({
        didInsertElement(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        },
        didUpdate(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          modifiedElement = this.element;
        }
      }));
      this.render("\n        {{#let this.foo as |v|}}\n          <TheFoo {{bar v foo=v}}/>\n        {{/let}}", {
        foo: 'bar'
      });
      assert.deepEqual(modifierParams, ['bar']);
      this.assertNamedArgs(modifierNamedArgs, {
        foo: 'bar'
      });
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        foo: 'qux'
      }));
      assert.deepEqual(modifierParams, ['qux']);
      this.assertNamedArgs(modifierNamedArgs, {
        foo: 'qux'
      });
      assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
    }
    '@test modifiers on components can be received and forwarded to inner component'(assert) {
      let modifierParams = null;
      let modifierNamedArgs = null;
      let elementIds = [];
      this.registerComponent('the-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="inner-div" ...attributes>{{yield}}</div>'
      });
      this.registerComponent('the-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="outer-div" ...attributes>Outer</div><TheInner ...attributes>Hello</TheInner>'
      });
      this.registerModifier('bar', BaseModifier.extend({
        didInsertElement(params, namedArgs) {
          modifierParams = params;
          modifierNamedArgs = namedArgs;
          if (this.element) {
            elementIds.push(this.element.getAttribute('id'));
          }
        }
      }));
      this.render("\n        {{#let this.foo as |v|}}\n          <TheFoo {{bar v foo=v}}/>\n        {{/let}}\n      ", {
        foo: 'bar'
      });
      assert.deepEqual(modifierParams, ['bar']);
      this.assertNamedArgs(modifierNamedArgs, {
        foo: 'bar'
      });
      assert.deepEqual(elementIds, ['outer-div', 'inner-div'], 'Modifiers are called on all levels');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/append-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _helpers) {
  "use strict";

  var _templateObject;
  class AbstractAppendTest extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      this.components = [];
      this.ids = [];
    }
    teardown() {
      this.component = null;
      this.components.forEach(component => {
        (0, _internalTestHelpers.runTask)(() => component.destroy());
      });
      this.ids.forEach(id => {
        let $element = document.getElementById(id);
        if ($element) {
          $element.parentNode.removeChild($element);
        }
        // this.assert.strictEqual($element.length, 0, `Should not leak element: #${id}`);
      });

      super.teardown();
    }

    /* abstract append(component): Element; */

    didAppend(component) {
      this.components.push(component);
      this.ids.push(component.elementId);
    }
    ['@test lifecycle hooks during component append'](assert) {
      let hooks = [];
      let oldRegisterComponent = this.registerComponent;
      let componentsByName = {};

      // TODO: refactor/combine with other life-cycle tests
      this.registerComponent = function (name, _options) {
        function pushHook(hookName) {
          hooks.push([name, hookName]);
        }
        let options = {
          ComponentClass: _options.ComponentClass.extend({
            init() {
              this._super(...arguments);
              if (name in componentsByName) {
                throw new TypeError('Component named: ` ' + name + ' ` already registered');
              }
              componentsByName[name] = this;
              pushHook('init');
              this.on('init', () => pushHook('on(init)'));
            },
            didReceiveAttrs() {
              pushHook('didReceiveAttrs');
            },
            willInsertElement() {
              pushHook('willInsertElement');
            },
            willRender() {
              pushHook('willRender');
            },
            didInsertElement() {
              pushHook('didInsertElement');
            },
            didRender() {
              pushHook('didRender');
            },
            didUpdateAttrs() {
              pushHook('didUpdateAttrs');
            },
            willUpdate() {
              pushHook('willUpdate');
            },
            didUpdate() {
              pushHook('didUpdate');
            },
            willDestroyElement() {
              pushHook('willDestroyElement');
            },
            willClearRender() {
              pushHook('willClearRender');
            },
            didDestroyElement() {
              pushHook('didDestroyElement');
            },
            willDestroy() {
              pushHook('willDestroy');
              this._super(...arguments);
            }
          }),
          template: _options.template
        };
        oldRegisterComponent.call(this, name, options);
      };
      this.registerComponent('x-parent', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-parent'
        }),
        template: '[parent: {{this.foo}}]{{#x-child bar=this.foo}}[yielded: {{this.foo}}]{{/x-child}}'
      });
      this.registerComponent('x-child', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '[child: {{this.bar}}]{{yield}}'
      });
      let XParent;
      XParent = this.owner.factoryFor('component:x-parent');
      this.component = XParent.create({
        foo: 'zomg'
      });
      assert.deepEqual(hooks, [['x-parent', 'init'], ['x-parent', 'on(init)']], 'creation of x-parent');
      hooks.length = 0;
      this.element = this.append(this.component);
      assert.deepEqual(hooks, [['x-parent', 'willInsertElement'], ['x-child', 'init'], ['x-child', 'on(init)'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willRender'], ['x-child', 'willInsertElement'], ['x-child', 'didInsertElement'], ['x-child', 'didRender'], ['x-parent', 'didInsertElement'], ['x-parent', 'didRender']], 'appending of x-parent');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(() => componentsByName['x-parent'].rerender());
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'rerender x-parent');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(() => componentsByName['x-child'].rerender());
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'rerender x-child');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.component, 'foo', 'wow'));
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'didUpdateAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'set foo = wow');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.component, 'foo', 'zomg'));
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'didUpdateAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'set foo = zomg');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(() => this.component.destroy());
      assert.deepEqual(hooks, [['x-parent', 'willDestroyElement'], ['x-parent', 'willClearRender'], ['x-child', 'willDestroyElement'], ['x-child', 'willClearRender'], ['x-parent', 'didDestroyElement'], ['x-parent', 'willDestroy'], ['x-child', 'didDestroyElement'], ['x-child', 'willDestroy']], 'destroy');
    }
    ['@test appending, updating and destroying a single component'](assert) {
      let willDestroyCalled = 0;
      this.registerComponent('x-parent', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-parent',
          willDestroyElement() {
            willDestroyCalled++;
          }
        }),
        template: '[parent: {{this.foo}}]{{#x-child bar=this.foo}}[yielded: {{this.foo}}]{{/x-child}}'
      });
      this.registerComponent('x-child', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '[child: {{this.bar}}]{{yield}}'
      });
      let XParent;
      XParent = this.owner.factoryFor('component:x-parent');
      this.component = XParent.create({
        foo: 'zomg'
      });
      assert.ok(!this.component.element, 'precond - should not have an element');
      this.element = this.append(this.component);
      let componentElement = this.component.element;
      this.assertComponentElement(componentElement, {
        content: '[parent: zomg][child: zomg][yielded: zomg]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(componentElement, {
        content: '[parent: zomg][child: zomg][yielded: zomg]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.component, 'foo', 'wow'));
      this.assertComponentElement(componentElement, {
        content: '[parent: wow][child: wow][yielded: wow]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.component, 'foo', 'zomg'));
      this.assertComponentElement(componentElement, {
        content: '[parent: zomg][child: zomg][yielded: zomg]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => this.component.destroy());
      assert.ok(!this.component.element, 'It should not have an element');
      assert.ok(!componentElement.parentElement, 'The component element should be detached');
      this.assert.equal(willDestroyCalled, 1);
    }
    ['@test releasing a root component after it has been destroy'](assert) {
      let renderer = this.owner.lookup('renderer:-dom');
      this.registerComponent('x-component', {
        ComponentClass: _helpers.Component.extend()
      });
      this.component = this.owner.factoryFor('component:x-component').create();
      this.append(this.component);
      assert.equal(renderer._roots.length, 1, 'added a root component');
      (0, _internalTestHelpers.runTask)(() => this.component.destroy());
      assert.equal(renderer._roots.length, 0, 'released the root component');
    }
    ['@test appending, updating and destroying multiple components'](assert) {
      let willDestroyCalled = 0;
      this.registerComponent('x-first', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-first',
          willDestroyElement() {
            willDestroyCalled++;
          }
        }),
        template: 'x-first {{this.foo}}!'
      });
      this.registerComponent('x-second', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-second',
          willDestroyElement() {
            willDestroyCalled++;
          }
        }),
        template: 'x-second {{this.bar}}!'
      });
      let First, Second;
      First = this.owner.factoryFor('component:x-first');
      Second = this.owner.factoryFor('component:x-second');
      let first = First.create({
        foo: 'foo'
      });
      let second = Second.create({
        bar: 'bar'
      });
      this.assert.ok(!first.element, 'precond - should not have an element');
      this.assert.ok(!second.element, 'precond - should not have an element');
      let wrapper1, wrapper2;
      (0, _internalTestHelpers.runTask)(() => wrapper1 = this.append(first));
      (0, _internalTestHelpers.runTask)(() => wrapper2 = this.append(second));
      let componentElement1 = first.element;
      let componentElement2 = second.element;
      this.assertComponentElement(componentElement1, {
        content: 'x-first foo!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second bar!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(first, 'foo', 'FOO'));
      this.assertComponentElement(componentElement1, {
        content: 'x-first FOO!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second bar!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(second, 'bar', 'BAR'));
      this.assertComponentElement(componentElement1, {
        content: 'x-first FOO!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second BAR!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(first, 'foo', 'foo');
        (0, _object.set)(second, 'bar', 'bar');
      });
      this.assertComponentElement(componentElement1, {
        content: 'x-first foo!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second bar!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(() => {
        first.destroy();
        second.destroy();
      });
      assert.ok(!first.element, 'The first component should not have an element');
      assert.ok(!second.element, 'The second component should not have an element');
      assert.ok(!componentElement1.parentElement, 'The first component element should be detached');
      assert.ok(!componentElement2.parentElement, 'The second component element should be detached');
      this.assert.equal(willDestroyCalled, 2);
    }
    ['@test can appendTo while rendering']() {
      let owner = this.owner;
      let append = component => {
        return this.append(component);
      };
      let element1, element2;
      this.registerComponent('first-component', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)('component-one'),
          didInsertElement() {
            element1 = this.element;
            let SecondComponent = owner.factoryFor('component:second-component');
            append(SecondComponent.create());
          }
        })
      });
      this.registerComponent('second-component', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)("component-two"),
          didInsertElement() {
            element2 = this.element;
          }
        })
      });
      let FirstComponent = this.owner.factoryFor('component:first-component');
      (0, _internalTestHelpers.runTask)(() => append(FirstComponent.create()));
      this.assertComponentElement(element1, {
        content: 'component-one'
      });
      this.assertComponentElement(element2, {
        content: 'component-two'
      });
    }
    ['@test can appendTo and remove while rendering'](assert) {
      let owner = this.owner;
      let append = component => {
        return this.append(component);
      };
      let element1, element2, element3, element4, component1, component2;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)('foo-bar'),
          init() {
            this._super(...arguments);
            component1 = this;
          },
          didInsertElement() {
            element1 = this.element;
            let OtherRoot = owner.factoryFor('component:other-root');
            this._instance = OtherRoot.create({
              didInsertElement() {
                element2 = this.element;
              }
            });
            append(this._instance);
          },
          willDestroy() {
            this._instance.destroy();
          }
        })
      });
      this.registerComponent('baz-qux', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)('baz-qux'),
          init() {
            this._super(...arguments);
            component2 = this;
          },
          didInsertElement() {
            element3 = this.element;
            let OtherRoot = owner.factoryFor('component:other-root');
            this._instance = OtherRoot.create({
              didInsertElement() {
                element4 = this.element;
              }
            });
            append(this._instance);
          },
          willDestroy() {
            this._instance.destroy();
          }
        })
      });
      let instantiatedRoots = 0;
      let destroyedRoots = 0;
      this.registerComponent('other-root', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)("fake-thing: {{this.counter}}"),
          init() {
            this._super(...arguments);
            this.counter = instantiatedRoots++;
          },
          willDestroy() {
            destroyedRoots++;
            this._super(...arguments);
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#if this.showFooBar}}\n        {{foo-bar}}\n      {{else}}\n        {{baz-qux}}\n      {{/if}}\n    "]))), {
        showFooBar: true
      });
      this.assertComponentElement(element1, {});
      this.assertComponentElement(element2, {
        content: 'fake-thing: 0'
      });
      assert.equal(instantiatedRoots, 1);
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'showFooBar', false));
      assert.equal(instantiatedRoots, 2);
      assert.equal(destroyedRoots, 1);
      this.assertComponentElement(element3, {});
      this.assertComponentElement(element4, {
        content: 'fake-thing: 1'
      });
      (0, _internalTestHelpers.runTask)(() => {
        component1.destroy();
        component2.destroy();
      });
      assert.equal(instantiatedRoots, 2);
      assert.equal(destroyedRoots, 2);
    }
  }
  (0, _internalTestHelpers.moduleFor)('append: no arguments (attaching to document.body)', class extends AbstractAppendTest {
    append(component) {
      (0, _internalTestHelpers.runTask)(() => component.append());
      this.didAppend(component);
      return document.body;
    }
  });
  (0, _internalTestHelpers.moduleFor)('appendTo: a selector', class extends AbstractAppendTest {
    append(component) {
      (0, _internalTestHelpers.runTask)(() => component.appendTo('#qunit-fixture'));
      this.didAppend(component);
      return document.getElementById('qunit-fixture');
    }
    ['@test raises an assertion when the target does not exist in the DOM'](assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/foo-bar'
        }),
        template: 'FOO BAR!'
      });
      let FooBar = this.owner.factoryFor('component:foo-bar');
      this.component = FooBar.create();
      assert.ok(!this.component.element, 'precond - should not have an element');
      (0, _internalTestHelpers.runTask)(() => {
        expectAssertion(() => {
          this.component.appendTo('#does-not-exist-in-dom');
        }, /You tried to append to \(#does-not-exist-in-dom\) but that isn't in the DOM/);
      });
      assert.ok(!this.component.element, 'component should not have an element');
    }
  });
  (0, _internalTestHelpers.moduleFor)('appendTo: an element', class extends AbstractAppendTest {
    append(component) {
      let element = document.getElementById('qunit-fixture');
      (0, _internalTestHelpers.runTask)(() => component.appendTo(element));
      this.didAppend(component);
      return element;
    }
  });
  (0, _internalTestHelpers.moduleFor)('appendTo: with multiple components', class extends AbstractAppendTest {
    append(component) {
      (0, _internalTestHelpers.runTask)(() => component.appendTo('#qunit-fixture'));
      this.didAppend(component);
      return document.getElementById('qunit-fixture');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/attribute-bindings-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _helpers) {
  "use strict";

  var _templateObject;
  (0, _internalTestHelpers.moduleFor)('Attribute bindings integration', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can have attribute bindings']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo:data-foo', 'bar:data-bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=this.foo bar=this.bar}}', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    }
    ['@test it can have attribute bindings with attrs']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['attrs.foo:data-foo', 'attrs.baz.bar:data-bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=this.model.foo baz=this.model.baz}}', {
        model: {
          foo: undefined,
          baz: {
            bar: 'bar'
          }
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          'data-bar': 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          'data-bar': 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model.foo', 'foo');
        (0, _object.set)(this.context, 'model.baz.bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: undefined,
        baz: {
          bar: 'bar'
        }
      }));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          'data-bar': 'bar'
        }
      });
    }
    ['@test it can have attribute bindings with a nested path']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo.bar:data-foo-bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=this.foo}}', {
        foo: {
          bar: 'foo-bar'
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'foo-bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'foo-bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo.bar', 'FOO-BAR'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'FOO-BAR'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo.bar', undefined));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', undefined));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: 'foo-bar'
      }));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'foo-bar'
        },
        content: 'hello'
      });
    }
    ['@test handles non-microsyntax attributeBindings']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['type']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar type=this.submit}}', {
        submit: 'submit'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'submit'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'submit'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'submit', 'password'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'submit', null));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'submit', 'submit'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'submit'
        },
        content: 'hello'
      });
    }
    ['@test non-microsyntax attributeBindings cannot contain nested paths']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo.bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar foo=this.foo}}', {
          foo: {
            bar: 'foo-bar'
          }
        });
      }, /Illegal attributeBinding: 'foo.bar' is not a valid attribute name./);
    }
    ['@test normalizes attributeBindings for property names']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['tiTLe']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar tiTLe=this.name}}', {
        name: 'qux'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          title: 'qux'
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', null));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'qux'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          title: 'qux'
        },
        content: 'hello'
      });
    }
    ['@test normalizes attributeBindings for attribute names']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo:data-FOO']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=this.foo}}', {
        foo: 'qux'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'qux'
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', null));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'qux'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'qux'
        },
        content: 'hello'
      });
    }
    ['@test  attributeBindings preserves case for mixed-case attributes']() {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'svg',
        attributeBindings: ['viewBox']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });
      this.render('{{foo-bar viewBox=this.foo}}', {
        foo: '0 0 100 100'
      });
      this.assert.equal(this.firstChild.getAttribute('viewBox'), '0 0 100 100', 'viewBox attribute');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', null));
      this.assert.ok(!this.firstChild.hasAttribute('viewBox'), 'viewBox attribute removed');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', '0 0 100 200'));
      this.assert.equal(this.firstChild.getAttribute('viewBox'), '0 0 100 200', 'viewBox attribute');
    }
    ['@test attributeBindings handles null/undefined']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['fizz', 'bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar fizz=this.fizz bar=this.bar}}', {
        fizz: null,
        bar: undefined
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'fizz', 'fizz');
        (0, _object.set)(this.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          fizz: 'fizz',
          bar: 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'fizz', null);
        (0, _object.set)(this.context, 'bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
    }
    ['@test attributeBindings handles number value']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['size']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar size=this.size}}', {
        size: 21
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '21'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '21'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'size', 0));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '0'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'size', 21));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '21'
        },
        content: 'hello'
      });
    }
    ['@test handles internal and external changes']() {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['type'],
        type: 'password',
        init() {
          this._super(...arguments);
          component = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'type', 'checkbox'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'checkbox'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'type', 'password'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
    }
    ['@test can set attributeBindings on component with a different tagName']() {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'input',
        attributeBindings: ['type', 'isDisabled:disabled']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar type=this.type isDisabled=this.disabled}}', {
        type: 'password',
        disabled: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'password'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'password'
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'type', 'checkbox');
        (0, _object.set)(this.context, 'disabled', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'checkbox',
          disabled: ''
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'type', 'password');
        (0, _object.set)(this.context, 'disabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'password'
        }
      });
    }
    ['@test should allow namespaced attributes in micro syntax']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['xlinkHref:xlink:href']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar type=this.type xlinkHref=this.xlinkHref}}', {
        xlinkHref: '/foo.png'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/foo.png'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/foo.png'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'xlinkHref', '/lol.png'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/lol.png'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'xlinkHref', '/foo.png'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/foo.png'
        }
      });
    }

    // This comes into play when using the {{#each}} helper. If the
    // passed array item is a String, it will be converted into a
    // String object instead of a normal string.
    ['@test should allow for String objects']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar foo=this.foo}}', {
        foo: function () {
          return this;
        }.call('bar')
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', function () {
        return this;
      }.call('baz')));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'baz'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', function () {
        return this;
      }.call('bar')));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'bar'
        }
      });
    }
    ['@test can set id initially via attributeBindings ']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['specialSauce:id']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar specialSauce=this.sauce}}', {
        sauce: 'special-sauce'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'sauce', 'foo'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'sauce', 'special-sauce'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
    }
    ['@test attributeBindings are overwritten']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['href'],
        href: 'a href'
      });
      let FizzBarComponent = FooBarComponent.extend({
        attributeBindings: ['newHref:href']
      });
      this.registerComponent('fizz-bar', {
        ComponentClass: FizzBarComponent
      });
      this.render('{{fizz-bar newHref=this.href}}', {
        href: 'dog.html'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          href: 'dog.html'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          href: 'dog.html'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'href', 'cat.html'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          href: 'cat.html'
        }
      });
    }
    ['@test it can set attribute bindings in the constructor']() {
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          let bindings = [];
          if (this.get('hasFoo')) {
            bindings.push('foo:data-foo');
          }
          if (this.get('hasBar')) {
            bindings.push('bar:data-bar');
          }
          this.attributeBindings = bindings;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{foo-bar hasFoo=true foo=this.foo hasBar=false bar=this.bar}}\n      {{foo-bar hasFoo=false foo=this.foo hasBar=true bar=this.bar}}\n      {{foo-bar hasFoo=true foo=this.foo hasBar=true bar=this.bar}}\n      {{foo-bar hasFoo=false foo=this.foo hasBar=false bar=this.bar}}\n    "]))), {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', undefined);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'bar', 'BAR'));
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'BAR'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO',
          'data-bar': 'BAR'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
    }
    ['@test asserts if an attributeBinding is setup on class']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['class']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /You cannot use class as an attributeBinding, use classNameBindings instead./i);
    }
    ['@test blacklists href bindings based on protocol']() {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'a',
        attributeBindings: ['href']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar href=this.xss}}', {
        xss: "javascript:alert('foo')"
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: "unsafe:javascript:alert('foo')"
        }
      });
    }
    ['@test it can bind the role attribute (issue #14007)']() {
      let FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['role']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar role=this.role}}', {
        role: 'button'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          role: 'button'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          role: 'button'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'role', 'combobox'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          role: 'combobox'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'role', null));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div'
      });
    }
    ['@test component with an `id` attribute binding of undefined']() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['id'],
          id: undefined
        })
      });
      this.registerComponent('baz-qux', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['somethingUndefined:id'],
          somethingUndefined: undefined
        })
      });
      this.render("{{foo-bar}}{{baz-qux}}");
      this.assertComponentElement(this.nthChild(0), {
        content: ''
      });
      this.assertComponentElement(this.nthChild(1), {
        content: ''
      });
      this.assert.ok(this.nthChild(0).id.match(/ember\d+/), 'a valid `id` was used');
      this.assert.ok(this.nthChild(1).id.match(/ember\d+/), 'a valid `id` was used');
    }
    ['@test component with an `id` attribute binding of null']() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['id'],
          id: null
        })
      });
      this.registerComponent('baz-qux', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['somethingNull:id'],
          somethingNull: null
        })
      });
      this.render("{{foo-bar}}{{baz-qux}}");
      this.assertComponentElement(this.nthChild(0), {
        content: ''
      });
      this.assertComponentElement(this.nthChild(1), {
        content: ''
      });
      this.assert.ok(this.nthChild(0).id.match(/ember\d+/), 'a valid `id` was used');
      this.assert.ok(this.nthChild(1).id.match(/ember\d+/), 'a valid `id` was used');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/attrs-lookup-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components test: attrs lookup', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it should be able to lookup attrs without `attrs.` - template access']() {
      this.registerComponent('foo-bar', {
        template: '{{this.first}}'
      });
      this.render("{{foo-bar first=this.firstAttr}}", {
        firstAttr: 'first attr'
      });
      this.assertText('first attr');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('first attr');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'firstAttr', 'second attr'));
      this.assertText('second attr');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'firstAttr', 'first attr'));
      this.assertText('first attr');
    }
    ['@test it should be able to lookup attrs without `attrs.` - component access'](assert) {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.first}}'
      });
      this.render("{{foo-bar first=this.firstAttr}}", {
        firstAttr: 'first attr'
      });
      assert.equal(instance.get('first'), 'first attr');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(instance.get('first'), 'first attr');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'firstAttr', 'second attr'));
      assert.equal(instance.get('first'), 'second attr');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'firstAttr', 'first attr'));
      this.assertText('first attr');
    }
    ['@test should be able to modify a provided attr into local state #11571 / #11559'](assert) {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        didReceiveAttrs() {
          this.set('first', this.get('first').toUpperCase());
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.first}}'
      });
      this.render("{{foo-bar first=\"first attr\"}}");
      assert.equal(instance.get('first'), 'FIRST ATTR', 'component lookup uses local state');
      this.assertText('FIRST ATTR');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(instance.get('first'), 'FIRST ATTR', 'component lookup uses local state during rerender');
      this.assertText('FIRST ATTR');

      // This is testing that passing string literals for use as initial values,
      // so there is no update step
    }

    ['@test should be able to access unspecified attr #12035'](assert) {
      let instance;
      let wootVal = 'yes';
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        didReceiveAttrs() {
          assert.equal(this.get('woot'), wootVal, 'found attr in didReceiveAttrs');
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render("{{foo-bar woot=this.woot}}", {
        woot: wootVal
      });
      assert.equal(instance.get('woot'), 'yes', 'component found attr');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(instance.get('woot'), 'yes', 'component found attr after rerender');
      (0, _internalTestHelpers.runTask)(() => {
        wootVal = 'nope';
        (0, _object.set)(this.context, 'woot', wootVal);
      });
      assert.equal(instance.get('woot'), 'nope', 'component found attr after attr change');
      (0, _internalTestHelpers.runTask)(() => {
        wootVal = 'yes';
        (0, _object.set)(this.context, 'woot', wootVal);
      });
      assert.equal(instance.get('woot'), 'yes', 'component found attr after reset');
    }
    ['@test getAttr() should return the same value as get()'](assert) {
      assert.expect(33);
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        didReceiveAttrs() {
          let rootFirstPositional = this.get('firstPositional');
          let rootFirst = this.get('first');
          let rootSecond = this.get('second');
          let attrFirstPositional = this.getAttr('firstPositional');
          let attrFirst = this.getAttr('first');
          let attrSecond = this.getAttr('second');
          assert.equal(rootFirstPositional, attrFirstPositional, 'root property matches attrs value');
          assert.equal(rootFirst, attrFirst, 'root property matches attrs value');
          assert.equal(rootSecond, attrSecond, 'root property matches attrs value');
        }
      });
      FooBarComponent.reopenClass({
        positionalParams: ['firstPositional']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render("{{foo-bar this.firstPositional first=this.first second=this.second}}", {
        firstPositional: 'firstPositional',
        first: 'first',
        second: 'second'
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'first', 'third');
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'second', 'fourth');
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'fourth', 'matches known value');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'firstPositional', 'fifth');
      });
      assert.equal(instance.get('firstPositional'), 'fifth', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'fourth', 'matches known value');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'firstPositional', 'firstPositional');
        (0, _object.set)(this.context, 'first', 'first');
        (0, _object.set)(this.context, 'second', 'second');
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
    }
    ['@test bound computed properties can be overridden in extensions, set during init, and passed in as attrs']() {
      let FooClass = _helpers.Component.extend({
        attributeBindings: ['style'],
        style: (0, _object.computed)('height', 'color', function () {
          let height = this.get('height');
          let color = this.get('color');
          return (0, _helpers.htmlSafe)("height: " + height + "px; background-color: " + color + ";");
        }),
        color: 'red',
        height: 20
      });
      let BarClass = FooClass.extend({
        init() {
          this._super(...arguments);
          this.height = 150;
        },
        color: 'yellow'
      });
      this.registerComponent('x-foo', {
        ComponentClass: FooClass
      });
      this.registerComponent('x-bar', {
        ComponentClass: BarClass
      });
      this.render('{{x-foo}}{{x-bar}}{{x-bar color="green"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 20px; background-color: red;')
        }
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 150px; background-color: yellow;')
        }
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 150px; background-color: green;')
        }
      });
      this.assertStableRerender();

      // No U-R
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/class-bindings-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _helpers) {
  "use strict";

  var _templateObject;
  (0, _internalTestHelpers.moduleFor)('ClassNameBindings integration', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can have class name bindings on the class definition']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['foo', 'isEnabled:enabled', 'isHappy:happy:sad']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=this.foo isEnabled=this.isEnabled isHappy=this.isHappy}}', {
        foo: 'foo',
        isEnabled: true,
        isHappy: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'isEnabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', undefined);
        (0, _object.set)(this.context, 'isHappy', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'isEnabled', true);
        (0, _object.set)(this.context, 'isHappy', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
    }
    ['@test attrs in classNameBindings']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['attrs.joker:purple:green', 'attrs.batman.robin:black:red']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar joker=this.model.wat batman=this.model.super}}', {
        model: {
          wat: false,
          super: {
            robin: true
          }
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view green black')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view green black')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model.wat', true);
        (0, _object.set)(this.context, 'model.super.robin', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view purple red')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        wat: false,
        super: {
          robin: true
        }
      }));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view green black')
        },
        content: 'hello'
      });
    }
    ['@test it can have class name bindings with nested paths']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['foo.bar', 'is.enabled:enabled', 'is.happy:happy:sad']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=this.foo is=this.is}}', {
        foo: {
          bar: 'foo-bar'
        },
        is: {
          enabled: true,
          happy: false
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo.bar', 'FOO-BAR');
        (0, _object.set)(this.context, 'is.enabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO-BAR sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo.bar', null);
        (0, _object.set)(this.context, 'is.happy', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', null);
        (0, _object.set)(this.context, 'is', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', {
          bar: 'foo-bar'
        });
        (0, _object.set)(this.context, 'is', {
          enabled: true,
          happy: false
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar enabled sad')
        },
        content: 'hello'
      });
    }
    ['@test it should dasherize the path when the it resolves to true']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['fooBar', 'nested.fooBarBaz']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar fooBar=this.fooBar nested=this.nested}}', {
        fooBar: true,
        nested: {
          fooBarBaz: false
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'fooBar', false);
        (0, _object.set)(this.context, 'nested.fooBarBaz', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar-baz')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'fooBar', 'FOO-BAR');
        (0, _object.set)(this.context, 'nested.fooBarBaz', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO-BAR')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'nested', null));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO-BAR')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'fooBar', true);
        (0, _object.set)(this.context, 'nested', {
          fooBarBaz: false
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        },
        content: 'hello'
      });
    }
    ['@test :: class name syntax works with an empty true class']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['isEnabled::not-enabled']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar isEnabled=this.enabled}}', {
        enabled: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view not-enabled')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'enabled', true));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'enabled', false));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view not-enabled')
        },
        content: 'hello'
      });
    }
    ['@test uses all provided static class names (issue #11193)']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: [':class-one', ':class-two']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}', {
        enabled: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view class-one class-two')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'enabled', true));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view class-one class-two')
        },
        content: 'hello'
      });
    }
    ['@test Providing a binding with a space in it asserts']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: 'i:think:i am:so:clever'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /classNameBindings must not have spaces in them/i);
    }
    ['@test it asserts that items must be strings']() {
      let FooBarComponent = _helpers.Component.extend({
        foo: 'foo',
        bar: 'bar',
        classNameBindings: ['foo',, 'bar'] // eslint-disable-line no-sparse-arrays
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /classNameBindings must be non-empty strings/);
    }
    ['@test it asserts that items must be non-empty strings']() {
      let FooBarComponent = _helpers.Component.extend({
        foo: 'foo',
        bar: 'bar',
        classNameBindings: ['foo', '', 'bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /classNameBindings must be non-empty strings/);
    }
    ['@test it can set class name bindings in the constructor']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['foo'],
        init() {
          this._super();
          let bindings = this.classNameBindings = this.classNameBindings.slice();
          if (this.get('bindIsEnabled')) {
            bindings.push('isEnabled:enabled');
          }
          if (this.get('bindIsHappy')) {
            bindings.push('isHappy:happy:sad');
          }
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{foo-bar foo=this.foo bindIsEnabled=true isEnabled=this.isEnabled bindIsHappy=false isHappy=this.isHappy}}\n      {{foo-bar foo=this.foo bindIsEnabled=false isEnabled=this.isEnabled bindIsHappy=true isHappy=this.isHappy}}\n      {{foo-bar foo=this.foo bindIsEnabled=true isEnabled=this.isEnabled bindIsHappy=true isHappy=this.isHappy}}\n      {{foo-bar foo=this.foo bindIsEnabled=false isEnabled=this.isEnabled bindIsHappy=false isHappy=this.isHappy}}\n    "]))), {
        foo: 'foo',
        isEnabled: true,
        isHappy: false
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'isEnabled', false);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', undefined);
        (0, _object.set)(this.context, 'isHappy', true);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'foo');
        (0, _object.set)(this.context, 'isEnabled', true);
        (0, _object.set)(this.context, 'isHappy', false);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
    }
    ['@test using a computed property for classNameBindings triggers an assertion']() {
      let FooBarComponent = _helpers.Component.extend({
        classNameBindings: (0, _object.computed)(function () {
          return ['isHappy:happy:sad'];
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /Only arrays are allowed/);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/component-template-test", ["internal-test-helpers", "@glimmer/manager", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _manager, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components test: setComponentTemplate', class extends _internalTestHelpers.RenderingTestCase {
    '@test it basically works'() {
      this.registerComponent('foo-bar', {
        ComponentClass: (0, _manager.setComponentTemplate)((0, _helpers.compile)('hello'), _helpers.Component.extend())
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test it takes precedence over resolver'() {
      this.registerComponent('foo-bar', {
        ComponentClass: (0, _manager.setComponentTemplate)((0, _helpers.compile)('hello'), _helpers.Component.extend()),
        template: 'noooooo!'
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test calling it with primitives asserts'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), null);
      }, /Cannot call `setComponentTemplate` on `null`/);
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), undefined);
      }, /Cannot call `setComponentTemplate` on `undefined`/);
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), true);
      }, /Cannot call `setComponentTemplate` on `true`/);
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), false);
      }, /Cannot call `setComponentTemplate` on `false`/);
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), 123);
      }, /Cannot call `setComponentTemplate` on `123`/);
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), 'foo');
      }, /Cannot call `setComponentTemplate` on `foo`/);
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), Symbol('foo'));
      }, /Cannot call `setComponentTemplate` on `Symbol\(foo\)`/);
    }
    '@test calling it twice on the same object asserts'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      let Thing = (0, _manager.setComponentTemplate)((0, _helpers.compile)('hello'), _helpers.Component.extend().reopenClass({
        toString() {
          return 'Thing';
        }
      }));
      assert.throws(() => {
        (0, _manager.setComponentTemplate)((0, _helpers.compile)('foo'), Thing);
      }, /Cannot call `setComponentTemplate` multiple times on the same class \(`Class`\)/);
    }
    '@test templates set with setComponentTemplate are inherited (EmberObject.extend())'() {
      let Parent = (0, _manager.setComponentTemplate)((0, _helpers.compile)('hello'), _helpers.Component.extend());
      this.registerComponent('foo-bar', {
        ComponentClass: Parent.extend()
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test templates set with setComponentTemplate are inherited (native ES class extends)'() {
      let Parent = (0, _manager.setComponentTemplate)((0, _helpers.compile)('hello'), _helpers.Component.extend());
      this.registerComponent('foo-bar', {
        ComponentClass: class extends Parent {}
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    '@test it can re-assign templates from another class'() {
      let Foo = (0, _manager.setComponentTemplate)((0, _helpers.compile)('shared'), _helpers.Component.extend());
      let Bar = (0, _manager.setComponentTemplate)((0, _manager.getComponentTemplate)(Foo), _helpers.Component.extend());
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Foo />|<Bar />');
      this.assertText('shared|shared');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('shared|shared');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/contextual-components-test", ["ember-babel", "internal-test-helpers", "@ember/utils", "@ember/array", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _utils, _array, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20;
  (0, _internalTestHelpers.moduleFor)('Components test: contextual components', class extends _internalTestHelpers.RenderingTestCase {
    ['@test renders with component helper']() {
      let expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: expectedText
      });
      this.render('{{component (component "-looked-up")}}');
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText(expectedText);
    }
    ['@test renders with component helper with invocation params, hash']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{this.greeting}} {{this.name}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{component (component \"-looked-up\") \"Hodari\" greeting=\"Hodi\"}}"]))));
      this.assertText('Hodi Hodari');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hodi Hodari');
    }
    ['@test GH#13742 keeps nested rest positional parameters if rendered with no positional parameters']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each this.params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component "-looked-up" this.model.greeting this.model.name)}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Good morning '));
      this.assertText('Good morning Zack');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.name', 'Matthew'));
      this.assertText('Good morning Matthew');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Gabon ',
        name: 'Zack'
      }));
      this.assertText('Gabon Zack');
    }

    // Take a look at this one. Seems to pass even when currying isn't implemented.
    ['@test overwrites nested rest positional parameters if rendered with positional parameters']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each this.params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component "-looked-up" this.model.greeting this.model.name) this.model.name this.model.greeting}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack '
        }
      });
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Good morning '));
      this.assertText('Good morning Zack Zack Good morning ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.name', 'Matthew '));
      this.assertText('Good morning Matthew Matthew Good morning ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Gabon ',
        name: 'Zack '
      }));
      this.assertText('Gabon Zack Zack Gabon ');
    }
    ['@test GH#13742  keeps nested rest positional parameters if nested and rendered with no positional parameters']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each this.params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component (component "-looked-up" this.model.greeting this.model.name))}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Good morning '));
      this.assertText('Good morning Zack');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.name', 'Matthew'));
      this.assertText('Good morning Matthew');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Gabon ',
        name: 'Zack'
      }));
      this.assertText('Gabon Zack');
    }
    ['@test overwrites nested rest positional parameters if nested with new pos params and rendered with no positional parameters']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each this.params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component (component "-looked-up" this.model.greeting this.model.name) this.model.name this.model.greeting)}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack '
        }
      });
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Good morning '));
      this.assertText('Good morning Zack Zack Good morning ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.name', 'Matthew '));
      this.assertText('Good morning Matthew Matthew Good morning ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Gabon ',
        name: 'Zack '
      }));
      this.assertText('Gabon Zack Zack Gabon ');
    }
    ['@test renders with component helper with curried params, hash']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{this.greeting}} {{this.name}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{component (component \"-looked-up\" \"Hodari\" greeting=\"Hodi\")\n                  greeting=\"Hola\"}}"]))));
      this.assertText('Hola Hodari');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hola Hodari');
    }
    ['@test updates when component path is bound']() {
      this.registerComponent('-mandarin', {
        template: 'ni hao'
      });
      this.registerComponent('-hindi', {
        template: 'Namaste'
      });
      this.render('{{component (component this.model.lookupComponent)}}', {
        model: {
          lookupComponent: '-mandarin'
        }
      });
      this.assertText('ni hao');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('ni hao');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.lookupComponent', '-hindi'));
      this.assertText('Namaste');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        lookupComponent: '-mandarin'
      }));
      this.assertText('ni hao');
    }
    ['@test updates when curried hash argument is bound']() {
      this.registerComponent('-looked-up', {
        template: '{{this.greeting}}'
      });
      this.render("{{component (component \"-looked-up\" greeting=this.model.greeting)}}", {
        model: {
          greeting: 'Hodi'
        }
      });
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Hola'));
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Hodi'
      }));
      this.assertText('Hodi');
    }
    ['@test updates when curried hash arguments is bound in block form']() {
      this.registerComponent('-looked-up', {
        template: '{{this.greeting}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash comp=(component \"-looked-up\" greeting=this.model.greeting)) as |my|}}\n        {{#my.comp}}{{/my.comp}}\n      {{/let}}"]))), {
        model: {
          greeting: 'Hodi'
        }
      });
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Hola'));
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Hodi'
      }));
      this.assertText('Hodi');
    }
    ['@test nested components do not overwrite positional parameters']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{this.name}} {{this.age}}'
      });
      this.render('{{component (component (component "-looked-up" "Sergio" 29) "Marvin" 21) "Hodari"}}');
      this.assertText('Sergio 29');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Sergio 29');
    }
    ['@test positional parameters are combined not clobbered']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['greeting', 'name', 'age']
        }),
        template: '{{this.greeting}} {{this.name}} {{this.age}}'
      });
      this.render('{{component (component (component "-looked-up" "Hi") "Max") 9}}');
      this.assertText('Hi Max 9');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hi Max 9');
    }
    ['@test nested components overwrite hash parameters']() {
      this.registerComponent('-looked-up', {
        template: '{{this.greeting}} {{this.name}} {{this.age}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (component \"-looked-up\" greeting=\"Hola\" name=\"Dolores\" age=33) as |first|}}\n        {{#let (component first greeting=\"Hej\" name=\"Sigmundur\") as |second|}}\n          {{component second greeting=this.model.greeting}}\n        {{/let}}\n      {{/let}}"]))), {
        model: {
          greeting: 'Hodi'
        }
      });
      this.assertText('Hodi Sigmundur 33');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hodi Sigmundur 33');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.greeting', 'Kaixo'));
      this.assertText('Kaixo Sigmundur 33');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        greeting: 'Hodi'
      }));
      this.assertText('Hodi Sigmundur 33');
    }
    ['@test bound outer named parameters get updated in the right scope']() {
      this.registerComponent('-inner-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['comp']
        }),
        template: '{{component this.comp "Inner"}}'
      });
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{this.name}} {{this.age}}'
      });
      this.render('{{component "-inner-component" (component "-looked-up" this.model.outerName this.model.outerAge)}}', {
        model: {
          outerName: 'Outer',
          outerAge: 28
        }
      });
      this.assertText('Outer 28');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Outer 28');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.outerAge', 29));
      this.assertText('Outer 29');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.outerName', 'Not outer'));
      this.assertText('Not outer 29');
      (0, _internalTestHelpers.runTask)(() => {
        this.context.set('model', {
          outerName: 'Outer',
          outerAge: 28
        });
      });
      this.assertText('Outer 28');
    }
    ['@test bound outer hash parameters get updated in the right scope']() {
      this.registerComponent('-inner-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['comp']
        }),
        template: '{{component this.comp name="Inner"}}'
      });
      this.registerComponent('-looked-up', {
        template: '{{this.name}} {{this.age}}'
      });
      this.render('{{component "-inner-component" (component "-looked-up" name=this.model.outerName age=this.model.outerAge)}}', {
        model: {
          outerName: 'Outer',
          outerAge: 28
        }
      });
      this.assertText('Inner 28');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Inner 28');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.outerAge', 29));
      this.assertText('Inner 29');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.outerName', 'Not outer'));
      this.assertText('Inner 29');
      (0, _internalTestHelpers.runTask)(() => {
        this.context.set('model', {
          outerName: 'Outer',
          outerAge: 28
        });
      });
      this.assertText('Inner 28');
    }
    ['@test conflicting positional and hash parameters does not raise an assertion if rerendered']() {
      // In some cases, rerendering with a positional param used to cause an
      // assertion. This test checks it does not.
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{this.greeting}} {{this.name}}'
      });
      this.render('{{component (component "-looked-up" this.model.name greeting="Hodi")}}', {
        model: {
          name: 'Hodari'
        }
      });
      this.assertText('Hodi Hodari');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hodi Hodari');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.name', 'Sergio'));
      this.assertText('Hodi Sergio');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        name: 'Hodari'
      }));
      this.assertText('Hodi Hodari');
    }
    ['@test component with dynamic component name resolving to undefined, then an existing component']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}}'
      });
      this.render('{{component (component this.componentName name=this.name)}}', {
        componentName: undefined,
        name: 'Alex'
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', 'foo-bar'));
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', undefined));
      this.assertText('');
    }
    ['@test component with dynamic component name resolving to a component, then undefined']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}}'
      });
      this.render('{{component (component this.componentName name=this.name)}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', undefined));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', 'foo-bar'));
      this.assertText('hello Alex');
    }
    ['@test component with dynamic component name resolving to null, then an existing component']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}}'
      });
      this.render('{{component (component this.componentName name=this.name)}}', {
        componentName: null,
        name: 'Alex'
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', 'foo-bar'));
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', null));
      this.assertText('');
    }
    ['@test component with dynamic component name resolving to a component, then null']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}}'
      });
      this.render('{{component (component this.componentName name=this.name)}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', null));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('componentName', 'foo-bar'));
      this.assertText('hello Alex');
    }
    ['@test raises an assertion when component path is not a component name (static)'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        this.render('{{component (component "not-a-component")}}');
      }, 'Could not find component named "not-a-component" (no component or template with that name was found)');
    }
    ['@test raises an assertion when component path is not a component name (dynamic)'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        this.render('{{component (component this.compName)}}', {
          compName: 'not-a-component'
        });
      }, 'Could not find component named "not-a-component" (no component or template with that name was found)');
    }
    ['@test renders with dot path']() {
      let expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: expectedText
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash lookedup=(component \"-looked-up\")) as |object|}}\n        {{object.lookedup}}\n      {{/let}}"]))));
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText(expectedText);
    }
    ['@test renders with dot path and attr']() {
      let expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: '{{this.expectedText}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash lookedup=(component \"-looked-up\")) as |object|}}\n        {{object.lookedup expectedText=this.model.expectedText}}\n      {{/let}}"]))), {
        model: {
          expectedText
        }
      });
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.expectedText', 'Hola'));
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        expectedText
      }));
      this.assertText(expectedText);
    }
    ['@test renders with dot path and curried over attr']() {
      let expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: '{{this.expectedText}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash lookedup=(component \"-looked-up\" expectedText=this.model.expectedText)) as |object|}}\n        {{object.lookedup}}\n      {{/let}}"]))), {
        model: {
          expectedText
        }
      });
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.expectedText', 'Hola'));
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        expectedText
      }));
      this.assertText(expectedText);
    }
    ['@test renders with dot path and with rest positional parameters']() {
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{this.params}}'
      });
      let expectedText = 'Hodi';
      this.render((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash lookedup=(component \"-looked-up\")) as |object|}}\n        {{object.lookedup this.model.expectedText \"Hola\"}}\n      {{/let}}"]))), {
        model: {
          expectedText
        }
      });
      this.assertText(expectedText + ",Hola");
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText(expectedText + ",Hola");
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.expectedText', 'Kaixo'));
      this.assertText('Kaixo,Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        expectedText
      }));
      this.assertText(expectedText + ",Hola");
    }
    ['@test renders with dot path and rest parameter does not leak'](assert) {
      // In the original implementation, positional parameters were not handled
      // correctly causing the first positional parameter to be the contextual
      // component itself.
      let value = false;
      this.registerComponent('my-component', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs() {
            value = this.getAttr('value');
          }
        }).reopenClass({
          positionalParams: ['value']
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash my-component=(component 'my-component' this.first)) as |c|}}\n        {{c.my-component}}\n      {{/let}}"]))), {
        first: 'first'
      });
      assert.equal(value, 'first', 'value is the expected parameter');
    }
    ['@test renders with dot path and updates attributes'](assert) {
      this.registerComponent('my-nested-component', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs() {
            this.set('myProp', this.getAttr('my-parent-attr'));
          }
        }),
        template: '<span id="nested-prop">{{this.myProp}}</span>'
      });
      this.registerComponent('my-component', {
        template: '{{yield (hash my-nested-component=(component "my-nested-component" my-parent-attr=this.my-attr))}}'
      });
      this.registerComponent('my-action-component', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            changeValue() {
              this.incrementProperty('myProp');
            }
          }
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#my-component my-attr=this.myProp as |api|}}\n          {{api.my-nested-component}}\n        {{/my-component}}\n        <br>\n        <button onclick={{action 'changeValue'}}>Change value</button>"])))
      });
      this.render('{{my-action-component myProp=this.model.myProp}}', {
        model: {
          myProp: 1
        }
      });
      assert.equal(this.$('#nested-prop').text(), '1');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$('#nested-prop').text(), '1');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(this.$('#nested-prop').text(), '2');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(this.$('#nested-prop').text(), '3');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        myProp: 1
      }));
      assert.equal(this.$('#nested-prop').text(), '1');
    }
    ["@test adding parameters to a contextual component's instance does not add it to other instances"]() {
      // If parameters and attributes are not handled correctly, setting a value
      // in an invokation can leak to others invocation.
      this.registerComponent('select-box', {
        template: '{{yield (hash option=(component "select-box-option"))}}'
      });
      this.registerComponent('select-box-option', {
        template: '{{this.label}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#select-box as |sb|}}\n        {{sb.option label=\"Foo\"}}\n        {{sb.option}}\n      {{/select-box}}"]))));
      this.assertText('Foo');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Foo');
    }
    ['@test parameters in a contextual component are mutable when value is a param'](assert) {
      // This checks that a `(mut)` is added to parameters and attributes to
      // contextual components when it is a param.

      this.registerComponent('change-button', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['val']
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <button {{action (action (mut this.val) 10)}} class=\"my-button\">\n          Change to 10\n        </button>"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject13 || (_templateObject13 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{component (component \"change-button\" this.model.val2)}}\n      <span class=\"value\">{{this.model.val2}}</span>"]))), {
        model: {
          val2: 8
        }
      });
      assert.equal(this.$('.value').text(), '8');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$('.value').text(), '8');
      (0, _internalTestHelpers.runTask)(() => this.$('.my-button').click());
      assert.equal(this.$('.value').text(), '10');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        val2: 8
      }));
      assert.equal(this.$('.value').text(), '8');
    }
    ['@test tagless blockless components render'](assert) {
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        })
      });
      this.render("{{my-comp}}");
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$().text(), '');
    }
    ['@test GH#13494 tagless blockless component with property binding'](assert) {
      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          message: 'hello',
          actions: {
            change() {
              this.set('message', 'goodbye');
            }
          }
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject14 || (_templateObject14 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        message: {{this.message}}{{inner-component message=this.message}}\n        <button onclick={{action \"change\"}} />"])))
      });
      this.registerComponent('inner-component', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        })
      });
      this.render("{{outer-component}}");
      assert.equal(this.$().text(), 'message: hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$().text(), 'message: hello');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(this.$().text(), 'message: goodbye');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$().text(), 'message: goodbye');
    }
    ['@test GH#13982 contextual component ref is stable even when bound params change'](assert) {
      let instance, previousInstance;
      let initCount = 0;
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: '{{if this.isOpen "open" "closed"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject15 || (_templateObject15 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash ctxCmp=(component \"my-comp\" isOpen=this.isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/let}}\n    "]))), {
        isOpen: true
      });
      assert.ok(!(0, _utils.isEmpty)(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(() => this.context.set('isOpen', false));
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(() => this.context.set('isOpen', true));
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
    }
    ['@test GH#13982 contextual component ref is stable even when bound params change (bound name param)'](assert) {
      let instance, previousInstance;
      let initCount = 0;
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: '{{if this.isOpen "open" "closed"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject16 || (_templateObject16 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash ctxCmp=(component this.compName isOpen=this.isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/let}}\n    "]))), {
        compName: 'my-comp',
        isOpen: true
      });
      assert.ok(!(0, _utils.isEmpty)(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(() => this.context.set('isOpen', false));
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(() => this.context.set('isOpen', true));
      assert.ok(!(0, _utils.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
    }
    ['@test GH#13982 contextual component ref is recomputed when component name param changes'](assert) {
      let instance, previousInstance;
      let initCount = 0;
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: 'my-comp: {{if this.isOpen "open" "closed"}}'
      });
      this.registerComponent('your-comp', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: 'your-comp: {{if this.isOpen "open" "closed"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject17 || (_templateObject17 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (hash ctxCmp=(component this.compName isOpen=this.isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/let}}\n    "]))), {
        compName: 'my-comp',
        isOpen: true
      });
      assert.ok(!(0, _utils.isEmpty)(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'there is no previous instance');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'my-comp: open');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!(0, _utils.isEmpty)(instance), 'a instance exists after rerender');
      assert.equal(previousInstance, undefined, 'there is no previous instance after rerender');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'my-comp: open');
      (0, _internalTestHelpers.runTask)(() => this.context.set('compName', 'your-comp'));
      assert.ok(!(0, _utils.isEmpty)(instance), 'an instance was created after component name changed');
      assert.ok(!(0, _utils.isEmpty)(previousInstance), 'a previous instance now exists');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object');
      assert.equal(initCount, 2, 'the component was constructed exactly 2 times');
      assert.equal(this.$().text(), 'your-comp: open');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!(0, _utils.isEmpty)(instance), 'an instance was created after component name changed (rerender)');
      assert.ok(!(0, _utils.isEmpty)(previousInstance), 'a previous instance now exists (rerender)');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object (rerender)');
      assert.equal(initCount, 2, 'the component was constructed exactly 2 times (rerender)');
      assert.equal(this.$().text(), 'your-comp: open');
      (0, _internalTestHelpers.runTask)(() => this.context.set('compName', 'my-comp'));
      assert.ok(!(0, _utils.isEmpty)(instance), 'an instance was created after component name changed');
      assert.ok(!(0, _utils.isEmpty)(previousInstance), 'a previous instance still exists');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object');
      assert.equal(initCount, 3, 'the component was constructed exactly 3 times (rerender)');
      assert.equal(this.$().text(), 'my-comp: open');
    }
    ['@test GH#14508 rest positional params are received when passed as named parameter']() {
      this.registerComponent('my-link', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each this.params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component "my-link") params=this.allParams}}', {
        allParams: (0, _array.A)(['a', 'b'])
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(() => this.context.get('allParams').pushObject('c'));
      this.assertText('abc');
      (0, _internalTestHelpers.runTask)(() => this.context.get('allParams').popObject());
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(() => this.context.get('allParams').clear());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('allParams', (0, _array.A)(['1', '2'])));
      this.assertText('12');
      (0, _internalTestHelpers.runTask)(() => this.context.set('allParams', (0, _array.A)(['a', 'b'])));
      this.assertText('ab');
    }
    ['@test GH#14508 rest positional params are received when passed as named parameter with dot notation']() {
      this.registerComponent('my-link', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each this.params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{#let (hash link=(component "my-link")) as |c|}}{{c.link params=this.allParams}}{{/let}}', {
        allParams: (0, _array.A)(['a', 'b'])
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(() => this.context.get('allParams').pushObject('c'));
      this.assertText('abc');
      (0, _internalTestHelpers.runTask)(() => this.context.get('allParams').popObject());
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(() => this.context.get('allParams').clear());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('allParams', (0, _array.A)(['1', '2'])));
      this.assertText('12');
      (0, _internalTestHelpers.runTask)(() => this.context.set('allParams', (0, _array.A)(['a', 'b'])));
      this.assertText('ab');
    }
    ['@test it can invoke input component']() {
      this.render('{{component (component "input" type="text" value=this.value)}}', {
        value: 'foo'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          class: 'ember-text-field ember-view',
          type: 'text'
        }
      });
      this.assert.strictEqual('foo', this.firstChild.value);
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'bar'));
      this.assert.strictEqual('bar', this.firstChild.value);
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'foo'));
      this.assert.strictEqual('foo', this.firstChild.value);
    }
    ['@test it can invoke textarea component']() {
      this.render('{{component (component "textarea" value=this.value)}}', {
        value: 'foo'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'textarea',
        attrs: {
          class: 'ember-text-area ember-view'
        }
      });
      this.assert.strictEqual('foo', this.firstChild.value);
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'bar'));
      this.assert.strictEqual('bar', this.firstChild.value);
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'foo'));
      this.assert.strictEqual('foo', this.firstChild.value);
    }
    ['@test GH#17121 local variable should win over helper (without arguments)']() {
      this.registerHelper('foo', () => 'foo helper');
      this.registerComponent('foo-bar', {
        template: 'foo-bar component'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject18 || (_templateObject18 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#let (component 'foo-bar') as |foo|}}\n          {{foo}}\n        {{/let}}\n      "]))));
      this.assertText('foo-bar component');
      this.assertStableRerender();
    }
    ['@test GH#17121 local variable should win over helper (with arguments)']() {
      this.registerHelper('foo', params => "foo helper: " + params.join(' '));
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: 'foo-bar component:{{#each this.params as |param|}} {{param}}{{/each}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject19 || (_templateObject19 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#let (component 'foo-bar') as |foo|}}\n          {{foo 1 2 3}}\n        {{/let}}\n      "]))));
      this.assertText('foo-bar component: 1 2 3');
      this.assertStableRerender();
    }
    ['@test RFC#311 invoking named args (without arguments)']() {
      this.registerComponent('x-outer', {
        template: '{{@inner}}'
      });
      this.registerComponent('x-inner', {
        template: 'inner'
      });
      this.render('{{x-outer inner=(component "x-inner")}}');
      this.assertText('inner');
      this.assertStableRerender();
    }
    ['@test RFC#311 invoking named args (with arguments)']() {
      this.registerComponent('x-outer', {
        template: '{{@inner 1 2 3}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: 'inner:{{#each this.params as |param|}} {{param}}{{/each}}'
      });
      this.render('{{x-outer inner=(component "x-inner")}}');
      this.assertText('inner: 1 2 3');
      this.assertStableRerender();
    }
    ['@test RFC#311 invoking named args (with a block)']() {
      this.registerComponent('x-outer', {
        template: '{{#@inner}}outer{{/@inner}}'
      });
      this.registerComponent('x-inner', {
        template: 'inner {{yield}}'
      });
      this.render('{{x-outer inner=(component "x-inner")}}');
      this.assertText('inner outer');
      this.assertStableRerender();
    }
    ['@test GH#18732 (has-block) works within a yielded curried component invoked within mustaches']() {
      this.registerComponent('component-with-has-block', {
        ComponentClass: _helpers.Component.extend(),
        template: '<div>{{(has-block)}}</div>'
      });
      this.registerComponent('yielding-component', {
        ComponentClass: _helpers.Component.extend(),
        template: '{{yield (component "component-with-has-block")}}'
      });
      this.registerComponent('test-component', {
        ComponentClass: _helpers.Component.extend(),
        template: '{{#yielding-component as |componentWithHasBlock|}}{{componentWithHasBlock}}{{/yielding-component}}'
      });
      this.render('{{test-component}}');
      this.assertText('false');
    }
    ['@test GH#18732 (has-block) works within a yielded curried component invoked with angle bracket invocation (falsy)']() {
      this.registerComponent('component-with-has-block', {
        ComponentClass: _helpers.Component.extend(),
        template: '<div>{{(has-block)}}</div>'
      });
      this.registerComponent('yielding-component', {
        ComponentClass: _helpers.Component.extend(),
        template: '{{yield (component "component-with-has-block")}}'
      });
      this.registerComponent('test-component', {
        ComponentClass: _helpers.Component.extend(),
        template: '{{#yielding-component as |componentWithHasBlock|}}<componentWithHasBlock/>{{/yielding-component}}'
      });
      this.render('{{test-component}}');
      this.assertText('false');
    }
    ['@test GH#18732 (has-block) works within a yielded curried component invoked with angle bracket invocation (truthy)']() {
      this.registerComponent('component-with-has-block', {
        ComponentClass: _helpers.Component.extend(),
        template: '<div>{{(has-block)}}</div>'
      });
      this.registerComponent('yielding-component', {
        ComponentClass: _helpers.Component.extend(),
        template: '{{yield (component "component-with-has-block")}}'
      });
      this.registerComponent('test-component', {
        ComponentClass: _helpers.Component.extend(),
        template: '{{#yielding-component as |componentWithHasBlock|}}<componentWithHasBlock></componentWithHasBlock>{{/yielding-component}}'
      });
      this.render('{{test-component}}');
      this.assertText('true');
    }
  });
  class ContextualComponentMutableParamsTest extends _internalTestHelpers.RenderingTestCase {
    render(templateStr, context) {
      if (context === void 0) {
        context = {};
      }
      super.render(templateStr + "<span class=\"value\">{{this.model.val2}}</span>", Object.assign(context, {
        model: {
          val2: 8
        }
      }));
    }
  }
  class MutableParamTestGenerator {
    constructor(cases) {
      this.cases = cases;
    }
    generate(_ref) {
      let {
        title,
        setup
      } = _ref;
      return {
        ["@test parameters in a contextual component are mutable when value is a " + title](assert) {
          this.registerComponent('change-button', {
            ComponentClass: _helpers.Component.extend().reopenClass({
              positionalParams: ['val']
            }),
            template: (0, _internalTestHelpers.strip)(_templateObject20 || (_templateObject20 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <button {{action (action (mut this.val) 10)}} class=\"my-button\">\n            Change to 10\n          </button>"])))
          });
          setup.call(this, assert);
          assert.equal(this.$('.value').text(), '8');
          (0, _internalTestHelpers.runTask)(() => this.rerender());
          assert.equal(this.$('.value').text(), '8');
          (0, _internalTestHelpers.runTask)(() => this.$('.my-button').click());
          assert.equal(this.$('.value').text(), '10');
          (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
            val2: 8
          }));
          assert.equal(this.$('.value').text(), '8');
        }
      };
    }
  }
  (0, _internalTestHelpers.applyMixins)(ContextualComponentMutableParamsTest, new MutableParamTestGenerator([{
    title: 'param',
    setup() {
      this.render('{{component (component "change-button" this.model.val2)}}');
    }
  }, {
    title: 'nested param',
    setup() {
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['components']
        }),
        template: '{{component this.components.comp}}'
      });
      this.render('{{my-comp (hash comp=(component "change-button" this.model.val2))}}');
    }
  }, {
    title: 'hash value',
    setup() {
      this.registerComponent('my-comp', {
        template: '{{component this.component}}'
      });
      this.render('{{my-comp component=(component "change-button" val=this.model.val2)}}');
    }
  }, {
    title: 'nested hash value',
    setup() {
      this.registerComponent('my-comp', {
        template: '{{component this.components.button}}'
      });
      this.render('{{my-comp components=(hash button=(component "change-button" val=this.model.val2))}}');
    }
  }]));
  (0, _internalTestHelpers.moduleFor)('Components test: contextual components -- mutable params', ContextualComponentMutableParamsTest);
});
define("@ember/-internals/glimmer/tests/integration/components/curly-components-test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/-internals/metal", "@ember/object/computed", "@ember/object/evented", "@ember/service", "@ember/object", "@ember/array", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/debug-stack"], function (_emberBabel, _internalTestHelpers, _runloop, _metal, _computed, _evented, _service, _object, _array, _helpers, _debugStack) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39, _templateObject40, _templateObject41, _templateObject42, _templateObject43, _templateObject44, _templateObject45, _templateObject46, _templateObject47;
  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('Components test: curly components', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can render a basic component']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test it can have a custom id and it is not bound']() {
      this.registerComponent('foo-bar', {
        template: '{{this.id}} {{this.elementId}}'
      });
      this.render('{{foo-bar id=this.customId}}', {
        customId: 'bizz'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'customId', 'bar'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bar bizz'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'customId', 'bizz'));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
    }
    ['@test elementId cannot change'](assert) {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        elementId: 'blahzorz',
        init() {
          this._super(...arguments);
          component = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.elementId}}'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'blahzorz'
        },
        content: 'blahzorz'
      });
      if (false /* DEBUG */) {
        let willThrow = () => (0, _runloop.run)(null, _object.set, component, 'elementId', 'herpyderpy');
        assert.throws(willThrow, /Changing a view's elementId after creation is not allowed/);
        this.assertComponentElement(this.firstChild, {
          tagName: 'div',
          attrs: {
            id: 'blahzorz'
          },
          content: 'blahzorz'
        });
      }
    }
    ['@test elementId is stable when other values change']() {
      let changingArg = 'arbitrary value';
      let parentInstance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            parentInstance = this;
          },
          changingArg: changingArg
        }),
        template: '{{quux-baz elementId="stable-id" changingArg=this.changingArg}}'
      });
      this.registerComponent('quux-baz', {
        ComponentClass: _helpers.Component.extend({}),
        template: '{{this.changingArg}}'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild.firstChild, {
        attrs: {
          id: 'stable-id'
        },
        content: 'arbitrary value'
      });
      changingArg = 'a different value';
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(parentInstance, 'changingArg', changingArg));
      this.assertComponentElement(this.firstChild.firstChild, {
        attrs: {
          id: 'stable-id'
        },
        content: changingArg
      });
    }
    ['@test can specify template with `layoutName` property']() {
      let FooBarComponent = _helpers.Component.extend({
        elementId: 'blahzorz',
        layoutName: 'fizz-bar',
        init() {
          this._super(...arguments);
          this.local = 'hey';
        }
      });
      this.registerTemplate('fizz-bar', "FIZZ BAR {{this.local}}");
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar}}');
      this.assertText('FIZZ BAR hey');
    }
    ['@test layout supports computed property']() {
      let FooBarComponent = _helpers.Component.extend({
        elementId: 'blahzorz',
        layout: (0, _object.computed)(function () {
          return (0, _helpers.compile)('so much layout wat {{this.lulz}}');
        }),
        init() {
          this._super(...arguments);
          this.lulz = 'heyo';
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar}}');
      this.assertText('so much layout wat heyo');
    }
    ['@test passing undefined elementId results in a default elementId'](assert) {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'h1'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'something'
      });
      this.render('{{foo-bar id=this.somethingUndefined}}');
      let foundId = this.$('h1').attr('id');
      assert.ok(/^ember/.test(foundId), 'Has a reasonable id attribute (found id=' + foundId + ').');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let newFoundId = this.$('h1').attr('id');
      assert.ok(/^ember/.test(newFoundId), 'Has a reasonable id attribute (found id=' + newFoundId + ').');
      assert.equal(foundId, newFoundId);
    }
    ['@test id is an alias for elementId'](assert) {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'h1'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'something'
      });
      this.render('{{foo-bar id="custom-id"}}');
      let foundId = this.$('h1').attr('id');
      assert.equal(foundId, 'custom-id');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let newFoundId = this.$('h1').attr('id');
      assert.equal(newFoundId, 'custom-id');
      assert.equal(foundId, newFoundId);
    }
    ['@test cannot pass both id and elementId at the same time']() {
      this.registerComponent('foo-bar', {
        template: ''
      });
      expectAssertion(() => {
        this.render('{{foo-bar id="zomg" elementId="lol"}}');
      }, /You cannot invoke a component with both 'id' and 'elementId' at the same time./);
    }
    ['@test it can have a custom tagName']() {
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'foo-bar'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    }
    ['@test it can have a custom tagName set in the constructor']() {
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          this.tagName = 'foo-bar';
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    }
    ['@test it can have a custom tagName from the invocation']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar tagName="foo-bar"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    }
    ['@test tagName can not be a computed property']() {
      let FooBarComponent = _helpers.Component.extend({
        tagName: (0, _object.computed)(function () {
          return 'foo-bar';
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /You cannot use a computed property for the component's `tagName` \(<.+?>\)\./);
    }
    ['@test class is applied before didInsertElement'](assert) {
      let componentClass;
      let FooBarComponent = _helpers.Component.extend({
        didInsertElement() {
          componentClass = this.element.className;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar class="foo-bar"}}');
      assert.equal(componentClass, 'foo-bar ember-view');
    }
    ['@test it can have custom classNames']() {
      let FooBarComponent = _helpers.Component.extend({
        classNames: ['foo', 'bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
    }
    ['@test should not apply falsy class name']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=this.somethingFalsy}}', {
        somethingFalsy: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
    }
    ['@test should update class using inline if, initially false, no alternate']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=(if this.predicate "thing") }}', {
        predicate: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'predicate', true));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view thing')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'predicate', false));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
    }
    ['@test should update class using inline if, initially true, no alternate']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=(if this.predicate "thing") }}', {
        predicate: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view thing')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'predicate', false));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'predicate', true));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view thing')
        },
        content: 'hello'
      });
    }
    ['@test class property on components can be dynamic']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=(if this.fooBar "foo-bar")}}', {
        fooBar: true
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', false));
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', true));
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
    }
    ['@test it can have custom classNames from constructor']() {
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          this.classNames = this.classNames.slice();
          this.classNames.push('foo', 'bar', "outside-" + this.get('extraClass'));
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar extraClass="baz"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar outside-baz')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar outside-baz')
        },
        content: 'hello'
      });
    }
    ['@test it can set custom classNames from the invocation']() {
      let FooBarComponent = _helpers.Component.extend({
        classNames: ['foo']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{foo-bar class=\"bar baz\"}}\n      {{foo-bar classNames=\"bar baz\"}}\n      {{foo-bar}}\n    "]))));
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
    }
    ['@test it has an element']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          instance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      let element1 = instance.element;
      this.assertComponentElement(element1, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let element2 = instance.element;
      this.assertComponentElement(element2, {
        content: 'hello'
      });
      this.assertSameNode(element2, element1);
    }
    ['@test an empty component does not have childNodes'](assert) {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        tagName: 'input',
        init() {
          this._super();
          fooBarInstance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'input'
      });
      assert.strictEqual(fooBarInstance.element.childNodes.length, 0);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        tagName: 'input'
      });
      assert.strictEqual(fooBarInstance.element.childNodes.length, 0);
    }
    ['@test it has the right parentView and childViews'](assert) {
      let fooBarInstance, fooBarBazInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
        }
      });
      let FooBarBazComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarBazInstance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'foo-bar {{foo-bar-baz}}'
      });
      this.registerComponent('foo-bar-baz', {
        ComponentClass: FooBarBazComponent,
        template: 'foo-bar-baz'
      });
      this.render('{{foo-bar}}');
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    }
    ['@test it renders passed named arguments']() {
      this.registerComponent('foo-bar', {
        template: '{{@foo}}'
      });
      this.render('{{foo-bar foo=this.model.bar}}', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.bar', 'Hello'));
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        bar: 'Hola'
      }));
      this.assertText('Hola');
    }
    ['@test it reflects named arguments as properties']() {
      this.registerComponent('foo-bar', {
        template: '{{this.foo}}'
      });
      this.render('{{foo-bar foo=this.model.bar}}', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.bar', 'Hello'));
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        bar: 'Hola'
      }));
      this.assertText('Hola');
    }
    ['@test it can render a basic component with a block']() {
      this.registerComponent('foo-bar', {
        template: '{{yield}} - In component'
      });
      this.render('{{#foo-bar}}hello{{/foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
    }
    ['@test it renders the layout with the component instance as the context']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          instance = this;
          this.set('message', 'hello');
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.message}}'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'message', 'goodbye'));
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'message', 'hello'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test it preserves the outer context when yielding']() {
      this.registerComponent('foo-bar', {
        template: '{{yield}}'
      });
      this.render('{{#foo-bar}}{{this.message}}{{/foo-bar}}', {
        message: 'hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'goodbye'));
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'hello'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test it can yield a block param named for reserved words [GH#14096]']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        name: 'foo-bar'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield this}}'
      });
      this.render('{{#foo-bar as |component|}}{{component.name}}{{/foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'foo-bar'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'name', 'derp-qux'));
      this.assertComponentElement(this.firstChild, {
        content: 'derp-qux'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'name', 'foo-bar'));
      this.assertComponentElement(this.firstChild, {
        content: 'foo-bar'
      });
    }
    ['@test it can yield internal and external properties positionally']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        greeting: 'hello'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield this.greeting this.greetee.firstName}}'
      });
      this.render('{{#foo-bar greetee=this.person as |greeting name|}}{{name}} {{this.person.lastName}}, {{greeting}}{{/foo-bar}}', {
        person: {
          firstName: 'Joel',
          lastName: 'Kang'
        }
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'person', {
        firstName: 'Dora',
        lastName: 'the Explorer'
      }));
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'greeting', 'hola'));
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hola'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(instance, 'greeting', 'hello');
        (0, _object.set)(this.context, 'person', {
          firstName: 'Joel',
          lastName: 'Kang'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
    }
    ['@test #11519 - block param infinite loop']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          instance = this;
        },
        danger: 0
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.danger}}{{yield this.danger}}'
      });

      // On initial render, create streams. The bug will not have manifested yet, but at this point
      // we have created streams that create a circular invalidation.
      this.render("{{#foo-bar as |dangerBlockParam|}}{{/foo-bar}}");
      this.assertText('0');

      // Trigger a non-revalidating re-render. The yielded block will not be dirtied
      // nor will block param streams, and thus no infinite loop will occur.
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('0');

      // Trigger a revalidation, which will cause an infinite loop without the fix
      // in place.  Note that we do not see the infinite loop is in testing mode,
      // because a deprecation warning about re-renders is issued, which Ember
      // treats as an exception.
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'danger', 1));
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'danger', 0));
      this.assertText('0');
    }
    ['@test the component and its child components are destroyed'](assert) {
      let destroyed = {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      };
      this.registerComponent('foo-bar', {
        template: '{{this.id}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          willDestroy() {
            this._super();
            destroyed[this.get('id')]++;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#if this.cond1}}\n        {{#foo-bar id=1}}\n          {{#if this.cond2}}\n            {{#foo-bar id=2}}{{/foo-bar}}\n            {{#if this.cond3}}\n              {{#foo-bar id=3}}\n                {{#if this.cond4}}\n                  {{#foo-bar id=4}}\n                    {{#if this.cond5}}\n                      {{#foo-bar id=5}}{{/foo-bar}}\n                      {{#foo-bar id=6}}{{/foo-bar}}\n                      {{#foo-bar id=7}}{{/foo-bar}}\n                    {{/if}}\n                    {{#foo-bar id=8}}{{/foo-bar}}\n                  {{/foo-bar}}\n                {{/if}}\n              {{/foo-bar}}\n            {{/if}}\n          {{/if}}\n        {{/foo-bar}}\n      {{/if}}"]))), {
        cond1: true,
        cond2: true,
        cond3: true,
        cond4: true,
        cond5: true
      });
      this.assertText('1 2 3 4 5 6 7 8 ');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond5', false));
      this.assertText('1 2 3 4 8 ');
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 1,
        6: 1,
        7: 1,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond3', false);
        (0, _object.set)(this.context, 'cond5', true);
        (0, _object.set)(this.context, 'cond4', false);
      });
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond2', false);
        (0, _object.set)(this.context, 'cond1', false);
      });
      assert.deepEqual(destroyed, {
        1: 1,
        2: 1,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
    }
    ['@test should escape HTML in normal mustaches']() {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        output: 'you need to be more <b>bold</b>'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.output}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('you need to be more <b>bold</b>');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('you need to be more <b>bold</b>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'output', 'you are so <i>super</i>'));
      this.assertText('you are so <i>super</i>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'output', 'you need to be more <b>bold</b>'));
    }
    ['@test should not escape HTML in triple mustaches']() {
      let expectedHtmlBold = 'you need to be more <b>bold</b>';
      let expectedHtmlItalic = 'you are so <i>super</i>';
      let component;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        output: expectedHtmlBold
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{{this.output}}}'
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'output', expectedHtmlItalic));
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlItalic);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'output', expectedHtmlBold));
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
    }
    ['@test should not escape HTML if string is a htmlSafe']() {
      let expectedHtmlBold = 'you need to be more <b>bold</b>';
      let expectedHtmlItalic = 'you are so <i>super</i>';
      let component;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        output: (0, _helpers.htmlSafe)(expectedHtmlBold)
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.output}}'
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'output', (0, _helpers.htmlSafe)(expectedHtmlItalic)));
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlItalic);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'output', (0, _helpers.htmlSafe)(expectedHtmlBold)));
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
    }
    ['@test late bound layouts return the same definition'](assert) {
      let templateIds = [];

      // This is testing the scenario where you import a template and
      // set it to the layout property:
      //
      // import Component from '@ember/component';
      // import layout from './template';
      //
      // export default Component.extend({
      //   layout
      // });
      let hello = (0, _helpers.compile)('Hello');
      let bye = (0, _helpers.compile)('Bye');
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          this.layout = this.cond ? hello : bye;
          templateIds.push(this.layout.id);
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar cond=true}}{{foo-bar cond=false}}{{foo-bar cond=true}}{{foo-bar cond=false}}');
      let [t1, t2, t3, t4] = templateIds;
      assert.equal(t1, t3);
      assert.equal(t2, t4);
    }
    ['@test can use isStream property without conflict (#13271)']() {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        isStream: true,
        init() {
          this._super(...arguments);
          component = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if this.isStream}}\n          true\n        {{else}}\n          false\n        {{/if}}\n      "])))
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'true'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'true'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'isStream', false));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'isStream', true));
      this.assertComponentElement(this.firstChild, {
        content: 'true'
      });
    }
    ['@test lookup of component takes priority over property']() {
      this.registerComponent('some-component', {
        template: 'some-component'
      });
      this.render('{{this.some-prop}} {{some-component}}', {
        'some-component': 'not-some-component',
        'some-prop': 'some-prop'
      });
      this.assertText('some-prop some-component');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('some-prop some-component');
    }
    ['@test component without dash is looked up']() {
      this.registerComponent('somecomponent', {
        template: 'somecomponent'
      });
      this.render('{{somecomponent}}', {
        somecomponent: 'notsomecomponent'
      });
      this.assertText('somecomponent');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.context.set('somecomponent', 'not not notsomecomponent'));
      this.assertText('somecomponent');
      (0, _internalTestHelpers.runTask)(() => this.context.set('somecomponent', 'notsomecomponent'));
      this.assertText('somecomponent');
    }
    ['@test non-block with properties access via attrs is asserted against']() {
      expectAssertion(() => {
        this.registerComponent('non-block', {
          template: 'In layout - someProp: {{attrs.someProp}}'
        });
      }, "Using {{attrs}} to reference named arguments is not supported. {{attrs.someProp}} should be updated to {{@someProp}}. ('my-app/templates/components/non-block.hbs' @ L1:C24) ");
    }
    ['@test non-block with properties on this.attrs']() {
      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{this.attrs.someProp}}'
      });
      this.render('{{non-block someProp=this.prop}}', {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'other thing there'));
      this.assertText('In layout - someProp: other thing there');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something here'));
      this.assertText('In layout - someProp: something here');
    }
    ['@test non-block with named argument']() {
      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{@someProp}}'
      });
      this.render('{{non-block someProp=this.prop}}', {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'other thing there'));
      this.assertText('In layout - someProp: other thing there');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something here'));
      this.assertText('In layout - someProp: something here');
    }
    ['@test non-block with properties overridden in init']() {
      let instance;
      this.registerComponent('non-block', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            instance = this;
            this.someProp = 'value set in instance';
          }
        }),
        template: 'In layout - someProp: {{this.someProp}}'
      });
      this.render('{{non-block someProp=this.prop}}', {
        prop: 'something passed when invoked'
      });
      this.assertText('In layout - someProp: value set in instance');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: value set in instance');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'updated something passed when invoked'));
      this.assertText('In layout - someProp: updated something passed when invoked');
      (0, _internalTestHelpers.runTask)(() => instance.set('someProp', 'update value set in instance'));
      this.assertText('In layout - someProp: update value set in instance');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something passed when invoked'));
      (0, _internalTestHelpers.runTask)(() => instance.set('someProp', 'value set in instance'));
      this.assertText('In layout - someProp: value set in instance');
    }
    ['@test rerendering component with attrs from parent'](assert) {
      let willUpdateCount = 0;
      let didReceiveAttrsCount = 0;
      function expectHooks(_ref, callback) {
        let {
          willUpdate,
          didReceiveAttrs
        } = _ref;
        willUpdateCount = 0;
        didReceiveAttrsCount = 0;
        callback();
        if (willUpdate) {
          assert.strictEqual(willUpdateCount, 1, 'The willUpdate hook was fired');
        } else {
          assert.strictEqual(willUpdateCount, 0, 'The willUpdate hook was not fired');
        }
        if (didReceiveAttrs) {
          assert.strictEqual(didReceiveAttrsCount, 1, 'The didReceiveAttrs hook was fired');
        } else {
          assert.strictEqual(didReceiveAttrsCount, 0, 'The didReceiveAttrs hook was not fired');
        }
      }
      this.registerComponent('non-block', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs() {
            didReceiveAttrsCount++;
          },
          willUpdate() {
            willUpdateCount++;
          }
        }),
        template: 'In layout - someProp: {{this.someProp}}'
      });
      expectHooks({
        willUpdate: false,
        didReceiveAttrs: true
      }, () => {
        this.render('{{non-block someProp=this.someProp}}', {
          someProp: 'wycats'
        });
      });
      this.assertText('In layout - someProp: wycats');

      // Note: Hooks are not fired in Glimmer for idempotent re-renders
      expectHooks({
        willUpdate: false,
        didReceiveAttrs: false
      }, () => {
        (0, _internalTestHelpers.runTask)(() => this.rerender());
      });
      this.assertText('In layout - someProp: wycats');
      expectHooks({
        willUpdate: true,
        didReceiveAttrs: true
      }, () => {
        (0, _internalTestHelpers.runTask)(() => this.context.set('someProp', 'tomdale'));
      });
      this.assertText('In layout - someProp: tomdale');

      // Note: Hooks are not fired in Glimmer for idempotent re-renders
      expectHooks({
        willUpdate: false,
        didReceiveAttrs: false
      }, () => {
        (0, _internalTestHelpers.runTask)(() => this.rerender());
      });
      this.assertText('In layout - someProp: tomdale');
      expectHooks({
        willUpdate: true,
        didReceiveAttrs: true
      }, () => {
        (0, _internalTestHelpers.runTask)(() => this.context.set('someProp', 'wycats'));
      });
      this.assertText('In layout - someProp: wycats');
    }
    ['@test setting a value for a computed property then later getting the value for that property works'](assert) {
      let componentInstance = null;
      this.registerComponent('non-block', {
        ComponentClass: _helpers.Component.extend({
          counter: (0, _object.computed)({
            set(key, value) {
              return value;
            }
          }),
          init() {
            this._super(...arguments);
            componentInstance = this;
          },
          actions: {
            click() {
              let currentCounter = this.get('counter');
              assert.equal(currentCounter, 0, 'the current `counter` value is correct');
              let newCounter = currentCounter + 1;
              this.set('counter', newCounter);
              assert.equal(this.get('counter'), newCounter, "getting the newly set `counter` property works; it's equal to the value we just set and not `undefined`");
            }
          }
        }),
        template: "\n          <button {{action \"click\"}}>foobar</button>\n        "
      });
      this.render("{{non-block counter=this.counter}}", {
        counter: 0
      });
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(componentInstance.get('counter'), 1, '`counter` incremented on click on the component and is not `undefined`');
    }
    ['@test this.attrs.foo === @foo === foo']() {
      this.registerComponent('foo-bar', {
        template: (0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        Args: {{this.attrs.value}} | {{@value}} | {{this.value}}\n        {{#each this.attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each @items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each this.items as |item|}}\n          {{item}}\n        {{/each}}\n      "])))
      });
      this.render('{{foo-bar value=this.model.value items=this.model.items}}', {
        model: {
          value: 'wat',
          items: [1, 2, 3]
        }
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        this.context.set('model.value', 'lul');
        this.context.set('model.items', [1]);
      });
      this.assertText((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["Args: lul | lul | lul111"]))));
      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        value: 'wat',
        items: [1, 2, 3]
      }));
      this.assertText('Args: wat | wat | wat123123123');
    }
    ['@test non-block with properties on self']() {
      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{this.someProp}}'
      });
      this.render('{{non-block someProp=this.prop}}', {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something else'));
      this.assertText('In layout - someProp: something else');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something here'));
      this.assertText('In layout - someProp: something here');
    }
    ['@test block with properties on self']() {
      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{this.someProp}} - {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-block someProp=this.prop}}\n        In template\n      {{/with-block}}"]))), {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something else'));
      this.assertText('In layout - someProp: something else - In template');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something here'));
      this.assertText('In layout - someProp: something here - In template');
    }
    ['@test block with properties on attrs is asserted against']() {
      expectAssertion(() => {
        this.registerComponent('with-block', {
          template: 'In layout - someProp: {{attrs.someProp}} - {{yield}}'
        });
      }, "Using {{attrs}} to reference named arguments is not supported. {{attrs.someProp}} should be updated to {{@someProp}}. ('my-app/templates/components/with-block.hbs' @ L1:C24) ");
    }
    ['@test block with properties on this.attrs']() {
      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{this.attrs.someProp}} - {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-block someProp=this.prop}}\n        In template\n      {{/with-block}}"]))), {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something else'));
      this.assertText('In layout - someProp: something else - In template');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something here'));
      this.assertText('In layout - someProp: something here - In template');
    }
    ['@test block with named argument']() {
      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{@someProp}} - {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-block someProp=this.prop}}\n        In template\n      {{/with-block}}"]))), {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something else'));
      this.assertText('In layout - someProp: something else - In template');
      (0, _internalTestHelpers.runTask)(() => this.context.set('prop', 'something here'));
      this.assertText('In layout - someProp: something here - In template');
    }
    ['@test static arbitrary number of positional parameters'](assert) {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.names as |name|}}\n          {{name}}\n        {{/each}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{sample-component \"Foo\" 4 \"Bar\" elementId=\"args-3\"}}\n      {{sample-component \"Foo\" 4 \"Bar\" 5 \"Baz\" elementId=\"args-5\"}}"]))));
      assert.equal(this.$('#args-3').text(), 'Foo4Bar');
      assert.equal(this.$('#args-5').text(), 'Foo4Bar5Baz');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$('#args-3').text(), 'Foo4Bar');
      assert.equal(this.$('#args-5').text(), 'Foo4Bar5Baz');
    }
    ['@test arbitrary positional parameter conflict with hash parameter is reported']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.names as |name|}}\n          {{name}}\n        {{/each}}"])))
      });
      expectAssertion(() => {
        this.render("{{sample-component \"Foo\" 4 \"Bar\" names=this.numbers id=\"args-3\"}}", {
          numbers: [1, 2, 3]
        });
      }, 'You cannot specify positional parameters and the hash argument `names`.');
    }
    ['@test can use hash parameter instead of arbitrary positional param [GH #12444]']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.names as |name|}}\n          {{name}}\n        {{/each}}"])))
      });
      this.render('{{sample-component names=this.things}}', {
        things: (0, _array.A)(['Foo', 4, 'Bar'])
      });
      this.assertText('Foo4Bar');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Foo4Bar');
      (0, _internalTestHelpers.runTask)(() => this.context.get('things').pushObject(5));
      this.assertText('Foo4Bar5');
      (0, _internalTestHelpers.runTask)(() => this.context.get('things').shiftObject());
      this.assertText('4Bar5');
      (0, _internalTestHelpers.runTask)(() => this.context.get('things').clear());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.context.set('things', (0, _array.A)(['Foo', 4, 'Bar'])));
      this.assertText('Foo4Bar');
    }
    ['@test can use hash parameter instead of positional param'](assert) {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['first', 'second']
        }),
        template: '{{this.first}} - {{this.second}}'
      });

      // TODO: Fix when id is implemented
      this.render((0, _internalTestHelpers.strip)(_templateObject13 || (_templateObject13 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{sample-component \"one\" \"two\" elementId=\"two-positional\"}}\n      {{sample-component \"one\" second=\"two\" elementId=\"one-positional\"}}\n      {{sample-component first=\"one\" second=\"two\" elementId=\"no-positional\"}}"]))));
      assert.equal(this.$('#two-positional').text(), 'one - two');
      assert.equal(this.$('#one-positional').text(), 'one - two');
      assert.equal(this.$('#no-positional').text(), 'one - two');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$('#two-positional').text(), 'one - two');
      assert.equal(this.$('#one-positional').text(), 'one - two');
      assert.equal(this.$('#no-positional').text(), 'one - two');
    }
    ['@test dynamic arbitrary number of positional parameters']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'n'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject14 || (_templateObject14 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.n as |name|}}\n          {{name}}\n        {{/each}}"])))
      });
      this.render("{{sample-component this.user1 this.user2}}", {
        user1: 'Foo',
        user2: 4
      });
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(() => this.context.set('user1', 'Bar'));
      this.assertText('Bar4');
      (0, _internalTestHelpers.runTask)(() => this.context.set('user2', '5'));
      this.assertText('Bar5');
      (0, _internalTestHelpers.runTask)(() => {
        this.context.set('user1', 'Foo');
        this.context.set('user2', 4);
      });
      this.assertText('Foo4');
    }
    ['@test with ariaRole specified']() {
      this.registerComponent('aria-test', {
        template: 'Here!'
      });
      this.render('{{aria-test ariaRole=this.role}}', {
        role: 'main'
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'main'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'main'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.context.set('role', 'input'));
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'input'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.context.set('role', 'main'));
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'main'
        }
      });
    }
    ['@test with ariaRole defined but initially falsey GH#16379']() {
      this.registerComponent('aria-test', {
        template: 'Here!'
      });
      this.render('{{aria-test ariaRole=this.role}}', {
        role: undefined
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(() => this.context.set('role', 'input'));
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'input'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.context.set('role', undefined));
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
    }
    ['@test without ariaRole defined initially']() {
      // we are using the ability to lazily add a role as a sign that we are
      // doing extra work
      let instance;
      this.registerComponent('aria-test', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            instance = this;
          }
        }),
        template: 'Here!'
      });
      this.render('{{aria-test}}');
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(() => instance.set('ariaRole', 'input'));
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
    }
    ['@test `template` specified in component is overridden by block']() {
      this.registerComponent('with-template', {
        ComponentClass: _helpers.Component.extend({
          template: (0, _helpers.compile)('Should not be used')
        }),
        template: '[In layout - {{this.name}}] {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject15 || (_templateObject15 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-template name=\"with-block\"}}\n        [In block - {{this.name}}]\n      {{/with-template}}\n      {{with-template name=\"without-block\"}}"]))), {
        name: 'Whoop, whoop!'
      });
      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('name', 'Ole, ole'));
      this.assertText('[In layout - with-block] [In block - Ole, ole][In layout - without-block] ');
      (0, _internalTestHelpers.runTask)(() => this.context.set('name', 'Whoop, whoop!'));
      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
    }
    ['@test (has-block) is true when block supplied']() {
      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject16 || (_templateObject16 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block)}}\n          {{yield}}\n        {{else}}\n          No Block!\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject17 || (_templateObject17 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-block}}\n        In template\n      {{/with-block}}"]))));
      this.assertText('In template');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In template');
    }
    ['@test (has-block) is false when no block supplied']() {
      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject18 || (_templateObject18 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block)}}\n          {{yield}}\n        {{else}}\n          No Block!\n        {{/if}}"])))
      });
      this.render('{{with-block}}');
      this.assertText('No Block!');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('No Block!');
    }
    ['@test (has-block-params) is true when block param supplied']() {
      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject19 || (_templateObject19 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block-params)}}\n          {{yield this}} - In Component\n        {{else}}\n          {{yield}} No Block!\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject20 || (_templateObject20 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-block as |something|}}\n        In template\n      {{/with-block}}"]))));
      this.assertText('In template - In Component');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In template - In Component');
    }
    ['@test (has-block-params) is false when no block param supplied']() {
      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject21 || (_templateObject21 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block-params)}}\n          {{yield this}}\n        {{else}}\n          {{yield}} No Block Param!\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject22 || (_templateObject22 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#with-block}}\n        In block\n      {{/with-block}}"]))));
      this.assertText('In block No Block Param!');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In block No Block Param!');
    }
    ['@test static named positional parameters']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{this.name}}{{this.age}}'
      });
      this.render('{{sample-component "Quint" 4}}');
      this.assertText('Quint4');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Quint4');
    }
    ['@test dynamic named positional parameters']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{this.name}}{{this.age}}'
      });
      this.render('{{sample-component this.myName this.myAge}}', {
        myName: 'Quint',
        myAge: 4
      });
      this.assertText('Quint4');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Quint4');
      (0, _internalTestHelpers.runTask)(() => this.context.set('myName', 'Sergio'));
      this.assertText('Sergio4');
      (0, _internalTestHelpers.runTask)(() => this.context.set('myAge', 2));
      this.assertText('Sergio2');
      (0, _internalTestHelpers.runTask)(() => {
        this.context.set('myName', 'Quint');
        this.context.set('myAge', 4);
      });
      this.assertText('Quint4');
    }
    ['@test if a value is passed as a non-positional parameter, it raises an assertion']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{this.name}}'
      });
      expectAssertion(() => {
        this.render('{{sample-component this.notMyName name=this.myName}}', {
          myName: 'Quint',
          notMyName: 'Sergio'
        });
      }, 'You cannot specify both a positional param (at position 0) and the hash argument `name`.');
    }
    ['@test yield to inverse']() {
      this.registerComponent('my-if', {
        template: (0, _internalTestHelpers.strip)(_templateObject23 || (_templateObject23 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if this.predicate}}\n          Yes:{{yield this.someValue}}\n        {{else}}\n          No:{{yield to=\"inverse\"}}\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject24 || (_templateObject24 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#my-if predicate=this.activated someValue=42 as |result|}}\n        Hello{{result}}\n      {{else}}\n        Goodbye\n      {{/my-if}}"]))), {
        activated: true
      });
      this.assertText('Yes:Hello42');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Yes:Hello42');
      (0, _internalTestHelpers.runTask)(() => this.context.set('activated', false));
      this.assertText('No:Goodbye');
      (0, _internalTestHelpers.runTask)(() => this.context.set('activated', true));
      this.assertText('Yes:Hello42');
    }
    ['@test expression (has-block) inverse']() {
      this.registerComponent('check-inverse', {
        template: (0, _internalTestHelpers.strip)(_templateObject25 || (_templateObject25 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block \"inverse\")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject26 || (_templateObject26 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse}}{{else}}{{/check-inverse}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    }
    ['@test expression (has-block) default']() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject27 || (_templateObject27 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject28 || (_templateObject28 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{check-block}}\n      {{#check-block}}{{/check-block}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    }
    ['@test expression (has-block-params) inverse']() {
      this.registerComponent('check-inverse', {
        template: (0, _internalTestHelpers.strip)(_templateObject29 || (_templateObject29 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block-params \"inverse\")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject30 || (_templateObject30 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse as |something|}}{{/check-inverse}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'No'
      });
      this.assertStableRerender();
    }
    ['@test expression (has-block-params) default']() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject31 || (_templateObject31 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#if (has-block-params)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject32 || (_templateObject32 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-block}}{{/check-block}}\n      {{#check-block as |something|}}{{/check-block}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    }
    ['@test (has-block) expression in an attribute'](assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{(has-block)}}></button>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject33 || (_templateObject33 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{check-attr}}\n      {{#check-attr}}{{/check-attr}}"]))));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'true'
      }, '');
      this.assertStableRerender();
    }
    ['@test (has-block) inverse expression in an attribute'](assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{(has-block "inverse")}}></button>'
      }, '');
      this.render((0, _internalTestHelpers.strip)(_templateObject34 || (_templateObject34 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr}}{{else}}{{/check-attr}}"]))));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'true'
      }, '');
      this.assertStableRerender();
    }
    ['@test (has-block-params) expression in an attribute'](assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{(has-block-params)}}></button>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject35 || (_templateObject35 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr as |something|}}{{/check-attr}}"]))));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'true'
      }, '');
      this.assertStableRerender();
    }
    ['@test (has-block-params) inverse expression in an attribute'](assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{(has-block-params "inverse")}}></button>'
      }, '');
      this.render((0, _internalTestHelpers.strip)(_templateObject36 || (_templateObject36 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr as |something|}}{{/check-attr}}"]))));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'false'
      }, '');
      this.assertStableRerender();
    }
    ['@test (has-block) as a param to a helper']() {
      this.registerComponent('check-helper', {
        template: '{{if (has-block) "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject37 || (_templateObject37 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{check-helper}}\n      {{#check-helper}}{{/check-helper}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    }
    ['@test (has-block) inverse as a param to a helper']() {
      this.registerComponent('check-helper', {
        template: '{{if (has-block "inverse") "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject38 || (_templateObject38 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper}}{{else}}{{/check-helper}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    }
    ['@test (has-block-params) as a param to a helper']() {
      this.registerComponent('check-helper', {
        template: '{{if (has-block-params) "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject39 || (_templateObject39 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    }
    ['@test (has-block-params) inverse as a param to a helper']() {
      this.registerComponent('check-helper', {
        template: '{{if (has-block-params "inverse") "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject40 || (_templateObject40 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}"]))));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'false'
      });
      this.assertStableRerender();
    }
    ['@test component in template of a yielding component should have the proper parentView'](assert) {
      let outer, innerTemplate, innerLayout;
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            outer = this;
          }
        }),
        template: '{{x-inner-in-layout}}{{yield}}'
      });
      this.registerComponent('x-inner-in-template', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            innerTemplate = this;
          }
        })
      });
      this.registerComponent('x-inner-in-layout', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            innerLayout = this;
          }
        })
      });
      this.render('{{#x-outer}}{{x-inner-in-template}}{{/x-outer}}');
      assert.equal(innerTemplate.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      assert.equal(innerLayout.parentView, outer, 'receives the wrapping component as its parentView in layout');
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(innerTemplate.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      assert.equal(innerLayout.parentView, outer, 'receives the wrapping component as its parentView in layout');
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
    }
    ['@test newly-added sub-components get correct parentView'](assert) {
      let outer, inner;
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            outer = this;
          }
        })
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            inner = this;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject41 || (_templateObject41 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#x-outer}}\n        {{#if this.showInner}}\n          {{x-inner}}\n        {{/if}}\n      {{/x-outer}}"]))), {
        showInner: false
      });
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView (after rerender)');
      (0, _internalTestHelpers.runTask)(() => this.context.set('showInner', true));
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      assert.equal(inner.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      (0, _internalTestHelpers.runTask)(() => this.context.set('showInner', false));
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
    }
    ["@test when a property is changed during children's rendering"]() {
      let middle;
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          value: 1
        }),
        template: '{{#x-middle}}{{x-inner value=this.value}}{{/x-middle}}'
      });
      this.registerComponent('x-middle', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            middle = this;
          },
          value: null
        }),
        template: '<div id="middle-value">{{this.value}}</div>{{yield}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          value: null,
          didReceiveAttrs() {
            middle.set('value', this.get('value'));
          }
        }),
        template: '<div id="inner-value">{{value}}</div>'
      });
      let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('value', '<.+?>', {
        renderTree: ['x-outer', 'x-middle', 'this.value']
      });
      expectAssertion(() => {
        this.render('{{x-outer}}');
      }, expectedBacktrackingMessage);
    }
    ["@test when a shared dependency is changed during children's rendering"]() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          value: 1,
          wrapper: _object.default.create({
            content: null
          })
        }),
        template: '<div id="outer-value">{{this.wrapper.content}}</div> {{x-inner value=this.value wrapper=this.wrapper}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs() {
            this.get('wrapper').set('content', this.get('value'));
          },
          value: null
        }),
        template: '<div id="inner-value">{{wrapper.content}}</div>'
      });
      let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('content', '<.+?>', {
        renderTree: ['x-outer', 'this.wrapper.content']
      });
      expectAssertion(() => {
        this.render('{{x-outer}}');
      }, expectedBacktrackingMessage);
    }
    ["@test when a shared dependency is changed during children's rendering (tracked)"]() {
      var _class, _descriptor;
      let Wrapper = (_class = class Wrapper {
        constructor() {
          _initializerDefineProperty(this, "content", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "content", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class);
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          value: 1,
          wrapper: new Wrapper()
        }),
        template: '<div id="outer-value">{{this.wrapper.content}}</div> {{x-inner value=this.value wrapper=this.wrapper}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs() {
            this.get('wrapper').content = this.get('value');
          },
          value: null
        }),
        template: '<div id="inner-value">{{this.wrapper.content}}</div>'
      });
      let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('content', 'Wrapper', {
        renderTree: ['x-outer', 'this.wrapper.content']
      });
      expectAssertion(() => {
        this.render('{{x-outer}}');
      }, expectedBacktrackingMessage);
    }
    ['@test non-block with each rendering child components']() {
      this.registerComponent('non-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject42 || (_templateObject42 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        In layout. {{#each this.items as |item|}}\n          [{{child-non-block item=item}}]\n        {{/each}}"])))
      });
      this.registerComponent('child-non-block', {
        template: 'Child: {{this.item}}.'
      });
      let items = (0, _array.A)(['Tom', 'Dick', 'Harry']);
      this.render('{{non-block items=this.items}}', {
        items
      });
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
      (0, _internalTestHelpers.runTask)(() => this.context.get('items').pushObject('Sergio'));
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.][Child: Sergio.]');
      (0, _internalTestHelpers.runTask)(() => this.context.get('items').shiftObject());
      this.assertText('In layout. [Child: Dick.][Child: Harry.][Child: Sergio.]');
      (0, _internalTestHelpers.runTask)(() => this.context.set('items', (0, _array.A)(['Tom', 'Dick', 'Harry'])));
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
    }
    ['@test specifying classNames results in correct class'](assert) {
      this.registerComponent('some-clicky-thing', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'button',
          classNames: ['foo', 'bar']
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject43 || (_templateObject43 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#some-clicky-thing classNames=\"baz\"}}\n        Click Me\n      {{/some-clicky-thing}}"]))));

      // TODO: ember-view is no longer viewable in the classNames array. Bug or
      // feature?
      let expectedClassNames = ['ember-view', 'foo', 'bar', 'baz'];
      assert.ok(this.$('button').is('.foo.bar.baz.ember-view'), "the element has the correct classes: " + this.$('button').attr('class'));
      // `ember-view` is no longer in classNames.
      // assert.deepEqual(clickyThing.get('classNames'), expectedClassNames, 'classNames are properly combined');
      this.assertComponentElement(this.firstChild, {
        tagName: 'button',
        attrs: {
          class: (0, _internalTestHelpers.classes)(expectedClassNames.join(' '))
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(this.$('button').is('.foo.bar.baz.ember-view'), "the element has the correct classes: " + this.$('button').attr('class') + " (rerender)");
      // `ember-view` is no longer in classNames.
      // assert.deepEqual(clickyThing.get('classNames'), expectedClassNames, 'classNames are properly combined (rerender)');
      this.assertComponentElement(this.firstChild, {
        tagName: 'button',
        attrs: {
          class: (0, _internalTestHelpers.classes)(expectedClassNames.join(' '))
        }
      });
    }
    ['@test specifying custom concatenatedProperties avoids clobbering']() {
      this.registerComponent('some-clicky-thing', {
        ComponentClass: _helpers.Component.extend({
          concatenatedProperties: ['blahzz'],
          blahzz: ['blark', 'pory']
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject44 || (_templateObject44 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.blahzz as |p|}}\n          {{p}}\n        {{/each}}\n        - {{yield}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject45 || (_templateObject45 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#some-clicky-thing blahzz=\"baz\"}}\n        Click Me\n      {{/some-clicky-thing}}"]))));
      this.assertText('blarkporybaz- Click Me');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('blarkporybaz- Click Me');
    }
    ['@test a two way binding flows upstream when consumed in the template']() {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.bar}}'
      });
      this.render('{{this.localBar}} - {{foo-bar bar=this.localBar}}', {
        localBar: 'initial value'
      });
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('bar', 'updated value');
      });
      this.assertText('updated value - updated value');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('bar', undefined);
      });
      this.assertText(' - ');
      (0, _internalTestHelpers.runTask)(() => {
        this.component.set('localBar', 'initial value');
      });
      this.assertText('initial value - initial value');
    }
    ['@test a two way binding flows upstream through a CP when consumed in the template']() {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        bar: (0, _object.computed)({
          get() {
            return this._bar;
          },
          set(key, value) {
            this._bar = value;
            return this._bar;
          }
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.bar}}'
      });
      this.render('{{this.localBar}} - {{foo-bar bar=this.localBar}}', {
        localBar: 'initial value'
      });
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('bar', 'updated value');
      });
      this.assertText('updated value - updated value');
      (0, _internalTestHelpers.runTask)(() => {
        this.component.set('localBar', 'initial value');
      });
      this.assertText('initial value - initial value');
    }
    ['@test a two way binding flows upstream through a CP without template consumption']() {
      let component;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        bar: (0, _object.computed)({
          get() {
            return this._bar;
          },
          set(key, value) {
            this._bar = value;
            return this._bar;
          }
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });
      this.render('{{this.localBar}}{{foo-bar bar=this.localBar}}', {
        localBar: 'initial value'
      });
      this.assertText('initial value');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('initial value');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('bar', 'updated value');
      });
      this.assertText('updated value');
      (0, _internalTestHelpers.runTask)(() => {
        this.component.set('localBar', 'initial value');
      });
      this.assertText('initial value');
    }
    ['@test GH#18417 - a two way binding flows upstream to a parent component through a CP']() {
      let parent, child;
      let ParentComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          parent = this;
        },
        string: 'Hello|World'
      });
      this.registerComponent('parent', {
        ComponentClass: ParentComponent,
        template: "{{child value=this.string}}\n\n        Parent String=<span data-test-parent-value>{{this.string}}</span>"
      });
      let ChildComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          child = this;
        },
        a: null,
        // computed based on passed in value of `string`
        b: null,
        // computed based on passed in value of `string`

        value: (0, _object.computed)('a', 'b', {
          get() {
            return this.a + '|' + this.b;
          },
          set(key, value) {
            let vals = value.split('|');
            (0, _object.set)(this, 'a', vals[0]);
            (0, _object.set)(this, 'b', vals[1]);
            return value;
          }
        })
      });
      this.registerComponent('child', {
        ComponentClass: ChildComponent,
        template: '{{this.value}}'
      });
      this.render('{{parent}}');
      this.assert.equal(parent.string, 'Hello|World', 'precond - parent value');
      this.assert.equal(this.element.querySelector('[data-test-parent-value]').textContent.trim(), 'Hello|World', 'precond - parent rendered value');
      (0, _internalTestHelpers.runTask)(() => {
        child.set('a', 'Foo');
      });
      this.assert.equal(parent.string, 'Foo|World', 'parent value updated');
      this.assert.equal(this.element.querySelector('[data-test-parent-value]').textContent.trim(), 'Foo|World', 'parent updated value rendered');
      (0, _internalTestHelpers.runTask)(() => {
        child.set('a', 'Hello');
      });
      this.assert.equal(parent.string, 'Hello|World', 'parent value reset');
      this.assert.equal(this.element.querySelector('[data-test-parent-value]').textContent.trim(), 'Hello|World', 'parent template reset');
    }
    ['@test services can be injected into components']() {
      let serviceInstance;
      this.registerService('name', _service.default.extend({
        init() {
          this._super(...arguments);
          serviceInstance = this;
        },
        last: 'Jackson'
      }));
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          name: (0, _service.service)()
        }),
        template: '{{this.name.last}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('Jackson');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Jackson');
      (0, _internalTestHelpers.runTask)(() => {
        serviceInstance.set('last', 'McGuffey');
      });
      this.assertText('McGuffey');
      (0, _internalTestHelpers.runTask)(() => {
        serviceInstance.set('last', 'Jackson');
      });
      this.assertText('Jackson');
    }
    ['@test injecting an unknown service raises an exception']() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          missingService: (0, _service.service)()
        })
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, "Attempting to inject an unknown injection: 'service:missingService'");
    }
    ['@test throws if `this._super` is not called from `init`']() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {}
        })
      });
      expectAssertion(() => {
        this.render('{{foo-bar}}');
      }, /You must call `super.init\(...arguments\);` or `this._super\(...arguments\)` when overriding `init` on a framework object. Please update .*/);
    }
    ['@test it can use readDOMAttr to read input value']() {
      let component;
      let assertElement = expectedValue => {
        // value is a property, not an attribute
        this.assertHTML("<input class=\"ember-view\" id=\"" + component.elementId + "\">");
        this.assert.equal(this.firstChild.value, expectedValue, 'value property is correct');
        this.assert.equal((0, _object.get)(component, 'value'), expectedValue, 'component.get("value") is correct');
      };
      this.registerComponent('one-way-input', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'input',
          attributeBindings: ['value'],
          init() {
            this._super(...arguments);
            component = this;
          },
          change() {
            let value = this.readDOMAttr('value');
            this.set('value', value);
          }
        })
      });
      this.render('{{one-way-input value=this.value}}', {
        value: 'foo'
      });
      assertElement('foo');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'bar';
        this.$('input').trigger('change');
      });
      assertElement('bar');
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'foo';
        this.$('input').trigger('change');
      });
      assertElement('foo');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(component, 'value', 'bar');
      });
      assertElement('bar');
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'foo';
        this.$('input').trigger('change');
      });
      assertElement('foo');
    }
    ['@test child triggers revalidate during parent destruction (GH#13846)']() {
      this.registerComponent('x-select', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'select',
          init() {
            this._super();
            this.options = (0, _array.A)([]);
            this.value = null;
          },
          updateValue() {
            let newValue = this.get('options.lastObject.value');
            this.set('value', newValue);
          },
          registerOption(option) {
            this.get('options').addObject(option);
          },
          unregisterOption(option) {
            this.get('options').removeObject(option);
            this.updateValue();
          }
        }),
        template: '{{yield this}}'
      });
      this.registerComponent('x-option', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'option',
          attributeBindings: ['selected'],
          didInsertElement() {
            this._super(...arguments);
            this.get('select').registerOption(this);
          },
          selected: (0, _object.computed)('select.value', function () {
            return this.get('value') === this.get('select.value');
          }),
          willDestroyElement() {
            this._super(...arguments);
            this.get('select').unregisterOption(this);
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject46 || (_templateObject46 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#x-select value=this.value as |select|}}\n        {{#x-option value=\"1\" select=select}}1{{/x-option}}\n        {{#x-option value=\"2\" select=select}}2{{/x-option}}\n      {{/x-select}}\n    "]))));
      this.teardown();
      this.assert.ok(true, 'no errors during teardown');
    }
    ['@test setting a property in willDestroyElement does not assert (GH#14273)'](assert) {
      assert.expect(2);
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            this.showFoo = true;
          },
          willDestroyElement() {
            this.set('showFoo', false);
            assert.ok(true, 'willDestroyElement was fired');
            this._super(...arguments);
          }
        }),
        template: "{{#if this.showFoo}}things{{/if}}"
      });
      this.render("{{foo-bar}}");
      this.assertText('things');
    }
    async ['@test didReceiveAttrs fires after .init() but before observers become active'](assert) {
      let barCopyDidChangeCount = 0;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            this.didInit = true;
          },
          didReceiveAttrs() {
            assert.ok(this.didInit, 'expected init to have run before didReceiveAttrs');
            this.set('barCopy', this.attrs.bar.value + 1);
          },
          barCopyDidChange: (0, _object.observer)('barCopy', () => {
            barCopyDidChangeCount++;
          })
        }),
        template: '{{this.bar}}-{{this.barCopy}}'
      });
      await this.render("{{foo-bar bar=this.bar}}", {
        bar: 3
      });
      this.assertText('3-4');
      assert.strictEqual(barCopyDidChangeCount, 1, 'expected observer firing for: barCopy');
      (0, _object.set)(this.context, 'bar', 7);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('7-8');
      assert.strictEqual(barCopyDidChangeCount, 2, 'expected observer firing for: barCopy');
    }
    ['@test overriding didReceiveAttrs does not trigger deprecation'](assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs() {
            assert.equal(1, this.get('foo'), 'expected attrs to have correct value');
          }
        }),
        template: '{{this.foo}}-{{this.fooCopy}}-{{this.bar}}-{{this.barCopy}}'
      });
      this.render("{{foo-bar foo=this.foo bar=this.bar}}", {
        foo: 1,
        bar: 3
      });
    }
    ['@test overriding didUpdateAttrs does not trigger deprecation'](assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didUpdateAttrs() {
            assert.equal(5, this.get('foo'), 'expected newAttrs to have new value');
          }
        }),
        template: '{{this.foo}}-{{this.fooCopy}}-{{this.bar}}-{{this.barCopy}}'
      });
      this.render("{{foo-bar foo=this.foo bar=this.bar}}", {
        foo: 1,
        bar: 3
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 5));
    }
    ['@test returning `true` from an action does not bubble if `target` is not specified (GH#14275)'](assert) {
      this.registerComponent('display-toggle', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            show() {
              assert.ok(true, 'display-toggle show action was called');
              return true;
            }
          }
        }),
        template: "<button {{action 'show'}}>Show</button>"
      });
      this.render("{{display-toggle}}", {
        send() {
          assert.notOk(true, 'send should not be called when action is not "subscribed" to');
        }
      });
      this.assertText('Show');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
    }
    ['@test returning `true` from an action bubbles to the `target` if specified'](assert) {
      assert.expect(4);
      this.registerComponent('display-toggle', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            show() {
              assert.ok(true, 'display-toggle show action was called');
              return true;
            }
          }
        }),
        template: "<button {{action 'show'}}>Show</button>"
      });
      this.render("{{display-toggle target=this}}", {
        send(actionName) {
          assert.ok(true, 'send should be called when action is "subscribed" to');
          assert.equal(actionName, 'show');
        }
      });
      this.assertText('Show');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
    }
    ['@test triggering an event only attempts to invoke an identically named method, if it actually is a function (GH#15228)'](assert) {
      assert.expect(3);
      let payload = ['arbitrary', 'event', 'data'];
      this.registerComponent('evented-component', {
        ComponentClass: _helpers.Component.extend({
          someTruthyProperty: true,
          init() {
            this._super(...arguments);
            this.trigger('someMethod', ...payload);
            this.trigger('someTruthyProperty', ...payload);
          },
          someMethod() {
            for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {
              data[_key] = arguments[_key];
            }
            assert.deepEqual(data, payload, 'the method `someMethod` should be called, when `someMethod` is triggered');
          },
          listenerForSomeMethod: (0, _evented.on)('someMethod', function () {
            for (var _len2 = arguments.length, data = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              data[_key2] = arguments[_key2];
            }
            assert.deepEqual(data, payload, 'the listener `listenerForSomeMethod` should be called, when `someMethod` is triggered');
          }),
          listenerForSomeTruthyProperty: (0, _evented.on)('someTruthyProperty', function () {
            for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              data[_key3] = arguments[_key3];
            }
            assert.deepEqual(data, payload, 'the listener `listenerForSomeTruthyProperty` should be called, when `someTruthyProperty` is triggered');
          })
        })
      });
      this.render("{{evented-component}}");
    }
    ['@test component yielding in an {{#each}} has correct block values after rerendering (GH#14284)']() {
      this.registerComponent('list-items', {
        template: "{{#each this.items as |item|}}{{yield item}}{{/each}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject47 || (_templateObject47 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#list-items items=this.items as |thing|}}\n        |{{thing}}|\n\n        {{#if this.editMode}}\n          Remove {{thing}}\n        {{/if}}\n      {{/list-items}}\n    "]))), {
        editMode: false,
        items: ['foo', 'bar', 'qux', 'baz']
      });
      this.assertText('|foo||bar||qux||baz|');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'editMode', true));
      this.assertText('|foo|Remove foo|bar|Remove bar|qux|Remove qux|baz|Remove baz');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'editMode', false));
      this.assertText('|foo||bar||qux||baz|');
    }
    ['@test unimplimented positionalParams do not cause an error GH#14416']() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar this.wat}}');
      this.assertText('hello');
    }
    ['@test using attrs for positional params is asserted against']() {
      let MyComponent = _helpers.Component.extend();
      expectAssertion(() => {
        this.registerComponent('foo-bar', {
          ComponentClass: MyComponent.reopenClass({
            positionalParams: ['myVar']
          }),
          template: 'MyVar1: {{attrs.myVar}} {{this.myVar}} MyVar2: {{this.myVar2}} {{attrs.myVar2}}'
        });
      }, "Using {{attrs}} to reference named arguments is not supported. {{attrs.myVar}} should be updated to {{@myVar}}. ('my-app/templates/components/foo-bar.hbs' @ L1:C10) ");
    }
    ['@test using this.attrs for positional params']() {
      let MyComponent = _helpers.Component.extend();
      this.registerComponent('foo-bar', {
        ComponentClass: MyComponent.reopenClass({
          positionalParams: ['myVar']
        }),
        template: 'MyVar1: {{this.attrs.myVar}} {{this.myVar}} MyVar2: {{this.myVar2}} {{this.attrs.myVar2}}'
      });
      this.render('{{foo-bar 1 myVar2=2}}');
      this.assertText('MyVar1: 1 1 MyVar2: 2 2');
    }
    ['@test using named arguments for positional params']() {
      let MyComponent = _helpers.Component.extend();
      this.registerComponent('foo-bar', {
        ComponentClass: MyComponent.reopenClass({
          positionalParams: ['myVar']
        }),
        template: 'MyVar1: {{@myVar}} {{this.myVar}} MyVar2: {{this.myVar2}} {{@myVar2}}'
      });
      this.render('{{foo-bar 1 myVar2=2}}');
      this.assertText('MyVar1: 1 1 MyVar2: 2 2');
    }
    ["@test can use `{{this}}` to emit the component's toString value [GH#14581]"]() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          toString() {
            return 'special sauce goes here!';
          }
        }),
        template: '{{this}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('special sauce goes here!');
    }
    ['@test can use `{{this` to access paths on current context [GH#14581]']() {
      let instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            instance = this;
          },
          foo: {
            bar: {
              baz: 'huzzah!'
            }
          }
        }),
        template: '{{this.foo.bar.baz}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('huzzah!');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'foo.bar.baz', 'yippie!'));
      this.assertText('yippie!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'foo.bar.baz', 'huzzah!'));
      this.assertText('huzzah!');
    }
    ['@test can use custom element in component layout']() {
      this.registerComponent('foo-bar', {
        template: '<blah-zorz>Hi!</blah-zorz>'
      });
      this.render('{{foo-bar}}');
      this.assertText('Hi!');
    }
    ['@test can use nested custom element in component layout']() {
      this.registerComponent('foo-bar', {
        template: '<blah-zorz><hows-it-going>Hi!</hows-it-going></blah-zorz>'
      });
      this.render('{{foo-bar}}');
      this.assertText('Hi!');
    }
    ['@test can access properties off of rest style positionalParams array']() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'things'
        }),
        template: "{{@things.length}}"
      });
      this.render('{{foo-bar "foo" "bar" "baz"}}');
      this.assertText('3');
    }
    ['@test has attrs by didReceiveAttrs with native classes'](assert) {
      class FooBarComponent extends _helpers.Component {
        constructor(injections) {
          super(injections);
          // analogous to class field defaults
          this.foo = 'bar';
        }
        didReceiveAttrs() {
          assert.equal(this.foo, 'bar', 'received default attrs correctly');
        }
      }
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar}}');
    }
    ['@test ensure aliases are watched properly [GH#17243]']() {
      let fooInstance, barInstance;
      let FooComponent = _helpers.Component.extend({
        source: 'first',
        foo: (0, _computed.alias)('source'),
        init() {
          this._super(...arguments);
          fooInstance = this;
        }
      });
      this.registerComponent('foo', {
        ComponentClass: FooComponent,
        template: '{{this.foo}}'
      });
      let BarComponent = _helpers.Component.extend({
        target: null,
        init() {
          this._super(...arguments);
          barInstance = this;
        },
        bar: (0, _object.computed)('target.foo', function () {
          if (this.target) {
            return this.target.foo.toUpperCase();
          }
        })
      });
      this.registerComponent('bar', {
        ComponentClass: BarComponent,
        template: '{{this.bar}}'
      });
      this.render('[<Foo />][<Bar />]');
      this.assertText('[first][]');

      // addObserver
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(barInstance, 'target', fooInstance));
      this.assertText('[first][FIRST]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooInstance, 'source', 'second'));
      this.assertText('[second][SECOND]');

      // removeObserver
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(barInstance, 'target', null));
      this.assertText('[second][]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooInstance, 'source', 'third'));
      this.assertText('[third][]');
    }
    ['@test it can render a basic component in native ES class syntax'](assert) {
      let testContext = this;
      this.registerComponent('foo-bar', {
        ComponentClass: class extends _helpers.Component {
          constructor(owner) {
            super(owner);
            assert.equal(owner, testContext.owner, 'owner was passed as a constructor argument');
          }
        },
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test can use `{{@component.foo}}` in a template GH#19313']() {
      this.registerComponent('foo-bar', {
        template: '{{@component.foo}}'
      });
      this.render('{{foo-bar component=(hash foo="bar")}}');
      this.assertComponentElement(this.firstChild, {
        content: 'bar'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'bar'
      });
    }
    '@test lifecycle hooks are not tracked'() {
      var _class3, _descriptor2;
      this.registerComponent('foo-bar', {
        ComponentClass: (_class3 = class _class3 extends _helpers.Component {
          constructor() {
            super(...arguments);
            _initializerDefineProperty(this, "foo", _descriptor2, this);
          }
          willInsertElement() {
            this.foo;
            this.foo = 123;
          }
          willRender() {
            this.foo;
            this.foo = 123;
          }
          didRender() {
            this.foo;
            this.foo = 123;
          }
          didReceiveAttrs() {
            this.foo;
            this.foo = 123;
          }
          didUpdate() {
            this.foo;
            this.foo = 123;
          }
          didUpdateAttrs() {
            this.foo;
            this.foo = 123;
          }
          didInsertElement() {
            this.foo;
            this.foo = 123;
          }
          willClearRender() {
            this.foo;
            this.foo = 123;
          }
          willDestroyElement() {
            this.foo;
            this.foo = 123;
          }
          didDestroyElement() {
            this.foo;
            this.foo = 123;
          }
        }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "foo", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class3),
        template: '{{this.baz}}'
      });
      this.render('{{#if this.cond}}{{foo-bar baz=this.value}}{{/if}}', {
        cond: true,
        value: 'hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'world'));
      this.assertComponentElement(this.firstChild, {
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', false));
    }
    '@test tracked property mutation in init does not error'() {
      var _class5, _descriptor3;
      // TODO: this should issue a deprecation, but since the curly manager
      // uses an untracked frame for construction we don't (yet)
      this.registerComponent('foo-bar', {
        template: "{{this.itemCount}}",
        ComponentClass: (_class5 = class _class5 extends _helpers.Component {
          constructor() {
            super(...arguments);
            _initializerDefineProperty(this, "itemCount", _descriptor3, this);
          }
          init() {
            super.init(...arguments);

            // first read the tracked property
            let {
              itemCount
            } = this;

            // then attempt to update the tracked property
            this.itemCount = itemCount + 1;
          }
        }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "itemCount", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 0;
          }
        }), _class5)
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: '1'
      });
    }
    '@test `{{#let blah as |foo|}}` does not affect `<Foo />` resolution'() {
      this.registerComponent('foo', {
        ComponentClass: null,
        template: 'foo component'
      });
      this.render('{{#let "foo block param" as |foo|}}<Foo />{{/let}}');
      this.assertText('foo component');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('foo component');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/dynamic-components-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/debug-stack"], function (_emberBabel, _internalTestHelpers, _object, _helpers, _debugStack) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3;
  (0, _internalTestHelpers.moduleFor)('Components test: dynamic components', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can render a basic component with a static component name argument']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}}'
      });
      this.render('{{component "foo-bar" name=this.name}}', {
        name: 'Sarah'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Sarah'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello Sarah'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Gavin'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Gavin'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Sarah'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Sarah'
      });
    }
    ['@test it can render a basic component with a dynamic component name argument']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}} from foo-bar'
      });
      this.registerComponent('foo-bar-baz', {
        template: 'hello {{this.name}} from foo-bar-baz'
      });
      this.render('{{component this.componentName name=this.name}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Ben'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'foo-bar-baz'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben from foo-bar-baz'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'componentName', 'foo-bar');
        (0, _object.set)(this.context, 'name', 'Alex');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex from foo-bar'
      });
    }
    ['@test it has an element']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          instance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{component "foo-bar"}}');
      let element1 = instance.element;
      this.assertComponentElement(element1, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let element2 = instance.element;
      this.assertComponentElement(element2, {
        content: 'hello'
      });
      this.assertSameNode(element2, element1);
    }
    ['@test it has the right parentView and childViews'](assert) {
      let fooBarInstance, fooBarBazInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
        }
      });
      let FooBarBazComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarBazInstance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'foo-bar {{foo-bar-baz}}'
      });
      this.registerComponent('foo-bar-baz', {
        ComponentClass: FooBarBazComponent,
        template: 'foo-bar-baz'
      });
      this.render('{{component "foo-bar"}}');
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    }
    ['@test it can render a basic component with a block']() {
      this.registerComponent('foo-bar', {
        template: '{{yield}}'
      });
      this.render('{{#component "foo-bar"}}hello{{/component}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test it renders the layout with the component instance as the context']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          instance = this;
          this.set('message', 'hello');
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{this.message}}'
      });
      this.render('{{component "foo-bar"}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'message', 'goodbye'));
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'message', 'hello'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test it preserves the outer context when yielding']() {
      this.registerComponent('foo-bar', {
        template: '{{yield}}'
      });
      this.render('{{#component "foo-bar"}}{{this.message}}{{/component}}', {
        message: 'hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'goodbye'));
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'hello'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    }
    ['@test the component and its child components are destroyed'](assert) {
      let destroyed = {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      };
      this.registerComponent('foo-bar', {
        template: '{{this.id}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          willDestroy() {
            this._super();
            destroyed[this.get('id')]++;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#if this.cond1}}\n        {{#component \"foo-bar\" id=1}}\n          {{#if this.cond2}}\n            {{#component \"foo-bar\" id=2}}{{/component}}\n            {{#if this.cond3}}\n              {{#component \"foo-bar\" id=3}}\n                {{#if this.cond4}}\n                  {{#component \"foo-bar\" id=4}}\n                    {{#if this.cond5}}\n                      {{#component \"foo-bar\" id=5}}{{/component}}\n                      {{#component \"foo-bar\" id=6}}{{/component}}\n                      {{#component \"foo-bar\" id=7}}{{/component}}\n                    {{/if}}\n                    {{#component \"foo-bar\" id=8}}{{/component}}\n                  {{/component}}\n                {{/if}}\n              {{/component}}\n            {{/if}}\n          {{/if}}\n        {{/component}}\n      {{/if}}"]))), {
        cond1: true,
        cond2: true,
        cond3: true,
        cond4: true,
        cond5: true
      });
      this.assertText('1 2 3 4 5 6 7 8 ');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond5', false));
      this.assertText('1 2 3 4 8 ');
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 1,
        6: 1,
        7: 1,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond3', false);
        (0, _object.set)(this.context, 'cond5', true);
        (0, _object.set)(this.context, 'cond4', false);
      });
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond2', false);
        (0, _object.set)(this.context, 'cond1', false);
      });
      assert.deepEqual(destroyed, {
        1: 1,
        2: 1,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
    }
    ['@test component helper destroys underlying component when it is swapped out'](assert) {
      let destroyed = {
        'foo-bar': 0,
        'foo-bar-baz': 0
      };
      let testContext = this;
      this.registerComponent('foo-bar', {
        template: 'hello from foo-bar',
        ComponentClass: _helpers.Component.extend({
          willDestroyElement() {
            assert.equal(testContext.$("#" + this.elementId).length, 1, 'element is still attached to the document');
          },
          willDestroy() {
            this._super();
            destroyed['foo-bar']++;
          }
        })
      });
      this.registerComponent('foo-bar-baz', {
        template: 'hello from foo-bar-baz',
        ComponentClass: _helpers.Component.extend({
          willDestroy() {
            this._super();
            destroyed['foo-bar-baz']++;
          }
        })
      });
      this.render('{{component this.componentName name=this.name}}', {
        componentName: 'foo-bar'
      });
      assert.deepEqual(destroyed, {
        'foo-bar': 0,
        'foo-bar-baz': 0
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.deepEqual(destroyed, {
        'foo-bar': 0,
        'foo-bar-baz': 0
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'foo-bar-baz'));
      assert.deepEqual(destroyed, {
        'foo-bar': 1,
        'foo-bar-baz': 0
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'foo-bar'));
      assert.deepEqual(destroyed, {
        'foo-bar': 1,
        'foo-bar-baz': 1
      });
    }
    ['@test component helper with bound properties are updating correctly in init of component']() {
      this.registerComponent('foo-bar', {
        template: 'foo-bar {{this.location}} {{this.locationCopy}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super(...arguments);
            this.set('locationCopy', this.get('location'));
          }
        })
      });
      this.registerComponent('foo-bar-baz', {
        template: 'foo-bar-baz {{this.location}} {{this.locationCopy}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super(...arguments);
            this.set('locationCopy', this.get('location'));
          }
        })
      });
      this.registerComponent('outer-component', {
        template: '{{#component this.componentName location=this.location}}arepas!{{/component}}',
        ComponentClass: _helpers.Component.extend({
          componentName: (0, _object.computed)('location', function () {
            if (this.get('location') === 'Caracas') {
              return 'foo-bar';
            } else {
              return 'foo-bar-baz';
            }
          })
        })
      });
      this.render('{{outer-component location=this.location}}', {
        location: 'Caracas'
      });
      this.assertText('foo-bar Caracas Caracas arepas!');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('foo-bar Caracas Caracas arepas!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'location', 'Loisaida'));
      this.assertText('foo-bar-baz Loisaida Loisaida arepas!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'location', 'Caracas'));
      this.assertText('foo-bar Caracas Caracas arepas!');
    }
    ['@test component helper with actions'](assert) {
      this.registerComponent('inner-component', {
        template: 'inner-component {{yield}}',
        ComponentClass: _helpers.Component.extend({
          classNames: 'inner-component',
          didInsertElement() {
            // trigger action on click in absence of app's EventDispatcher
            let sendAction = this.eventHandler = () => {
              if (this.somethingClicked) {
                this.somethingClicked();
              }
            };
            this.element.addEventListener('click', sendAction);
          },
          willDestroyElement() {
            this.element.removeEventListener('click', this.eventHandler);
          }
        })
      });
      let actionTriggered = 0;
      this.registerComponent('outer-component', {
        template: '{{#component this.componentName somethingClicked=(action "mappedAction")}}arepas!{{/component}}',
        ComponentClass: _helpers.Component.extend({
          classNames: 'outer-component',
          componentName: 'inner-component',
          actions: {
            mappedAction() {
              actionTriggered++;
            }
          }
        })
      });
      this.render('{{outer-component}}');
      assert.equal(actionTriggered, 0, 'action was not triggered');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('.inner-component').click();
      });
      assert.equal(actionTriggered, 1, 'action was triggered');
    }
    ['@test nested component helpers']() {
      this.registerComponent('foo-bar', {
        template: 'yippie! {{@location}} {{yield}}'
      });
      this.registerComponent('baz-qux', {
        template: 'yummy {{@location}} {{yield}}'
      });
      this.registerComponent('corge-grault', {
        template: 'delicious {{@location}} {{yield}}'
      });
      this.render('{{#component this.componentName1 location=this.location}}{{#component this.componentName2 location=this.location}}arepas!{{/component}}{{/component}}', {
        componentName1: 'foo-bar',
        componentName2: 'baz-qux',
        location: 'Caracas'
      });
      this.assertText('yippie! Caracas yummy Caracas arepas!');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('yippie! Caracas yummy Caracas arepas!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'location', 'Loisaida'));
      this.assertText('yippie! Loisaida yummy Loisaida arepas!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName1', 'corge-grault'));
      this.assertText('delicious Loisaida yummy Loisaida arepas!');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'componentName1', 'foo-bar');
        (0, _object.set)(this.context, 'location', 'Caracas');
      });
      this.assertText('yippie! Caracas yummy Caracas arepas!');
    }
    ['@test component with dynamic name argument resolving to non-existent component'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        this.render('{{component this.componentName}}', {
          componentName: 'does-not-exist'
        });
      }, /Attempted to resolve `does-not-exist`, which was expected to be a component, but nothing was found./);
    }
    ['@test component with static name argument for non-existent component'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        this.render('{{component "does-not-exist"}}');
      }, /Attempted to resolve `does-not-exist`, which was expected to be a component, but nothing was found./);
    }
    ['@test component with dynamic component name resolving to a component, then non-existent component']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}}'
      });
      this.render('{{component this.componentName name=this.name}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', undefined));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'foo-bar'));
      this.assertText('hello Alex');
    }
    ['@test component helper properly invalidates hash params inside an {{each}} invocation #11044']() {
      this.registerComponent('foo-bar', {
        template: '[{{this.internalName}} - {{this.name}}]',
        ComponentClass: _helpers.Component.extend({
          willRender() {
            // store internally available name to ensure that the name available in `this.attrs.name`
            // matches the template lookup name
            (0, _object.set)(this, 'internalName', this.get('name'));
          }
        })
      });
      this.render('{{#each this.items as |item|}}{{component "foo-bar" name=item.name}}{{/each}}', {
        items: [{
          name: 'Robert'
        }, {
          name: 'Jacquie'
        }]
      });
      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items', [{
        name: 'Max'
      }, {
        name: 'James'
      }]));
      this.assertText('[Max - Max][James - James]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items', [{
        name: 'Robert'
      }, {
        name: 'Jacquie'
      }]));
      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
    }
    ['@test positional parameters does not clash when rendering different components']() {
      this.registerComponent('foo-bar', {
        template: 'hello {{this.name}} ({{this.age}}) from foo-bar',
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        })
      });
      this.registerComponent('foo-bar-baz', {
        template: 'hello {{this.name}} ({{this.age}}) from foo-bar-baz',
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        })
      });
      this.render('{{component this.componentName this.name this.age}}', {
        componentName: 'foo-bar',
        name: 'Alex',
        age: 29
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex (29) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex (29) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Ben'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben (29) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'age', 22));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben (22) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'foo-bar-baz'));
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben (22) from foo-bar-baz'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'componentName', 'foo-bar');
        (0, _object.set)(this.context, 'name', 'Alex');
        (0, _object.set)(this.context, 'age', 29);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex (29) from foo-bar'
      });
    }
    ['@test positional parameters does not pollute the attributes when changing components']() {
      this.registerComponent('normal-message', {
        template: 'Normal: {{this.something}}!',
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['something']
        })
      });
      this.registerComponent('alternative-message', {
        template: 'Alternative: {{this.something}} {{this.somethingElse}}!',
        ComponentClass: _helpers.Component.extend({
          something: 'Another'
        }).reopenClass({
          positionalParams: ['somethingElse']
        })
      });
      this.render('{{component this.componentName this.message}}', {
        componentName: 'normal-message',
        message: 'Hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Normal: Hello!'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertComponentElement(this.firstChild, {
        content: 'Normal: Hello!'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'alternative-message'));
      this.assertComponentElement(this.firstChild, {
        content: 'Alternative: Another Hello!'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'Hi'));
      this.assertComponentElement(this.firstChild, {
        content: 'Alternative: Another Hi!'
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'componentName', 'normal-message');
        (0, _object.set)(this.context, 'message', 'Hello');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Normal: Hello!'
      });
    }
    ['@test static arbitrary number of positional parameters']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.names as |name|}}\n          {{name}}\n        {{/each}}"])))
      });
      this.render("{{component \"sample-component\" \"Foo\" 4 \"Bar\" 5 \"Baz\" elementId=\"helper\"}}");
      this.assertText('Foo4Bar5Baz');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Foo4Bar5Baz');
    }
    ['@test dynamic arbitrary number of positional parameters']() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'n'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.n as |name|}}\n          {{name}}\n        {{/each}}"])))
      });
      this.render("{{component \"sample-component\" this.user1 this.user2}}", {
        user1: 'Foo',
        user2: 4
      });
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(() => this.context.set('user1', 'Bar'));
      this.assertText('Bar4');
      (0, _internalTestHelpers.runTask)(() => this.context.set('user2', '5'));
      this.assertText('Bar5');
      (0, _internalTestHelpers.runTask)(() => {
        this.context.set('user1', 'Foo');
        this.context.set('user2', 4);
      });
      this.assertText('Foo4');
    }
    ['@test component helper emits useful backtracking re-render assertion message']() {
      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            this.set('person', {
              name: 'Alex',
              toString() {
                return "Person (" + this.name + ")";
              }
            });
          }
        }),
        template: "Hi {{this.person.name}}! {{component \"error-component\" person=this.person}}"
      });
      this.registerComponent('error-component', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            this.set('person.name', 'Ben');
          }
        }),
        template: '{{this.person.name}}'
      });
      let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('name', 'Person \\(Ben\\)', {
        renderTree: ['outer-component', 'this.person.name']
      });
      expectAssertion(() => {
        this.render('{{component this.componentName}}', {
          componentName: 'outer-component'
        });
      }, expectedBacktrackingMessage);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/error-handling-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Errors thrown during render', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can recover resets the transaction when an error is thrown during initial render'](assert) {
      let shouldThrow = true;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          if (shouldThrow) {
            throw new Error('silly mistake in init!');
          }
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      assert.throws(() => {
        this.render('{{#if this.switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
          switch: true
        });
      }, /silly mistake in init/);
      assert.equal(this.renderer._inRenderTransaction, false, 'should not be in a transaction even though an error was thrown');
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', false));
      shouldThrow = false;
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', true));
      if (false /* DEBUG */) {
        this.assertText('', 'it does not rerender after error in development');
      } else {
        this.assertText('hello', 'it rerenders after error in production');
      }
    }
    ['@skip it can recover resets the transaction when an error is thrown during rerender'](assert) {
      let shouldThrow = false;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          if (shouldThrow) {
            throw new Error('silly mistake in init!');
          }
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if this.switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
        switch: true
      });
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', false));
      shouldThrow = true;
      assert.throws(() => {
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', true));
      }, /silly mistake in init/);
      assert.equal(this.renderer._inRenderTransaction, false, 'should not be in a transaction even though an error was thrown');
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', false));
      shouldThrow = false;
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', true));
      if (false /* DEBUG */) {
        this.assertText('', 'it does not rerender after error in development');
      } else {
        this.assertText('hello', 'it does rerender after error in production');
      }
    }
    ['@test it can recover resets the transaction when an error is thrown during didInsertElement'](assert) {
      let shouldThrow = true;
      let FooBarComponent = _helpers.Component.extend({
        didInsertElement() {
          this._super(...arguments);
          if (shouldThrow) {
            throw new Error('silly mistake!');
          }
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      assert.throws(() => {
        this.render('{{#if this.switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
          switch: true
        });
      }, /silly mistake/);
      assert.equal(this.renderer._inRenderTransaction, false, 'should not be in a transaction even though an error was thrown');
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', false));
      this.assertText('');
    }
    ['@test it can recover resets the transaction when an error is thrown during destroy'](assert) {
      let shouldThrow = true;
      let FooBarComponent = _helpers.Component.extend({
        destroy() {
          this._super(...arguments);
          if (shouldThrow) {
            throw new Error('silly mistake!');
          }
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if this.switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
        switch: true
      });
      this.assertText('hello');
      assert.throws(() => {
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', false));
      }, /silly mistake/);
      this.assertText('');
      shouldThrow = false;
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', true));
      this.assertText('hello');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/fragment-components-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3;
  (0, _internalTestHelpers.moduleFor)('Components test: fragment components', class extends _internalTestHelpers.RenderingTestCase {
    getCustomDispatcherEvents() {
      return {
        hitDem: 'folks'
      };
    }
    ['@test fragments do not render an outer tag']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        init() {
          this._super();
          instance = this;
          this.foo = true;
          this.bar = 'bar';
        }
      });
      let template = "{{#if this.foo}}<div>Hey</div>{{/if}}{{yield this.bar}}";
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      this.render("{{#foo-bar as |bar|}}{{bar}}{{/foo-bar}}");
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["<div>Hey</div>bar"]))));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'foo', false));
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["<!---->bar"]))));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(instance, 'bar', 'bizz'));
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["<!---->bizz"]))));
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(instance, 'bar', 'bar');
        (0, _object.set)(instance, 'foo', true);
      });
    }
    ['@test throws an error if an event function is defined in a tagless component']() {
      let template = "hit dem folks";
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        click() {},
        mouseEnter() {}
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      expectAssertion(() => {
        this.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You can not define `click` function\(s\) to handle DOM event in the .* tagless component since it doesn't have any DOM element./);
    }
    ['@test throws an error if a custom defined event function is defined in a tagless component']() {
      let template = "hit dem folks";
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        folks() {}
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      expectAssertion(() => {
        this.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You can not define `folks` function\(s\) to handle DOM event in the .* tagless component since it doesn't have any DOM element./);
    }
    ['@test throws an error if `tagName` is an empty string and `classNameBindings` are specified']() {
      let template = "hit dem folks";
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        foo: true,
        classNameBindings: ['foo:is-foo:is-bar']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      expectAssertion(() => {
        this.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot use `classNameBindings` on a tag-less component/);
    }
    ['@test throws an error if `tagName` is an empty string and `attributeBindings` are specified']() {
      let template = "hit dem folks";
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        attributeBindings: ['href']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      expectAssertion(() => {
        this.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot use `attributeBindings` on a tag-less component/);
    }
    ['@test throws an error if `tagName` is an empty string and `elementId` is specified via JS']() {
      let template = "hit dem folks";
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        elementId: 'turntUp'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      expectAssertion(() => {
        this.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot use `elementId` on a tag-less component/);
    }
    ['@test throws an error if `tagName` is an empty string and `elementId` is specified via template']() {
      let template = "hit dem folks";
      let FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      expectAssertion(() => {
        this.render("{{#foo-bar elementId='turntUp'}}{{/foo-bar}}");
      }, /You cannot use `elementId` on a tag-less component/);
    }
    ['@test does not throw an error if `tagName` is an empty string and `id` is specified via JS']() {
      let template = "{{this.id}}";
      let FooBarComponent = _helpers.Component.extend({
        tagName: '',
        id: 'baz'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      this.render("{{#foo-bar}}{{/foo-bar}}");
      this.assertText('baz');
    }
    ['@test does not throw an error if `tagName` is an empty string and `id` is specified via template']() {
      let template = "{{this.id}}";
      let FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      this.render("{{#foo-bar id='baz'}}{{/foo-bar}}");
      this.assertText('baz');
    }
    ['@test does not throw an error if `tagName` is an empty string and `id` is bound property specified via template']() {
      let template = "{{this.id}}";
      let FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template
      });
      this.render("{{#foo-bar id=this.fooBarId}}{{/foo-bar}}", {
        fooBarId: 'baz'
      });
      this.assertText('baz');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBarId', 'qux'));
      this.assertText('qux');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBarId', 'baz'));
      this.assertText('baz');
    }
    ['@test does not throw an error if `tagName` is an empty string and `id` is specified via template and passed to child component']() {
      let fooBarTemplate = "{{#baz-child id=this.id}}{{/baz-child}}";
      let FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });
      let BazChildComponent = _helpers.Component.extend();
      let bazChildTemplate = "{{this.id}}";
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: fooBarTemplate
      });
      this.registerComponent('baz-child', {
        ComponentClass: BazChildComponent,
        template: bazChildTemplate
      });
      this.render("{{#foo-bar id='baz'}}{{/foo-bar}}");
      this.assertText('baz');
    }
    ['@test renders a contained view with omitted start tag and tagless parent view context']() {
      this.registerComponent('root-component', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'section'
        }),
        template: '{{frag-ment}}'
      });
      this.registerComponent('frag-ment', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{my-span}}'
      });
      this.registerComponent('my-span', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'span'
        }),
        template: 'dab'
      });
      this.render("{{root-component}}");
      this.assertElement(this.firstChild, {
        tagName: 'section'
      });
      this.assertElement(this.firstChild.firstElementChild, {
        tagName: 'span'
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'section'
      });
      this.assertElement(this.firstChild.firstElementChild, {
        tagName: 'span'
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/input-angle-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  class InputRenderingTest extends _internalTestHelpers.RenderingTestCase {
    $input() {
      return this.$('input');
    }
    inputID() {
      return this.$input().prop('id');
    }
    assertDisabled() {
      this.assert.ok(this.$('input').prop('disabled'), 'The input is disabled');
    }
    assertNotDisabled() {
      this.assert.ok(this.$('input').is(':not(:disabled)'), 'The input is not disabled');
    }
    assertInputId(expectedId) {
      this.assert.equal(this.inputID(), expectedId, 'the input id should be `expectedId`');
    }
    assertSingleInput() {
      this.assert.equal(this.$('input').length, 1, 'A single text field was inserted');
    }
    assertSingleCheckbox() {
      this.assert.equal(this.$('input[type=checkbox]').length, 1, 'A single checkbox is added');
    }
    assertCheckboxIsChecked() {
      this.assert.equal(this.$input().prop('checked'), true, 'the checkbox is checked');
    }
    assertCheckboxIsNotChecked() {
      this.assert.equal(this.$input().prop('checked'), false, 'the checkbox is not checked');
    }
    assertValue(expected) {
      this.assert.equal(this.$input().val(), expected, "the input value should be " + expected);
    }
    assertAttr(name, expected) {
      this.assert.equal(this.$input().attr(name), expected, "the input " + name + " attribute has the value '" + expected + "'");
    }
    assertAllAttrs(names, expected) {
      names.forEach(name => this.assertAttr(name, expected));
    }
    assertSelectionRange(start, end) {
      let input = this.$input()[0];
      this.assert.equal(input.selectionStart, start, "the cursor start position should be " + start);
      this.assert.equal(input.selectionEnd, end, "the cursor end position should be " + end);
    }
    triggerEvent(type, options, selector) {
      let event = document.createEvent('Events');
      event.initEvent(type, true, true);
      Object.assign(event, options);
      let element = this.$(selector || 'input')[0];
      (0, _internalTestHelpers.runTask)(() => {
        element.dispatchEvent(event);
      });
    }
  }
  (0, _internalTestHelpers.moduleFor)('Components test: <Input />', class extends InputRenderingTest {
    ['@test a single text field is inserted into the DOM']() {
      this.render("<Input @type=\"text\" @value={{this.value}} />", {
        value: 'hello'
      });
      let id = this.inputID();
      this.assertValue('hello');
      this.assertSingleInput();
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'goodbye'));
      this.assertValue('goodbye');
      this.assertSingleInput();
      this.assertInputId(id);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
    }
    ['@test default type']() {
      this.render("<Input />");
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttr('type', 'text');
    }
    ['@test dynamic attributes (HTML attribute)']() {
      this.render("\n      <Input @type=\"text\" @value={{this.value}}\n        role={{this.role}}\n        disabled={{this.disabled}}\n        placeholder={{this.placeholder}}\n        name={{this.name}}\n        maxlength={{this.maxlength}}\n        minlength={{this.minlength}}\n        size={{this.size}}\n        tabindex={{this.tabindex}}\n      />", {
        value: 'Original value',
        role: 'textbox',
        disabled: false,
        placeholder: 'Original placeholder',
        name: 'original-name',
        maxlength: 10,
        minlength: 5,
        size: 20,
        tabindex: 30
      });
      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('role', 'textbox');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5');
      // this.assertAttr('size', '20'); //NOTE: failing in IE  (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('role', 'textbox');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5');
      // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'value', 'Updated value');
        (0, _object.set)(this.context, 'role', 'search');
        (0, _object.set)(this.context, 'disabled', true);
        (0, _object.set)(this.context, 'placeholder', 'Updated placeholder');
        (0, _object.set)(this.context, 'name', 'updated-name');
        (0, _object.set)(this.context, 'maxlength', 11);
        (0, _object.set)(this.context, 'minlength', 6);
        // set(this.context, 'size', 21); //NOTE: failing in IE (TEST_SUITE=sauce)
        // set(this.context, 'tabindex', 31); //NOTE: failing in IE (TEST_SUITE=sauce)
      });

      this.assertDisabled();
      this.assertValue('Updated value');
      this.assertAttr('role', 'search');
      this.assertAttr('placeholder', 'Updated placeholder');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('maxlength', '11');
      this.assertAttr('minlength', '6');
      // this.assertAttr('size', '21'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '31'); //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'value', 'Original value');
        (0, _object.set)(this.context, 'role', 'textbox');
        (0, _object.set)(this.context, 'disabled', false);
        (0, _object.set)(this.context, 'placeholder', 'Original placeholder');
        (0, _object.set)(this.context, 'name', 'original-name');
        (0, _object.set)(this.context, 'maxlength', 10);
        (0, _object.set)(this.context, 'minlength', 5);
        // set(this.context, 'size', 20); //NOTE: failing in IE (TEST_SUITE=sauce)
        // set(this.context, 'tabindex', 30); //NOTE: failing in IE (TEST_SUITE=sauce)
      });

      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('role', 'textbox');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5');
      // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)
    }

    ['@test static attributes (HTML attribute)']() {
      this.render("\n      <Input @type=\"text\" @value=\"Original value\"\n        id=\"test-input\"\n        role=\"search\"\n        disabled=\"disabled\"\n        placeholder=\"Original placeholder\"\n        name=\"original-name\"\n        maxlength=\"10\"\n        minlength=\"5\"\n        size=\"20\"\n        tabindex=\"30\"\n      />");
      this.assertDisabled();
      this.assertValue('Original value');
      this.assertAttr('id', 'test-input');
      this.assertAttr('role', 'search');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5');
      // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertDisabled();
      this.assertValue('Original value');
      this.assertAttr('id', 'test-input');
      this.assertAttr('role', 'search');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5');
      // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)
    }

    ['@test cursor selection range']() {
      // Modifying input.selectionStart, which is utilized in the cursor tests,
      // causes an event in Safari.
      (0, _internalTestHelpers.runDestroy)(this.owner.lookup('event_dispatcher:main'));
      this.render("<Input @type=\"text\" @value={{this.value}} />", {
        value: 'original'
      });
      let input = this.$input()[0];

      // See https://ember-twiddle.com/33e506329f8176ae874422644d4cc08c?openFiles=components.input-component.js%2Ctemplates.components.input-component.hbs
      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => this.rerender());

      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => {
        input.selectionStart = 2;
        input.selectionEnd = 4;
      });
      this.assertSelectionRange(2, 4);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertSelectionRange(2, 4);

      // runTask(() => set(this.context, 'value', 'updated'));
      //
      // this.assertSelectionRange(7, 7); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
      //
      // runTask(() => set(this.context, 'value', 'original'));
      //
      // this.assertSelectionRange(8, 8); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
    }

    ['@test sends an action with `<Input @enter={{action "foo"}} />` when <enter> is pressed'](assert) {
      assert.expect(2);
      this.render("<Input @enter={{action 'foo'}} />", {
        actions: {
          foo(value, event) {
            assert.ok(true, 'action was triggered');
            assert.ok(event instanceof Event, 'Native event was passed');
          }
        }
      });
      this.triggerEvent('keyup', {
        key: 'Enter'
      });
    }
    ['@test sends `insert-newline` when <enter> is pressed'](assert) {
      assert.expect(2);
      this.render("<Input @insert-newline={{action 'foo'}} />", {
        actions: {
          foo(value, event) {
            assert.ok(true, 'action was triggered');
            assert.ok(event instanceof Event, 'Native event was passed');
          }
        }
      });
      this.triggerEvent('keyup', {
        key: 'Enter'
      });
    }
    ['@test sends an action with `<Input @escape-press={{action "foo"}} />` when <escape> is pressed'](assert) {
      assert.expect(2);
      this.render("<Input @escape-press={{action 'foo'}} />", {
        actions: {
          foo(value, event) {
            assert.ok(true, 'action was triggered');
            assert.ok(event instanceof Event, 'Native event was passed');
          }
        }
      });
      this.triggerEvent('keyup', {
        key: 'Escape'
      });
    }
    ['@test GH#14727 can render a file input after having had render an input of other type']() {
      this.render("<Input @type=\"text\" /><Input @type=\"file\" />");
      this.assert.equal(this.$input()[0].type, 'text');
      this.assert.equal(this.$input()[1].type, 'file');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Components test: <Input /> with dynamic type', class extends InputRenderingTest {
    ['@test a bound property can be used to determine type']() {
      this.render("<Input @type={{this.type}} />", {
        type: 'password'
      });
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'type', 'text'));
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'type', 'password'));
      this.assertAttr('type', 'password');
    }
    ['@test a subexpression can be used to determine type']() {
      this.render("<Input @type={{if this.isTruthy this.trueType this.falseType}} />", {
        isTruthy: true,
        trueType: 'text',
        falseType: 'password'
      });
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isTruthy', false));
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isTruthy', true));
      this.assertAttr('type', 'text');
    }
    ['@test GH16256 input macro does not modify params in place']() {
      this.registerComponent('my-input', {
        template: "<Input @type={{this.inputType}} />"
      });
      this.render("<MyInput @inputType={{this.firstType}} /><MyInput @inputType={{this.secondType}} />", {
        firstType: 'password',
        secondType: 'email'
      });
      let inputs = this.element.querySelectorAll('input');
      this.assert.equal(inputs.length, 2, 'there are two inputs');
      this.assert.equal(inputs[0].getAttribute('type'), 'password');
      this.assert.equal(inputs[1].getAttribute('type'), 'email');
    }
  });
  (0, _internalTestHelpers.moduleFor)("Components test: <Input @type='checkbox' />", class extends InputRenderingTest {
    ['@test dynamic attributes (HTML attribute)']() {
      this.render("<Input @type='checkbox' @checked={{this.checked}}\n          role={{this.role}}\n          disabled={{this.disabled}}\n          name={{this.name}}\n          tabindex={{this.tabindex}}\n        />", {
        role: 'checkbox',
        disabled: false,
        name: 'original-name',
        checked: false,
        tabindex: 10
      });
      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('role', 'checkbox');
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('role', 'checkbox');
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'role', 'radio');
        (0, _object.set)(this.context, 'disabled', true);
        (0, _object.set)(this.context, 'name', 'updated-name');
        (0, _object.set)(this.context, 'tabindex', 11);
      });
      this.assertSingleCheckbox();
      this.assertDisabled();
      this.assertAttr('role', 'radio');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('tabindex', '11');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'role', 'checkbox');
        (0, _object.set)(this.context, 'disabled', false);
        (0, _object.set)(this.context, 'name', 'original-name');
        (0, _object.set)(this.context, 'tabindex', 10);
      });
      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('role', 'checkbox');
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
    }
    ['`value` property warning']() {
      let message = '`<Input @type="checkbox" />` reflects its checked state via the `@checked` argument. ' + 'You wrote `<Input @type="checkbox" @value={{...}} />` which is likely not what you intended. ' + 'Did you mean `<Input @type="checkbox" @checked={{...}} />`?';
      expectWarning(() => {
        this.render("<Input @type=\"checkbox\" @value={{this.value}} />", {
          value: true
        });
      }, message);
      this.assert.strictEqual(this.context.value, true);
      this.assertCheckboxIsNotChecked();
      expectWarning(() => this.$input()[0].click(), message);
      this.assert.strictEqual(this.context.value, true);
      this.assertCheckboxIsChecked();
    }
    ['@test with a bound type']() {
      this.render("<Input @type={{this.inputType}} @checked={{this.isChecked}} />", {
        inputType: 'checkbox',
        isChecked: true
      });
      this.assertSingleCheckbox();
      this.assertCheckboxIsChecked();
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertCheckboxIsChecked();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isChecked', false));
      this.assertCheckboxIsNotChecked();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isChecked', true));
      this.assertCheckboxIsChecked();
    }
    ['@test native click changes check property']() {
      this.render("<Input @type=\"checkbox\" />");
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.$input()[0].click();
      this.assertCheckboxIsChecked();
      this.$input()[0].click();
      this.assertCheckboxIsNotChecked();
    }
    ['@test with static values (HTML attribute)']() {
      this.render("<Input @type=\"checkbox\" @checked={{false}} role=\"radio\" disabled={{false}} tabindex=\"10\" name=\"original-name\" />");
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.assertNotDisabled();
      this.assertAttr('role', 'radio');
      this.assertAttr('tabindex', '10');
      this.assertAttr('name', 'original-name');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.assertNotDisabled();
      this.assertAttr('tabindex', '10');
      this.assertAttr('name', 'original-name');
    }
  });
  (0, _internalTestHelpers.moduleFor)("Components test: <Input @type='text' />", class extends InputRenderingTest {
    ['@test null values (HTML attribute)']() {
      let attributes = ['role', 'disabled', 'placeholder', 'name', 'maxlength', 'size', 'tabindex'];
      this.render("\n      <Input @type=\"text\" @value={{this.value}}\n        role={{this.role}}\n        disabled={{this.disabled}}\n        placeholder={{this.placeholder}}\n        name={{this.name}}\n        maxlength={{this.maxlength}}\n        size={{this.size}}\n        tabindex={{this.tabindex}}\n      />", {
        value: null,
        role: null,
        disabled: null,
        placeholder: null,
        name: null,
        maxlength: null,
        size: null,
        tabindex: null
      });
      this.assertValue('');
      this.assertAllAttrs(attributes, undefined);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertValue('');
      this.assertAllAttrs(attributes, undefined);
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'role', 'search');
        (0, _object.set)(this.context, 'disabled', true);
        (0, _object.set)(this.context, 'value', 'Updated value');
        (0, _object.set)(this.context, 'placeholder', 'Updated placeholder');
        (0, _object.set)(this.context, 'name', 'updated-name');
        (0, _object.set)(this.context, 'maxlength', 11);
        (0, _object.set)(this.context, 'size', 21);
        (0, _object.set)(this.context, 'tabindex', 31);
      });
      this.assertDisabled();
      this.assertValue('Updated value');
      this.assertAttr('role', 'search');
      this.assertAttr('placeholder', 'Updated placeholder');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('maxlength', '11');
      this.assertAttr('size', '21');
      this.assertAttr('tabindex', '31');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'role', null);
        (0, _object.set)(this.context, 'disabled', null);
        (0, _object.set)(this.context, 'value', null);
        (0, _object.set)(this.context, 'placeholder', null);
        (0, _object.set)(this.context, 'name', null);
        (0, _object.set)(this.context, 'maxlength', null);
        // set(this.context, 'size', null); //NOTE: this fails with `Error: Failed to set the 'size' property on 'HTMLInputElement': The value provided is 0, which is an invalid size.` (TEST_SUITE=sauce)
        (0, _object.set)(this.context, 'tabindex', null);
      });
      this.assertAttr('disabled', undefined);
      this.assertValue('');
      this.assertAttr('role', undefined);
      // this.assertAttr('placeholder', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
      // this.assertAttr('name', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
      this.assertAttr('maxlength', undefined);
      // this.assertAttr('size', undefined); //NOTE: re-enable once `size` bug above has been addressed
      this.assertAttr('tabindex', undefined);
    }
  });
  function InputAttributesTest(attrs) {
    return class extends InputRenderingTest {
      renderInput(value) {
        if (value === void 0) {
          value = 25;
        }
        this.render("<Input " + attrs.replace('%x', value) + " />");
      }
      ['@test value over default max but below set max is kept']() {
        this.renderInput('25');
        this.assertValue('25');
      }
      ['@test value below default min but above set min is kept']() {
        this.renderInput('-2');
        this.assertValue('-2');
      }
      ['@test in the valid default range is kept']() {
        this.renderInput('5');
        this.assertValue('5');
      }
      ['@test value above max is reset to max']() {
        this.renderInput('55');
        this.assertValue('50');
      }
      ['@test value below min is reset to min']() {
        this.renderInput('-10');
        this.assertValue('-5');
      }
    };
  }

  // These are the permutations of the set:
  // ['type="range"', 'min="-5" max="50"', value="%x"']
  [
  // HTML attribute
  '@type="range" min="-5" max="50" @value="%x"', '@type="range" @value="%x" min="-5" max="50"', 'min="-5" max="50" @type="range" @value="%x"', 'min="-5" max="50" @value="%x" @type="range"', '@value="%x" min="-5" max="50" @type="range"', '@value="%x" @type="range" min="-5" max="50"'].forEach(attrs => {
    (0, _internalTestHelpers.moduleFor)("[GH#15675] Components test: <Input " + attrs + " />", InputAttributesTest(attrs));
  });
});
define("@ember/-internals/glimmer/tests/integration/components/input-curly-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  class InputRenderingTest extends _internalTestHelpers.RenderingTestCase {
    $input() {
      return this.$('input');
    }
    inputID() {
      return this.$input().prop('id');
    }
    assertDisabled() {
      this.assert.ok(this.$('input').prop('disabled'), 'The input is disabled');
    }
    assertNotDisabled() {
      this.assert.ok(this.$('input').is(':not(:disabled)'), 'The input is not disabled');
    }
    assertInputId(expectedId) {
      this.assert.equal(this.inputID(), expectedId, 'the input id should be `expectedId`');
    }
    assertSingleInput() {
      this.assert.equal(this.$('input').length, 1, 'A single text field was inserted');
    }
    assertSingleCheckbox() {
      this.assert.equal(this.$('input[type=checkbox]').length, 1, 'A single checkbox is added');
    }
    assertCheckboxIsChecked() {
      this.assert.equal(this.$input().prop('checked'), true, 'the checkbox is checked');
    }
    assertCheckboxIsNotChecked() {
      this.assert.equal(this.$input().prop('checked'), false, 'the checkbox is not checked');
    }
    assertValue(expected) {
      this.assert.equal(this.$input().val(), expected, "the input value should be " + expected);
    }
    assertAttr(name, expected) {
      this.assert.equal(this.$input().attr(name), expected, "the input " + name + " attribute has the value '" + expected + "'");
    }
    assertAllAttrs(names, expected) {
      names.forEach(name => this.assertAttr(name, expected));
    }
    assertSelectionRange(start, end) {
      let input = this.$input()[0];
      this.assert.equal(input.selectionStart, start, "the cursor start position should be " + start);
      this.assert.equal(input.selectionEnd, end, "the cursor end position should be " + end);
    }
    triggerEvent(type, options) {
      let event = document.createEvent('Events');
      event.initEvent(type, true, true);
      Object.assign(event, options);
      let element = this.$input()[0];
      (0, _internalTestHelpers.runTask)(() => {
        element.dispatchEvent(event);
      });
    }
  }
  (0, _internalTestHelpers.moduleFor)('Components test: {{input}}', class extends InputRenderingTest {
    ['@test a single text field is inserted into the DOM']() {
      this.render("{{input type=\"text\" value=this.value}}", {
        value: 'hello'
      });
      let id = this.inputID();
      this.assertValue('hello');
      this.assertSingleInput();
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'goodbye'));
      this.assertValue('goodbye');
      this.assertSingleInput();
      this.assertInputId(id);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
    }
    ['@test default type']() {
      this.render("{{input}}");
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttr('type', 'text');
    }
    ['@test cursor selection range']() {
      // Modifying input.selectionStart, which is utilized in the cursor tests,
      // causes an event in Safari.
      (0, _internalTestHelpers.runDestroy)(this.owner.lookup('event_dispatcher:main'));
      this.render("{{input type=\"text\" value=this.value}}", {
        value: 'original'
      });
      let input = this.$input()[0];

      // See https://ember-twiddle.com/33e506329f8176ae874422644d4cc08c?openFiles=components.input-component.js%2Ctemplates.components.input-component.hbs
      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => this.rerender());

      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(() => {
        input.selectionStart = 2;
        input.selectionEnd = 4;
      });
      this.assertSelectionRange(2, 4);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertSelectionRange(2, 4);

      // runTask(() => set(this.context, 'value', 'updated'));
      //
      // this.assertSelectionRange(7, 7); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
      //
      // runTask(() => set(this.context, 'value', 'original'));
      //
      // this.assertSelectionRange(8, 8); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
    }

    ['@test sends an action with `{{input enter=(action "foo")}}` when <enter> is pressed'](assert) {
      assert.expect(2);
      this.render("{{input enter=(action 'foo')}}", {
        actions: {
          foo(value, event) {
            assert.ok(true, 'action was triggered');
            assert.ok(event instanceof Event, 'Native event was passed');
          }
        }
      });
      this.triggerEvent('keyup', {
        key: 'Enter'
      });
    }
    ['@test sends `insert-newline` when <enter> is pressed'](assert) {
      assert.expect(2);
      this.render("{{input insert-newline=(action 'foo')}}", {
        actions: {
          foo(value, event) {
            assert.ok(true, 'action was triggered');
            assert.ok(event instanceof Event, 'Native event was passed');
          }
        }
      });
      this.triggerEvent('keyup', {
        key: 'Enter'
      });
    }
    ['@test sends an action with `{{input escape-press=(action "foo")}}` when <escape> is pressed'](assert) {
      assert.expect(2);
      this.render("{{input escape-press=(action 'foo')}}", {
        actions: {
          foo(value, event) {
            assert.ok(true, 'action was triggered');
            assert.ok(event instanceof Event, 'Native event was passed');
          }
        }
      });
      this.triggerEvent('keyup', {
        key: 'Escape'
      });
    }
    ['@test GH#14727 can render a file input after having had render an input of other type']() {
      this.render("{{input type=\"text\"}}{{input type=\"file\"}}");
      this.assert.equal(this.$input()[0].type, 'text');
      this.assert.equal(this.$input()[1].type, 'file');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Components test: {{input}} with dynamic type', class extends InputRenderingTest {
    ['@test a bound property can be used to determine type']() {
      this.render("{{input type=this.type}}", {
        type: 'password'
      });
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'type', 'text'));
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'type', 'password'));
      this.assertAttr('type', 'password');
    }
    ['@test a subexpression can be used to determine type']() {
      this.render("{{input type=(if this.isTruthy this.trueType this.falseType)}}", {
        isTruthy: true,
        trueType: 'text',
        falseType: 'password'
      });
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isTruthy', false));
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isTruthy', true));
      this.assertAttr('type', 'text');
    }
    ['@test GH16256 input macro does not modify params in place']() {
      this.registerComponent('my-input', {
        template: "{{input type=this.inputType}}"
      });
      this.render("{{my-input inputType=this.firstType}}{{my-input inputType=this.secondType}}", {
        firstType: 'password',
        secondType: 'email'
      });
      let inputs = this.element.querySelectorAll('input');
      this.assert.equal(inputs.length, 2, 'there are two inputs');
      this.assert.equal(inputs[0].getAttribute('type'), 'password');
      this.assert.equal(inputs[1].getAttribute('type'), 'email');
    }
  });
  (0, _internalTestHelpers.moduleFor)("Components test: {{input type='checkbox'}}", class extends InputRenderingTest {
    ['`value` property warning']() {
      let message = '`<Input @type="checkbox" />` reflects its checked state via the `@checked` argument. ' + 'You wrote `<Input @type="checkbox" @value={{...}} />` which is likely not what you intended. ' + 'Did you mean `<Input @type="checkbox" @checked={{...}} />`?';
      expectWarning(() => {
        this.render("{{input type=\"checkbox\" value=this.value}}", {
          value: true
        });
      }, message);
      this.assert.strictEqual(this.context.value, true);
      this.assertCheckboxIsNotChecked();
      expectWarning(() => this.$input()[0].click(), message);
      this.assert.strictEqual(this.context.value, true);
      this.assertCheckboxIsChecked();
    }
    ['@test with a bound type']() {
      this.render("{{input type=this.inputType checked=this.isChecked}}", {
        inputType: 'checkbox',
        isChecked: true
      });
      this.assertSingleCheckbox();
      this.assertCheckboxIsChecked();
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertCheckboxIsChecked();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isChecked', false));
      this.assertCheckboxIsNotChecked();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isChecked', true));
      this.assertCheckboxIsChecked();
    }
    ['@test native click changes check property']() {
      this.render("{{input type=\"checkbox\"}}");
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.$input()[0].click();
      this.assertCheckboxIsChecked();
      this.$input()[0].click();
      this.assertCheckboxIsNotChecked();
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/instrumentation-compile-test", ["internal-test-helpers", "@ember/instrumentation", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _instrumentation, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components compile instrumentation', class extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      this.resetEvents();
      (0, _instrumentation.subscribe)('render.getComponentDefinition', {
        before: (name, timestamp, payload) => {
          if (payload.view !== this.component) {
            this.actual.before.push(payload);
          }
        },
        after: (name, timestamp, payload) => {
          if (payload.view !== this.component) {
            this.actual.after.push(payload);
          }
        }
      });
    }
    resetEvents() {
      this.expected = {
        before: [],
        after: []
      };
      this.actual = {
        before: [],
        after: []
      };
    }
    teardown() {
      this.assert.deepEqual(this.actual.before, [], 'No unexpected events (before)');
      this.assert.deepEqual(this.actual.after, [], 'No unexpected events (after)');
      super.teardown();
      (0, _instrumentation.reset)();
    }
    ['@test it should only receive an instrumentation event for initial render']() {
      let testCase = this;
      let BaseClass = _helpers.Component.extend({
        tagName: '',
        willRender() {
          testCase.expected.before.push(this);
          testCase.expected.after.unshift(this);
        }
      });
      this.registerComponent('x-bar', {
        template: '[x-bar: {{this.bar}}]',
        ComponentClass: BaseClass.extend()
      });
      this.render("[-top-level: {{this.foo}}] {{x-bar bar=this.bar}}", {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertText('[-top-level: foo] [x-bar: bar]');
      this.assertEvents('after initial render');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertEvents('after no-op rerender');
    }
    assertEvents(label) {
      let {
        actual,
        expected
      } = this;
      this.assert.strictEqual(actual.before.length, actual.after.length, label + ": before and after callbacks should be balanced");
      this._assertEvents(label + " (before):", actual.before, expected.before);
      this._assertEvents(label + " (after):", actual.before, expected.before);
      this.resetEvents();
    }
    _assertEvents(label, actual, expected) {
      this.assert.equal(actual.length, expected.length, label + ": expected " + expected.length + " and got " + actual.length);
      actual.forEach((payload, i) => this.assertPayload(payload, expected[i]));
    }
    assertPayload(payload, component) {
      this.assert.equal(payload.object, component._debugContainerKey, 'payload.object');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/instrumentation-test", ["internal-test-helpers", "@ember/object", "@ember/instrumentation", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _instrumentation, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components instrumentation', class extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      this.resetEvents();
      (0, _instrumentation.subscribe)('render.component', {
        before: (name, timestamp, payload) => {
          if (payload.view !== this.component) {
            this.actual.before.push(payload);
          }
        },
        after: (name, timestamp, payload) => {
          if (payload.view !== this.component) {
            this.actual.after.push(payload);
          }
        }
      });
    }
    resetEvents() {
      this.expected = {
        before: [],
        after: []
      };
      this.actual = {
        before: [],
        after: []
      };
    }
    teardown() {
      this.assert.deepEqual(this.actual.before, [], 'No unexpected events (before)');
      this.assert.deepEqual(this.actual.after, [], 'No unexpected events (after)');
      super.teardown();
      (0, _instrumentation.reset)();
    }
    ['@test zomg'](assert) {
      assert.ok(true);
    }
    ['@test it should receive an instrumentation event for both initial render and updates']() {
      let testCase = this;
      let BaseClass = _helpers.Component.extend({
        tagName: '',
        willRender() {
          testCase.expected.before.push(this);
          testCase.expected.after.unshift(this);
        }
      });
      this.registerComponent('x-bar', {
        template: '[x-bar: {{this.bar}}] {{yield}}',
        ComponentClass: BaseClass.extend()
      });
      this.registerComponent('x-baz', {
        template: '[x-baz: {{this.baz}}]',
        ComponentClass: BaseClass.extend()
      });
      this.registerComponent('x-bat', {
        template: '[x-bat: {{this.bat}}]',
        ComponentClass: BaseClass.extend()
      });
      this.render("[-top-level: {{this.foo}}] {{#x-bar bar=this.bar}}{{x-baz baz=this.baz}}{{/x-bar}} {{x-bat bat=this.bat}}", {
        foo: 'foo',
        bar: 'bar',
        baz: 'baz',
        bat: 'bat'
      });
      this.assertText('[-top-level: foo] [x-bar: bar] [x-baz: baz] [x-bat: bat]');
      this.assertEvents('after initial render', true);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertEvents('after no-op rerender');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'FOO'));
      this.assertEvents('after updating top-level');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'baz', 'BAZ'));
      this.assertEvents('after updating inner-most');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'bar', 'BAR');
        (0, _object.set)(this.context, 'bat', 'BAT');
      });
      this.assertEvents('after updating the rest');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'FOO');
        (0, _object.set)(this.context, 'bar', 'BAR');
        (0, _object.set)(this.context, 'baz', 'BAZ');
        (0, _object.set)(this.context, 'bat', 'BAT');
      });
      this.assertEvents('after reset');
    }
    assertEvents(label, initialRender) {
      if (initialRender === void 0) {
        initialRender = false;
      }
      let {
        actual,
        expected
      } = this;
      this.assert.strictEqual(actual.before.length, actual.after.length, label + ": before and after callbacks should be balanced");
      this._assertEvents(label + " (before):", actual.before, expected.before, initialRender);
      this._assertEvents(label + " (after):", actual.before, expected.before, initialRender);
      this.resetEvents();
    }
    _assertEvents(label, actual, expected, initialRender) {
      this.assert.equal(actual.length, expected.length, label + ": expected " + expected.length + " and got " + actual.length);
      actual.forEach((payload, i) => this.assertPayload(payload, expected[i], initialRender));
    }
    assertPayload(payload, component, initialRender) {
      this.assert.equal(payload.object, component.toString(), 'payload.object');
      this.assert.ok(payload.containerKey, 'the container key should be present');
      this.assert.equal(payload.containerKey, component._debugContainerKey, 'payload.containerKey');
      this.assert.equal(payload.view, component, 'payload.view');
      this.assert.strictEqual(payload.initialRender, initialRender, 'payload.initialRender');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/life-cycle-test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/object", "@ember/array", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _runloop, _object, _array, _views, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;
  class LifeCycleHooksTest extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      this.hooks = [];
      this.components = {};
      this.componentRegistry = [];
      this.teardownAssertions = [];
      this.viewRegistry = this.owner.lookup('-view-registry:main');
    }
    afterEach() {
      super.afterEach();
      for (let i = 0; i < this.teardownAssertions.length; i++) {
        this.teardownAssertions[i]();
      }
    }
    get isInteractive() {
      return true;
    }
    getBootOptions() {
      return {
        isInteractive: this.isInteractive
      };
    }

    /* abstract */
    get ComponentClass() {
      throw new Error('Not implemented: `ComponentClass`');
    }

    /* abstract */
    invocationFor( /* name, namedArgs = {} */
    ) {
      throw new Error('Not implemented: `invocationFor`');
    }

    /* abstract */
    attrFor( /* name */
    ) {
      throw new Error('Not implemented: `attrFor`');
    }
    get boundHelpers() {
      return {
        invoke: bind(this.invocationFor, this),
        attr: bind(this.attrFor, this)
      };
    }
    assertRegisteredViews(label) {
      let viewRegistry = this.viewRegistry;
      let topLevelId = (0, _views.getViewId)(this.component);
      let actual = Object.keys(viewRegistry).sort().filter(id => id !== topLevelId);
      if (this.isInteractive) {
        let expected = this.componentRegistry.sort();
        this.assert.deepEqual(actual, expected, 'registered views - ' + label);
      } else {
        this.assert.deepEqual(actual, [], 'no views should be registered for non-interactive mode');
      }
    }
    registerComponent(name, _ref) {
      var _this = this;
      let {
        template = null
      } = _ref;
      let pushComponent = instance => {
        this.components[name] = instance;
        this.componentRegistry.push((0, _views.getViewId)(instance));
      };
      let removeComponent = instance => {
        let index = this.componentRegistry.indexOf((0, _views.getViewId)(instance));
        this.componentRegistry.splice(index, 1);
        delete this.components[name];
      };
      let pushHook = (hookName, args) => {
        this.hooks.push(hook(name, hookName, args));
      };
      let assertParentView = (hookName, instance) => {
        this.assert.ok(instance.parentView, "parentView should be present in " + hookName);
        if (hookName === 'willDestroyElement') {
          this.assert.ok(instance.parentView.childViews.indexOf(instance) !== -1, "view is still connected to parentView in " + hookName);
        }
      };
      let assertElement = function (hookName, instance, inDOM) {
        if (inDOM === void 0) {
          inDOM = true;
        }
        if (instance.tagName === '') {
          return;
        }
        _this.assert.ok((0, _views.getViewElement)(instance), "element should be present on " + instance + " during " + hookName);
        if (_this.isInteractive) {
          _this.assert.ok(instance.element, "this.element should be present on " + instance + " during " + hookName);
          _this.assert.equal(document.body.contains(instance.element), inDOM, "element for " + instance + " " + (inDOM ? 'should' : 'should not') + " be in the DOM during " + hookName);
        } else {
          _this.assert.throws(() => instance.element, /Accessing `this.element` is not allowed in non-interactive environments/);
        }
      };
      let assertNoElement = (hookName, instance) => {
        this.assert.strictEqual((0, _views.getViewElement)(instance), null, "element should not be present in " + hookName);
        if (this.isInteractive) {
          this.assert.strictEqual(instance.element, null, "this.element should not be present in " + hookName);
        } else {
          this.assert.throws(() => instance.element, /Accessing `this.element` is not allowed in non-interactive environments/);
        }
      };
      let assertState = (hookName, expectedState, instance) => {
        this.assert.equal(instance._state, expectedState, "within " + hookName + " the expected _state is " + expectedState);
      };
      let {
        isInteractive
      } = this;
      let ComponentClass = this.ComponentClass.extend({
        init() {
          this._super(...arguments);
          this.isInitialRender = true;
          this.componentName = name;
          pushHook('init');
          pushComponent(this);
          assertParentView('init', this);
          assertNoElement('init', this);
          assertState('init', 'preRender', this);
          this.on('init', () => pushHook('on(init)'));
          (0, _runloop.schedule)('afterRender', () => {
            this.isInitialRender = false;
          });
        },
        didReceiveAttrs(options) {
          pushHook('didReceiveAttrs', options);
          assertParentView('didReceiveAttrs', this);
          if (this.isInitialRender) {
            assertNoElement('didReceiveAttrs', this);
            assertState('didReceiveAttrs', 'preRender', this);
          } else {
            assertElement('didReceiveAttrs', this);
            if (isInteractive) {
              assertState('didReceiveAttrs', 'inDOM', this);
            } else {
              assertState('didReceiveAttrs', 'hasElement', this);
            }
          }
        },
        willInsertElement() {
          pushHook('willInsertElement');
          assertParentView('willInsertElement', this);
          assertElement('willInsertElement', this, false);
          assertState('willInsertElement', 'hasElement', this);
        },
        willRender() {
          pushHook('willRender');
          assertParentView('willRender', this);
          if (this.isInitialRender) {
            assertNoElement('willRender', this, false);
            assertState('willRender', 'preRender', this);
          } else {
            assertElement('willRender', this);
            assertState('willRender', 'inDOM', this);
          }
        },
        didInsertElement() {
          pushHook('didInsertElement');
          assertParentView('didInsertElement', this);
          assertElement('didInsertElement', this);
          assertState('didInsertElement', 'inDOM', this);
        },
        didRender() {
          pushHook('didRender');
          assertParentView('didRender', this);
          assertElement('didRender', this);
          assertState('didRender', 'inDOM', this);
        },
        didUpdateAttrs(options) {
          pushHook('didUpdateAttrs', options);
          assertParentView('didUpdateAttrs', this);
          if (isInteractive) {
            assertState('didUpdateAttrs', 'inDOM', this);
          } else {
            assertState('didUpdateAttrs', 'hasElement', this);
          }
        },
        willUpdate(options) {
          pushHook('willUpdate', options);
          assertParentView('willUpdate', this);
          assertElement('willUpdate', this);
          assertState('willUpdate', 'inDOM', this);
        },
        didUpdate(options) {
          pushHook('didUpdate', options);
          assertParentView('didUpdate', this);
          assertElement('didUpdate', this);
          assertState('didUpdate', 'inDOM', this);
        },
        willDestroyElement() {
          pushHook('willDestroyElement');
          assertParentView('willDestroyElement', this);
          assertElement('willDestroyElement', this);
          assertState('willDestroyElement', 'inDOM', this);
        },
        willClearRender() {
          pushHook('willClearRender');
          assertParentView('willClearRender', this);
          assertElement('willClearRender', this);
          assertState('willClearRender', 'inDOM', this);
        },
        didDestroyElement() {
          pushHook('didDestroyElement');
          assertNoElement('didDestroyElement', this);
          assertState('didDestroyElement', 'destroying', this);
        },
        willDestroy() {
          pushHook('willDestroy');
          removeComponent(this);
          this._super(...arguments);
        }
      });
      super.registerComponent(name, {
        ComponentClass,
        template
      });
    }
    assertHooks(_ref2) {
      let {
        label,
        interactive,
        nonInteractive
      } = _ref2;
      let rawHooks = this.isInteractive ? interactive : nonInteractive;
      let hooks = rawHooks.map(raw => hook(...raw));
      this.assert.deepEqual(json(this.hooks), json(hooks), label);
      this.hooks = [];
    }
    ['@test lifecycle hooks are invoked in a predictable order']() {
      let {
        attr,
        invoke
      } = this.boundHelpers;
      this.registerComponent('the-top', {
        template: (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        Twitter: {{", "}}|\n        ", "\n      </div>"])), attr('twitter'), invoke('the-middle', {
          name: string('Tom Dale')
        }))
      });
      this.registerComponent('the-middle', {
        template: (0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        Name: {{", "}}|\n        ", "\n      </div>"])), attr('name'), invoke('the-bottom', {
          website: string('tomdale.net')
        }))
      });
      this.registerComponent('the-bottom', {
        template: (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        Website: {{", "}}\n      </div>"])), attr('website'))
      });
      this.render(invoke('the-top', {
        twitter: expr(attr('twitter'))
      }), {
        twitter: '@tomdale'
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertRegisteredViews('intial render');
      this.assertHooks({
        label: 'after initial render',
        interactive: [
        // Sync hooks

        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willRender'], ['the-top', 'willInsertElement'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-middle', 'willRender'], ['the-middle', 'willInsertElement'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs'], ['the-bottom', 'willRender'], ['the-bottom', 'willInsertElement'],
        // Async hooks

        ['the-bottom', 'didInsertElement'], ['the-bottom', 'didRender'], ['the-middle', 'didInsertElement'], ['the-middle', 'didRender'], ['the-top', 'didInsertElement'], ['the-top', 'didRender']],
        nonInteractive: [
        // Sync hooks
        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-bottom'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (bottom)',
        interactive: [
        // Sync hooks
        ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], ['the-bottom', 'willUpdate'], ['the-bottom', 'willRender'],
        // Async hooks

        ['the-bottom', 'didUpdate'], ['the-bottom', 'didRender'], ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-middle'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (middle)',
        interactive: [
        // Sync hooks

        ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'],
        // Async hooks

        ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-top'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (top)',
        interactive: [
        // Sync hooks

        ['the-top', 'willUpdate'], ['the-top', 'willRender'],
        // Async hooks

        ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'twitter', '@horsetomdale'));
      this.assertText('Twitter: @horsetomdale|Name: Tom Dale|Website: tomdale.net');

      // Because the `twitter` attr is only used by the topmost component,
      // and not passed down, we do not expect to see lifecycle hooks
      // called for child components. If the `didReceiveAttrs` hook used
      // the new attribute to rerender itself imperatively, that would result
      // in lifecycle hooks being invoked for the child.

      this.assertHooks({
        label: 'after update',
        interactive: [
        // Sync hooks

        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willUpdate'], ['the-top', 'willRender'],
        // Async hooks

        ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: [
        // Sync hooks
        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs']]
      });
      this.teardownAssertions.push(() => {
        this.assertHooks({
          label: 'destroy',
          interactive: [['the-top', 'willDestroyElement'], ['the-top', 'willClearRender'], ['the-middle', 'willDestroyElement'], ['the-middle', 'willClearRender'], ['the-bottom', 'willDestroyElement'], ['the-bottom', 'willClearRender'], ['the-top', 'didDestroyElement'], ['the-middle', 'didDestroyElement'], ['the-bottom', 'didDestroyElement'], ['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']],
          nonInteractive: [['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']]
        });
        this.assertRegisteredViews('after destroy');
      });
    }
    ['@test lifecycle hooks are invoked in a correct sibling order']() {
      let {
        attr,
        invoke
      } = this.boundHelpers;
      this.registerComponent('the-parent', {
        template: (0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        ", "|\n        ", "|\n        ", "\n      </div>"])), invoke('the-first-child', {
          twitter: expr(attr('twitter'))
        }), invoke('the-second-child', {
          name: expr(attr('name'))
        }), invoke('the-last-child', {
          website: expr(attr('website'))
        }))
      });
      this.registerComponent('the-first-child', {
        template: "Twitter: {{" + attr('twitter') + "}}"
      });
      this.registerComponent('the-second-child', {
        template: "Name: {{" + attr('name') + "}}"
      });
      this.registerComponent('the-last-child', {
        template: "Website: {{" + attr('website') + "}}"
      });
      this.render(invoke('the-parent', {
        twitter: expr(attr('twitter')),
        name: expr(attr('name')),
        website: expr(attr('website'))
      }), {
        twitter: '@tomdale',
        name: 'Tom Dale',
        website: 'tomdale.net'
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertRegisteredViews('intial render');
      this.assertHooks({
        label: 'after initial render',
        interactive: [
        // Sync hooks

        ['the-parent', 'init'], ['the-parent', 'on(init)'], ['the-parent', 'didReceiveAttrs'], ['the-parent', 'willRender'], ['the-parent', 'willInsertElement'], ['the-first-child', 'init'], ['the-first-child', 'on(init)'], ['the-first-child', 'didReceiveAttrs'], ['the-first-child', 'willRender'], ['the-first-child', 'willInsertElement'], ['the-second-child', 'init'], ['the-second-child', 'on(init)'], ['the-second-child', 'didReceiveAttrs'], ['the-second-child', 'willRender'], ['the-second-child', 'willInsertElement'], ['the-last-child', 'init'], ['the-last-child', 'on(init)'], ['the-last-child', 'didReceiveAttrs'], ['the-last-child', 'willRender'], ['the-last-child', 'willInsertElement'],
        // Async hooks

        ['the-first-child', 'didInsertElement'], ['the-first-child', 'didRender'], ['the-second-child', 'didInsertElement'], ['the-second-child', 'didRender'], ['the-last-child', 'didInsertElement'], ['the-last-child', 'didRender'], ['the-parent', 'didInsertElement'], ['the-parent', 'didRender']],
        nonInteractive: [
        // Sync hooks

        ['the-parent', 'init'], ['the-parent', 'on(init)'], ['the-parent', 'didReceiveAttrs'], ['the-first-child', 'init'], ['the-first-child', 'on(init)'], ['the-first-child', 'didReceiveAttrs'], ['the-second-child', 'init'], ['the-second-child', 'on(init)'], ['the-second-child', 'didReceiveAttrs'], ['the-last-child', 'init'], ['the-last-child', 'on(init)'], ['the-last-child', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-first-child'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (first child)',
        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-first-child', 'willUpdate'], ['the-first-child', 'willRender'],
        // Async hooks

        ['the-first-child', 'didUpdate'], ['the-first-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-second-child'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (second child)',
        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-second-child', 'willUpdate'], ['the-second-child', 'willRender'],
        // Async hooks

        ['the-second-child', 'didUpdate'], ['the-second-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-last-child'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (last child)',
        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-last-child', 'willUpdate'], ['the-last-child', 'willRender'],
        // Async hooks

        ['the-last-child', 'didUpdate'], ['the-last-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => this.components['the-parent'].rerender());
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (parent)',
        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'],
        // Async hooks

        ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        twitter: '@horsetomdale',
        name: 'Horse Tom Dale',
        website: 'horsetomdale.net'
      }));
      this.assertText('Twitter: @horsetomdale|Name: Horse Tom Dale|Website: horsetomdale.net');
      this.assertHooks({
        label: 'after update',
        interactive: [
        // Sync hooks

        ['the-parent', 'didUpdateAttrs'], ['the-parent', 'didReceiveAttrs'], ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-first-child', 'didUpdateAttrs'], ['the-first-child', 'didReceiveAttrs'], ['the-first-child', 'willUpdate'], ['the-first-child', 'willRender'], ['the-second-child', 'didUpdateAttrs'], ['the-second-child', 'didReceiveAttrs'], ['the-second-child', 'willUpdate'], ['the-second-child', 'willRender'], ['the-last-child', 'didUpdateAttrs'], ['the-last-child', 'didReceiveAttrs'], ['the-last-child', 'willUpdate'], ['the-last-child', 'willRender'],
        // Async hooks

        ['the-first-child', 'didUpdate'], ['the-first-child', 'didRender'], ['the-second-child', 'didUpdate'], ['the-second-child', 'didRender'], ['the-last-child', 'didUpdate'], ['the-last-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: [
        // Sync hooks

        ['the-parent', 'didUpdateAttrs'], ['the-parent', 'didReceiveAttrs'], ['the-first-child', 'didUpdateAttrs'], ['the-first-child', 'didReceiveAttrs'], ['the-second-child', 'didUpdateAttrs'], ['the-second-child', 'didReceiveAttrs'], ['the-last-child', 'didUpdateAttrs'], ['the-last-child', 'didReceiveAttrs']]
      });
      this.teardownAssertions.push(() => {
        this.assertHooks({
          label: 'destroy',
          interactive: [['the-parent', 'willDestroyElement'], ['the-parent', 'willClearRender'], ['the-first-child', 'willDestroyElement'], ['the-first-child', 'willClearRender'], ['the-second-child', 'willDestroyElement'], ['the-second-child', 'willClearRender'], ['the-last-child', 'willDestroyElement'], ['the-last-child', 'willClearRender'], ['the-parent', 'didDestroyElement'], ['the-first-child', 'didDestroyElement'], ['the-second-child', 'didDestroyElement'], ['the-last-child', 'didDestroyElement'], ['the-parent', 'willDestroy'], ['the-first-child', 'willDestroy'], ['the-second-child', 'willDestroy'], ['the-last-child', 'willDestroy']],
          nonInteractive: [['the-parent', 'willDestroy'], ['the-first-child', 'willDestroy'], ['the-second-child', 'willDestroy'], ['the-last-child', 'willDestroy']]
        });
        this.assertRegisteredViews('after destroy');
      });
    }
    ['@test passing values through attrs causes lifecycle hooks to fire if the attribute values have changed']() {
      let {
        attr,
        invoke
      } = this.boundHelpers;
      this.registerComponent('the-top', {
        template: (0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        Top: ", "\n      </div>"])), invoke('the-middle', {
          twitterTop: expr(attr('twitter'))
        }))
      });
      this.registerComponent('the-middle', {
        template: (0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        Middle: ", "\n      </div>"])), invoke('the-bottom', {
          twitterMiddle: expr(attr('twitterTop'))
        }))
      });
      this.registerComponent('the-bottom', {
        template: (0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        Bottom: {{", "}}\n      </div>"])), attr('twitterMiddle'))
      });
      this.render(invoke('the-top', {
        twitter: expr(attr('twitter'))
      }), {
        twitter: '@tomdale'
      });
      this.assertText('Top: Middle: Bottom: @tomdale');
      this.assertRegisteredViews('intial render');
      this.assertHooks({
        label: 'after initial render',
        interactive: [
        // Sync hooks

        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willRender'], ['the-top', 'willInsertElement'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-middle', 'willRender'], ['the-middle', 'willInsertElement'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs'], ['the-bottom', 'willRender'], ['the-bottom', 'willInsertElement'],
        // Async hooks

        ['the-bottom', 'didInsertElement'], ['the-bottom', 'didRender'], ['the-middle', 'didInsertElement'], ['the-middle', 'didRender'], ['the-top', 'didInsertElement'], ['the-top', 'didRender']],
        nonInteractive: [
        // Sync hooks

        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'twitter', '@horsetomdale'));
      this.assertText('Top: Middle: Bottom: @horsetomdale');

      // Because the `twitter` attr is used by the all of the components,
      // the lifecycle hooks are invoked for all components.

      this.assertHooks({
        label: 'after updating (root)',
        interactive: [
        // Sync hooks

        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'didUpdateAttrs'], ['the-middle', 'didReceiveAttrs'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], ['the-bottom', 'didUpdateAttrs'], ['the-bottom', 'didReceiveAttrs'], ['the-bottom', 'willUpdate'], ['the-bottom', 'willRender'],
        // Async hooks

        ['the-bottom', 'didUpdate'], ['the-bottom', 'didRender'], ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: [
        // Sync hooks

        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs'], ['the-middle', 'didUpdateAttrs'], ['the-middle', 'didReceiveAttrs'], ['the-bottom', 'didUpdateAttrs'], ['the-bottom', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Top: Middle: Bottom: @horsetomdale');

      // In this case, because the attrs are passed down, all child components are invoked.

      this.assertHooks({
        label: 'after no-op rernder (root)',
        interactive: [],
        nonInteractive: []
      });
      this.teardownAssertions.push(() => {
        this.assertHooks({
          label: 'destroy',
          interactive: [['the-top', 'willDestroyElement'], ['the-top', 'willClearRender'], ['the-middle', 'willDestroyElement'], ['the-middle', 'willClearRender'], ['the-bottom', 'willDestroyElement'], ['the-bottom', 'willClearRender'], ['the-top', 'didDestroyElement'], ['the-middle', 'didDestroyElement'], ['the-bottom', 'didDestroyElement'], ['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']],
          nonInteractive: [['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']]
        });
        this.assertRegisteredViews('after destroy');
      });
    }
    ['@test components rendered from `{{each}}` have correct life-cycle hooks to be called']() {
      let {
        invoke
      } = this.boundHelpers;
      this.registerComponent('nested-item', {
        template: "{{yield}}"
      });
      this.registerComponent('an-item', {
        template: (0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#nested-item}}Item: {{this.count}}{{/nested-item}}\n    "])))
      });
      this.registerComponent('no-items', {
        template: (0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#nested-item}}Nothing to see here{{/nested-item}}\n    "])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each this.items as |item|}}\n        ", "\n      {{else}}\n        ", "\n      {{/each}}\n    "])), invoke('an-item', {
        count: expr('item')
      }), invoke('no-items')), {
        items: [1, 2, 3, 4, 5]
      });
      this.assertText('Item: 1Item: 2Item: 3Item: 4Item: 5');
      this.assertRegisteredViews('intial render');
      let initialHooks = () => {
        let ret = [['an-item', 'init'], ['an-item', 'on(init)'], ['an-item', 'didReceiveAttrs']];
        if (this.isInteractive) {
          ret.push(['an-item', 'willRender'], ['an-item', 'willInsertElement']);
        }
        ret.push(['nested-item', 'init'], ['nested-item', 'on(init)'], ['nested-item', 'didReceiveAttrs']);
        if (this.isInteractive) {
          ret.push(['nested-item', 'willRender'], ['nested-item', 'willInsertElement']);
        }
        return ret;
      };
      let initialAfterRenderHooks = () => {
        if (this.isInteractive) {
          return [['nested-item', 'didInsertElement'], ['nested-item', 'didRender'], ['an-item', 'didInsertElement'], ['an-item', 'didRender']];
        } else {
          return [];
        }
      };
      this.assertHooks({
        label: 'after initial render',
        interactive: [
        // Sync hooks
        ...initialHooks(1), ...initialHooks(2), ...initialHooks(3), ...initialHooks(4), ...initialHooks(5),
        // Async hooks
        ...initialAfterRenderHooks(5), ...initialAfterRenderHooks(4), ...initialAfterRenderHooks(3), ...initialAfterRenderHooks(2), ...initialAfterRenderHooks(1)],
        nonInteractive: [
        // Sync hooks
        ...initialHooks(1), ...initialHooks(2), ...initialHooks(3), ...initialHooks(4), ...initialHooks(5),
        // Async hooks
        ...initialAfterRenderHooks(5), ...initialAfterRenderHooks(4), ...initialAfterRenderHooks(3), ...initialAfterRenderHooks(2), ...initialAfterRenderHooks(1)]
      });

      // TODO: Is this correct? Should childViews be populated in non-interactive mode?
      if (this.isInteractive) {
        this.assert.equal(this.component.childViews.length, 5, 'childViews precond');
      }
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items', []));

      // TODO: Is this correct? Should childViews be populated in non-interactive mode?
      if (this.isInteractive) {
        this.assert.equal(this.component.childViews.length, 1, 'childViews updated');
      }
      this.assertText('Nothing to see here');
      this.assertHooks({
        label: 'reset to empty array',
        interactive: [['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['no-items', 'init'], ['no-items', 'on(init)'], ['no-items', 'didReceiveAttrs'], ['no-items', 'willRender'], ['no-items', 'willInsertElement'], ['nested-item', 'init'], ['nested-item', 'on(init)'], ['nested-item', 'didReceiveAttrs'], ['nested-item', 'willRender'], ['nested-item', 'willInsertElement'], ['nested-item', 'didInsertElement'], ['nested-item', 'didRender'], ['no-items', 'didInsertElement'], ['no-items', 'didRender'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy']],
        nonInteractive: [['no-items', 'init'], ['no-items', 'on(init)'], ['no-items', 'didReceiveAttrs'], ['nested-item', 'init'], ['nested-item', 'on(init)'], ['nested-item', 'didReceiveAttrs'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy']]
      });
      this.teardownAssertions.push(() => {
        this.assertHooks({
          label: 'destroy',
          interactive: [['no-items', 'willDestroyElement'], ['no-items', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['no-items', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['no-items', 'willDestroy'], ['nested-item', 'willDestroy']],
          nonInteractive: [['no-items', 'willDestroy'], ['nested-item', 'willDestroy']]
        });
        this.assertRegisteredViews('after destroy');
      });
    }
  }
  class CurlyComponentsTest extends LifeCycleHooksTest {
    get ComponentClass() {
      return _helpers.Component;
    }
    invocationFor(name, namedArgs) {
      if (namedArgs === void 0) {
        namedArgs = {};
      }
      let attrs = Object.keys(namedArgs).map(k => k + "=" + this.val(namedArgs[k])).join(' ');
      return "{{" + name + " " + attrs + "}}";
    }
    attrFor(name) {
      return "this." + name;
    }

    /* private */
    val(value) {
      if (value.isString) {
        return JSON.stringify(value.value);
      } else if (value.isExpr) {
        return "(readonly " + value.value + ")";
      } else {
        throw new Error("Unknown value: " + value);
      }
    }
  }
  (0, _internalTestHelpers.moduleFor)('Components test: interactive lifecycle hooks (curly components)', class extends CurlyComponentsTest {
    get isInteractive() {
      return true;
    }
  });
  (0, _internalTestHelpers.moduleFor)('Components test: non-interactive lifecycle hooks (curly components)', class extends CurlyComponentsTest {
    get isInteractive() {
      return false;
    }
  });
  (0, _internalTestHelpers.moduleFor)('Components test: interactive lifecycle hooks (tagless curly components)', class extends CurlyComponentsTest {
    get ComponentClass() {
      return _helpers.Component.extend({
        tagName: ''
      });
    }
    get isInteractive() {
      return true;
    }
  });
  (0, _internalTestHelpers.moduleFor)('Components test: non-interactive lifecycle hooks (tagless curly components)', class extends CurlyComponentsTest {
    get ComponentClass() {
      return _helpers.Component.extend({
        tagName: ''
      });
    }
    get isInteractive() {
      return false;
    }
  });
  (0, _internalTestHelpers.moduleFor)('Run loop and lifecycle hooks', class extends _internalTestHelpers.RenderingTestCase {
    ['@test afterRender set']() {
      let ComponentClass = _helpers.Component.extend({
        width: '5',
        didInsertElement() {
          (0, _runloop.schedule)('afterRender', () => {
            this.set('width', '10');
          });
        }
      });
      let template = "{{this.width}}";
      this.registerComponent('foo-bar', {
        ComponentClass,
        template
      });
      this.render('{{foo-bar}}');
      this.assertText('10');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('10');
    }
    ['@test afterRender set on parent']() {
      let ComponentClass = _helpers.Component.extend({
        didInsertElement() {
          (0, _runloop.schedule)('afterRender', () => {
            let parent = this.get('parent');
            parent.set('foo', 'wat');
          });
        }
      });
      let template = "{{this.foo}}";
      this.registerComponent('foo-bar', {
        ComponentClass,
        template
      });
      this.render('{{foo-bar parent=this foo=this.foo}}');
      this.assertText('wat');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('wat');
    }
    ['@test `willRender` can set before render (GH#14458)']() {
      let ComponentClass = _helpers.Component.extend({
        tagName: 'a',
        customHref: 'http://google.com',
        attributeBindings: ['customHref:href'],
        willRender() {
          this.set('customHref', 'http://willRender.com');
        }
      });
      let template = "Hello World";
      this.registerComponent('foo-bar', {
        ComponentClass,
        template
      });
      this.render("{{foo-bar id=\"foo\"}}");
      this.assertElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          id: 'foo',
          href: 'http://willRender.com',
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
    }
    ['@test that thing about destroying'](assert) {
      let ParentDestroyedElements = [];
      let ChildDestroyedElements = [];
      let ParentComponent = _helpers.Component.extend({
        willDestroyElement() {
          ParentDestroyedElements.push({
            id: this.itemId,
            name: 'parent-component',
            hasParent: Boolean(this.element.parentNode),
            nextSibling: Boolean(this.element.nextSibling),
            previousSibling: Boolean(this.element.previousSibling)
          });
        }
      });
      let PartentTemplate = (0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{yield}}\n      <ul>\n        {{#nested-component nestedId=(concat this.itemId '-A')}}A{{/nested-component}}\n        {{#nested-component nestedId=(concat this.itemId '-B')}}B{{/nested-component}}\n      </ul>\n    "])));
      let NestedComponent = _helpers.Component.extend({
        willDestroyElement() {
          ChildDestroyedElements.push({
            id: this.nestedId,
            name: 'nested-component',
            hasParent: Boolean(this.element.parentNode),
            nextSibling: Boolean(this.element.nextSibling),
            previousSibling: Boolean(this.element.previousSibling)
          });
        }
      });
      let NestedTemplate = "{{yield}}";
      this.registerComponent('parent-component', {
        ComponentClass: ParentComponent,
        template: PartentTemplate
      });
      this.registerComponent('nested-component', {
        ComponentClass: NestedComponent,
        template: NestedTemplate
      });
      let array = (0, _array.A)([{
        id: 1
      }, {
        id: 2
      }, {
        id: 3
      }, {
        id: 4
      }, {
        id: 5
      }]);
      this.render((0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.items as |item|}}\n          {{#parent-component itemId=item.id}}{{item.id}}{{/parent-component}}\n        {{/each}}\n        {{#if this.model.shouldShow}}\n          {{#parent-component itemId=6}}6{{/parent-component}}\n        {{/if}}\n        {{#if this.model.shouldShow}}\n          {{#parent-component itemId=7}}7{{/parent-component}}\n        {{/if}}\n        "]))), {
        items: array,
        model: {
          shouldShow: true
        }
      });
      this.assertText('1AB2AB3AB4AB5AB6AB7AB');
      (0, _internalTestHelpers.runTask)(() => {
        array.removeAt(2);
        array.removeAt(2);
        (0, _object.set)(this.context, 'model.shouldShow', false);
      });
      this.assertText('1AB2AB5AB');
      assertDestroyHooks(assert, [...ParentDestroyedElements], [{
        id: 3,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 4,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 6,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 7,
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }]);
      assertDestroyHooks(assert, [...ChildDestroyedElements], [{
        id: '3-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '3-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '4-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '4-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '6-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '6-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '7-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '7-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }]);
    }
    ['@test lifecycle hooks exist on the base class'](assert) {
      // Make sure we get the finalized component prototype
      let prototype = _helpers.Component.proto();
      assert.equal(typeof prototype.didDestroyElement, 'function', 'didDestroyElement exists');
      assert.equal(typeof prototype.didInsertElement, 'function', 'didInsertElement exists');
      assert.equal(typeof prototype.didReceiveAttrs, 'function', 'didReceiveAttrs exists');
      assert.equal(typeof prototype.didRender, 'function', 'didRender exists');
      assert.equal(typeof prototype.didUpdate, 'function', 'didUpdate exists');
      assert.equal(typeof prototype.didUpdateAttrs, 'function', 'didUpdateAttrs exists');
      assert.equal(typeof prototype.willClearRender, 'function', 'willClearRender exists');
      assert.equal(typeof prototype.willDestroy, 'function', 'willDestroy exists');
      assert.equal(typeof prototype.willDestroyElement, 'function', 'willDestroyElement exists');
      assert.equal(typeof prototype.willInsertElement, 'function', 'willInsertElement exists');
      assert.equal(typeof prototype.willRender, 'function', 'willRender exists');
      assert.equal(typeof prototype.willUpdate, 'function', 'willUpdate exists');
    }
  });
  function assertDestroyHooks(assert, _actual, _expected) {
    _expected.forEach((expected, i) => {
      let name = expected.name;
      assert.equal(expected.id, _actual[i].id, name + " id is the same");
      assert.equal(expected.hasParent, _actual[i].hasParent, name + " has parent node");
      assert.equal(expected.nextSibling, _actual[i].nextSibling, name + " has next sibling node");
      assert.equal(expected.previousSibling, _actual[i].previousSibling, name + " has previous sibling node");
    });
  }
  function bind(func, thisArg) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return func.apply(thisArg, args);
    };
  }
  function string(value) {
    return {
      isString: true,
      value
    };
  }
  function expr(value) {
    return {
      isExpr: true,
      value
    };
  }
  function hook(name, hook, _temp) {
    let {
      attrs,
      oldAttrs,
      newAttrs
    } = _temp === void 0 ? {} : _temp;
    return {
      name,
      hook,
      args: {
        attrs,
        oldAttrs,
        newAttrs
      }
    };
  }
  function json(serializable) {
    return JSON.parse(JSON.stringify(serializable));
  }
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/query-params-angle-test", ["@ember/controller", "@ember/-internals/runtime", "@ember/routing/route", "internal-test-helpers"], function (_controller, _runtime, _route, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component with query-params (rendering)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123',
        bar: 'yes'
      }));
    }
    async ['@test it populates href with fully supplied query param values']() {
      this.addTemplate('index', "<LinkTo @route='index' @query={{hash foo='456' bar='NAW'}}>Index</LinkTo>");
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/?bar=NAW&foo=456'
        },
        content: 'Index'
      });
    }
    async ['@test it populates href with fully supplied query param values, but without @route param']() {
      this.addTemplate('index', "<LinkTo @query={{hash foo='2' bar='NAW'}}>QueryParams</LinkTo>");
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/?bar=NAW&foo=2'
        },
        content: 'QueryParams'
      });
    }
    async ['@test it populates href with partially supplied query param values, but omits if value is default value']() {
      this.addTemplate('index', "<LinkTo @route='index' @query={{hash foo='123'}}>Index</LinkTo>");
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/',
          class: (0, _internalTestHelpers.classes)('ember-view active')
        },
        content: 'Index'
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component with query params (routing)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      let indexProperties = {
        foo: '123',
        bar: 'abc'
      };
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo', 'bar', 'abool'];
          this.foo = indexProperties.foo;
          this.bar = indexProperties.bar;
          this.boundThing = 'OMG';
          this.abool = true;
        }
      });
      this.add('controller:about', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['baz', 'bat'];
          this.baz = 'alex';
          this.bat = 'borf';
        }
      });
      this.indexProperties = indexProperties;
    }
    shouldNotBeActive(assert, selector) {
      this.checkActive(assert, selector, false);
    }
    shouldBeActive(assert, selector) {
      this.checkActive(assert, selector, true);
    }
    getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    }
    checkActive(assert, selector, active) {
      let classList = this.$(selector)[0].className;
      assert.equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
    }
    async ["@test it doesn't update controller QP properties on current route when invoked"](assert) {
      this.addTemplate('index', "<LinkTo id='the-link' @route='index'>Index</LinkTo>");
      await this.visit('/');
      await this.click('#the-link');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), this.indexProperties, 'controller QP properties do not update');
    }
    async ["@test it doesn't update controller QP properties on current route when invoked (empty query-params obj)"](assert) {
      this.addTemplate('index', "<LinkTo id='the-link' @route='index' @query={{(hash)}}>Index</LinkTo>");
      await this.visit('/');
      await this.click('#the-link');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), this.indexProperties, 'controller QP properties do not update');
    }
    async ["@test it doesn't update controller QP properties on current route when invoked (empty query-params obj, inferred route)"](assert) {
      this.addTemplate('index', "<LinkTo id='the-link' @query={{(hash)}}>Index</LinkTo>");
      await this.visit('/');
      await this.click('#the-link');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), this.indexProperties, 'controller QP properties do not update');
    }
    async ['@test it updates controller QP properties on current route when invoked'](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"the-link\" @route='index' @query={{hash foo='456'}}>\n          Index\n        </LinkTo>\n        ");
      await this.visit('/');
      await this.click('#the-link');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), {
        foo: '456',
        bar: 'abc'
      }, 'controller QP properties updated');
    }
    async ['@test it updates controller QP properties on current route when invoked (inferred route)'](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"the-link\" @query={{hash foo='456'}}>\n          Index\n        </LinkTo>\n        ");
      await this.visit('/');
      await this.click('#the-link');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), {
        foo: '456',
        bar: 'abc'
      }, 'controller QP properties updated');
    }
    async ['@test it updates controller QP properties on other route after transitioning to that route'](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <LinkTo id=\"the-link\" @route=\"about\" @query={{hash baz='lol'}}>\n          About\n        </LinkTo>\n        ");
      await this.visit('/');
      let theLink = this.$('#the-link');
      assert.equal(theLink.attr('href'), '/about?baz=lol');
      (0, _internalTestHelpers.runTask)(() => this.click('#the-link'));
      let aboutController = this.getController('about');
      assert.deepEqual(aboutController.getProperties('baz', 'bat'), {
        baz: 'lol',
        bat: 'borf'
      }, 'about controller QP properties updated');
    }
    async ['@test it generates proper href for `LinkTo` with no @route after transitioning to an error route [GH#17963]'](assert) {
      this.router.map(function () {
        this.route('bad');
      });
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['baz'];
        }
      });
      this.add('route:bad', class extends _route.default {
        model() {
          throw new Error('bad!');
        }
      });
      this.addTemplate('error', "Error: {{@model.message}}");
      this.addTemplate('application', "\n        <LinkTo id=\"bad-link\" @route=\"bad\">\n          Bad\n        </LinkTo>\n\n        <LinkTo id=\"good-link\" @query={{hash baz='lol'}}>\n          Good\n        </LinkTo>\n\n        {{outlet}}\n        ");
      await this.visit('/');
      assert.equal(this.$('#good-link').length, 1, 'good-link should be in the DOM');
      assert.equal(this.$('#bad-link').length, 1, 'bad-link should be in the DOM');
      let goodLink = this.$('#good-link');
      assert.equal(goodLink.attr('href'), '/?baz=lol');
      await this.visit('/bad');
      assert.equal(this.$('#good-link').length, 1, 'good-link should be in the DOM');
      assert.equal(this.$('#bad-link').length, 1, 'bad-link should be in the DOM');
      goodLink = this.$('#good-link');
      // should still be / because we never entered /bad (it errored before being fully entered)
      // and error states do not get represented in the URL, so we are _effectively_ still
      // on /
      assert.equal(goodLink.attr('href'), '/?baz=lol');
      (0, _internalTestHelpers.runTask)(() => this.click('#good-link'));
      let applicationController = this.getController('application');
      assert.deepEqual(applicationController.getProperties('baz'), {
        baz: 'lol'
      }, 'index controller QP properties updated');
    }
    async ['@test supplied QP properties can be bound'](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"the-link\" @query={{hash foo=this.boundThing}}>\n          Index\n        </LinkTo>\n        ");
      await this.visit('/');
      let indexController = this.getController('index');
      let theLink = this.$('#the-link');
      assert.equal(theLink.attr('href'), '/?foo=OMG');
      (0, _internalTestHelpers.runTask)(() => indexController.set('boundThing', 'ASL'));
      assert.equal(theLink.attr('href'), '/?foo=ASL');
    }
    async ['@test supplied QP properties can be bound (booleans)'](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"the-link\" @query={{hash abool=this.boundThing}}>\n          Index\n        </LinkTo>\n        ");
      await this.visit('/');
      let indexController = this.getController('index');
      let theLink = this.$('#the-link');
      assert.equal(theLink.attr('href'), '/?abool=OMG');
      (0, _internalTestHelpers.runTask)(() => indexController.set('boundThing', false));
      assert.equal(theLink.attr('href'), '/?abool=false');
      await this.click('#the-link');
      assert.deepEqual(indexController.getProperties('foo', 'bar', 'abool'), {
        foo: '123',
        bar: 'abc',
        abool: false
      }, 'bound bool QP properties update');
    }
    async ['@test href updates when unsupplied controller QP props change'](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"the-link\" @query={{hash foo='lol'}}>\n          Index\n        </LinkTo>\n        ");
      await this.visit('/');
      let indexController = this.getController('index');
      let theLink = this.$('#the-link');
      assert.equal(theLink.attr('href'), '/?foo=lol');
      (0, _internalTestHelpers.runTask)(() => indexController.set('bar', 'BORF'));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
      (0, _internalTestHelpers.runTask)(() => indexController.set('foo', 'YEAH'));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
    }
    async ['@test [GH#12033] with only query params, it always transitions to the current route with the query params applied'](assert) {
      this.addTemplate('cars', "\n        <LinkTo id='create-link' @route='cars.create'>Create new car</LinkTo>\n        <LinkTo id='page2-link' @query={{hash page='2'}}>Page 2</LinkTo>\n        {{outlet}}\n        ");
      this.addTemplate('cars.create', "<LinkTo id='close-link' @route='cars'>Close create form</LinkTo>");
      this.router.map(function () {
        this.route('cars', function () {
          this.route('create');
        });
      });
      this.add('controller:cars', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
        }
      });
      await this.visit('/cars/create');
      let router = this.appRouter;
      let carsController = this.getController('cars');
      assert.equal(router.currentRouteName, 'cars.create');
      (0, _internalTestHelpers.runTask)(() => this.click('#close-link'));
      assert.equal(router.currentRouteName, 'cars.index');
      assert.equal(router.get('url'), '/cars');
      assert.equal(carsController.get('page'), 1, 'The page query-param is 1');
      (0, _internalTestHelpers.runTask)(() => this.click('#page2-link'));
      assert.equal(router.currentRouteName, 'cars.index', 'The active route is still cars');
      assert.equal(router.get('url'), '/cars?page=2', 'The url has been updated');
      assert.equal(carsController.get('page'), 2, 'The query params have been updated');
    }
    async ['@test it applies activeClass when query params are not changed'](assert) {
      this.addTemplate('index', "\n        <LinkTo id='cat-link' @query={{hash foo='cat'}}>Index</LinkTo>\n        <LinkTo id='dog-link' @query={{hash foo='dog'}}>Index</LinkTo>\n        <LinkTo id='change-nothing' @route='index'>Index</LinkTo>\n        ");
      this.addTemplate('search', "\n        <LinkTo id='same-search' @query={{hash search='same'}}>Index</LinkTo>\n        <LinkTo id='change-search' @query={{hash search='change'}}>Index</LinkTo>\n        <LinkTo id='same-search-add-archive' @query={{hash search='same' archive=true}}>Index</LinkTo>\n        <LinkTo id='only-add-archive' @query={{hash archive=true}}>Index</LinkTo>\n        <LinkTo id='both-same' @query={{hash search='same' archive=true}}>Index</LinkTo>\n        <LinkTo id='change-one' @query={{hash search='different' archive=true}}>Index</LinkTo>\n        <LinkTo id='remove-one' @query={{hash search='different' archive=false}}>Index</LinkTo>\n        {{outlet}}\n        ");
      this.addTemplate('search.results', "\n        <LinkTo id='same-sort-child-only' @query={{hash sort='title'}}>Index</LinkTo>\n        <LinkTo id='same-search-parent-only' @query={{hash search='same'}}>Index</LinkTo>\n        <LinkTo id='change-search-parent-only' @query={{hash search='change'}}>Index</LinkTo>\n        <LinkTo id='same-search-same-sort-child-and-parent' @query={{hash search='same' sort='title'}}>Index</LinkTo>\n        <LinkTo id='same-search-different-sort-child-and-parent' @query={{hash search='same' sort='author'}}>Index</LinkTo>\n        <LinkTo id='change-search-same-sort-child-and-parent' @query={{hash search='change' sort='title'}}>Index</LinkTo>\n        <LinkTo id='dog-link' @query={{hash foo='dog'}}>Index</LinkTo>\n        ");
      this.router.map(function () {
        this.route('search', function () {
          this.route('results');
        });
      });
      this.add('controller:search', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['search', 'archive'];
          this.search = '';
          this.archive = false;
        }
      });
      this.add('controller:search.results', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['sort', 'showDetails'];
          this.sort = 'title';
          this.showDetails = true;
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#cat-link');
      this.shouldNotBeActive(assert, '#dog-link');
      await this.visit('/?foo=cat');
      this.shouldBeActive(assert, '#cat-link');
      this.shouldNotBeActive(assert, '#dog-link');
      await this.visit('/?foo=dog');
      this.shouldBeActive(assert, '#dog-link');
      this.shouldNotBeActive(assert, '#cat-link');
      this.shouldBeActive(assert, '#change-nothing');
      await this.visit('/search?search=same');
      this.shouldBeActive(assert, '#same-search');
      this.shouldNotBeActive(assert, '#change-search');
      this.shouldNotBeActive(assert, '#same-search-add-archive');
      this.shouldNotBeActive(assert, '#only-add-archive');
      this.shouldNotBeActive(assert, '#remove-one');
      await this.visit('/search?search=same&archive=true');
      this.shouldBeActive(assert, '#both-same');
      this.shouldNotBeActive(assert, '#change-one');
      await this.visit('/search/results?search=same&sort=title&showDetails=true');
      this.shouldBeActive(assert, '#same-sort-child-only');
      this.shouldBeActive(assert, '#same-search-parent-only');
      this.shouldNotBeActive(assert, '#change-search-parent-only');
      this.shouldBeActive(assert, '#same-search-same-sort-child-and-parent');
      this.shouldNotBeActive(assert, '#same-search-different-sort-child-and-parent');
      this.shouldNotBeActive(assert, '#change-search-same-sort-child-and-parent');
    }
    async ['@test it applies active class when query-param is a number'](assert) {
      this.addTemplate('index', "\n        <LinkTo id='page-link' @query={{hash page=this.pageNumber}}>\n          Index\n        </LinkTo>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
          this.pageNumber = 5;
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#page-link');
      await this.visit('/?page=5');
      this.shouldBeActive(assert, '#page-link');
    }
    async ['@test it applies active class when query-param is an array'](assert) {
      this.addTemplate('index', "\n        <LinkTo id='array-link' @query={{hash pages=this.pagesArray}}>Index</LinkTo>\n        <LinkTo id='bigger-link' @query={{hash pages=this.biggerArray}}>Index</LinkTo>\n        <LinkTo id='empty-link' @query={{hash pages=this.emptyArray}}>Index</LinkTo>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['pages'];
          this.pages = [];
          this.pagesArray = [1, 2];
          this.biggerArray = [1, 2, 3];
          this.emptyArray = [];
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#array-link');
      await this.visit('/?pages=%5B1%2C2%5D');
      this.shouldBeActive(assert, '#array-link');
      this.shouldNotBeActive(assert, '#bigger-link');
      this.shouldNotBeActive(assert, '#empty-link');
      await this.visit('/?pages=%5B2%2C1%5D');
      this.shouldNotBeActive(assert, '#array-link');
      this.shouldNotBeActive(assert, '#bigger-link');
      this.shouldNotBeActive(assert, '#empty-link');
      await this.visit('/?pages=%5B1%2C2%2C3%5D');
      this.shouldBeActive(assert, '#bigger-link');
      this.shouldNotBeActive(assert, '#array-link');
      this.shouldNotBeActive(assert, '#empty-link');
    }
    async ['@test it applies active class to the parent route'](assert) {
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.addTemplate('application', "\n        <LinkTo id='parent-link' @route='parent'>Parent</LinkTo>\n        <LinkTo id='parent-child-link' @route='parent.child'>Child</LinkTo>\n        <LinkTo id='parent-link-qp' @route='parent' @query={{hash foo=this.cat}}>Parent</LinkTo>\n        {{outlet}}\n        ");
      this.add('controller:parent.child', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo'];
          this.foo = 'bar';
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#parent-link');
      this.shouldNotBeActive(assert, '#parent-child-link');
      this.shouldNotBeActive(assert, '#parent-link-qp');
      await this.visit('/parent/child?foo=dog');
      this.shouldBeActive(assert, '#parent-link');
      this.shouldNotBeActive(assert, '#parent-link-qp');
    }
    async ['@test it disregards query-params in activeness computation when current-when is specified'](assert) {
      let appLink;
      this.router.map(function () {
        this.route('parent');
      });
      this.addTemplate('application', "\n        <LinkTo id='app-link' @route='parent' @query={{hash page=1}} @current-when='parent'>\n          Parent\n        </LinkTo>\n        {{outlet}}\n        ");
      this.addTemplate('parent', "\n        <LinkTo id='parent-link' @route='parent' @query={{hash page=1}} @current-when='parent'>\n          Parent\n        </LinkTo>\n        {{outlet}}\n        ");
      this.add('controller:parent', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
        }
      });
      await this.visit('/');
      appLink = this.$('#app-link');
      assert.equal(appLink.attr('href'), '/parent');
      this.shouldNotBeActive(assert, '#app-link');
      await this.visit('/parent?page=2');
      appLink = this.$('#app-link');
      let router = this.appRouter;
      assert.equal(appLink.attr('href'), '/parent');
      this.shouldBeActive(assert, '#app-link');
      assert.equal(this.$('#parent-link').attr('href'), '/parent');
      this.shouldBeActive(assert, '#parent-link');
      let parentController = this.getController('parent');
      assert.equal(parentController.get('page'), 2);
      (0, _internalTestHelpers.runTask)(() => parentController.set('page', 3));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(router.get('location.path'), '/parent?page=3');
      this.shouldBeActive(assert, '#app-link');
      this.shouldBeActive(assert, '#parent-link');
      await this.click('#app-link');
      assert.equal(router.get('location.path'), '/parent');
    }
    async ['@test it defaults query params while in active transition regression test'](assert) {
      this.router.map(function () {
        this.route('foos');
        this.route('bars');
      });
      let foos = _runtime.RSVP.defer();
      let bars = _runtime.RSVP.defer();
      this.addTemplate('application', "\n        <LinkTo id='foos-link' @route='foos'>Foos</LinkTo>\n        <LinkTo id='baz-foos-link' @route='foos' @query={{hash baz=true}}>Baz Foos</LinkTo>\n        <LinkTo id='bars-link' @route='bars' @query={{hash quux=true}}>Quux Bars</LinkTo>\n        ");
      this.add('controller:foos', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['status'];
          this.baz = false;
        }
      });
      this.add('route:foos', class extends _route.default {
        model() {
          return foos.promise;
        }
      });
      this.add('controller:bars', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['status'];
          this.quux = false;
        }
      });
      this.add('route:bars', class extends _route.default {
        model() {
          return bars.promise;
        }
      });
      await this.visit('/');
      let router = this.appRouter;
      let foosLink = this.$('#foos-link');
      let barsLink = this.$('#bars-link');
      let bazLink = this.$('#baz-foos-link');
      assert.equal(foosLink.attr('href'), '/foos');
      assert.equal(bazLink.attr('href'), '/foos?baz=true');
      assert.equal(barsLink.attr('href'), '/bars?quux=true');
      assert.equal(router.get('location.path'), '/');
      this.shouldNotBeActive(assert, '#foos-link');
      this.shouldNotBeActive(assert, '#baz-foos-link');
      this.shouldNotBeActive(assert, '#bars-link');
      (0, _internalTestHelpers.runTask)(() => barsLink.click());
      this.shouldNotBeActive(assert, '#bars-link');
      (0, _internalTestHelpers.runTask)(() => foosLink.click());
      this.shouldNotBeActive(assert, '#foos-link');
      (0, _internalTestHelpers.runTask)(() => foos.resolve());
      assert.equal(router.get('location.path'), '/foos');
      this.shouldBeActive(assert, '#foos-link');
    }
    async ['@test it does not throw an error if called without a @route argument, but with a @query argument'](assert) {
      this.addTemplate('index', "\n        <LinkTo @query={{hash page=this.pageNumber}} id=\"page-link\">\n          Index\n        </LinkTo>\n        ");
      this.add('route:index', class extends _route.default {
        model() {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      });
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
          this.pageNumber = 5;
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#page-link');
      await this.visit('/?page=5');
      this.shouldBeActive(assert, '#page-link');
    }
    async ['@test with dynamic segment and loading route, it should preserve query parameters'](assert) {
      this.router.map(function () {
        this.route('foo', {
          path: ':foo'
        }, function () {
          this.route('bar', function () {
            this.route('baz');
          });
        });
      });
      this.addTemplate('foo.bar', "<LinkTo id='baz-link' @route='foo.bar.baz'>Baz</LinkTo>");
      this.addTemplate('foo.bar.loading', 'Loading');
      this.add('controller:foo.bar', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['qux'];
          this.qux = null;
        }
      });
      this.add('route:foo.bar.baz', class extends _route.default {
        model() {
          return new _runtime.RSVP.Promise(resolve => {
            setTimeout(resolve, 1);
          });
        }
      });
      await this.visit('/foo/bar/baz?qux=abc');
      let bazLink = this.$('#baz-link');
      assert.equal(bazLink.attr('href'), '/foo/bar/baz?qux=abc');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/query-params-curly-test", ["@ember/controller", "@ember/-internals/runtime", "@ember/routing/route", "internal-test-helpers"], function (_controller, _runtime, _route, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('{{link-to}} component with query-params (rendering)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123',
        bar: 'yes'
      }));
    }
    async ['@test populates href with fully supplied query param values']() {
      this.addTemplate('index', "{{#link-to route='index' query=(hash foo='456' bar='NAW')}}Index{{/link-to}}");
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/?bar=NAW&foo=456'
        },
        content: 'Index'
      });
    }
    async ['@test it populates href with fully supplied query param values, but without @route param']() {
      this.addTemplate('index', "{{#link-to query=(hash foo='2' bar='NAW')}}QueryParams{{/link-to}}");
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/?bar=NAW&foo=2'
        },
        content: 'QueryParams'
      });
    }
    async ['@test populates href with partially supplied query param values, but omits if value is default value']() {
      this.addTemplate('index', "{{#link-to route='index' query=(hash foo='123')}}Index{{/link-to}}");
      return this.visit('/').then(() => {
        this.assertComponentElement(this.firstChild, {
          tagName: 'a',
          attrs: {
            href: '/',
            class: (0, _internalTestHelpers.classes)('ember-view active')
          },
          content: 'Index'
        });
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component with query params (routing)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      let indexProperties = {
        foo: '123',
        bar: 'abc'
      };
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo', 'bar', 'abool'];
          this.foo = indexProperties.foo;
          this.bar = indexProperties.bar;
          this.boundThing = 'OMG';
          this.abool = true;
        }
      });
      this.add('controller:about', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['baz', 'bat'];
          this.baz = 'alex';
          this.bat = 'borf';
        }
      });
      this.indexProperties = indexProperties;
    }
    shouldNotBeActive(assert, selector) {
      this.checkActive(assert, selector, false);
    }
    shouldBeActive(assert, selector) {
      this.checkActive(assert, selector, true);
    }
    getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    }
    checkActive(assert, selector, active) {
      let classList = this.$(selector)[0].className;
      assert.equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
    }
    async ["@test it doesn't update controller QP properties on current route when invoked"](assert) {
      this.addTemplate('index', "<div id='the-link'>{{#link-to route='index'}}Index{{/link-to}}</div>");
      await this.visit('/');
      await this.click('#the-link > a');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), this.indexProperties, 'controller QP properties do not update');
    }
    async ["@test doesn't update controller QP properties on current route when invoked (empty query-params obj)"](assert) {
      this.addTemplate('index', "<div id='the-link'>{{#link-to route='index' query=(hash)}}Index{{/link-to}}</div>");
      await this.visit('/');
      await this.click('#the-link > a');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), this.indexProperties, 'controller QP properties do not update');
    }
    async ["@test it doesn't update controller QP properties on current route when invoked (empty query-params obj, inferred route)"](assert) {
      this.addTemplate('index', "<div id='the-link'>{{#link-to query=(hash)}}Index{{/link-to}}</div>");
      await this.visit('/');
      await this.click('#the-link > a');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), this.indexProperties, 'controller QP properties do not update');
    }
    async ['@test it updates controller QP properties on current route when invoked'](assert) {
      this.addTemplate('index', "\n        <div id=\"the-link\">\n          {{#link-to route='index' query=(hash foo='456')}}\n            Index\n          {{/link-to}}\n        </div>\n        ");
      await this.visit('/');
      await this.click('#the-link > a');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), {
        foo: '456',
        bar: 'abc'
      }, 'controller QP properties updated');
    }
    async ['@test it updates controller QP properties on current route when invoked (inferred route)'](assert) {
      this.addTemplate('index', "\n        <div id=\"the-link\">\n          {{#link-to query=(hash foo='456')}}\n            Index\n          {{/link-to}}\n        </div>\n        ");
      await this.visit('/');
      await this.click('#the-link > a');
      let indexController = this.getController('index');
      assert.deepEqual(indexController.getProperties('foo', 'bar'), {
        foo: '456',
        bar: 'abc'
      }, 'controller QP properties updated');
    }
    async ['@test it updates controller QP properties on other route after transitioning to that route'](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <div id='the-link'>\n          {{#link-to route='about' query=(hash baz='lol')}}\n            About\n          {{/link-to}}\n        </div>\n        ");
      await this.visit('/');
      let theLink = this.$('#the-link > a');
      assert.equal(theLink.attr('href'), '/about?baz=lol');
      (0, _internalTestHelpers.runTask)(() => this.click('#the-link > a'));
      let aboutController = this.getController('about');
      assert.deepEqual(aboutController.getProperties('baz', 'bat'), {
        baz: 'lol',
        bat: 'borf'
      }, 'about controller QP properties updated');
    }
    async ['@test supplied QP properties can be bound'](assert) {
      this.addTemplate('index', "<div id='the-link'>{{#link-to query=(hash foo=this.boundThing)}}Index{{/link-to}}</div>");
      await this.visit('/');
      let indexController = this.getController('index');
      let theLink = this.$('#the-link > a');
      assert.equal(theLink.attr('href'), '/?foo=OMG');
      (0, _internalTestHelpers.runTask)(() => indexController.set('boundThing', 'ASL'));
      assert.equal(theLink.attr('href'), '/?foo=ASL');
    }
    async ['@test supplied QP properties can be bound (booleans)'](assert) {
      this.addTemplate('index', "\n        <div id='the-link'>\n          {{#link-to query=(hash abool=this.boundThing)}}\n            Index\n          {{/link-to}}\n        </div>\n        ");
      await this.visit('/');
      let indexController = this.getController('index');
      let theLink = this.$('#the-link > a');
      assert.equal(theLink.attr('href'), '/?abool=OMG');
      (0, _internalTestHelpers.runTask)(() => indexController.set('boundThing', false));
      assert.equal(theLink.attr('href'), '/?abool=false');
      await this.click('#the-link > a');
      assert.deepEqual(indexController.getProperties('foo', 'bar', 'abool'), {
        foo: '123',
        bar: 'abc',
        abool: false
      }, 'bound bool QP properties update');
    }
    async ['@test href updates when unsupplied controller QP props change'](assert) {
      this.addTemplate('index', "\n        <div id='the-link'>\n          {{#link-to query=(hash foo='lol')}}Index{{/link-to}}\n        </div>\n        ");
      await this.visit('/');
      let indexController = this.getController('index');
      let theLink = this.$('#the-link > a');
      assert.equal(theLink.attr('href'), '/?foo=lol');
      (0, _internalTestHelpers.runTask)(() => indexController.set('bar', 'BORF'));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
      (0, _internalTestHelpers.runTask)(() => indexController.set('foo', 'YEAH'));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
    }
    async ['@test [GH#12033] with only query params, it always transitions to the current route with the query params applied'](assert) {
      this.addTemplate('cars', "\n        <div id='create-link'>{{#link-to route='cars.create'}}Create new car{{/link-to}}</div>\n        <div id='page2-link'>{{#link-to query=(hash page='2')}}Page 2{{/link-to}}</div>\n        {{outlet}}\n        ");
      this.addTemplate('cars.create', "<div id='close-link'>{{#link-to route='cars'}}Close create form{{/link-to}}</div>");
      this.router.map(function () {
        this.route('cars', function () {
          this.route('create');
        });
      });
      this.add('controller:cars', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
        }
      });
      await this.visit('/cars/create');
      let router = this.appRouter;
      let carsController = this.getController('cars');
      assert.equal(router.currentRouteName, 'cars.create');
      (0, _internalTestHelpers.runTask)(() => this.click('#close-link > a'));
      assert.equal(router.currentRouteName, 'cars.index');
      assert.equal(router.get('url'), '/cars');
      assert.equal(carsController.get('page'), 1, 'The page query-param is 1');
      (0, _internalTestHelpers.runTask)(() => this.click('#page2-link > a'));
      assert.equal(router.currentRouteName, 'cars.index', 'The active route is still cars');
      assert.equal(router.get('url'), '/cars?page=2', 'The url has been updated');
      assert.equal(carsController.get('page'), 2, 'The query params have been updated');
    }
    async ['@test it applies activeClass when query params are not changed'](assert) {
      this.addTemplate('index', "\n        <div id='cat-link'>{{#link-to query=(hash foo='cat')}}Index{{/link-to}}</div>\n        <div id='dog-link'>{{#link-to query=(hash foo='dog')}}Index{{/link-to}}</div>\n        <div id='change-nothing'>{{#link-to route='index'}}Index{{/link-to}}</div>\n        ");
      this.addTemplate('search', "\n        <div id='same-search'>{{#link-to query=(hash search='same')}}Index{{/link-to}}</div>\n        <div id='change-search'>{{#link-to query=(hash search='change')}}Index{{/link-to}}</div>\n        <div id='same-search-add-archive'>{{#link-to query=(hash search='same' archive=true)}}Index{{/link-to}}</div>\n        <div id='only-add-archive'>{{#link-to query=(hash archive=true)}}Index{{/link-to}}</div>\n        <div id='both-same'>{{#link-to query=(hash search='same' archive=true)}}Index{{/link-to}}</div>\n        <div id='change-one'>{{#link-to query=(hash search='different' archive=true)}}Index{{/link-to}}</div>\n        <div id='remove-one'>{{#link-to query=(hash search='different' archive=false)}}Index{{/link-to}}</div>\n        {{outlet}}\n        ");
      this.addTemplate('search.results', "\n        <div id='same-sort-child-only'>{{#link-to query=(hash sort='title')}}Index{{/link-to}}</div>\n        <div id='same-search-parent-only'>{{#link-to query=(hash search='same')}}Index{{/link-to}}</div>\n        <div id='change-search-parent-only'>{{#link-to query=(hash search='change')}}Index{{/link-to}}</div>\n        <div id='same-search-same-sort-child-and-parent'>{{#link-to query=(hash search='same' sort='title')}}Index{{/link-to}}</div>\n        <div id='same-search-different-sort-child-and-parent'>{{#link-to query=(hash search='same' sort='author')}}Index{{/link-to}}</div>\n        <div id='change-search-same-sort-child-and-parent'>{{#link-to query=(hash search='change' sort='title')}}Index{{/link-to}}</div>\n        <div id='dog-link'>{{#link-to query=(hash foo='dog')}}Index{{/link-to}}</div>\n        ");
      this.router.map(function () {
        this.route('search', function () {
          this.route('results');
        });
      });
      this.add('controller:search', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['search', 'archive'];
          this.search = '';
          this.archive = false;
        }
      });
      this.add('controller:search.results', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['sort', 'showDetails'];
          this.sort = 'title';
          this.showDetails = true;
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#cat-link > a');
      this.shouldNotBeActive(assert, '#dog-link > a');
      await this.visit('/?foo=cat');
      this.shouldBeActive(assert, '#cat-link > a');
      this.shouldNotBeActive(assert, '#dog-link > a');
      await this.visit('/?foo=dog');
      this.shouldBeActive(assert, '#dog-link > a');
      this.shouldNotBeActive(assert, '#cat-link > a');
      this.shouldBeActive(assert, '#change-nothing > a');
      await this.visit('/search?search=same');
      this.shouldBeActive(assert, '#same-search > a');
      this.shouldNotBeActive(assert, '#change-search > a');
      this.shouldNotBeActive(assert, '#same-search-add-archive > a');
      this.shouldNotBeActive(assert, '#only-add-archive > a');
      this.shouldNotBeActive(assert, '#remove-one > a');
      await this.visit('/search?search=same&archive=true');
      this.shouldBeActive(assert, '#both-same > a');
      this.shouldNotBeActive(assert, '#change-one > a');
      await this.visit('/search/results?search=same&sort=title&showDetails=true');
      this.shouldBeActive(assert, '#same-sort-child-only > a');
      this.shouldBeActive(assert, '#same-search-parent-only > a');
      this.shouldNotBeActive(assert, '#change-search-parent-only > a');
      this.shouldBeActive(assert, '#same-search-same-sort-child-and-parent > a');
      this.shouldNotBeActive(assert, '#same-search-different-sort-child-and-parent > a');
      this.shouldNotBeActive(assert, '#change-search-same-sort-child-and-parent > a');
    }
    async ['@test it applies active class when query-param is a number'](assert) {
      this.addTemplate('index', "\n        <div id='page-link'>\n          {{#link-to query=(hash page=this.pageNumber)}}\n            Index\n          {{/link-to}}\n        </div>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
          this.pageNumber = 5;
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#page-link > a');
      await this.visit('/?page=5');
      this.shouldBeActive(assert, '#page-link > a');
    }
    async ['@test it applies active class when query-param is an array'](assert) {
      this.addTemplate('index', "\n        <div id='array-link'>{{#link-to query=(hash pages=this.pagesArray)}}Index{{/link-to}}</div>\n        <div id='bigger-link'>{{#link-to query=(hash pages=this.biggerArray)}}Index{{/link-to}}</div>\n        <div id='empty-link'>{{#link-to query=(hash pages=this.emptyArray)}}Index{{/link-to}}</div>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['pages'];
          this.pages = [];
          this.pagesArray = [1, 2];
          this.biggerArray = [1, 2, 3];
          this.emptyArray = [];
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#array-link > a');
      await this.visit('/?pages=%5B1%2C2%5D');
      this.shouldBeActive(assert, '#array-link > a');
      this.shouldNotBeActive(assert, '#bigger-link > a');
      this.shouldNotBeActive(assert, '#empty-link > a');
      await this.visit('/?pages=%5B2%2C1%5D');
      this.shouldNotBeActive(assert, '#array-link > a');
      this.shouldNotBeActive(assert, '#bigger-link > a');
      this.shouldNotBeActive(assert, '#empty-link > a');
      await this.visit('/?pages=%5B1%2C2%2C3%5D');
      this.shouldBeActive(assert, '#bigger-link > a');
      this.shouldNotBeActive(assert, '#array-link > a');
      this.shouldNotBeActive(assert, '#empty-link > a');
    }
    async ['@test it applies active class to the parent route'](assert) {
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.addTemplate('application', "\n        <div id='parent-link'>{{#link-to route='parent'}}Parent{{/link-to}}</div>\n        <div id='parent-child-link'>{{#link-to route='parent.child'}}P}}Child{{/link-to}}</div>\n        <div id='parent-link-qp'>{{#link-to route='parent' query=(hash foo=this.cat)}}P}}Parent{{/link-to}}</div>\n        {{outlet}}\n        ");
      this.add('controller:parent.child', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo'];
          this.foo = 'bar';
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#parent-link > a');
      this.shouldNotBeActive(assert, '#parent-child-link > a');
      this.shouldNotBeActive(assert, '#parent-link-qp > a');
      await this.visit('/parent/child?foo=dog');
      this.shouldBeActive(assert, '#parent-link > a');
      this.shouldNotBeActive(assert, '#parent-link-qp > a');
    }
    async ['@test it disregards query-params in activeness computation when current-when is specified'](assert) {
      let appLink;
      this.router.map(function () {
        this.route('parent');
      });
      this.addTemplate('application', "\n        <div id='app-link'>\n          {{#link-to route='parent' query=(hash page=1) current-when='parent'}}\n            Parent\n          {{/link-to}}\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('parent', "\n        <div id='parent-link'>\n          {{#link-to route='parent' query=(hash page=1) current-when='parent'}}\n            Parent\n          {{/link-to}}\n        </div>\n        {{outlet}}\n        ");
      this.add('controller:parent', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
        }
      });
      await this.visit('/');
      appLink = this.$('#app-link > a');
      assert.equal(appLink.attr('href'), '/parent');
      this.shouldNotBeActive(assert, '#app-link > a');
      await this.visit('/parent?page=2');
      appLink = this.$('#app-link > a');
      let router = this.appRouter;
      assert.equal(appLink.attr('href'), '/parent');
      this.shouldBeActive(assert, '#app-link > a');
      assert.equal(this.$('#parent-link > a').attr('href'), '/parent');
      this.shouldBeActive(assert, '#parent-link > a');
      let parentController = this.getController('parent');
      assert.equal(parentController.get('page'), 2);
      (0, _internalTestHelpers.runTask)(() => parentController.set('page', 3));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(router.get('location.path'), '/parent?page=3');
      this.shouldBeActive(assert, '#app-link > a');
      this.shouldBeActive(assert, '#parent-link > a');
      await this.click('#app-link > a');
      assert.equal(router.get('location.path'), '/parent');
    }
    async ['@test it defaults query params while in active transition regression test'](assert) {
      this.router.map(function () {
        this.route('foos');
        this.route('bars');
      });
      let foos = _runtime.RSVP.defer();
      let bars = _runtime.RSVP.defer();
      this.addTemplate('application', "\n        <div id='foos-link'>{{#link-to route='foos'}}Foos{{/link-to}}</div>\n        <div id='baz-foos-link'>{{#link-to route='foos' query=(hash baz=true)}}Baz Foos{{/link-to}}</div>\n        <div id='bars-link'>{{#link-to route='bars' query=(hash quux=true)}}Quux Bars{{/link-to}}</div>\n        ");
      this.add('controller:foos', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['status'];
          this.baz = false;
        }
      });
      this.add('route:foos', class extends _route.default {
        model() {
          return foos.promise;
        }
      });
      this.add('controller:bars', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['status'];
          this.quux = false;
        }
      });
      this.add('route:bars', class extends _route.default {
        model() {
          return bars.promise;
        }
      });
      await this.visit('/');
      let router = this.appRouter;
      let foosLink = this.$('#foos-link > a');
      let barsLink = this.$('#bars-link > a');
      let bazLink = this.$('#baz-foos-link > a');
      assert.equal(foosLink.attr('href'), '/foos');
      assert.equal(bazLink.attr('href'), '/foos?baz=true');
      assert.equal(barsLink.attr('href'), '/bars?quux=true');
      assert.equal(router.get('location.path'), '/');
      this.shouldNotBeActive(assert, '#foos-link > a');
      this.shouldNotBeActive(assert, '#baz-foos-link > a');
      this.shouldNotBeActive(assert, '#bars-link > a');
      (0, _internalTestHelpers.runTask)(() => barsLink.click());
      this.shouldNotBeActive(assert, '#bars-link > a');
      (0, _internalTestHelpers.runTask)(() => foosLink.click());
      this.shouldNotBeActive(assert, '#foos-link > a');
      (0, _internalTestHelpers.runTask)(() => foos.resolve());
      assert.equal(router.get('location.path'), '/foos');
      this.shouldBeActive(assert, '#foos-link > a');
    }
    async ['@test it does not throw an error if called without a @route argument, but with a @query argument'](assert) {
      this.addTemplate('index', "\n        <div id='page-link'>\n          {{#link-to query=(hash page=this.pageNumber)}}\n            Index\n          {{/link-to}}\n        </div>\n        ");
      this.add('route:index', class extends _route.default {
        model() {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      });
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['page'];
          this.page = 1;
          this.pageNumber = 5;
        }
      });
      await this.visit('/');
      this.shouldNotBeActive(assert, '#page-link > a');
      await this.visit('/?page=5');
      this.shouldBeActive(assert, '#page-link > a');
    }
    async ['@test with dynamic segment and loading route, it should preserve query parameters'](assert) {
      this.router.map(function () {
        this.route('foo', {
          path: ':foo'
        }, function () {
          this.route('bar', function () {
            this.route('baz');
          });
        });
      });
      this.addTemplate('foo.bar', "<div id='baz-link'>{{#link-to route='foo.bar.baz'}}Baz{{/link-to}}</div>");
      this.addTemplate('foo.bar.loading', 'Loading');
      this.add('controller:foo.bar', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['qux'];
          this.qux = null;
        }
      });
      this.add('route:foo.bar.baz', class extends _route.default {
        model() {
          return new _runtime.RSVP.Promise(resolve => {
            setTimeout(resolve, 1);
          });
        }
      });
      await this.visit('/foo/bar/baz?qux=abc');
      let bazLink = this.$('#baz-link > a');
      assert.equal(bazLink.attr('href'), '/foo/bar/baz?qux=abc');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/rendering-angle-test", ["internal-test-helpers", "@ember/routing/router", "@ember/routing/route", "@ember/controller", "@ember/object"], function (_internalTestHelpers, _router, _route, _controller, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (rendering tests)', class extends _internalTestHelpers.ApplicationTestCase {
    async ["@test it throws a useful error if you invoke it wrong"](assert) {
      this.addTemplate('application', "<LinkTo>Index</LinkTo>");
      return assert.rejectsAssertion(this.visit('/'), /You must provide at least one of the `@route`, `@model`, `@models` or `@query` arguments to `<LinkTo>`/);
    }
    async ["@test it throws a useful error if you pass the href argument"](assert) {
      this.addTemplate('application', "<LinkTo @href=\"nope\" @route=\"index\">Index</LinkTo>");
      if (false /* DEBUG */) {
        await assert.rejects(this.visit('/'), /Passing the `@href` argument to <LinkTo> is not supported\./);
      } else {
        assert.expect(0);
      }
    }
    async ['@test it should be able to be inserted in DOM when the router is not present']() {
      this.addTemplate('application', "<LinkTo @route='index'>Go to Index</LinkTo>");
      await this.visit('/');
      this.assertText('Go to Index');
    }
    async ['@test it re-renders when title changes']() {
      let controller;
      this.addTemplate('application', "<LinkTo @route='index'>{{this.title}}</LinkTo>");
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.title = 'foo';
          controller = this;
        }
      });
      await this.visit('/');
      this.assertText('foo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'title', 'bar'));
      this.assertText('bar');
    }
    async ['@test it re-computes active class when params change'](assert) {
      let controller;
      this.addTemplate('application', '<LinkTo @route={{this.routeName}}>foo</LinkTo>');
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.routeName = 'index';
          controller = this;
        }
      });
      this.router.map(function () {
        this.route('bar', {
          path: '/bar'
        });
      });
      await this.visit('/bar');
      assert.equal(this.firstChild.classList.contains('active'), false);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'routeName', 'bar'));
      assert.equal(this.firstChild.classList.contains('active'), true);
    }
    async ['@test able to popolate innermost dynamic segment when immediate parent route is active']() {
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('parents', '{{outlet}}');
      this.addTemplate('parents.parent', '<LinkTo @route="parents.parent.child" @model=1>Link To Child</LinkTo>');
      this.addTemplate('parents.parent.child', '<LinkTo @route="parents.parent">Link To Parent</LinkTo>');
      this.add('route:parents.parent', class extends _route.default {
        async model(_ref) {
          let {
            id
          } = _ref;
          return {
            value: id
          };
        }
      });
      this.router.map(function () {
        this.route('parents', function () {
          this.route('parent', {
            path: '/:parent_id'
          }, function () {
            this.route('children');
            this.route('child', {
              path: '/child/:child_id'
            });
          });
        });
      });
      await this.visit('/parents/1');
      this.assertText('Link To Child');
    }
  });
  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (rendering tests, without router)', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it should be able to be inserted in DOM when the router is not present - block']() {
      this.render("<LinkTo @route='index'>Go to Index</LinkTo>");
      this.assertComponentElement(this.element.firstChild, {
        tagName: 'a',
        attrs: {
          href: '#/'
        },
        content: 'Go to Index'
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (rendering tests, with router not started)', class extends _internalTestHelpers.RouterNonApplicationTestCase {
    constructor() {
      super(...arguments);
      this.resolver.add('router:main', _router.default.extend(this.routerOptions));
      this.router.map(function () {
        this.route('dynamicWithChild', {
          path: '/dynamic-with-child/:dynamic_id'
        }, function () {
          this.route('child');
        });
      });
    }
    get routerOptions() {
      return {
        location: 'none'
      };
    }
    get router() {
      return this.owner.resolveRegistration('router:main');
    }
    ['@test it should be able to be inserted in DOM when initial transition not started']() {
      this.render("<LinkTo @route=\"dynamicWithChild.child\">Link</LinkTo>");
      this.assertComponentElement(this.element.firstChild, {
        tagName: 'a',
        attrs: {
          href: null
        },
        content: 'Link'
      });
    }
    ['@test it should be able to be inserted in DOM with valid href when complete models are passed even if initial transition is not started']() {
      this.render("<LinkTo @route=\"dynamicWithChild.child\" @model=\"1\">Link</LinkTo>");
      this.assertComponentElement(this.element.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/dynamic-with-child/1/child'
        },
        content: 'Link'
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/rendering-curly-test", ["internal-test-helpers", "@ember/controller", "@ember/object"], function (_internalTestHelpers, _controller, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (rendering tests)', class extends _internalTestHelpers.ApplicationTestCase {
    async ["@test it throws a useful error if you invoke it wrong"](assert) {
      this.addTemplate('application', "{{#link-to}}Index{{/link-to}}");
      if (false /* DEBUG */) {
        await assert.rejects(this.visit('/'), /You must provide at least one of the `@route`, `@model`, `@models` or `@query` arguments to `<LinkTo>`./);
      } else {
        assert.expect(0);
      }
    }
    async ["@test it throws a useful error if you pass the href argument"](assert) {
      this.addTemplate('application', "{{#link-to href=\"nope\" route=\"index\"}}Index{{/link-to}}");
      if (false /* DEBUG */) {
        await assert.rejects(this.visit('/'), /Passing the `@href` argument to <LinkTo> is not supported\./);
      } else {
        assert.expect(0);
      }
    }
    async ['@test it should be able to be inserted in DOM when the router is not present']() {
      this.addTemplate('application', "{{#link-to route='index'}}Go to Index{{/link-to}}");
      await this.visit('/');
      this.assertText('Go to Index');
    }
    async ['@test it re-renders when title changes']() {
      let controller;
      this.addTemplate('application', "{{#link-to route='index'}}{{this.title}}{{/link-to}}");
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.title = 'foo';
          controller = this;
        }
      });
      await this.visit('/');
      this.assertText('foo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'title', 'bar'));
      this.assertText('bar');
    }
    async ['@test it re-computes active class when params change'](assert) {
      let controller;
      this.addTemplate('application', '{{#link-to route=this.routeName}}foo{{/link-to}}');
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.routeName = 'index';
          controller = this;
        }
      });
      this.router.map(function () {
        this.route('bar', {
          path: '/bar'
        });
      });
      await this.visit('/bar');
      assert.equal(this.firstChild.classList.contains('active'), false);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'routeName', 'bar'));
      assert.equal(this.firstChild.classList.contains('active'), true);
    }
  });
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (rendering tests, without router)', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it should be able to be inserted in DOM when the router is not present - block']() {
      this.render("{{#link-to route='index'}}Go to Index{{/link-to}}");
      this.assertText('Go to Index');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/routing-angle-test", ["internal-test-helpers", "@ember/controller", "@ember/array", "@ember/-internals/runtime", "@ember/routing/route", "@ember/routing/none-location", "@ember/service", "@ember/engine", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _controller, _array, _runtime, _route, _noneLocation, _service, _engine, _helpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  // IE includes the host name
  function normalizeUrl(url) {
    return url.replace(/https?:\/\/[^/]+/, '');
  }
  function shouldNotBeActive(assert, element) {
    checkActive(assert, element, false);
  }
  function shouldBeActive(assert, element) {
    checkActive(assert, element, true);
  }
  function checkActive(assert, element, active) {
    let classList = element.attr('class');
    assert.equal(classList.indexOf('active') > -1, active, element + " active should be " + active);
  }
  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (routing tests)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo @route='about' id='about-link'>About</LinkTo>\n        <LinkTo @route='index' id='self-link'>Self</LinkTo>\n        ");
      this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        <LinkTo @route='index' id='home-link'>Home</LinkTo>\n        <LinkTo @route='about' id='self-link'>Self</LinkTo>\n        ");
    }
    async ['@test it navigates into the named route'](assert) {
      await this.visit('/');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
      await this.click('#about-link');
      assert.equal(this.$('h3.about').length, 1, 'The about template was rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
    }
    async ['@test [GH#19546] it navigates into the named route when containing other elements'](assert) {
      this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        <LinkTo @route='index' id='home-link'><span id='inside'>Home</span></LinkTo>\n        <LinkTo @route='about' id='self-link'>Self</LinkTo>\n        ");
      await this.visit('/about');
      assert.equal(this.$('h3.about').length, 1, 'The about template was rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
      await this.click('#inside');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
    }
    async ["@test it applies a 'disabled' class when disabled"](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"about-link-static\" @route=\"about\" @disabled=\"truthy\">About</LinkTo>\n        <LinkTo id=\"about-link-dynamic\" @route=\"about\" @disabled={{this.dynamicDisabled}}>About</LinkTo>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.dynamicDisabled = true;
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('#about-link-static.disabled').length, 1, 'The static link is disabled when its disabled is true');
      assert.equal(this.$('#about-link-dynamic.disabled').length, 1, 'The dynamic link is disabled when its disabled is true');
      (0, _internalTestHelpers.runTask)(() => controller.set('dynamicDisabled', false));
      assert.equal(this.$('#about-link-static.disabled').length, 1, 'The static link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-dynamic.disabled').length, 0, 'The dynamic link is re-enabled when its disabled becomes false');
    }
    async ["@test it doesn't apply a 'disabled' class when not disabled"](assert) {
      this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\">About</LinkTo>");
      await this.visit('/');
      assert.ok(!this.$('#about-link').hasClass('disabled'), 'The link is not disabled if disabled was not provided');
    }
    async ["@test it supports a custom disabledClass"](assert) {
      this.addTemplate('index', "\n        <LinkTo id=\"about-link-static\" @route=\"about\" @disabledClass=\"do-not-want\" @disabled={{true}}>About</LinkTo>\n        <LinkTo id=\"about-link-dynamic\" @route=\"about\" @disabledClass=\"do-not-want\" @disabled={{this.dynamicDisabled}}>About</LinkTo>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.dynamicDisabled = true;
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('#about-link-static.do-not-want').length, 1, 'The static link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-dynamic.do-not-want').length, 1, 'The dynamic link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-static.disabled').length, 0, 'The default disabled class is not added on the static link');
      assert.strictEqual(this.$('#about-link-dynamic.disabled').length, 0, 'The default disabled class is not added on the dynamic link');
      (0, _internalTestHelpers.runTask)(() => controller.set('dynamicDisabled', false));
      assert.equal(this.$('#about-link-static.do-not-want').length, 1, 'The static link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-dynamic.disabled').length, 0, 'The dynamic link is re-enabled when its disabled becomes false');
      assert.strictEqual(this.$('#about-link-static.disabled').length, 0, 'The default disabled class is not added on the static link');
      assert.strictEqual(this.$('#about-link-dynamic.disabled').length, 0, 'The default disabled class is not added on the dynamic link');
    }
    async ["@test it supports a custom disabledClass set via bound param"](assert) {
      this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabledClass={{this.disabledClass}} @disabled={{true}}>About</LinkTo>");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.disabledClass = 'do-not-want';
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class via bound param');
      assert.strictEqual(this.$('#about-link.disabled').length, 0, 'The default disabled class is not added');
      (0, _internalTestHelpers.runTask)(() => controller.set('disabledClass', 'can-not-use'));
      assert.equal(this.$('#about-link.can-not-use').length, 1, 'The link can apply a custom disabled class via bound param');
      assert.strictEqual(this.$('#about-link.do-not-want').length, 0, 'The old class is removed');
      assert.strictEqual(this.$('#about-link.disabled').length, 0, 'The default disabled class is not added');
    }
    async ["@test it does not respond to clicks when disabled"](assert) {
      this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabled={{true}}>About</LinkTo>");
      await this.visit('/');
      await this.click('#about-link');
      assert.strictEqual(this.$('h3.about').length, 0, 'Transitioning did not occur');
    }
    async ["@test it responds to clicks according to its disabled bound param"](assert) {
      this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabled={{this.dynamicDisabled}}>About</LinkTo>");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.dynamicDisabled = true;
          controller = this;
        }
      });
      await this.visit('/');
      await this.click('#about-link');
      assert.strictEqual(this.$('h3.about').length, 0, 'Transitioning did not occur');
      (0, _internalTestHelpers.runTask)(() => controller.set('dynamicDisabled', false));
      await this.click('#about-link');
      assert.equal(this.$('h3.about').length, 1, 'Transitioning did occur when disabled became false');
    }
    async ["@test it supports a custom activeClass"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about' @activeClass='zomg-active'>About</LinkTo>\n        <LinkTo id='self-link' @route='index' @activeClass='zomg-active'>Self</LinkTo>\n        ");
      await this.visit('/');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link:not(.zomg-active)').length, 1, 'The other link was rendered without active class');
      assert.strictEqual(this.$('#self-link.active').length, 0, 'The self-link was rendered without the default active class');
      assert.strictEqual(this.$('#about-link.active').length, 0, 'The other link was rendered without the default active class');
    }
    async ["@test it supports a custom activeClass from a bound param"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about' @activeClass={{this.activeClass}}>About</LinkTo>\n        <LinkTo id='self-link' @route='index' @activeClass={{this.activeClass}}>Self</LinkTo>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.activeClass = 'zomg-active';
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link:not(.zomg-active)').length, 1, 'The other link was rendered without active class');
      assert.strictEqual(this.$('#self-link.active').length, 0, 'The self-link was rendered without the default active class');
      assert.strictEqual(this.$('#about-link.active').length, 0, 'The other link was rendered without the default active class');
      (0, _internalTestHelpers.runTask)(() => controller.set('activeClass', 'wow-active'));
      assert.equal(this.$('#self-link.wow-active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link:not(.wow-active)').length, 1, 'The other link was rendered without active class');
      assert.strictEqual(this.$('#self-link.zomg-active').length, 0, 'The self-link was rendered without the previous active class');
      assert.strictEqual(this.$('#self-link.active').length, 0, 'The self-link was rendered without the default active class');
      assert.strictEqual(this.$('#about-link.active').length, 0, 'The other link was rendered without the default active class');
    }
    async ['@test Using <LinkTo> inside a non-routable engine errors'](assert) {
      this.add('engine:not-routable', class NotRoutableEngine extends _engine.default {
        constructor() {
          super(...arguments);
          this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
        }
        init() {
          super.init(...arguments);
          this.register('template:application', (0, _helpers.compile)("<LinkTo @route='about'>About</LinkTo>", {
            moduleName: 'non-routable/templates/application.hbs'
          }));
        }
      });
      this.addTemplate('index', "{{mount 'not-routable'}}");
      await assert.rejectsAssertion(this.visit('/'), 'You attempted to use the <LinkTo> component within a routeless engine, this is not supported. ' + 'If you are using the ember-engines addon, use the <LinkToExternal> component instead. ' + 'See https://ember-engines.com/docs/links for more info.');
    }
    async ['@test Using <LinkTo> inside a routable engine link within the engine'](assert) {
      this.add('engine:routable', class RoutableEngine extends _engine.default {
        constructor() {
          super(...arguments);
          this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
        }
        init() {
          super.init(...arguments);
          this.register('template:application', (0, _helpers.compile)("\n                <h2 id='engine-layout'>Routable Engine</h2>\n                {{outlet}}\n                <LinkTo @route='application' id='engine-application-link'>Engine Appliction</LinkTo>\n                ", {
            moduleName: 'routable/templates/application.hbs'
          }));
          this.register('template:index', (0, _helpers.compile)("\n                <h3 class='engine-home'>Engine Home</h3>\n                <LinkTo @route='about' id='engine-about-link'>Engine About</LinkTo>\n                <LinkTo @route='index' id='engine-self-link'>Engine Self</LinkTo>\n                ", {
            moduleName: 'routable/templates/index.hbs'
          }));
          this.register('template:about', (0, _helpers.compile)("\n                <h3 class='engine-about'>Engine About</h3>\n                <LinkTo @route='index' id='engine-home-link'>Engine Home</LinkTo>\n                <LinkTo @route='about' id='engine-self-link'>Engine Self</LinkTo>\n                ", {
            moduleName: 'routable/templates/about.hbs'
          }));
        }
      });
      this.router.map(function () {
        this.mount('routable');
      });
      this.add('route-map:routable', function () {
        this.route('about');
      });
      this.addTemplate('application', "\n        <h1 id='application-layout'>Application</h1>\n        {{outlet}}\n        <LinkTo @route='application' id='application-link'>Appliction</LinkTo>\n        <LinkTo @route='routable' id='engine-link'>Engine</LinkTo>\n        ");
      await this.visit('/');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.strictEqual(this.$('#engine-layout').length, 0, 'The engine layout was not rendered');
      assert.equal(this.$('#application-link.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link:not(.active)').length, 1, 'The engine link is not active');
      assert.equal(this.$('h3.home').length, 1, 'The application index page is rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The application index link is active');
      assert.equal(this.$('#about-link:not(.active)').length, 1, 'The application about link is not active');
      await this.click('#about-link');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.strictEqual(this.$('#engine-layout').length, 0, 'The engine layout was not rendered');
      assert.equal(this.$('#application-link.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link:not(.active)').length, 1, 'The engine link is not active');
      assert.equal(this.$('h3.about').length, 1, 'The application about page is rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The application about link is active');
      assert.equal(this.$('#home-link:not(.active)').length, 1, 'The application home link is not active');
      await this.click('#engine-link');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.equal(this.$('#engine-layout').length, 1, 'The engine layout was rendered');
      assert.equal(this.$('#application-link.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link.active').length, 1, 'The engine link is active');
      assert.equal(this.$('#engine-application-link.active').length, 1, 'The engine application link is active');
      assert.equal(this.$('h3.engine-home').length, 1, 'The engine index page is rendered');
      assert.equal(this.$('#engine-self-link.active').length, 1, 'The engine index link is active');
      assert.equal(this.$('#engine-about-link:not(.active)').length, 1, 'The engine about link is not active');
      await this.click('#engine-about-link');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.equal(this.$('#engine-layout').length, 1, 'The engine layout was rendered');
      assert.equal(this.$('#application-link.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link.active').length, 1, 'The engine link is active');
      assert.equal(this.$('#engine-application-link.active').length, 1, 'The engine application link is active');
      assert.equal(this.$('h3.engine-about').length, 1, 'The engine about page is rendered');
      assert.equal(this.$('#engine-self-link.active').length, 1, 'The engine about link is active');
      assert.equal(this.$('#engine-home-link:not(.active)').length, 1, 'The engine home link is not active');
      await this.click('#engine-application-link');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.equal(this.$('#engine-layout').length, 1, 'The engine layout was rendered');
      assert.equal(this.$('#application-link.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link.active').length, 1, 'The engine link is active');
      assert.equal(this.$('#engine-application-link.active').length, 1, 'The engine application link is active');
      assert.equal(this.$('h3.engine-home').length, 1, 'The engine index page is rendered');
      assert.equal(this.$('#engine-self-link.active').length, 1, 'The engine index link is active');
      assert.equal(this.$('#engine-about-link:not(.active)').length, 1, 'The engine about link is not active');
      await this.click('#application-link');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.strictEqual(this.$('#engine-layout').length, 0, 'The engine layout was not rendered');
      assert.equal(this.$('#application-link.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link:not(.active)').length, 1, 'The engine link is not active');
      assert.equal(this.$('h3.home').length, 1, 'The application index page is rendered');
      assert.equal(this.$('#self-link.active').length, 1, 'The application index link is active');
      assert.equal(this.$('#about-link:not(.active)').length, 1, 'The application about link is not active');
    }
  });
  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (routing tests - location hooks)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      this.updateCount = 0;
      this.replaceCount = 0;
      let testContext = this;
      this.add('location:none', class extends _noneLocation.default {
        setURL() {
          testContext.updateCount++;
          return super.setURL(...arguments);
        }
        replaceURL() {
          testContext.replaceCount++;
          return super.setURL(...arguments);
        }
      });
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about'>About</LinkTo>\n        <LinkTo id='self-link' @route='index'>Self</LinkTo>\n        ");
      this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        <LinkTo id='home-link' @route='index'>Home</LinkTo>\n        <LinkTo id='self-link' @route='about'>Self</LinkTo>\n        ");
    }
    async visit() {
      await super.visit(...arguments);
      this.updateCountAfterVisit = this.updateCount;
      this.replaceCountAfterVisit = this.replaceCount;
    }
    async ['@test it supports URL replacement'](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about' @replace={{true}}>About</LinkTo>\n        ");
      await this.visit('/');
      await this.click('#about-link');
      assert.strictEqual(this.updateCount, this.updateCountAfterVisit, 'setURL should not be called');
      assert.strictEqual(this.replaceCount, this.replaceCountAfterVisit + 1, 'replaceURL should be called once');
    }
    async ['@test it supports URL replacement via replace=boundTruthyThing'](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about' @replace={{this.boundTruthyThing}}>About</LinkTo>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.boundTruthyThing = true;
        }
      });
      await this.visit('/');
      await this.click('#about-link');
      assert.strictEqual(this.updateCount, this.updateCountAfterVisit, 'setURL should not be called');
      assert.strictEqual(this.replaceCount, this.replaceCountAfterVisit + 1, 'replaceURL should be called once');
    }
    async ['@test it supports setting replace=boundFalseyThing'](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about' replace={{this.boundFalseyThing}}>About</LinkTo>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.boundFalseyThing = false;
        }
      });
      await this.visit('/');
      await this.click('#about-link');
      assert.strictEqual(this.updateCount, this.updateCountAfterVisit + 1, 'setURL should be called');
      assert.strictEqual(this.replaceCount, this.replaceCountAfterVisit, 'replaceURL should not be called');
    }
  });
  (0, _internalTestHelpers.moduleFor)('The <LinkTo /> component - nested routes and link-to arguments', class extends _internalTestHelpers.ApplicationTestCase {
    async ['@test it supports leaving off .index for nested routes'](assert) {
      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "<h1>About</h1>{{outlet}}");
      this.addTemplate('about.index', "<div id='index'>Index</div>");
      this.addTemplate('about.item', "<div id='item'><LinkTo @route='about'>About</LinkTo></div>");
      await this.visit('/about/item');
      assert.equal(normalizeUrl(this.$('#item a').attr('href')), '/about');
    }
    async ["@test it supports custom, nested, current-when"](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<LinkTo id='other-link' @route='item' @current-when='index'>ITEM</LinkTo>");
      await this.visit('/about');
      assert.equal(this.$('#other-link.active').length, 1, 'The link is active since current-when is a parent route');
    }
    async ["@test it does not disregard current-when when it is given explicitly for a route"](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<LinkTo id='other-link' @route='items' @current-when='index'>ITEM</LinkTo>");
      await this.visit('/about');
      assert.equal(this.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
    }
    async ['@test it does not disregard current-when when it is set via a bound param'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.add('controller:index.about', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.currentWhen = 'index';
        }
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<LinkTo id='other-link' @route='items' @current-when={{this.currentWhen}}>ITEM</LinkTo>");
      await this.visit('/about');
      assert.equal(this.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
    }
    async ['@test it supports multiple current-when routes'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
        this.route('foo');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<LinkTo id='link1' @route='item' @current-when='item index'>ITEM</LinkTo>");
      this.addTemplate('item', "<LinkTo id='link2' @route='item' @current-when='item index'>ITEM</LinkTo>");
      this.addTemplate('foo', "<LinkTo id='link3' @route='item' @current-when='item index'>ITEM</LinkTo>");
      await this.visit('/about');
      assert.equal(this.$('#link1.active').length, 1, 'The link is active since current-when contains the parent route');
      await this.visit('/item');
      assert.equal(this.$('#link2.active').length, 1, 'The link is active since you are on the active route');
      await this.visit('/foo');
      assert.equal(this.$('#link3.active').length, 0, 'The link is not active since current-when does not contain the active route');
    }
    async ['@test it supports boolean values for current-when'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index.about', "\n        <LinkTo id='index-link' @route='index' @current-when={{this.isCurrent}}>ITEM</LinkTo>\n        <LinkTo id='about-link' @route='item' @current-when={{true}}>ITEM</LinkTo>\n        ");
      let controller;
      this.add('controller:index.about', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.isCurrent = false;
          controller = this;
        }
      });
      await this.visit('/about');
      assert.ok(this.$('#about-link').hasClass('active'), 'The link is active since current-when is true');
      assert.notOk(this.$('#index-link').hasClass('active'), 'The link is not active since current-when is false');
      (0, _internalTestHelpers.runTask)(() => controller.set('isCurrent', true));
      assert.ok(this.$('#index-link').hasClass('active'), 'The link is active since current-when is true');
    }
    async ['@test it defaults to bubbling'](assert) {
      this.addTemplate('about', "\n        <div {{action this.hide}}>\n          <LinkTo id='about-contact' @route='about.contact'>About</LinkTo>\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      let hidden = 0;
      this.add('controller:about', class extends _controller.default {
        hide() {
          hidden++;
        }
      });
      await this.visit('/about');
      await this.click('#about-contact');
      assert.equal(this.$('#contact').text(), 'Contact', 'precond - the link worked');
      assert.equal(hidden, 1, 'The link bubbles');
    }
    async ["The propagation of the click event can be stopped"](assert) {
      this.addTemplate('about', "\n        <div {{on 'click' this.hide}}>\n          <LinkTo id='about-contact' @route='about.contact' {{on 'click' this.stopPropagation}}>\n            About\n          </LinkTo>\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      let hidden = 0;
      this.add('controller:about', class extends _controller.default {
        hide() {
          hidden++;
        }
        stopPropagation(event) {
          event.stopPropagation();
        }
      });
      await this.visit('/about');
      await this.click('#about-contact');
      assert.equal(this.$('#contact').text(), 'Contact', 'precond - the link worked');
      assert.equal(hidden, 0, "The link didn't bubble");
    }
    async ["@test it moves into the named route with context"](assert) {
      this.router.map(function () {
        this.route('about');
        this.route('item', {
          path: '/item/:id'
        });
      });
      this.addTemplate('about', "\n        <h3 class=\"list\">List</h3>\n        <ul>\n          {{#each @model as |person|}}\n            <li>\n              <LinkTo id={{person.id}} @route='item' @model={{person}}>\n                {{person.name}}\n              </LinkTo>\n            </li>\n          {{/each}}\n        </ul>\n        <LinkTo id='home-link' @route='index'>Home</LinkTo>\n        ");
      this.addTemplate('item', "\n        <h3 class=\"item\">Item</h3>\n        <p>{{@model.name}}</p>\n        <LinkTo id='home-link' @route='index'>Home</LinkTo>\n        ");
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='about-link' @route='about'>About</LinkTo>\n        ");
      this.add('route:about', class extends _route.default {
        model() {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      });
      await this.visit('/about');
      assert.equal(this.$('h3.list').length, 1, 'The home template was rendered');
      assert.equal(normalizeUrl(this.$('#home-link').attr('href')), '/', 'The home link points back at /');
      await this.click('#yehuda');
      assert.equal(this.$('h3.item').length, 1, 'The item template was rendered');
      assert.equal(this.$('p').text(), 'Yehuda Katz', 'The name is correct');
      await this.click('#home-link');
      await this.click('#about-link');
      assert.equal(normalizeUrl(this.$('li a#yehuda').attr('href')), '/item/yehuda');
      assert.equal(normalizeUrl(this.$('li a#tom').attr('href')), '/item/tom');
      assert.equal(normalizeUrl(this.$('li a#erik').attr('href')), '/item/erik');
      await this.click('#erik');
      assert.equal(this.$('h3.item').length, 1, 'The item template was rendered');
      assert.equal(this.$('p').text(), 'Erik Brynroflsson', 'The name is correct');
    }
    async ["@test it binds some anchor html tag common attributes"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='self-link' @route='index' title='title-attr' rel='rel-attr' tabindex='-1'>\n          Self\n        </LinkTo>\n        ");
      await this.visit('/');
      let link = this.$('#self-link');
      assert.equal(link.attr('title'), 'title-attr', 'The self-link contains title attribute');
      assert.equal(link.attr('rel'), 'rel-attr', 'The self-link contains rel attribute');
      assert.equal(link.attr('tabindex'), '-1', 'The self-link contains tabindex attribute');
    }
    async ["@test it supports 'target' attribute"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='self-link' @route='index' target='_blank'>Self</LinkTo>\n        ");
      await this.visit('/');
      let link = this.$('#self-link');
      assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
    }
    async ["@test it supports 'target' attribute specified as a bound param"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='self-link' @route='index' target={{this.boundLinkTarget}}>Self</LinkTo>\n        ");
      let controller = this;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.boundLinkTarget = '_blank';
          controller = this;
        }
      });
      await this.visit('/');
      let link = this.$('#self-link');
      assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
      (0, _internalTestHelpers.runTask)(() => controller.set('boundLinkTarget', '_self'));
      assert.equal(link.attr('target'), '_self', 'The self-link contains `target` attribute');
    }
    async ["@test it calls preventDefault"](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "<LinkTo @route='about' id='about-link'>About</LinkTo>");
      await this.visit('/');
      assertNav({
        prevented: true
      }, () => this.$('#about-link').click(), assert);
    }
    async ["@test it does not call preventDefault if 'target' attribute is provided"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='self-link' @route='index' target='_blank'>Self</LinkTo>\n        ");
      await this.visit('/');
      assertNav({
        prevented: false
      }, () => this.$('#self-link').click(), assert);
    }
    async ["@test it should preventDefault when 'target = _self'"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <LinkTo id='self-link' @route='index' target='_self'>Self</LinkTo>\n        ");
      await this.visit('/');
      assertNav({
        prevented: true
      }, () => this.$('#self-link').click(), assert);
    }
    async ["@test it should not transition if target is not equal to _self or empty"](assert) {
      this.addTemplate('index', "\n        <LinkTo id='about-link' @route='about' @replace={{true}} target='_blank'>\n          About\n        </LinkTo>\n        ");
      this.router.map(function () {
        this.route('about');
      });
      await this.visit('/');
      await this.click('#about-link');
      assert.notEqual(this.appRouter.currentRouteName, 'about', 'link-to should not transition if target is not equal to _self or empty');
    }
    async ["@test it accepts string/numeric arguments"](assert) {
      this.router.map(function () {
        this.route('filter', {
          path: '/filters/:filter'
        });
        this.route('post', {
          path: '/post/:post_id'
        });
        this.route('repo', {
          path: '/repo/:owner/:name'
        });
      });
      this.add('controller:filter', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.filter = 'unpopular';
          this.repo = {
            owner: 'ember',
            name: 'ember.js'
          };
          this.post_id = 123;
        }
      });
      this.addTemplate('filter', "\n        <p>{{this.filter}}</p>\n        <LinkTo id=\"link\" @route=\"filter\" @model=\"unpopular\">Unpopular</LinkTo>\n        <LinkTo id=\"path-link\" @route=\"filter\" @model={{this.filter}}>Unpopular</LinkTo>\n        <LinkTo id=\"post-path-link\" @route=\"post\" @model={{this.post_id}}>Post</LinkTo>\n        <LinkTo id=\"post-number-link\" @route=\"post\" @model={{123}}>Post</LinkTo>\n        <LinkTo id=\"repo-object-link\" @route=\"repo\" @model={{this.repo}}>Repo</LinkTo>\n        ");
      await this.visit('/filters/popular');
      assert.equal(normalizeUrl(this.$('#link').attr('href')), '/filters/unpopular');
      assert.equal(normalizeUrl(this.$('#path-link').attr('href')), '/filters/unpopular');
      assert.equal(normalizeUrl(this.$('#post-path-link').attr('href')), '/post/123');
      assert.equal(normalizeUrl(this.$('#post-number-link').attr('href')), '/post/123');
      assert.equal(normalizeUrl(this.$('#repo-object-link').attr('href')), '/repo/ember/ember.js');
    }
    async ["@test [GH#4201] Shorthand for route.index shouldn't throw errors about context arguments"](assert) {
      this.router.map(function () {
        this.route('lobby', function () {
          this.route('index', {
            path: ':lobby_id'
          });
          this.route('list');
        });
      });
      this.add('route:lobby.index', class extends _route.default {
        model(params) {
          assert.equal(params.lobby_id, 'foobar');
          return params.lobby_id;
        }
      });
      this.addTemplate('lobby.index', "<LinkTo id='lobby-link' @route='lobby' @model='foobar'>Lobby</LinkTo>");
      this.addTemplate('lobby.list', "<LinkTo id='lobby-link' @route='lobby' @model='foobar'>Lobby</LinkTo>");
      await this.visit('/lobby/list');
      await this.click('#lobby-link');
      shouldBeActive(assert, this.$('#lobby-link'));
    }
    async ["@test Quoteless route param performs property lookup"](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <LinkTo id='string-link' @route='index'>string</LinkTo>\n        <LinkTo id='path-link' @route={{this.foo}}>path</LinkTo>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.foo = 'index';
          controller = this;
        }
      });
      let assertEquality = href => {
        assert.equal(normalizeUrl(this.$('#string-link').attr('href')), '/');
        assert.equal(normalizeUrl(this.$('#path-link').attr('href')), href);
      };
      await this.visit('/');
      assertEquality('/');
      (0, _internalTestHelpers.runTask)(() => controller.set('foo', 'about'));
      assertEquality('/about');
    }
    async ["@test it refreshes href element when one of params changes"](assert) {
      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      let post = {
        id: '1'
      };
      let secondPost = {
        id: '2'
      };
      this.addTemplate('index', "<LinkTo id=\"post\" @route=\"post\" @model={{this.post}}>post</LinkTo>");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          controller = this;
        }
      });
      await this.visit('/');
      (0, _internalTestHelpers.runTask)(() => controller.set('post', post));
      assert.equal(normalizeUrl(this.$('#post').attr('href')), '/posts/1', 'precond - Link has rendered href attr properly');
      (0, _internalTestHelpers.runTask)(() => controller.set('post', secondPost));
      assert.equal(this.$('#post').attr('href'), '/posts/2', 'href attr was updated after one of the params had been changed');
      (0, _internalTestHelpers.runTask)(() => controller.set('post', null));
      assert.equal(this.$('#post').attr('href'), '#', 'href attr becomes # when one of the arguments in nullified');
    }
    async ["@test it is active when a route is active"](assert) {
      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "\n        <div id='about'>\n          <LinkTo id='about-link' @route='about'>About</LinkTo>\n          <LinkTo id='item-link' @route='about.item'>Item</LinkTo>\n          {{outlet}}\n        </div>\n        ");
      await this.visit('/about');
      assert.equal(this.$('#about-link.active').length, 1, 'The about route link is active');
      assert.equal(this.$('#item-link.active').length, 0, 'The item route link is inactive');
      await this.visit('/about/item');
      assert.equal(this.$('#about-link.active').length, 1, 'The about route link is active');
      assert.equal(this.$('#item-link.active').length, 1, 'The item route link is active');
    }
    async ["@test it works in an #each'd array of string route names"](assert) {
      this.router.map(function () {
        this.route('foo');
        this.route('bar');
        this.route('rar');
      });
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.routeNames = (0, _array.A)(['foo', 'bar', 'rar']);
          this.route1 = 'bar';
          this.route2 = 'foo';
          controller = this;
        }
      });
      this.addTemplate('index', "\n        {{#each this.routeNames as |routeName|}}\n          <LinkTo @route={{routeName}}>{{routeName}}</LinkTo>\n        {{/each}}\n        {{#each this.routeNames as |r|}}\n          <LinkTo @route={{r}}>{{r}}</LinkTo>\n        {{/each}}\n        <LinkTo @route={{this.route1}}>a</LinkTo>\n        <LinkTo @route={{this.route2}}>b</LinkTo>\n        ");
      let linksEqual = (links, expected) => {
        assert.equal(links.length, expected.length, 'Has correct number of links');
        let idx;
        for (idx = 0; idx < links.length; idx++) {
          let href = this.$(links[idx]).attr('href');
          // Old IE includes the whole hostname as well
          assert.equal(href.slice(-expected[idx].length), expected[idx], "Expected link to be '" + expected[idx] + "', but was '" + href + "'");
        }
      };
      await this.visit('/');
      linksEqual(this.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/bar', '/foo']);
      (0, _internalTestHelpers.runTask)(() => controller.set('route1', 'rar'));
      linksEqual(this.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/rar', '/foo']);
      (0, _internalTestHelpers.runTask)(() => controller.routeNames.shiftObject());
      linksEqual(this.$('a'), ['/bar', '/rar', '/bar', '/rar', '/rar', '/foo']);
    }
    async ["@test it throws a useful error if you invoke it wrong"](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "<LinkTo @route='post'>Post</LinkTo>");
      return assert.rejectsAssertion(this.visit('/'), /(You attempted to generate a link for the "post" route, but did not pass the models required for generating its dynamic segments.|You must provide param `post_id` to `generate`)/);
    }
    async ["@test it does not throw an error if its route has exited"](assert) {
      var _dec, _class16, _descriptor;
      assert.expect(0);
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "\n        <LinkTo id='home-link' @route='index'>Home</LinkTo>\n        <LinkTo id='default-post-link' @route='post' @model={{this.defaultPost}}>Default Post</LinkTo>\n        {{#if this.currentPost}}\n          <LinkTo id='current-post-link' @route='post' @model={{this.currentPost}}>Current Post</LinkTo>\n        {{/if}}\n        ");
      this.add('controller:application', (_dec = (0, _controller.inject)('post'), (_class16 = class _class16 extends _controller.default {
        constructor() {
          super(...arguments);
          this.defaultPost = {
            id: 1
          };
          _initializerDefineProperty(this, "postController", _descriptor, this);
        }
        get currentPost() {
          return this.postController.model;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class16.prototype, "postController", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class16)));
      this.add('controller:post', class extends _controller.default {});
      this.add('route:post', class extends _route.default {
        model() {
          return {
            id: 2
          };
        }
        serialize(model) {
          return {
            post_id: model.id
          };
        }
      });
      await this.visit('/');
      await this.click('#default-post-link');
      await this.click('#home-link');
      await this.click('#current-post-link');
      await this.click('#home-link');
    }
    async ["@test its active property respects changing parent route context"](assert) {
      this.router.map(function () {
        this.route('things', {
          path: '/things/:name'
        }, function () {
          this.route('other');
        });
      });
      this.addTemplate('application', "\n        <LinkTo id='omg-link' @route='things' @model='omg'>OMG</LinkTo>\n        <LinkTo id='lol-link' @route='things' @model='lol'>LOL</LinkTo>\n        ");
      await this.visit('/things/omg');
      shouldBeActive(assert, this.$('#omg-link'));
      shouldNotBeActive(assert, this.$('#lol-link'));
      await this.visit('/things/omg/other');
      shouldBeActive(assert, this.$('#omg-link'));
      shouldNotBeActive(assert, this.$('#lol-link'));
    }
    async ["@test it populates href with default query param values even without query-params object"](assert) {
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo'];
          this.foo = '123';
        }
      });
      this.addTemplate('index', "<LinkTo id='the-link' @route='index'>Index</LinkTo>");
      await this.visit('/');
      assert.equal(this.$('#the-link').attr('href'), '/', 'link has right href');
    }
    async ["@test it populates href with default query param values with empty query-params object"](assert) {
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo'];
          this.foo = '123';
        }
      });
      this.addTemplate('index', "<LinkTo id='the-link' @route='index' @query={{(hash)}}>Index</LinkTo>");
      await this.visit('/');
      assert.equal(this.$('#the-link').attr('href'), '/', 'link has right href');
    }
    async ["@test it updates when route changes with only query-params and a block"](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo', 'bar'];
          this.foo = '123';
          this.bar = 'yes';
        }
      });
      this.addTemplate('application', "<LinkTo id='the-link' @query={{hash foo='456' bar='NAW'}}>Index</LinkTo>");
      await this.visit('/');
      assert.equal(this.$('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
      await this.visit('/about');
      assert.equal(this.$('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
    }
    async ['@test [GH#17018] passing model to <LinkTo /> with `hash` helper works']() {
      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      this.add('route:index', class extends _route.default {
        model() {
          return _runtime.RSVP.hash({
            user: {
              name: 'Papa Smurf'
            }
          });
        }
      });
      this.addTemplate('index', "<LinkTo @route='post' @model={{hash id=\"someId\" user=@model.user}}>Post</LinkTo>");
      this.addTemplate('post', 'Post: {{@model.user.name}}');
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/posts/someId'
        },
        content: 'Post'
      });
      await this.click('a');
      this.assertText('Post: Papa Smurf');
    }
    async ["@test [GH#13256]: <LinkTo /> to a parent root model hook which performs a 'transitionTo' has correct active class"](assert) {
      var _class21, _descriptor2;
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.add('route:parent', (_class21 = class _class21 extends _route.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "router", _descriptor2, this);
        }
        afterModel() {
          this.router.transitionTo('parent.child');
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class21.prototype, "router", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class21));
      this.addTemplate('application', "<LinkTo id='parent-link' @route='parent'>Parent</LinkTo>");
      await this.visit('/');
      await this.click('#parent-link');
      shouldBeActive(assert, this.$('#parent-link'));
    }
  });
  (0, _internalTestHelpers.moduleFor)('The <LinkTo /> component - loading states and warnings', class extends _internalTestHelpers.ApplicationTestCase {
    async ["@test <LinkTo /> with null/undefined dynamic parameters are put in a loading state"](assert) {
      let warningMessage = 'This link is in an inactive loading state because at least one of its models currently has a null/undefined value, or the provided route name is invalid.';
      this.router.map(function () {
        this.route('thing', {
          path: '/thing/:thing_id'
        });
        this.route('about');
      });
      this.addTemplate('index', "\n        <LinkTo id='context-link' @route={{this.destinationRoute}} @model={{this.routeContext}} @loadingClass='i-am-loading'>\n          string\n        </LinkTo>\n        <LinkTo id='static-link' @route={{this.secondRoute}} @loadingClass={{this.loadingClass}}>\n          string\n        </LinkTo>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.destinationRoute = null;
          this.routeContext = null;
          this.loadingClass = 'i-am-loading';
          controller = this;
        }
      });
      let activate = 0;
      this.add('route:about', class extends _route.default {
        activate() {
          activate++;
        }
      });
      function assertLinkStatus(link, url) {
        if (url) {
          assert.equal(normalizeUrl(link.attr('href')), url, 'loaded link-to has expected href');
          assert.ok(!link.hasClass('i-am-loading'), 'loaded linkComponent has no loadingClass');
        } else {
          assert.equal(normalizeUrl(link.attr('href')), '#', "unloaded link-to has href='#'");
          assert.ok(link.hasClass('i-am-loading'), 'loading linkComponent has loadingClass');
        }
      }
      await this.visit('/');
      let contextLink = this.$('#context-link');
      let staticLink = this.$('#static-link');
      assertLinkStatus(contextLink);
      assertLinkStatus(staticLink);
      await expectWarning(() => this.click(contextLink[0]), warningMessage);

      // Set the destinationRoute (context is still null).
      (0, _internalTestHelpers.runTask)(() => controller.set('destinationRoute', 'thing'));
      assertLinkStatus(contextLink);

      // Set the routeContext to an id
      (0, _internalTestHelpers.runTask)(() => controller.set('routeContext', '456'));
      assertLinkStatus(contextLink, '/thing/456');

      // Test that 0 isn't interpreted as falsy.
      (0, _internalTestHelpers.runTask)(() => controller.set('routeContext', 0));
      assertLinkStatus(contextLink, '/thing/0');

      // Set the routeContext to an object
      (0, _internalTestHelpers.runTask)(() => controller.set('routeContext', {
        id: 123
      }));
      assertLinkStatus(contextLink, '/thing/123');

      // Set the destinationRoute back to null.
      (0, _internalTestHelpers.runTask)(() => controller.set('destinationRoute', null));
      assertLinkStatus(contextLink);
      await expectWarning(() => this.click(staticLink[0]), warningMessage);
      (0, _internalTestHelpers.runTask)(() => controller.set('secondRoute', 'about'));
      assertLinkStatus(staticLink, '/about');

      // Click the now-active link
      await this.click(staticLink[0]);
      assert.equal(activate, 1, 'About route was entered');
    }
  });
  function assertNav(options, callback, assert) {
    let nav = false;
    function check(event) {
      assert.equal(event.defaultPrevented, options.prevented, "expected defaultPrevented=" + options.prevented);
      nav = true;
      event.preventDefault();
    }
    try {
      document.addEventListener('click', check);
      callback();
    } finally {
      document.removeEventListener('click', check);
      assert.ok(nav, 'Expected a link to be clicked');
    }
  }
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/routing-curly-test", ["internal-test-helpers", "@ember/controller", "@ember/array", "@ember/-internals/runtime", "@ember/routing/route", "@ember/routing/none-location", "@ember/service", "@ember/engine", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _controller, _array, _runtime, _route, _noneLocation, _service, _engine, _helpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  // IE includes the host name
  function normalizeUrl(url) {
    return url.replace(/https?:\/\/[^/]+/, '');
  }
  function shouldNotBeActive(assert, element) {
    checkActive(assert, element, false);
  }
  function shouldBeActive(assert, element) {
    checkActive(assert, element, true);
  }
  function checkActive(assert, element, active) {
    let classList = element.attr('class');
    assert.equal(classList.indexOf('active') > -1, active, element + " active should be " + active);
  }
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (routing tests)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about'}}About{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='index'}}Self{{/link-to}}</div>\n        ");
      this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        <div id=\"home-link\">{{#link-to route='index'}}Home{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='about'}}Self{{/link-to}}</div>\n        ");
    }
    async ['@test it navigates into the named route'](assert) {
      await this.visit('/');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link a.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link > a:not(.active)').length, 1, 'The other link was rendered without active class');
      await this.click('#about-link > a');
      assert.equal(this.$('h3.about').length, 1, 'The about template was rendered');
      assert.equal(this.$('#self-link > a.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#home-link > a:not(.active)').length, 1, 'The other link was rendered without active class');
    }
    async ['@test [GH#19546] it navigates into the named route when containing other elements'](assert) {
      this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        <div id=\"home-link\">{{#link-to route='index'}}<span id='inside'>Home</span>{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='about'}}Self{{/link-to}}</div>\n        ");
      await this.visit('/about');
      assert.equal(this.$('h3.about').length, 1, 'The about template was rendered');
      assert.equal(this.$('#self-link > a.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#home-link > a:not(.active)').length, 1, 'The other link was rendered without active class');
      await this.click('#inside');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link > a.active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link > a:not(.active)').length, 1, 'The other link was rendered without active class');
    }
    async ["@test it applies a 'disabled' class when disabled"](assert) {
      this.addTemplate('index', "\n        <div id=\"about-link-static\">{{#link-to route=\"about\" disabled=\"truthy\"}}About{{/link-to}}</div>\n        <div id=\"about-link-dynamic\">{{#link-to route=\"about\" disabled=this.dynamicDisabled}}About{{/link-to}}</div>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.dynamicDisabled = true;
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('#about-link-static > a.disabled').length, 1, 'The static link is disabled when its disabled is true');
      assert.equal(this.$('#about-link-dynamic > a.disabled').length, 1, 'The dynamic link is disabled when its disabled is true');
      (0, _internalTestHelpers.runTask)(() => controller.set('dynamicDisabled', false));
      assert.equal(this.$('#about-link-static > a.disabled').length, 1, 'The static link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-dynamic > a.disabled').length, 0, 'The dynamic link is re-enabled when its disabled becomes false');
    }
    async ["@test it doesn't apply a 'disabled' class when not disabled"](assert) {
      this.addTemplate('index', "<div id=\"about-link\">{{#link-to route=\"about\"}}About{{/link-to}}</div>");
      await this.visit('/');
      assert.ok(!this.$('#about-link > a').hasClass('disabled'), 'The link is not disabled if disabled was not provided');
    }
    async ["@test it supports a custom disabledClass"](assert) {
      this.addTemplate('index', "\n        <div id=\"about-link-static\">{{#link-to route=\"about\" disabledClass=\"do-not-want\" disabled=\"truthy\"}}About{{/link-to}}</div>\n        <div id=\"about-link-dynamic\">{{#link-to route=\"about\" disabledClass=\"do-not-want\" disabled=this.dynamicDisabled}}About{{/link-to}}</div>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.dynamicDisabled = true;
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('#about-link-static > a.do-not-want').length, 1, 'The static link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-dynamic > a.do-not-want').length, 1, 'The dynamic link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-static > a.disabled').length, 0, 'The default disabled class is not added on the static link');
      assert.strictEqual(this.$('#about-link-dynamic > a.disabled').length, 0, 'The default disabled class is not added on the dynamic link');
      (0, _internalTestHelpers.runTask)(() => controller.set('dynamicDisabled', false));
      assert.equal(this.$('#about-link-static > a.do-not-want').length, 1, 'The static link is disabled when its disabled is true');
      assert.strictEqual(this.$('#about-link-dynamic > a.disabled').length, 0, 'The dynamic link is re-enabled when its disabled becomes false');
      assert.strictEqual(this.$('#about-link-static > a.disabled').length, 0, 'The default disabled class is not added on the static link');
      assert.strictEqual(this.$('#about-link-dynamic > a.disabled').length, 0, 'The default disabled class is not added on the dynamic link');
    }
    async ["@test it supports a custom disabledClass set via bound param"](assert) {
      this.addTemplate('index', "<div id=\"about-link\">{{#link-to route=\"about\" disabledClass=this.disabledClass disabled=true}}About{{/link-to}}</div>");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.disabledClass = 'do-not-want';
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('#about-link > a.do-not-want').length, 1, 'The link can apply a custom disabled class via bound param');
      assert.strictEqual(this.$('#about-link > a.disabled').length, 0, 'The default disabled class is not added');
      (0, _internalTestHelpers.runTask)(() => controller.set('disabledClass', 'can-not-use'));
      assert.equal(this.$('#about-link > a.can-not-use').length, 1, 'The link can apply a custom disabled class via bound param');
      assert.strictEqual(this.$('#about-link > a.do-not-want').length, 0, 'The old class is removed');
      assert.strictEqual(this.$('#about-link > a.disabled').length, 0, 'The default disabled class is not added');
    }
    async ["@test it does not respond to clicks when disabled"](assert) {
      this.addTemplate('index', "<div id=\"about-link\">{{#link-to route=\"about\" disabled=true}}About{{/link-to}}</div>");
      await this.visit('/');
      await this.click('#about-link > a');
      assert.strictEqual(this.$('h3.about').length, 0, 'Transitioning did not occur');
    }
    async ["@test it responds to clicks according to its disabled bound param"](assert) {
      this.addTemplate('index', "<div id=\"about-link\">{{#link-to route=\"about\" disabled=this.dynamicDisabled}}About{{/link-to}}</div>");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.dynamicDisabled = true;
          controller = this;
        }
      });
      await this.visit('/');
      await this.click('#about-link > a');
      assert.strictEqual(this.$('h3.about').length, 0, 'Transitioning did not occur');
      (0, _internalTestHelpers.runTask)(() => controller.set('dynamicDisabled', false));
      await this.click('#about-link > a');
      assert.equal(this.$('h3.about').length, 1, 'Transitioning did occur when disabled became false');
    }
    async ["@test it supports a custom activeClass"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about' activeClass='zomg-active'}}About{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='index' activeClass='zomg-active'}}Self{{/link-to}}</div>\n        ");
      await this.visit('/');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link > a.zomg-active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link > a:not(.zomg-active)').length, 1, 'The other link was rendered without active class');
      assert.strictEqual(this.$('#self-link > a.active').length, 0, 'The self-link was rendered without the default active class');
      assert.strictEqual(this.$('#about-link > a.active').length, 0, 'The other link was rendered without the default active class');
    }
    async ["@test it supports a custom activeClass from a bound param"](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about' activeClass=this.activeClass}}About{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='index' activeClass=this.activeClass}}Self{{/link-to}}</div>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.activeClass = 'zomg-active';
          controller = this;
        }
      });
      await this.visit('/');
      assert.equal(this.$('h3.home').length, 1, 'The home template was rendered');
      assert.equal(this.$('#self-link > a.zomg-active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link > a:not(.zomg-active)').length, 1, 'The other link was rendered without active class');
      assert.strictEqual(this.$('#self-link > a.active').length, 0, 'The self-link was rendered without the default active class');
      assert.strictEqual(this.$('#about-link > a.active').length, 0, 'The other link was rendered without the default active class');
      (0, _internalTestHelpers.runTask)(() => controller.set('activeClass', 'wow-active'));
      assert.equal(this.$('#self-link > a.wow-active').length, 1, 'The self-link was rendered with active class');
      assert.equal(this.$('#about-link > a:not(.wow-active)').length, 1, 'The other link was rendered without active class');
      assert.strictEqual(this.$('#self-link > a.zomg-active').length, 0, 'The self-link was rendered without the previous active class');
      assert.strictEqual(this.$('#self-link > a.active').length, 0, 'The self-link was rendered without the default active class');
      assert.strictEqual(this.$('#about-link > a.active').length, 0, 'The other link was rendered without the default active class');
    }
    async ['@test Using {{link-to}} inside a non-routable engine errors'](assert) {
      this.add('engine:not-routable', class NotRoutableEngine extends _engine.default {
        constructor() {
          super(...arguments);
          this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
        }
        init() {
          super.init(...arguments);
          this.register('template:application', (0, _helpers.compile)("{{#link-to route='about'}}About{{/link-to}}", {
            moduleName: 'non-routable/templates/application.hbs'
          }));
        }
      });
      this.addTemplate('index', "{{mount \"not-routable\"}}");
      await assert.rejectsAssertion(this.visit('/'), 'You attempted to use the <LinkTo> component within a routeless engine, this is not supported. ' + 'If you are using the ember-engines addon, use the <LinkToExternal> component instead. ' + 'See https://ember-engines.com/docs/links for more info.');
    }
    async ['@test Using {{link-to}} inside a routable engine link within the engine'](assert) {
      this.add('engine:routable', class RoutableEngine extends _engine.default {
        constructor() {
          super(...arguments);
          this.Resolver = _internalTestHelpers.ModuleBasedTestResolver;
        }
        init() {
          super.init(...arguments);
          this.register('template:application', (0, _helpers.compile)("\n                <h2 id='engine-layout'>Routable Engine</h2>\n                {{outlet}}\n                <div id=\"engine-application-link\">{{#link-to route='application'}}Engine Application{{/link-to}}</div>\n                ", {
            moduleName: 'routable/templates/application.hbs'
          }));
          this.register('template:index', (0, _helpers.compile)("\n                <h3 class='engine-home'>Engine Home</h3>\n                <div id=\"engine-about-link\">{{#link-to route='about'}}Engine About{{/link-to}}</div>\n                <div id=\"engine-self-link\">{{#link-to route='index'}}Engine Self{{/link-to}}</div>\n                ", {
            moduleName: 'routable/templates/index.hbs'
          }));
          this.register('template:about', (0, _helpers.compile)("\n                <h3 class='engine-about'>Engine About</h3>\n                <div id=\"engine-home-link\">{{#link-to route='index'}}Engine Home{{/link-to}}</div>\n                <div id=\"engine-self-link\">{{#link-to route='about'}}Engine Self{{/link-to}}</div>\n                ", {
            moduleName: 'routable/templates/about.hbs'
          }));
        }
      });
      this.router.map(function () {
        this.mount('routable');
      });
      this.add('route-map:routable', function () {
        this.route('about');
      });
      this.addTemplate('application', "\n        <h1 id=\"application-layout\">Application</h1>\n        {{outlet}}\n        <div id=\"application-link\">{{#link-to route='application'}}Appliction{{/link-to}}</div>\n        <div id=\"engine-link\">{{#link-to route='routable'}}Engine{{/link-to}}</div>\n        ");
      await this.visit('/');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.strictEqual(this.$('#engine-layout').length, 0, 'The engine layout was not rendered');
      assert.equal(this.$('#application-link > a.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link > a:not(.active)').length, 1, 'The engine link is not active');
      assert.equal(this.$('h3.home').length, 1, 'The application index page is rendered');
      assert.equal(this.$('#self-link > a.active').length, 1, 'The application index link is active');
      assert.equal(this.$('#about-link > a:not(.active)').length, 1, 'The application about link is not active');
      await this.click('#about-link > a');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.strictEqual(this.$('#engine-layout').length, 0, 'The engine layout was not rendered');
      assert.equal(this.$('#application-link > a.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link > a:not(.active)').length, 1, 'The engine link is not active');
      assert.equal(this.$('h3.about').length, 1, 'The application about page is rendered');
      assert.equal(this.$('#self-link > a.active').length, 1, 'The application about link is active');
      assert.equal(this.$('#home-link > a:not(.active)').length, 1, 'The application home link is not active');
      await this.click('#engine-link > a');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.equal(this.$('#engine-layout').length, 1, 'The engine layout was rendered');
      assert.equal(this.$('#application-link > a.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link > a.active').length, 1, 'The engine link is active');
      assert.equal(this.$('#engine-application-link > a.active').length, 1, 'The engine application link is active');
      assert.equal(this.$('h3.engine-home').length, 1, 'The engine index page is rendered');
      assert.equal(this.$('#engine-self-link > a.active').length, 1, 'The engine index link is active');
      assert.equal(this.$('#engine-about-link > a:not(.active)').length, 1, 'The engine about link is not active');
      await this.click('#engine-about-link > a');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.equal(this.$('#engine-layout').length, 1, 'The engine layout was rendered');
      assert.equal(this.$('#application-link > a.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link > a.active').length, 1, 'The engine link is active');
      assert.equal(this.$('#engine-application-link > a.active').length, 1, 'The engine application link is active');
      assert.equal(this.$('h3.engine-about').length, 1, 'The engine about page is rendered');
      assert.equal(this.$('#engine-self-link > a.active').length, 1, 'The engine about link is active');
      assert.equal(this.$('#engine-home-link > a:not(.active)').length, 1, 'The engine home link is not active');
      await this.click('#engine-application-link > a');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.equal(this.$('#engine-layout').length, 1, 'The engine layout was rendered');
      assert.equal(this.$('#application-link > a.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link > a.active').length, 1, 'The engine link is active');
      assert.equal(this.$('#engine-application-link > a.active').length, 1, 'The engine application link is active');
      assert.equal(this.$('h3.engine-home').length, 1, 'The engine index page is rendered');
      assert.equal(this.$('#engine-self-link > a.active').length, 1, 'The engine index link is active');
      assert.equal(this.$('#engine-about-link > a:not(.active)').length, 1, 'The engine about link is not active');
      await this.click('#application-link > a');
      assert.equal(this.$('#application-layout').length, 1, 'The application layout was rendered');
      assert.strictEqual(this.$('#engine-layout').length, 0, 'The engine layout was not rendered');
      assert.equal(this.$('#application-link > a.active').length, 1, 'The application link is active');
      assert.equal(this.$('#engine-link > a:not(.active)').length, 1, 'The engine link is not active');
      assert.equal(this.$('h3.home').length, 1, 'The application index page is rendered');
      assert.equal(this.$('#self-link > a.active').length, 1, 'The application index link is active');
      assert.equal(this.$('#about-link > a:not(.active)').length, 1, 'The application about link is not active');
    }
  });
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (routing tests - location hooks)', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      this.updateCount = 0;
      this.replaceCount = 0;
      let testContext = this;
      this.add('location:none', class extends _noneLocation.default {
        setURL() {
          testContext.updateCount++;
          return super.setURL(...arguments);
        }
        replaceURL() {
          testContext.replaceCount++;
          return super.setURL(...arguments);
        }
      });
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about'}}About{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='index'}}Self{{/link-to}}</div>\n        ");
      this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        <div id=\"home-link\">{{#link-to route='index'}}Home{{/link-to}}</div>\n        <div id=\"self-link\">{{#link-to route='about'}}Self{{/link-to}}</div>\n        ");
    }
    async visit() {
      await super.visit(...arguments);
      this.updateCountAfterVisit = this.updateCount;
      this.replaceCountAfterVisit = this.replaceCount;
    }
    async ['@test it supports URL replacement'](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about' replace=true}}About{{/link-to}}</div>\n        ");
      await this.visit('/');
      await this.click('#about-link > a');
      assert.strictEqual(this.updateCount, this.updateCountAfterVisit, 'setURL should not be called');
      assert.strictEqual(this.replaceCount, this.replaceCountAfterVisit + 1, 'replaceURL should be called once');
    }
    async ['@test it supports URL replacement via replace=boundTruthyThing'](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about' replace=this.boundTruthyThing}}About{{/link-to}}</div>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.boundTruthyThing = true;
        }
      });
      await this.visit('/');
      await this.click('#about-link > a');
      assert.strictEqual(this.updateCount, this.updateCountAfterVisit, 'setURL should not be called');
      assert.strictEqual(this.replaceCount, this.replaceCountAfterVisit + 1, 'replaceURL should be called once');
    }
    async ['@test it supports setting replace=boundFalseyThing'](assert) {
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id=\"about-link\">{{#link-to route='about' replace=this.boundFalseyThing}}About{{/link-to}}</div>\n        ");
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.boundFalseyThing = false;
        }
      });
      await this.visit('/');
      await this.click('#about-link > a');
      assert.strictEqual(this.updateCount, this.updateCountAfterVisit + 1, 'setURL should be called');
      assert.strictEqual(this.replaceCount, this.replaceCountAfterVisit, 'replaceURL should not be called');
    }
  });
  (0, _internalTestHelpers.moduleFor)('The {{link-to}} component - nested routes and link-to arguments', class extends _internalTestHelpers.ApplicationTestCase {
    async ['@test it supports leaving off .index for nested routes'](assert) {
      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "<h1>About</h1>{{outlet}}");
      this.addTemplate('about.index', "<div id='index'>Index</div>");
      this.addTemplate('about.item', "<div id='item'>{{#link-to route='about'}}About{{/link-to}}</div>");
      await this.visit('/about/item');
      assert.equal(normalizeUrl(this.$('#item a').attr('href')), '/about');
    }
    async ["@test it supports custom, nested, current-when"](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<div id=\"other-link\">{{#link-to route='item' current-when='index'}}ITEM{{/link-to}}</div>");
      await this.visit('/about');
      assert.equal(this.$('#other-link > a.active').length, 1, 'The link is active since current-when is a parent route');
    }
    async ["@test it does not disregard current-when when it is given explicitly for a route"](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<div id=\"other-link\">{{#link-to route='items' current-when='index'}}ITEM{{/link-to}}</div>");
      await this.visit('/about');
      assert.equal(this.$('#other-link > a.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
    }
    async ['@test it does not disregard current-when when it is set via a bound param'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.add('controller:index.about', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.currentWhen = 'index';
        }
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<div id=\"other-link\">{{#link-to route='items' current-when=this.currentWhen}}ITEM{{/link-to}}</div>");
      await this.visit('/about');
      assert.equal(this.$('#other-link > a.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
    }
    async ['@test it supports multiple current-when routes'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
        this.route('foo');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "<div id=\"link1\">{{#link-to route='item' current-when='item index'}}ITEM{{/link-to}}</div>");
      this.addTemplate('item', "<div id=\"link2\">{{#link-to route='item' current-when='item index'}}ITEM{{/link-to}}</div>");
      this.addTemplate('foo', "<div id=\"link3\">{{#link-to route='item' current-when='item index'}}ITEM{{/link-to}}</div>");
      await this.visit('/about');
      assert.equal(this.$('#link1 > a.active').length, 1, 'The link is active since current-when contains the parent route');
      await this.visit('/item');
      assert.equal(this.$('#link2 > a.active').length, 1, 'The link is active since you are on the active route');
      await this.visit('/foo');
      assert.equal(this.$('#link3 > a.active').length, 0, 'The link is not active since current-when does not contain the active route');
    }
    async ['@test it supports boolean values for current-when'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index.about', "\n        <div id=\"index-link\">{{#link-to route='index' current-when=this.isCurrent}}index{{/link-to}}</div>\n        <div id=\"about-link\">{{#link-to route='item' current-when=true}}ITEM{{/link-to}}</div>\n        ");
      let controller;
      this.add('controller:index.about', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.isCurrent = false;
          controller = this;
        }
      });
      await this.visit('/about');
      assert.ok(this.$('#about-link > a').hasClass('active'), 'The link is active since current-when is true');
      assert.notOk(this.$('#index-link > a').hasClass('active'), 'The link is not active since current-when is false');
      (0, _internalTestHelpers.runTask)(() => controller.set('isCurrent', true));
      assert.ok(this.$('#index-link > a').hasClass('active'), 'The link is active since current-when is true');
    }
    async ['@test it defaults to bubbling'](assert) {
      this.addTemplate('about', "\n        <div {{action this.hide}}>\n          <div id=\"about-contact\">{{#link-to route='about.contact'}}About{{/link-to}}</div>\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      let hidden = 0;
      this.add('controller:about', class extends _controller.default {
        hide() {
          hidden++;
        }
      });
      await this.visit('/about');
      await this.click('#about-contact > a');
      assert.equal(this.$('#contact').text(), 'Contact', 'precond - the link worked');
      assert.equal(hidden, 1, 'The link bubbles');
    }
    async ["@test it moves into the named route with context"](assert) {
      this.router.map(function () {
        this.route('about');
        this.route('item', {
          path: '/item/:id'
        });
      });
      this.addTemplate('about', "\n        <h3 class=\"list\">List</h3>\n        <ul>\n          {{#each @model as |person|}}\n            <li id={{person.id}}>\n              {{#link-to route='item' model=person}}\n                {{person.name}}\n              {{/link-to}}\n            </li>\n          {{/each}}\n        </ul>\n        <div id='home-link'>{{#link-to route='index'}}Home{{/link-to}}</div>\n        ");
      this.addTemplate('item', "\n        <h3 class=\"item\">Item</h3>\n        <p>{{@model.name}}</p>\n        <div id='home-link'>{{#link-to route='index'}}Home{{/link-to}}</div>\n        ");
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <div id='about-link'>{{#link-to route='about'}}About{{/link-to}}</div>\n        ");
      this.add('route:about', _route.default.extend({
        model() {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      }));
      await this.visit('/about');
      assert.equal(this.$('h3.list').length, 1, 'The home template was rendered');
      assert.equal(normalizeUrl(this.$('#home-link > a').attr('href')), '/', 'The home link points back at /');
      await this.click('#yehuda > a');
      assert.equal(this.$('h3.item').length, 1, 'The item template was rendered');
      assert.equal(this.$('p').text(), 'Yehuda Katz', 'The name is correct');
      await this.click('#home-link > a');
      await this.click('#about-link > a');
      assert.equal(normalizeUrl(this.$('li#yehuda > a').attr('href')), '/item/yehuda');
      assert.equal(normalizeUrl(this.$('li#tom > a').attr('href')), '/item/tom');
      assert.equal(normalizeUrl(this.$('li#erik > a').attr('href')), '/item/erik');
      await this.click('#erik > a');
      assert.equal(this.$('h3.item').length, 1, 'The item template was rendered');
      assert.equal(this.$('p').text(), 'Erik Brynroflsson', 'The name is correct');
    }
    async ["@test it calls preventDefault"](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "<div id='about-link'>{{#link-to route='about'}}About{{/link-to}}</div>");
      await this.visit('/');
      assertNav({
        prevented: true
      }, () => this.$('#about-link > a').click(), assert);
    }
    async ["@test it accepts string/numeric arguments"](assert) {
      this.router.map(function () {
        this.route('filter', {
          path: '/filters/:filter'
        });
        this.route('post', {
          path: '/post/:post_id'
        });
        this.route('repo', {
          path: '/repo/:owner/:name'
        });
      });
      this.add('controller:filter', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.filter = 'unpopular';
          this.repo = {
            owner: 'ember',
            name: 'ember.js'
          };
          this.post_id = 123;
        }
      });
      this.addTemplate('filter', "\n        <p>{{this.filter}}</p>\n        <div id=\"link\">{{#link-to route=\"filter\" model=\"unpopular\"}}Unpopular{{/link-to}}</div>\n        <div id=\"path-link\">{{#link-to route=\"filter\" model=this.filter}}Unpopular{{/link-to}}</div>\n        <div id=\"post-path-link\">{{#link-to route=\"post\" model=this.post_id}}Post{{/link-to}}</div>\n        <div id=\"post-number-link\">{{#link-to route=\"post\" model=123}}Post{{/link-to}}</div>\n        <div id=\"repo-object-link\">{{#link-to route=\"repo\" model=this.repo}}Repo{{/link-to}}</div>\n        ");
      await this.visit('/filters/popular');
      assert.equal(normalizeUrl(this.$('#link > a').attr('href')), '/filters/unpopular');
      assert.equal(normalizeUrl(this.$('#path-link > a').attr('href')), '/filters/unpopular');
      assert.equal(normalizeUrl(this.$('#post-path-link > a').attr('href')), '/post/123');
      assert.equal(normalizeUrl(this.$('#post-number-link > a').attr('href')), '/post/123');
      assert.equal(normalizeUrl(this.$('#repo-object-link > a').attr('href')), '/repo/ember/ember.js');
    }
    async ["@test [GH#4201] Shorthand for route.index shouldn't throw errors about context arguments"](assert) {
      this.router.map(function () {
        this.route('lobby', function () {
          this.route('index', {
            path: ':lobby_id'
          });
          this.route('list');
        });
      });
      this.add('route:lobby.index', class extends _route.default {
        model(params) {
          assert.equal(params.lobby_id, 'foobar');
          return params.lobby_id;
        }
      });
      this.addTemplate('lobby.index', "<div id='lobby-link'>{{#link-to route='lobby' model='foobar'}}Lobby{{/link-to}}</div>");
      this.addTemplate('lobby.list', "<div id='lobby-link'>{{#link-to route='lobby' model='foobar'}}Lobby{{/link-to}}</div>");
      await this.visit('/lobby/list');
      await this.click('#lobby-link > a');
      shouldBeActive(assert, this.$('#lobby-link > a'));
    }
    async ["@test Quoteless route param performs property lookup"](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        <div id='string-link'>{{#link-to route='index'}}string{{/link-to}}</div>\n        <div id='path-link'>{{#link-to route=this.foo}}path{{/link-to}}</div>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.foo = 'index';
          controller = this;
        }
      });
      let assertEquality = href => {
        assert.equal(normalizeUrl(this.$('#string-link > a').attr('href')), '/');
        assert.equal(normalizeUrl(this.$('#path-link > a').attr('href')), href);
      };
      await this.visit('/');
      assertEquality('/');
      (0, _internalTestHelpers.runTask)(() => controller.set('foo', 'about'));
      assertEquality('/about');
    }
    async ["@test it refreshes href element when one of params changes"](assert) {
      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      let post = {
        id: '1'
      };
      let secondPost = {
        id: '2'
      };
      this.addTemplate('index', "<div id=\"post\">{{#link-to route=\"post\" model=this.post}}post{{/link-to}}</div>");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          controller = this;
        }
      });
      await this.visit('/');
      (0, _internalTestHelpers.runTask)(() => controller.set('post', post));
      assert.equal(normalizeUrl(this.$('#post > a').attr('href')), '/posts/1', 'precond - Link has rendered href attr properly');
      (0, _internalTestHelpers.runTask)(() => controller.set('post', secondPost));
      assert.equal(this.$('#post > a').attr('href'), '/posts/2', 'href attr was updated after one of the params had been changed');
      (0, _internalTestHelpers.runTask)(() => controller.set('post', null));
      assert.equal(this.$('#post > a').attr('href'), '#', 'href attr becomes # when one of the arguments in nullified');
    }
    async ["@test it is active when a route is active"](assert) {
      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "\n        <div id='about'>\n          <div id='about-link'>{{#link-to route='about'}}About{{/link-to}}</div>\n          <div id='item-link'>{{#link-to route='about.item'}}Item{{/link-to}}</div>\n          {{outlet}}\n        </div>\n        ");
      await this.visit('/about');
      assert.equal(this.$('#about-link > a.active').length, 1, 'The about route link is active');
      assert.equal(this.$('#item-link > a.active').length, 0, 'The item route link is inactive');
      await this.visit('/about/item');
      assert.equal(this.$('#about-link > a.active').length, 1, 'The about route link is active');
      assert.equal(this.$('#item-link > a.active').length, 1, 'The item route link is active');
    }
    async ["@test it works in an #each'd array of string route names"](assert) {
      this.router.map(function () {
        this.route('foo');
        this.route('bar');
        this.route('rar');
      });
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.routeNames = (0, _array.A)(['foo', 'bar', 'rar']);
          this.route1 = 'bar';
          this.route2 = 'foo';
          controller = this;
        }
      });
      this.addTemplate('index', "\n        {{#each this.routeNames as |routeName|}}\n          {{#link-to route=routeName}}{{routeName}}{{/link-to}}\n        {{/each}}\n        {{#each this.routeNames as |r|}}\n          {{#link-to route=r}}{{r}}{{/link-to}}\n        {{/each}}\n        {{#link-to route=this.route1}}a{{/link-to}}\n        {{#link-to route=this.route2}}b{{/link-to}}\n        ");
      let linksEqual = (links, expected) => {
        assert.equal(links.length, expected.length, 'Has correct number of links');
        let idx;
        for (idx = 0; idx < links.length; idx++) {
          let href = this.$(links[idx]).attr('href');
          // Old IE includes the whole hostname as well
          assert.equal(href.slice(-expected[idx].length), expected[idx], "Expected link to be '" + expected[idx] + "', but was '" + href + "'");
        }
      };
      await this.visit('/');
      linksEqual(this.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/bar', '/foo']);
      (0, _internalTestHelpers.runTask)(() => controller.set('route1', 'rar'));
      linksEqual(this.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/rar', '/foo']);
      (0, _internalTestHelpers.runTask)(() => controller.routeNames.shiftObject());
      linksEqual(this.$('a'), ['/bar', '/rar', '/bar', '/rar', '/rar', '/foo']);
    }
    async ["@test it throws a useful error if you invoke it wrong"](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "{{#link-to route='post'}}Post{{/link-to}}");
      return assert.rejectsAssertion(this.visit('/'), /(You attempted to define a `\{\{link-to "post"\}\}` but did not pass the parameters required for generating its dynamic segments.|You must provide param `post_id` to `generate`)/);
    }
    async ["@test it does not throw an error if its route has exited"](assert) {
      var _dec, _class15, _descriptor;
      assert.expect(0);
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "\n        <div id='home-link'>{{#link-to route='index'}}Home{{/link-to}}</div>\n        <div id='default-post-link'>{{#link-to route='post' model=this.defaultPost}}Default Post{{/link-to}}</div>\n        {{#if this.currentPost}}\n          <div id='current-post-link'>{{#link-to route='post' model=this.currentPost}}Current Post{{/link-to}}</div>\n        {{/if}}\n        ");
      this.add('controller:application', (_dec = (0, _controller.inject)('post'), (_class15 = class _class15 extends _controller.default {
        constructor() {
          super(...arguments);
          this.defaultPost = {
            id: 1
          };
          _initializerDefineProperty(this, "postController", _descriptor, this);
        }
        get currentPost() {
          return this.postController.model;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class15.prototype, "postController", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class15)));
      this.add('controller:post', class extends _controller.default {});
      this.add('route:post', class extends _route.default {
        model() {
          return {
            id: 2
          };
        }
        serialize(model) {
          return {
            post_id: model.id
          };
        }
      });
      await this.visit('/');
      await this.click('#default-post-link > a');
      await this.click('#home-link > a');
      await this.click('#current-post-link > a');
      await this.click('#home-link > a');
    }
    async ["@test its active property respects changing parent route context"](assert) {
      this.router.map(function () {
        this.route('things', {
          path: '/things/:name'
        }, function () {
          this.route('other');
        });
      });
      this.addTemplate('application', "\n        <div id='omg-link'>{{#link-to route='things' model='omg'}}OMG{{/link-to}}</div>\n        <div id='lol-link'>{{#link-to route='things' model='lol'}}LOL{{/link-to}}</div>\n        ");
      await this.visit('/things/omg');
      shouldBeActive(assert, this.$('#omg-link > a'));
      shouldNotBeActive(assert, this.$('#lol-link > a'));
      await this.visit('/things/omg/other');
      shouldBeActive(assert, this.$('#omg-link > a'));
      shouldNotBeActive(assert, this.$('#lol-link > a'));
    }
    async ["@test it populates href with default query param values even without query-params object"](assert) {
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo'];
          this.foo = '123';
        }
      });
      this.addTemplate('index', "<div id='the-link'>{{#link-to route='index'}}Index{{/link-to}}</div>");
      await this.visit('/');
      assert.equal(this.$('#the-link > a').attr('href'), '/', 'link has right href');
    }
    async ["@test it populates href with default query param values with empty query-params object"](assert) {
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo'];
          this.foo = '123';
        }
      });
      this.addTemplate('index', "<div id='the-link'>{{#link-to route='index' query=(hash)}}Index{{/link-to}}</div>");
      await this.visit('/');
      assert.equal(this.$('#the-link > a').attr('href'), '/', 'link has right href');
    }
    async ["@test it updates when route changes with only query-params and a block"](assert) {
      this.router.map(function () {
        this.route('about');
      });
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo', 'bar'];
          this.foo = '123';
          this.bar = 'yes';
        }
      });
      this.addTemplate('application', "<div id='the-link'>{{#link-to query=(hash foo='456' bar='NAW')}}Index{{/link-to}}</div>");
      await this.visit('/');
      assert.equal(this.$('#the-link > a').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
      await this.visit('/about');
      assert.equal(this.$('#the-link > a').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
    }
    async ['@test [GH#17018] passing model to {{link-to}} with `hash` helper works']() {
      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      this.add('route:index', class extends _route.default {
        model() {
          return _runtime.RSVP.hash({
            user: {
              name: 'Papa Smurf'
            }
          });
        }
      });
      this.addTemplate('index', "{{#link-to route='post' model=(hash id=\"someId\" user=@model.user)}}Post{{/link-to}}");
      this.addTemplate('post', 'Post: {{@model.user.name}}');
      await this.visit('/');
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: '/posts/someId'
        },
        content: 'Post'
      });
      await this.click('a');
      this.assertText('Post: Papa Smurf');
    }
    async ["@test [GH#13256]: {{link-to}} to a parent root model hook which performs a 'transitionTo' has correct active class"](assert) {
      var _class20, _descriptor2;
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.add('route:parent', (_class20 = class _class20 extends _route.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "router", _descriptor2, this);
        }
        afterModel() {
          this.router.transitionTo('parent.child');
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class20.prototype, "router", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class20));
      this.addTemplate('application', "<div id='parent-link'>{{#link-to route='parent'}}Parent{{/link-to}}</div>");
      await this.visit('/');
      await this.click('#parent-link > a');
      shouldBeActive(assert, this.$('#parent-link > a'));
    }
  });
  (0, _internalTestHelpers.moduleFor)('The {{link-to}} component - loading states and warnings', class extends _internalTestHelpers.ApplicationTestCase {
    async ["@test {{link-to}} with null/undefined dynamic parameters are put in a loading state"](assert) {
      let warningMessage = 'This link is in an inactive loading state because at least one of its models currently has a null/undefined value, or the provided route name is invalid.';
      this.router.map(function () {
        this.route('thing', {
          path: '/thing/:thing_id'
        });
        this.route('about');
      });
      this.addTemplate('index', "\n        <div id='context-link'>\n          {{#link-to route=this.destinationRoute model=this.routeContext loadingClass='i-am-loading'}}\n            string\n          {{/link-to}}\n        </div>\n        <div id='static-link'>\n          {{#link-to route=this.secondRoute loadingClass=this.loadingClass}}\n            string\n          {{/link-to}}\n        </div>\n        ");
      let controller;
      this.add('controller:index', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.destinationRoute = null;
          this.routeContext = null;
          this.loadingClass = 'i-am-loading';
          controller = this;
        }
      });
      let activate = 0;
      this.add('route:about', class extends _route.default {
        activate() {
          activate++;
        }
      });
      function assertLinkStatus(link, url) {
        if (url) {
          assert.equal(normalizeUrl(link.attr('href')), url, 'loaded link-to has expected href');
          assert.ok(!link.hasClass('i-am-loading'), 'loaded linkComponent has no loadingClass');
        } else {
          assert.equal(normalizeUrl(link.attr('href')), '#', "unloaded link-to has href='#'");
          assert.ok(link.hasClass('i-am-loading'), 'loading linkComponent has loadingClass');
        }
      }
      await this.visit('/');
      let contextLink = this.$('#context-link > a');
      let staticLink = this.$('#static-link > a');
      assertLinkStatus(contextLink);
      assertLinkStatus(staticLink);
      await expectWarning(() => this.click(contextLink[0]), warningMessage);

      // Set the destinationRoute (context is still null).
      (0, _internalTestHelpers.runTask)(() => controller.set('destinationRoute', 'thing'));
      assertLinkStatus(contextLink);

      // Set the routeContext to an id
      (0, _internalTestHelpers.runTask)(() => controller.set('routeContext', '456'));
      assertLinkStatus(contextLink, '/thing/456');

      // Test that 0 isn't interpreted as falsy.
      (0, _internalTestHelpers.runTask)(() => controller.set('routeContext', 0));
      assertLinkStatus(contextLink, '/thing/0');

      // Set the routeContext to an object
      (0, _internalTestHelpers.runTask)(() => controller.set('routeContext', {
        id: 123
      }));
      assertLinkStatus(contextLink, '/thing/123');

      // Set the destinationRoute back to null.
      (0, _internalTestHelpers.runTask)(() => controller.set('destinationRoute', null));
      assertLinkStatus(contextLink);
      await expectWarning(() => this.click(staticLink[0]), warningMessage);
      (0, _internalTestHelpers.runTask)(() => controller.set('secondRoute', 'about'));
      assertLinkStatus(staticLink, '/about');

      // Click the now-active link
      await this.click(staticLink[0]);
      assert.equal(activate, 1, 'About route was entered');
    }
  });
  function assertNav(options, callback, assert) {
    let nav = false;
    function check(event) {
      assert.equal(event.defaultPrevented, options.prevented, "expected defaultPrevented=" + options.prevented);
      nav = true;
      event.preventDefault();
    }
    try {
      document.addEventListener('click', check);
      callback();
    } finally {
      document.removeEventListener('click', check);
      assert.ok(nav, 'Expected a link to be clicked');
    }
  }
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/transitioning-classes-angle-test", ["@ember/-internals/runtime", "@ember/routing/route", "internal-test-helpers"], function (_runtime, _route, _internalTestHelpers) {
  "use strict";

  function assertHasClass(assert, selector, label) {
    let testLabel = selector.attr('id') + " should have class " + label;
    assert.equal(selector.hasClass(label), true, testLabel);
  }
  function assertHasNoClass(assert, selector, label) {
    let testLabel = selector.attr('id') + " should not have class " + label;
    assert.equal(selector.hasClass(label), false, testLabel);
  }
  (0, _internalTestHelpers.moduleFor)('<LinkTo /> component: .transitioning-in .transitioning-out CSS classes', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.aboutDefer = _runtime.RSVP.defer();
      this.otherDefer = _runtime.RSVP.defer();
      this.newsDefer = _runtime.RSVP.defer();
      let _this = this;
      this.router.map(function () {
        this.route('about');
        this.route('other');
        this.route('news');
      });
      this.add('route:about', class extends _route.default {
        model() {
          return _this.aboutDefer.promise;
        }
      });
      this.add('route:other', class extends _route.default {
        model() {
          return _this.otherDefer.promise;
        }
      });
      this.add('route:news', class extends _route.default {
        model() {
          return _this.newsDefer.promise;
        }
      });
      this.addTemplate('application', "\n        {{outlet}}\n        <LinkTo id='index-link' @route='index'>Index</LinkTo>\n        <LinkTo id='about-link' @route='about'>About</LinkTo>\n        <LinkTo id='other-link' @route='other'>Other</LinkTo>\n        <LinkTo id='news-link' @route='news' @activeClass={{false}}>News</LinkTo>\n        ");
    }
    beforeEach() {
      return this.visit('/');
    }
    afterEach() {
      super.afterEach();
      this.aboutDefer = null;
      this.otherDefer = null;
      this.newsDefer = null;
    }
    ['@test while a transition is underway'](assert) {
      let $index = this.$('#index-link');
      let $about = this.$('#about-link');
      let $other = this.$('#other-link');
      (0, _internalTestHelpers.runTask)(() => $about.click());
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(() => this.aboutDefer.resolve());
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    }
    ['@test while a transition is underway with activeClass is false'](assert) {
      let $index = this.$('#index-link');
      let $news = this.$('#news-link');
      let $other = this.$('#other-link');
      (0, _internalTestHelpers.runTask)(() => $news.click());
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(() => this.newsDefer.resolve());
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/link-to/transitioning-classes-curly-test", ["@ember/-internals/runtime", "@ember/routing/route", "internal-test-helpers"], function (_runtime, _route, _internalTestHelpers) {
  "use strict";

  function assertHasClass(assert, selector, label) {
    let testLabel = selector.attr('id') + " should have class " + label;
    assert.equal(selector.hasClass(label), true, testLabel);
  }
  function assertHasNoClass(assert, selector, label) {
    let testLabel = selector.attr('id') + " should not have class " + label;
    assert.equal(selector.hasClass(label), false, testLabel);
  }
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component: .transitioning-in .transitioning-out CSS classes', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.aboutDefer = _runtime.RSVP.defer();
      this.otherDefer = _runtime.RSVP.defer();
      this.newsDefer = _runtime.RSVP.defer();
      let _this = this;
      this.router.map(function () {
        this.route('about');
        this.route('other');
        this.route('news');
      });
      this.add('route:about', class extends _route.default {
        model() {
          return _this.aboutDefer.promise;
        }
      });
      this.add('route:other', class extends _route.default {
        model() {
          return _this.otherDefer.promise;
        }
      });
      this.add('route:news', class extends _route.default {
        model() {
          return _this.newsDefer.promise;
        }
      });
      this.addTemplate('application', "\n        {{outlet}}\n        <div id='index-link'>{{#link-to route='index'}}Index{{/link-to}}</div>\n        <div id='about-link'>{{#link-to route='about'}}About{{/link-to}}</div>\n        <div id='other-link'>{{#link-to route='other'}}Other{{/link-to}}</div>\n        <div id='news-link'>{{#link-to route='news' activeClass=false}}News{{/link-to}}</div>\n        ");
    }
    beforeEach() {
      return this.visit('/');
    }
    afterEach() {
      super.afterEach();
      this.aboutDefer = null;
      this.otherDefer = null;
      this.newsDefer = null;
    }
    ['@test while a transition is underway'](assert) {
      let $index = this.$('#index-link > a');
      let $about = this.$('#about-link > a');
      let $other = this.$('#other-link > a');
      (0, _internalTestHelpers.runTask)(() => $about.click());
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(() => this.aboutDefer.resolve());
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    }
    ['@test while a transition is underway with activeClass is false'](assert) {
      let $index = this.$('#index-link > a');
      let $news = this.$('#news-link > a');
      let $other = this.$('#other-link > a');
      (0, _internalTestHelpers.runTask)(() => $news.click());
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(() => this.newsDefer.resolve());
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/render-to-element-test", [], function () {
  "use strict";
});
define("@ember/-internals/glimmer/tests/integration/components/strict-mode-test", ["internal-test-helpers", "@ember/component", "@ember/routing", "@glimmer/runtime", "@ember/-internals/glimmer/tests/utils/glimmerish-component"], function (_internalTestHelpers, _component, _routing, _runtime, _glimmerishComponent) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Strict Mode', class extends _internalTestHelpers.RenderingTestCase {
    '@test Can use a component in scope'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({}, 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({
        Foo
      }, '<Foo/>');
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a custom helper in scope (in append position)'() {
      let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({
        foo
      }, '{{foo}}');
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a custom modifier in scope'() {
      let foo = (0, _internalTestHelpers.defineSimpleModifier)(element => element.innerHTML = 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({
        foo
      }, '<div {{foo}}></div>');
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('<div>Hello, world!</div>');
      this.assertStableRerender();
    }
    '@test Can shadow keywords'() {
      let ifComponent = (0, _internalTestHelpers.defineComponent)({}, 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({
        if: ifComponent
      }, '{{#if}}{{/if}}');
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use constant values in ambiguous helper/component position'() {
      let value = 'Hello, world!';
      let Foo = (0, _internalTestHelpers.defineComponent)({
        value
      }, '{{value}}');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use inline if and unless in strict mode templates'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({}, '{{if true "foo" "bar"}}{{unless true "foo" "bar"}}');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertHTML('foobar');
      this.assertStableRerender();
    }
    '@test Can use a dynamic component definition'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({}, 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({}, '<this.Foo/>', class extends _glimmerishComponent.default {
        constructor() {
          super(...arguments);
          this.Foo = Foo;
        }
      });
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a dynamic component definition (curly)'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({}, 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({}, '{{this.Foo}}', class extends _glimmerishComponent.default {
        constructor() {
          super(...arguments);
          this.Foo = Foo;
        }
      });
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a dynamic helper definition'() {
      let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'Hello, world!');
      let Bar = (0, _internalTestHelpers.defineComponent)({}, '{{this.foo}}', class extends _glimmerishComponent.default {
        constructor() {
          super(...arguments);
          this.foo = foo;
        }
      });
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a curried dynamic helper'() {
      let foo = (0, _internalTestHelpers.defineSimpleHelper)(value => value);
      let Foo = (0, _internalTestHelpers.defineComponent)({}, '{{@value}}');
      let Bar = (0, _internalTestHelpers.defineComponent)({
        Foo,
        foo
      }, '<Foo @value={{helper foo "Hello, world!"}}/>');
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a curried dynamic modifier'() {
      let foo = (0, _internalTestHelpers.defineSimpleModifier)((element, _ref) => {
        let [text] = _ref;
        return element.innerHTML = text;
      });
      let Foo = (0, _internalTestHelpers.defineComponent)({}, '<div {{@value}}></div>');
      let Bar = (0, _internalTestHelpers.defineComponent)({
        Foo,
        foo
      }, '<Foo @value={{modifier foo "Hello, world!"}}/>');
      this.registerComponent('bar', {
        ComponentClass: Bar
      });
      this.render('<Bar/>');
      this.assertHTML('<div>Hello, world!</div>');
      this.assertStableRerender();
    }
  });
  (0, _internalTestHelpers.moduleFor)('Strict Mode - built ins', class extends _internalTestHelpers.RenderingTestCase {
    '@test Can use Input'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        Input: _component.Input
      }, '<Input/>');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'text',
          class: 'ember-text-field ember-view'
        }
      });
      this.assertStableRerender();
    }
    '@test Can use Textarea'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        Textarea: _component.Textarea
      }, '<Textarea/>');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertComponentElement(this.firstChild, {
        tagName: 'textarea',
        attrs: {
          class: 'ember-text-area ember-view'
        }
      });
      this.assertStableRerender();
    }
    '@test Can use hash'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        hash: _runtime.hash
      }, '{{#let (hash value="Hello, world!") as |hash|}}{{hash.value}}{{/let}}');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use array'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        array: _runtime.array
      }, '{{#each (array "Hello, world!") as |value|}}{{value}}{{/each}}');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use concat'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        concat: _runtime.concat
      }, '{{(concat "Hello" ", " "world!")}}');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use get'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        hash: _runtime.hash,
        get: _runtime.get
      }, '{{#let (hash value="Hello, world!") as |hash|}}{{(get hash "value")}}{{/let}}');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.assertHTML('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use on and fn'(assert) {
      assert.expect(1);
      let handleClick = value => {
        assert.equal(value, 123);
      };
      let Foo = (0, _internalTestHelpers.defineComponent)({
        on: _runtime.on,
        fn: _runtime.fn,
        handleClick
      }, '<button {{on "click" (fn handleClick 123)}}>Click</button>');
      this.registerComponent('foo', {
        ComponentClass: Foo
      });
      this.render('<Foo/>');
      this.click('button');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Strict Mode - LinkTo', class extends _internalTestHelpers.ApplicationTestCase {
    '@test Can use LinkTo'() {
      let Foo = (0, _internalTestHelpers.defineComponent)({
        LinkTo: _routing.LinkTo
      }, '<LinkTo @route="index">Index</LinkTo>');
      this.addComponent('foo', {
        ComponentClass: Foo
      });
      this.addTemplate('index', "<Foo/>");
      return this.visit('/').then(() => {
        this.assertComponentElement(this.firstChild, {
          tagName: 'a',
          attrs: {
            href: '/',
            class: 'ember-view active'
          },
          content: 'Index'
        });
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/target-action-test", ["internal-test-helpers", "@ember/object", "@ember/object/mixin", "@ember/controller", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _mixin, _controller, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components test: send', class extends _internalTestHelpers.RenderingTestCase {
    ['@test sending to undefined actions triggers an error'](assert) {
      assert.expect(2);
      let component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            component = this;
          },
          actions: {
            foo(message) {
              assert.equal('bar', message);
            }
          }
        })
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.runTask)(() => component.send('foo', 'bar'));
      expectAssertion(() => {
        return component.send('baz', 'bar');
      }, /had no action handler for: baz/);
    }
    ['@test `send` will call send from a target if it is defined']() {
      let component;
      let target = {
        send: (message, payload) => {
          this.assert.equal('foo', message);
          this.assert.equal('baz', payload);
        }
      };
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            component = this;
          },
          target
        })
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.runTask)(() => component.send('foo', 'baz'));
    }
    ['@test a handled action can be bubbled to the target for continued processing']() {
      this.assert.expect(2);
      let component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            component = this;
          },
          actions: {
            poke: () => {
              this.assert.ok(true, 'component action called');
              return true;
            }
          },
          target: _controller.default.extend({
            actions: {
              poke: () => {
                this.assert.ok(true, 'action bubbled to controller');
              }
            }
          }).create()
        })
      });
      this.render('{{foo-bar poke="poke"}}');
      (0, _internalTestHelpers.runTask)(() => component.send('poke'));
    }
    ["@test action can be handled by a superclass' actions object"](assert) {
      this.assert.expect(4);
      let component;
      let SuperComponent = _helpers.Component.extend({
        actions: {
          foo() {
            assert.ok(true, 'foo');
          },
          bar(msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });
      let BarViewMixin = _mixin.default.create({
        actions: {
          bar(msg) {
            assert.equal(msg, 'HELLO');
            this._super(msg);
          }
        }
      });
      this.registerComponent('x-index', {
        ComponentClass: SuperComponent.extend(BarViewMixin, {
          init() {
            this._super(...arguments);
            component = this;
          },
          actions: {
            baz() {
              assert.ok(true, 'baz');
            }
          }
        })
      });
      this.render('{{x-index}}');
      (0, _internalTestHelpers.runTask)(() => {
        component.send('foo');
        component.send('bar', 'HELLO');
        component.send('baz');
      });
    }
    ['@test actions cannot be provided at create time'](assert) {
      this.registerComponent('foo-bar', _helpers.Component.extend());
      let ComponentFactory = this.owner.factoryFor('component:foo-bar');
      expectAssertion(() => {
        ComponentFactory.create({
          actions: {
            foo() {
              assert.ok(true, 'foo');
            }
          }
        });
      }, /`actions` must be provided at extend time, not at create time/);
      // but should be OK on an object that doesn't mix in Ember.ActionHandler
      _object.default.create({
        actions: ['foo']
      });
    }
    ['@test asserts if called on a destroyed component']() {
      let component;
      this.registerComponent('rip-alley', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super();
            component = this;
          },
          toString() {
            return 'component:rip-alley';
          }
        })
      });
      this.render('{{#if this.shouldRender}}{{rip-alley}}{{/if}}', {
        shouldRender: true
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'shouldRender', false);
      });
      expectAssertion(() => {
        component.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed object 'component:rip-alley'.");
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/template-only-components-test", ["internal-test-helpers", "@ember/-internals/environment", "@glimmer/manager", "@glimmer/runtime", "ember-template-compiler", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/debug-stack"], function (_internalTestHelpers, _environment, _manager, _runtime, _emberTemplateCompiler, _object, _helpers, _debugStack) {
  "use strict";

  class TemplateOnlyComponentsTest extends _internalTestHelpers.RenderingTestCase {
    registerTemplateOnlyComponent(name, template) {
      super.registerComponent(name, {
        template,
        ComponentClass: null
      });
    }
  }
  if (_environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS) {
    (0, _internalTestHelpers.moduleFor)('Components test: template-only components (glimmer components)', class extends TemplateOnlyComponentsTest {
      ['@test it can render a template-only component']() {
        this.registerTemplateOnlyComponent('foo-bar', 'hello');
        this.render('{{foo-bar}}');
        this.assertInnerHTML('hello');
        this.assertStableRerender();
      }
      ['@test it can render named arguments']() {
        this.registerTemplateOnlyComponent('foo-bar', '|{{@foo}}|{{@bar}}|');
        this.render('{{foo-bar foo=this.foo bar=this.bar}}', {
          foo: 'foo',
          bar: 'bar'
        });
        this.assertInnerHTML('|foo|bar|');
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('foo', 'FOO'));
        this.assertInnerHTML('|FOO|bar|');
        (0, _internalTestHelpers.runTask)(() => this.context.set('bar', 'BAR'));
        this.assertInnerHTML('|FOO|BAR|');
        (0, _internalTestHelpers.runTask)(() => this.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        }));
        this.assertInnerHTML('|foo|bar|');
      }
      ['@test it does not reflected arguments as properties']() {
        this.registerTemplateOnlyComponent('foo-bar', '|{{this.foo}}|{{this.bar}}|');
        this.render('{{foo-bar foo=foo bar=bar}}', {
          foo: 'foo',
          bar: 'bar'
        });
        this.assertInnerHTML('|||');
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('foo', 'FOO'));
        this.assertInnerHTML('|||');
        (0, _internalTestHelpers.runTask)(() => this.context.set('bar', null));
        this.assertInnerHTML('|||');
        (0, _internalTestHelpers.runTask)(() => this.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        }));
        this.assertInnerHTML('|||');
      }
      ['@test it does not have curly component features']() {
        this.registerTemplateOnlyComponent('foo-bar', 'hello');
        this.render('{{foo-bar tagName="p" class=class}}', {
          class: 'foo bar'
        });
        this.assertInnerHTML('hello');
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('class', 'foo'));
        this.assertInnerHTML('hello');
        (0, _internalTestHelpers.runTask)(() => this.context.set('class', null));
        this.assertInnerHTML('hello');
        (0, _internalTestHelpers.runTask)(() => this.context.set('class', 'foo bar'));
        this.assertInnerHTML('hello');
      }
      ['@test it has the correct bounds']() {
        this.registerTemplateOnlyComponent('foo-bar', 'hello');
        this.render('outside {{#if this.isShowing}}before {{foo-bar}} after{{/if}} outside', {
          isShowing: true
        });
        this.assertInnerHTML('outside before hello after outside');
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('isShowing', false));
        this.assertInnerHTML('outside <!----> outside');
        (0, _internalTestHelpers.runTask)(() => this.context.set('isShowing', null));
        this.assertInnerHTML('outside <!----> outside');
        (0, _internalTestHelpers.runTask)(() => this.context.set('isShowing', true));
        this.assertInnerHTML('outside before hello after outside');
      }
      ['@test asserts when a shared dependency is changed during rendering, and keeps original context']() {
        this.registerComponent('x-outer', {
          ComponentClass: _helpers.Component.extend({
            value: 1,
            wrapper: _object.default.create({
              content: null
            })
          }),
          template: '<div id="outer-value">{{x-inner-template-only value=this.wrapper.content wrapper=wrapper}}</div>{{x-inner value=this.value wrapper=this.wrapper}}'
        });
        this.registerComponent('x-inner', {
          ComponentClass: _helpers.Component.extend({
            didReceiveAttrs() {
              this.get('wrapper').set('content', this.get('value'));
            },
            value: null
          }),
          template: '<div id="inner-value">{{wrapper.content}}</div>'
        });
        this.registerTemplateOnlyComponent('x-inner-template-only', '{{@value}}');
        let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('content', '<.+?>', {
          renderTree: ['x-outer', 'x-inner-template-only', 'this.wrapper.content']
        });
        expectAssertion(() => {
          this.render('{{x-outer}}');
        }, expectedBacktrackingMessage);
      }
    });
  } else {
    (0, _internalTestHelpers.moduleFor)('Components test: template-only components (curly components)', class extends TemplateOnlyComponentsTest {
      ['@test it can render a template-only component']() {
        this.registerTemplateOnlyComponent('foo-bar', 'hello');
        this.render('{{foo-bar}}');
        this.assertComponentElement(this.firstChild, {
          content: 'hello'
        });
        this.assertStableRerender();
      }
      ['@test it can render named arguments']() {
        this.registerTemplateOnlyComponent('foo-bar', '|{{@foo}}|{{@bar}}|');
        this.render('{{foo-bar foo=this.foo bar=this.bar}}', {
          foo: 'foo',
          bar: 'bar'
        });
        this.assertComponentElement(this.firstChild, {
          content: '|foo|bar|'
        });
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('foo', 'FOO'));
        this.assertComponentElement(this.firstChild, {
          content: '|FOO|bar|'
        });
        (0, _internalTestHelpers.runTask)(() => this.context.set('bar', 'BAR'));
        this.assertComponentElement(this.firstChild, {
          content: '|FOO|BAR|'
        });
        (0, _internalTestHelpers.runTask)(() => this.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        }));
        this.assertComponentElement(this.firstChild, {
          content: '|foo|bar|'
        });
      }
      ['@test it renders named arguments as reflected properties']() {
        this.registerTemplateOnlyComponent('foo-bar', '|{{this.foo}}|{{this.bar}}|');
        this.render('{{foo-bar foo=this.foo bar=this.bar}}', {
          foo: 'foo',
          bar: 'bar'
        });
        this.assertComponentElement(this.firstChild, {
          content: '|foo|bar|'
        });
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('foo', 'FOO'));
        this.assertComponentElement(this.firstChild, {
          content: '|FOO|bar|'
        });
        (0, _internalTestHelpers.runTask)(() => this.context.set('bar', null));
        this.assertComponentElement(this.firstChild, {
          content: '|FOO||'
        });
        (0, _internalTestHelpers.runTask)(() => this.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        }));
        this.assertComponentElement(this.firstChild, {
          content: '|foo|bar|'
        });
      }
      ['@test it has curly component features']() {
        this.registerTemplateOnlyComponent('foo-bar', 'hello');
        this.render('{{foo-bar tagName="p" class=this.class}}', {
          class: 'foo bar'
        });
        this.assertComponentElement(this.firstChild, {
          tagName: 'p',
          attrs: {
            class: (0, _internalTestHelpers.classes)('foo bar ember-view')
          },
          content: 'hello'
        });
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(() => this.context.set('class', 'foo'));
        this.assertComponentElement(this.firstChild, {
          tagName: 'p',
          attrs: {
            class: (0, _internalTestHelpers.classes)('foo ember-view')
          },
          content: 'hello'
        });
        (0, _internalTestHelpers.runTask)(() => this.context.set('class', null));
        this.assertComponentElement(this.firstChild, {
          tagName: 'p',
          attrs: {
            class: (0, _internalTestHelpers.classes)('ember-view')
          },
          content: 'hello'
        });
        (0, _internalTestHelpers.runTask)(() => this.context.set('class', 'foo bar'));
        this.assertComponentElement(this.firstChild, {
          tagName: 'p',
          attrs: {
            class: (0, _internalTestHelpers.classes)('foo bar ember-view')
          },
          content: 'hello'
        });
      }
    });
  }
  (0, _internalTestHelpers.moduleFor)('Components test: template-only components (using `templateOnlyComponent()`)', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can render a component']() {
      this.registerComponent('foo-bar', {
        ComponentClass: (0, _runtime.templateOnlyComponent)(),
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertInnerHTML('hello');
      this.assertStableRerender();
    }
    ['@test it can render a component when template was not registered']() {
      let ComponentClass = (0, _runtime.templateOnlyComponent)();
      (0, _manager.setComponentTemplate)((0, _emberTemplateCompiler.compile)('hello'), ComponentClass);
      this.registerComponent('foo-bar', {
        ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertInnerHTML('hello');
      this.assertStableRerender();
    }
    ['@test setComponentTemplate takes precedence over registered layout']() {
      let ComponentClass = (0, _runtime.templateOnlyComponent)();
      (0, _manager.setComponentTemplate)((0, _emberTemplateCompiler.compile)('hello'), ComponentClass);
      this.registerComponent('foo-bar', {
        ComponentClass,
        template: 'this should not be rendered'
      });
      this.render('{{foo-bar}}');
      this.assertInnerHTML('hello');
      this.assertStableRerender();
    }
    ['@test templateOnly accepts a moduleName to be used for debugging / toString purposes'](assert) {
      let ComponentClass = (0, _runtime.templateOnlyComponent)('my-app/components/foo');
      assert.equal("" + ComponentClass, 'my-app/components/foo');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/textarea-angle-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  class TextAreaRenderingTest extends _internalTestHelpers.RenderingTestCase {
    assertTextArea(_temp) {
      let {
        attrs,
        value
      } = _temp === void 0 ? {} : _temp;
      let mergedAttrs = Object.assign({
        class: (0, _internalTestHelpers.classes)('ember-view ember-text-area')
      }, attrs);
      this.assertComponentElement(this.firstChild, {
        tagName: 'textarea',
        attrs: mergedAttrs
      });
      if (value) {
        this.assert.strictEqual(value, this.firstChild.value);
      }
    }
    triggerEvent(type, options) {
      if (options === void 0) {
        options = {};
      }
      let event = document.createEvent('Events');
      event.initEvent(type, true, true);
      Object.assign(event, options);
      this.firstChild.dispatchEvent(event);
    }
  }
  class BoundTextAreaAttributes {
    constructor(cases) {
      this.cases = cases;
    }
    generate(_ref) {
      let {
        attribute,
        first,
        second
      } = _ref;
      return {
        ["@test " + attribute + " (HTML attribute)"]() {
          this.render("<Textarea " + attribute + "={{this.value}} />", {
            value: first
          });
          this.assertTextArea({
            attrs: {
              [attribute]: first
            }
          });
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', second));
          this.assertTextArea({
            attrs: {
              [attribute]: second
            }
          });
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', first));
          this.assertTextArea({
            attrs: {
              [attribute]: first
            }
          });
        }
      };
    }
  }
  (0, _internalTestHelpers.applyMixins)(TextAreaRenderingTest, new BoundTextAreaAttributes([{
    attribute: 'role',
    first: 'textbox',
    second: 'search'
  }, {
    attribute: 'placeholder',
    first: 'Stuff here',
    second: 'Other stuff'
  }, {
    attribute: 'name',
    first: 'Stuff here',
    second: 'Other stuff'
  }, {
    attribute: 'title',
    first: 'Stuff here',
    second: 'Other stuff'
  }, {
    attribute: 'maxlength',
    first: '1',
    second: '2'
  }, {
    attribute: 'rows',
    first: '1',
    second: '2'
  }, {
    attribute: 'cols',
    first: '1',
    second: '2'
  }, {
    attribute: 'tabindex',
    first: '1',
    second: '2'
  }]));
  (0, _internalTestHelpers.moduleFor)('Components test: <Textarea>', class extends TextAreaRenderingTest {
    ['@test Should catch <TextArea />` typo']() {
      expectAssertion(() => {
        this.render('<TextArea />');
      }, 'Could not find component `<TextArea />` (did you mean `<Textarea />`?)');
    }
    ['@test Should insert a <textarea>'](assert) {
      this.render('<Textarea />');
      assert.equal(this.$('textarea').length, 1);
      this.assertStableRerender();
    }
    ['@test Should respect disabled (HTML attribute)'](assert) {
      this.render('<Textarea disabled={{this.disabled}} />', {
        disabled: true
      });
      assert.ok(this.$('textarea').is(':disabled'));
    }
    ['@test Should respect disabled (HTML attribute) when false'](assert) {
      this.render('<Textarea disabled={{this.disabled}} />', {
        disabled: false
      });
      assert.ok(this.$('textarea').is(':not(:disabled)'));
    }
    ['@test Should become disabled (HTML attribute) when the context changes'](assert) {
      this.render('<Textarea disabled={{this.disabled}} />');
      assert.ok(this.$('textarea').is(':not(:disabled)'));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'disabled', true));
      assert.ok(this.$('textarea').is(':disabled'));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'disabled', false));
      assert.ok(this.$('textarea').is(':not(:disabled)'));
    }
    ['@test Should bind its contents to the specified @value']() {
      this.render('<Textarea @value={{this.model.val}} />', {
        model: {
          val: 'A beautiful day in Seattle'
        }
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.val', 'Auckland'));
      this.assertTextArea({
        value: 'Auckland'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        val: 'A beautiful day in Seattle'
      }));
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
    }
    ['@test GH#14001 Should correctly handle an empty string bound value']() {
      this.render('<Textarea @value={{this.message}} />', {
        message: ''
      });
      this.assert.strictEqual(this.firstChild.value, '');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'hello'));
      this.assert.strictEqual(this.firstChild.value, 'hello');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', ''));
      this.assert.strictEqual(this.firstChild.value, '');
    }
    ['@test should update the @value for `cut` / `input` / `change` events']() {
      this.render('<Textarea @value={{this.model.val}} />', {
        model: {
          val: 'A beautiful day in Seattle'
        }
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'Auckland';
        this.triggerEvent('cut');
      });
      this.assertTextArea({
        value: 'Auckland'
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'Hope';
        this.triggerEvent('paste');
      });
      this.assertTextArea({
        value: 'Hope'
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'Boston';
        this.triggerEvent('input');
      });
      this.assertTextArea({
        value: 'Boston'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        val: 'A beautiful day in Seattle'
      }));
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/textarea-curly-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  class TextAreaRenderingTest extends _internalTestHelpers.RenderingTestCase {
    assertTextArea(_temp) {
      let {
        attrs,
        value
      } = _temp === void 0 ? {} : _temp;
      let mergedAttrs = Object.assign({
        class: (0, _internalTestHelpers.classes)('ember-view ember-text-area')
      }, attrs);
      this.assertComponentElement(this.firstChild, {
        tagName: 'textarea',
        attrs: mergedAttrs
      });
      if (value) {
        this.assert.strictEqual(value, this.firstChild.value);
      }
    }
    triggerEvent(type, options) {
      if (options === void 0) {
        options = {};
      }
      let event = document.createEvent('Events');
      event.initEvent(type, true, true);
      Object.assign(event, options);
      this.firstChild.dispatchEvent(event);
    }
  }
  (0, _internalTestHelpers.moduleFor)('Components test: {{textarea}}', class extends TextAreaRenderingTest {
    ['@test Should insert a textarea'](assert) {
      this.render('{{textarea}}');
      assert.equal(this.$('textarea').length, 1);
      this.assertStableRerender();
    }
    ['@test Should bind its contents to the specified value']() {
      this.render('{{textarea value=this.model.val}}', {
        model: {
          val: 'A beautiful day in Seattle'
        }
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.val', 'Auckland'));
      this.assertTextArea({
        value: 'Auckland'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        val: 'A beautiful day in Seattle'
      }));
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
    }
    ['@test GH#14001 Should correctly handle an empty string bound value']() {
      this.render('{{textarea value=this.message}}', {
        message: ''
      });
      this.assert.strictEqual(this.firstChild.value, '');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'hello'));
      this.assert.strictEqual(this.firstChild.value, 'hello');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', ''));
      this.assert.strictEqual(this.firstChild.value, '');
    }
    ['@test should update the value for `cut` / `input` / `change` events']() {
      this.render('{{textarea value=this.model.val}}', {
        model: {
          val: 'A beautiful day in Seattle'
        }
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'Auckland';
        this.triggerEvent('cut');
      });
      this.assertTextArea({
        value: 'Auckland'
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'Hope';
        this.triggerEvent('paste');
      });
      this.assertTextArea({
        value: 'Hope'
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.firstChild.value = 'Boston';
        this.triggerEvent('input');
      });
      this.assertTextArea({
        value: 'Boston'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        val: 'A beautiful day in Seattle'
      }));
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/to-string-test", ["internal-test-helpers", "@ember/-internals/glimmer"], function (_internalTestHelpers, _glimmer) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('built-in component toString', class AbstractAppendTest extends _internalTestHelpers.RenderingTestCase {
    '@test component has the correct toString value'(assert) {
      assert.strictEqual(_glimmer.Component.toString(), '@ember/component');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/tracked-test", ["ember-babel", "@ember/object", "@ember/array", "@ember/array/proxy", "@ember/object/promise-proxy-mixin", "@ember/-internals/metal", "rsvp", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/glimmerish-component", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _object, _array, _proxy, _promiseProxyMixin, _metal, _rsvp, _internalTestHelpers, _glimmerishComponent, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7;
  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('Component Tracked Properties', class extends _internalTestHelpers.RenderingTestCase {
    '@test simple test using classic component'() {
      var _class, _descriptor, _descriptor2, _class3, _descriptor3, _descriptor4;
      let personId = 0;
      let Person = (_class = class Person {
        constructor(first, last) {
          _initializerDefineProperty(this, "first", _descriptor, this);
          _initializerDefineProperty(this, "last", _descriptor2, this);
          this.id = personId++;
          this.first = first;
          this.last = last;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "last", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class);
      let PersonComponent = (_class3 = class PersonComponent extends _helpers.Component {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "first", _descriptor3, this);
          _initializerDefineProperty(this, "last", _descriptor4, this);
        }
        get person() {
          return new Person(this.first, this.last);
        }
      }, (_descriptor3 = _applyDecoratedDescriptor(_class3.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor4 = _applyDecoratedDescriptor(_class3.prototype, "last", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class3);
      this.registerComponent('person-wrapper', {
        ComponentClass: PersonComponent,
        template: '{{@first}} {{@last}} | {{this.person.first}} {{this.person.last}}'
      });
      this.render('<PersonWrapper @first={{this.first}} @last={{this.last}} />', {
        first: 'robert',
        last: 'jackson'
      });
      this.assertText('robert jackson | robert jackson');
      (0, _internalTestHelpers.runTask)(() => this.context.set('first', 'max'));
      this.assertText('max jackson | max jackson');
    }
    '@test simple test using glimmerish component'() {
      var _class5, _descriptor5, _descriptor6;
      let personId = 0;
      let Person = (_class5 = class Person {
        constructor(first, last) {
          _initializerDefineProperty(this, "first", _descriptor5, this);
          _initializerDefineProperty(this, "last", _descriptor6, this);
          this.id = personId++;
          this.first = first;
          this.last = last;
        }
      }, (_descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor6 = _applyDecoratedDescriptor(_class5.prototype, "last", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class5);
      class PersonComponent extends _glimmerishComponent.default {
        get person() {
          return new Person(this.args.first, this.args.last);
        }
      }
      this.registerComponent('person-wrapper', {
        ComponentClass: PersonComponent,
        template: '{{@first}} {{@last}} | {{this.person.first}} {{this.person.last}}'
      });
      this.render('<PersonWrapper @first={{this.first}} @last={{this.last}} />', {
        first: 'robert',
        last: 'jackson'
      });
      this.assertText('robert jackson | robert jackson');
      (0, _internalTestHelpers.runTask)(() => this.context.set('first', 'max'));
      this.assertText('max jackson | max jackson');
    }
    '@test creating an array proxy inside a tracking context does not trigger backtracking assertion'() {
      let PromiseArray = _proxy.default.extend(_promiseProxyMixin.default);
      class LoaderComponent extends _glimmerishComponent.default {
        get data() {
          if (!this._data) {
            this._data = PromiseArray.create({
              promise: _rsvp.Promise.resolve([1, 2, 3])
            });
          }
          return this._data;
        }
      }
      this.registerComponent('loader', {
        ComponentClass: LoaderComponent,
        template: '{{#each this.data as |item|}}{{item}}{{/each}}'
      });
      this.render('<Loader/>');
      this.assertText('123');
    }
    '@test creating an array proxy inside a tracking context and immediately updating its content before usage does not trigger backtracking assertion'() {
      class LoaderComponent extends _glimmerishComponent.default {
        get data() {
          if (!this._data) {
            this._data = _proxy.default.create({
              content: (0, _array.A)()
            });
            this._data.content.pushObjects([1, 2, 3]);
          }
          return this._data;
        }
      }
      this.registerComponent('loader', {
        ComponentClass: LoaderComponent,
        template: '{{#each this.data as |item|}}{{item}}{{/each}}'
      });
      this.render('<Loader/>');
      this.assertText('123');
    }
    '@test tracked properties that are uninitialized do not throw an error'() {
      let CountComponent = _helpers.Component.extend({
        count: (0, _metal.tracked)(),
        increment() {
          if (!this.count) {
            this.count = 0;
          }
          this.count++;
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.count}}</button>'
      });
      this.render('<Counter />');
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
    }
    '@test tracked properties rerender when updated'() {
      let CountComponent = _helpers.Component.extend({
        count: (0, _metal.tracked)({
          value: 0
        }),
        increment() {
          this.count++;
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.count}}</button>'
      });
      this.render('<Counter />');
      this.assertText('0');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
    }
    '@test tracked properties rerender when updated outside of a runloop'(assert) {
      let done = assert.async();
      let CountComponent = _helpers.Component.extend({
        count: (0, _metal.tracked)({
          value: 0
        }),
        increment() {
          setTimeout(() => {
            this.count++;
          }, 100);
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.count}}</button>'
      });
      this.render('<Counter />');
      this.assertText('0');

      // intentionally outside of a runTask
      this.$('button').click();
      setTimeout(() => {
        this.assertText('1');
        done();
      }, 200);
    }
    '@test nested tracked properties rerender when updated'() {
      let Counter = _object.default.extend({
        count: (0, _metal.tracked)({
          value: 0
        })
      });
      let CountComponent = _helpers.Component.extend({
        counter: Counter.create(),
        increment() {
          this.counter.count++;
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.counter.count}}</button>'
      });
      this.render('<Counter />');
      this.assertText('0');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
    }
    '@test array properties rerender when updated'() {
      let NumListComponent = _helpers.Component.extend({
        numbers: (0, _metal.tracked)({
          initializer: () => (0, _array.A)([1, 2, 3])
        }),
        addNumber() {
          this.numbers.pushObject(4);
        }
      });
      this.registerComponent('num-list', {
        ComponentClass: NumListComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <button {{action this.addNumber}}>\n              {{#each this.numbers as |num|}}{{num}}{{/each}}\n            </button>\n          "])))
      });
      this.render('<NumList />');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1234');
    }
    '@test getters update when dependent properties are invalidated'() {
      let CountComponent = _helpers.Component.extend({
        count: (0, _metal.tracked)({
          value: 0
        }),
        countAlias: (0, _metal.nativeDescDecorator)({
          get() {
            return this.count;
          }
        }),
        increment() {
          this.count++;
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.countAlias}}</button>'
      });
      this.render('<Counter />');
      this.assertText('0');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
    }
    '@test getters update when dependent computeds are invalidated'() {
      let CountComponent = _helpers.Component.extend({
        _count: 0,
        count: (0, _object.computed)({
          get() {
            return this._count;
          },
          set(key, value) {
            return this._count = value;
          }
        }),
        get countAlias() {
          return this.count;
        },
        increment() {
          this.set('count', this.count + 1);
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.countAlias}}</button>'
      });
      this.render('<Counter />');
      this.assertText('0');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('2');
    }
    '@test nested getters update when dependent properties are invalidated'() {
      let Counter = _object.default.extend({
        count: (0, _metal.tracked)({
          value: 0
        }),
        countAlias: (0, _metal.nativeDescDecorator)({
          get() {
            return this.count;
          }
        })
      });
      let CountComponent = _helpers.Component.extend({
        counter: Counter.create(),
        increment() {
          this.counter.count++;
        }
      });
      this.registerComponent('counter', {
        ComponentClass: CountComponent,
        template: '<button {{action this.increment}}>{{this.counter.countAlias}}</button>'
      });
      this.render('<Counter />');
      this.assertText('0');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
    }
    '@test tracked object passed down through components updates correctly'(assert) {
      let Person = _object.default.extend({
        first: (0, _metal.tracked)({
          value: 'Rob'
        }),
        last: (0, _metal.tracked)({
          value: 'Jackson'
        }),
        full: (0, _metal.nativeDescDecorator)({
          get() {
            return this.first + " " + this.last;
          }
        })
      });
      let ParentComponent = _helpers.Component.extend({
        person: Person.create()
      });
      let ChildComponent = _helpers.Component.extend({
        updatePerson() {
          this.person.first = 'Kris';
          this.person.last = 'Selden';
        }
      });
      this.registerComponent('parent', {
        ComponentClass: ParentComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <div id=\"parent\">{{this.person.full}}</div>\n            <Child @person={{this.person}}/>\n          "])))
      });
      this.registerComponent('child', {
        ComponentClass: ChildComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <div id=\"child\">{{this.person.full}}</div>\n            <button onclick={{action this.updatePerson}}></button>\n          "])))
      });
      this.render('<Parent />');
      assert.equal(this.$('#parent').text(), 'Rob Jackson');
      assert.equal(this.$('#child').text(), 'Rob Jackson');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(this.$('#parent').text(), 'Kris Selden');
      assert.equal(this.$('#child').text(), 'Kris Selden');
    }
    '@test yielded getters update correctly'() {
      let PersonComponent = _helpers.Component.extend({
        first: (0, _metal.tracked)({
          value: 'Rob'
        }),
        last: (0, _metal.tracked)({
          value: 'Jackson'
        }),
        full: (0, _metal.nativeDescDecorator)({
          get() {
            return this.first + " " + this.last;
          }
        }),
        updatePerson() {
          this.first = 'Kris';
          this.last = 'Selden';
        }
      });
      this.registerComponent('person', {
        ComponentClass: PersonComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{yield this.full (action this.updatePerson)}}\n          "])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <Person as |name update|>\n            <button onclick={{update}}>\n              {{name}}\n            </button>\n          </Person>\n        "]))));
      this.assertText('Rob Jackson');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('Kris Selden');
    }
    '@test yielded nested getters update correctly'() {
      let Person = _object.default.extend({
        first: (0, _metal.tracked)({
          value: 'Rob'
        }),
        last: (0, _metal.tracked)({
          value: 'Jackson'
        }),
        full: (0, _metal.nativeDescDecorator)({
          get() {
            return this.first + " " + this.last;
          }
        })
      });
      let PersonComponent = _helpers.Component.extend({
        person: Person.create(),
        updatePerson() {
          this.person.first = 'Kris';
          this.person.last = 'Selden';
        }
      });
      this.registerComponent('person', {
        ComponentClass: PersonComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{yield this.person (action this.updatePerson)}}\n          "])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <Person as |p update|>\n            <button onclick={{update}}>\n              {{p.full}}\n            </button>\n          </Person>\n        "]))));
      this.assertText('Rob Jackson');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('Kris Selden');
    }
    '@test does not setup mandatory setter for untracked values'() {
      let person;
      class Person {
        constructor(first, last) {
          person = this;
          this.first = first;
          this.last = last;
        }
      }
      class PersonComponent extends _glimmerishComponent.default {
        constructor() {
          super(...arguments);
          this.person = new Person(this.args.first, this.args.last);
        }
      }
      this.registerComponent('person-wrapper', {
        ComponentClass: PersonComponent,
        template: '{{this.person.first}} {{this.person.last}}'
      });
      this.render('<PersonWrapper @first={{this.first}} @last={{this.last}} />', {
        first: 'robert',
        last: 'jackson'
      });
      this.assertText('robert jackson');

      // check to make sure we can still mutate the person
      person.first = 'max';
    }
    '@test works when EmberObject created during render'() {
      this.registerComponent('test', {
        ComponentClass: class extends _glimmerishComponent.default {},
        template: '{{@data.length}}'
      });
      let RecordMeta = new WeakMap();
      function getRecordMeta(record) {
        let meta = RecordMeta.get(record);
        if (meta === undefined) {
          meta = Object.create(null);
          RecordMeta.set(record, meta);
        }
        return meta;
      }

      // does not reproduce with native JS class only
      class Person extends _object.default {
        get name() {
          let meta = getRecordMeta(this);
          let name = (0, _object.get)(meta, 'name');
          return name;
        }
        set name(v) {
          let meta = getRecordMeta(this);
          (0, _object.set)(meta, 'name', v);
        }
      }
      class List {
        get records() {
          let p = Person.create({
            name: 'ye-haw'
          });
          return [p];
        }
      }
      this.render('<Test @data={{this.data.records}} />', {
        data: new List()
      });
      this.assertText('1');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Component Tracked Properties w/ Args Proxy', class extends _internalTestHelpers.RenderingTestCase {
    '@test downstream property changes do not invalidate upstream component getters/arguments'(assert) {
      var _class8, _descriptor7;
      let outerRenderCount = 0;
      let innerRenderCount = 0;
      class OuterComponent extends _glimmerishComponent.default {
        get count() {
          outerRenderCount++;
          return this.args.count;
        }
      }
      let InnerComponent = (_class8 = class InnerComponent extends _glimmerishComponent.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "count", _descriptor7, this);
        }
        get combinedCounts() {
          innerRenderCount++;
          return this.args.count + this.count;
        }
        updateInnerCount() {
          this.count++;
        }
      }, _descriptor7 = _applyDecoratedDescriptor(_class8.prototype, "count", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 0;
        }
      }), _class8);
      this.registerComponent('outer', {
        ComponentClass: OuterComponent,
        template: '<Inner @count={{this.count}}/>'
      });
      this.registerComponent('inner', {
        ComponentClass: InnerComponent,
        template: '<button {{action this.updateInnerCount}}>{{this.combinedCounts}}</button>'
      });
      this.render('<Outer @count={{this.count}}/>', {
        count: 0
      });
      this.assertText('0');
      assert.equal(outerRenderCount, 1);
      assert.equal(innerRenderCount, 1);
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1');
      assert.equal(outerRenderCount, 1, 'updating inner component does not cause outer component to rerender');
      assert.equal(innerRenderCount, 2, 'updating inner component causes inner component to rerender');
      (0, _internalTestHelpers.runTask)(() => this.context.set('count', 1));
      this.assertText('2');
      assert.equal(outerRenderCount, 2, 'outer component updates based on context');
      assert.equal(innerRenderCount, 3, 'inner component updates based on outer component');
    }
    '@test computed properties can depend on args'() {
      var _dec, _class10;
      let TestComponent = (_dec = (0, _object.computed)('args.text'), (_class10 = class TestComponent extends _glimmerishComponent.default {
        get text() {
          return this.args.text;
        }
      }, _applyDecoratedDescriptor(_class10.prototype, "text", [_dec], Object.getOwnPropertyDescriptor(_class10.prototype, "text"), _class10.prototype), _class10));
      this.registerComponent('test', {
        ComponentClass: TestComponent,
        template: '<p>{{this.text}}</p>'
      });
      this.render('<Test @text={{this.text}}/>', {
        text: 'hello!'
      });
      this.assertText('hello!');
      (0, _internalTestHelpers.runTask)(() => this.context.set('text', 'hello world!'));
      this.assertText('hello world!');
      (0, _internalTestHelpers.runTask)(() => this.context.set('text', 'hello!'));
      this.assertText('hello!');
    }
    '@test computed properties can depend on nested args'() {
      var _dec2, _class11;
      let foo = _object.default.create({
        text: 'hello!'
      });
      let TestComponent = (_dec2 = (0, _object.computed)('args.foo.text'), (_class11 = class TestComponent extends _glimmerishComponent.default {
        get text() {
          return this.args.foo.text;
        }
      }, _applyDecoratedDescriptor(_class11.prototype, "text", [_dec2], Object.getOwnPropertyDescriptor(_class11.prototype, "text"), _class11.prototype), _class11));
      this.registerComponent('test', {
        ComponentClass: TestComponent,
        template: '<p>{{this.text}}</p>'
      });
      this.render('<Test @foo={{this.foo}}/>', {
        foo: foo
      });
      this.assertText('hello!');
      (0, _internalTestHelpers.runTask)(() => foo.set('text', 'hello world!'));
      this.assertText('hello world!');
      (0, _internalTestHelpers.runTask)(() => foo.set('text', 'hello!'));
      this.assertText('hello!');
    }
    '@test args can be accessed with get()'() {
      class TestComponent extends _glimmerishComponent.default {
        get text() {
          return (0, _object.get)(this, 'args.text');
        }
      }
      this.registerComponent('test', {
        ComponentClass: TestComponent,
        template: '<p>{{this.text}}</p>'
      });
      this.render('<Test @text={{this.text}}/>', {
        text: 'hello!'
      });
      this.assertText('hello!');
      (0, _internalTestHelpers.runTask)(() => this.context.set('text', 'hello world!'));
      this.assertText('hello world!');
      (0, _internalTestHelpers.runTask)(() => this.context.set('text', 'hello!'));
      this.assertText('hello!');
    }
    '@test args can be accessed with get() if no value is passed'() {
      class TestComponent extends _glimmerishComponent.default {
        get text() {
          return (0, _object.get)(this, 'args.text') || 'hello!';
        }
      }
      this.registerComponent('test', {
        ComponentClass: TestComponent,
        template: '<p>{{this.text}}</p>'
      });
      this.render('<Test/>', {
        text: 'hello!'
      });
      this.assertText('hello!');
    }
    '@test named args are enumerable'() {
      class TestComponent extends _glimmerishComponent.default {
        get objectKeys() {
          return Object.keys(this.args).join('');
        }
        get hasArg() {
          return 'text' in this.args;
        }
      }
      this.registerComponent('test', {
        ComponentClass: TestComponent,
        template: '<p>{{this.objectKeys}} {{this.hasArg}}</p>'
      });
      this.render('<Test @text={{this.text}}/>', {
        text: 'hello!'
      });
      this.assertText('text true');
    }
    '@test each-in works with args'() {
      this.registerComponent('test', {
        ComponentClass: class extends _glimmerishComponent.default {},
        template: '{{#each-in this.args as |key value|}}{{key}}:{{value}}{{/each-in}}'
      });
      this.render('<Test @text={{this.text}}/>', {
        text: 'hello!'
      });
      this.assertText('text:hello!');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/utils-test", ["internal-test-helpers", "@ember/controller", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _controller, _views, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View tree tests', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.addComponent('x-tagless', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="{{this.id}}">[{{this.id}}] {{#if this.isShowing}}{{yield}}{{/if}}</div>'
      });
      this.addComponent('x-toggle', {
        ComponentClass: _helpers.Component.extend({
          isExpanded: true,
          click() {
            this.toggleProperty('isExpanded');
            return false;
          }
        }),
        template: '[{{this.id}}] {{#if this.isExpanded}}{{yield}}{{/if}}'
      });
      let ToggleController = _controller.default.extend({
        isExpanded: true,
        actions: {
          toggle: function () {
            this.toggleProperty('isExpanded');
          }
        }
      });
      this.add('controller:application', ToggleController);
      this.addTemplate('application', "\n      {{x-tagless id=\"root-1\"}}\n\n      {{#x-toggle id=\"root-2\"}}\n        {{x-toggle id=\"inner-1\"}}\n\n        {{#x-toggle id=\"inner-2\"}}\n          {{x-toggle id=\"inner-3\"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      <button id=\"toggle-application\" {{action \"toggle\"}}>Toggle</button>\n\n      {{#if this.isExpanded}}\n        {{x-toggle id=\"root-3\"}}\n      {{/if}}\n\n      {{outlet}}\n    ");
      this.add('controller:index', ToggleController.extend({
        isExpanded: false
      }));
      this.addTemplate('index', "\n      {{x-tagless id=\"root-4\"}}\n\n      {{#x-toggle id=\"root-5\" isExpanded=false}}\n        {{x-toggle id=\"inner-4\"}}\n\n        {{#x-toggle id=\"inner-5\"}}\n          {{x-toggle id=\"inner-6\"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      <button id=\"toggle-index\" {{action \"toggle\"}}>Toggle</button>\n\n      {{#if this.isExpanded}}\n        {{x-toggle id=\"root-6\"}}\n      {{/if}}\n    ");
      this.addTemplate('zomg', "\n      {{x-tagless id=\"root-7\"}}\n\n      {{#x-toggle id=\"root-8\"}}\n        {{x-toggle id=\"inner-7\"}}\n\n        {{#x-toggle id=\"inner-8\"}}\n          {{x-toggle id=\"inner-9\"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      {{#x-toggle id=\"root-9\"}}\n        {{outlet}}\n      {{/x-toggle}}\n    ");
      this.addTemplate('zomg.lol', "\n      {{x-toggle id=\"inner-10\"}}\n    ");
      this.router.map(function () {
        this.route('zomg', function () {
          this.route('lol');
        });
      });
    }
    ['@test getRootViews']() {
      return this.visit('/').then(() => {
        this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5']);
        (0, _internalTestHelpers.runTask)(() => this.$('#toggle-application').click());
        this.assertRootViews(['root-1', 'root-2', 'root-4', 'root-5']);
        (0, _internalTestHelpers.runTask)(() => {
          this.$('#toggle-application').click();
          this.$('#toggle-index').click();
        });
        this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5', 'root-6']);
        return this.visit('/zomg/lol');
      }).then(() => {
        this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-7', 'root-8', 'root-9']);
        return this.visit('/');
      }).then(() => {
        this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5', 'root-6']);
      });
    }
    assertRootViews(ids) {
      let owner = this.applicationInstance;
      let actual = (0, _views.getRootViews)(owner).map(view => view.id).sort();
      let expected = ids.sort();
      this.assert.deepEqual(actual, expected, 'root views');
    }
    ['@test getChildViews']() {
      return this.visit('/').then(() => {
        this.assertChildViews('root-2', ['inner-1', 'inner-2']);
        this.assertChildViews('root-5', []);
        this.assertChildViews('inner-2', ['inner-3']);
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        this.assertChildViews('root-2', []);
        (0, _internalTestHelpers.runTask)(() => this.$('#root-5').click());
        this.assertChildViews('root-5', ['inner-4', 'inner-5']);
        this.assertChildViews('inner-5', ['inner-6']);
        return this.visit('/zomg');
      }).then(() => {
        this.assertChildViews('root-2', []);
        this.assertChildViews('root-8', ['inner-7', 'inner-8']);
        this.assertChildViews('inner-8', ['inner-9']);
        this.assertChildViews('root-9', []);
        (0, _internalTestHelpers.runTask)(() => this.$('#root-8').click());
        this.assertChildViews('root-8', []);
        return this.visit('/zomg/lol');
      }).then(() => {
        this.assertChildViews('root-2', []);
        this.assertChildViews('root-8', []);
        this.assertChildViews('root-9', ['inner-10']);
        return this.visit('/');
      }).then(() => {
        this.assertChildViews('root-2', []);
        this.assertChildViews('root-5', []);
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#inner-2').click());
        this.assertChildViews('root-2', ['inner-1', 'inner-2']);
        this.assertChildViews('inner-2', []);
      });
    }
    ['@test getChildViews does not return duplicates']() {
      return this.visit('/').then(() => {
        this.assertChildViews('root-2', ['inner-1', 'inner-2']);
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        (0, _internalTestHelpers.runTask)(() => this.$('#root-2').click());
        this.assertChildViews('root-2', ['inner-1', 'inner-2']);
      });
    }
    assertChildViews(parentId, childIds) {
      let parentView = this.viewFor(parentId);
      let childViews = (0, _views.getChildViews)(parentView);
      let actual = childViews.map(view => view.id).sort();
      let expected = childIds.sort();
      this.assert.deepEqual(actual, expected, "child views for #" + parentId);
    }
    viewFor(id) {
      let owner = this.applicationInstance;
      let registry = owner.lookup('-view-registry:main');
      return registry[id];
    }
  });
  let hasGetClientRects, hasGetBoundingClientRect;
  let ClientRectListCtor, ClientRectCtor;
  (function () {
    if (document.createRange) {
      let range = document.createRange();
      if (range.getClientRects) {
        let clientRectsList = range.getClientRects();
        hasGetClientRects = true;
        ClientRectListCtor = clientRectsList && clientRectsList.constructor;
      }
      if (range.getBoundingClientRect) {
        let clientRect = range.getBoundingClientRect();
        hasGetBoundingClientRect = true;
        ClientRectCtor = clientRect && clientRect.constructor;
      }
    }
  })();
  (0, _internalTestHelpers.moduleFor)('Bounds tests', class extends _internalTestHelpers.RenderingTestCase {
    ['@test getViewBounds on a regular component'](assert) {
      let component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            component = this;
          }
        }),
        template: "<p>Hi, mom!</p>"
      });
      this.render("{{hi-mom}}");
      let {
        parentElement,
        firstNode,
        lastNode
      } = (0, _views.getViewBounds)(component);
      assert.equal(parentElement, this.element, 'a regular component should have the right parentElement');
      assert.equal(firstNode, component.element, 'a regular component should have a single node that is its element');
      assert.equal(lastNode, component.element, 'a regular component should have a single node that is its element');
    }
    ['@test getViewBounds on a tagless component'](assert) {
      let component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init() {
            this._super(...arguments);
            component = this;
          }
        }),
        template: "<span id=\"start-node\">Hi,</span> <em id=\"before-end-node\">mom</em>!"
      });
      this.render("{{hi-mom}}");
      let {
        parentElement,
        firstNode,
        lastNode
      } = (0, _views.getViewBounds)(component);
      assert.equal(parentElement, this.element, 'a tagless component should have the right parentElement');
      assert.equal(firstNode, this.$('#start-node')[0], 'a tagless component should have a range enclosing all of its nodes');
      assert.equal(lastNode, this.$('#before-end-node')[0].nextSibling, 'a tagless component should have a range enclosing all of its nodes');
    }
    ['@test getViewClientRects'](assert) {
      if (!hasGetClientRects || !ClientRectListCtor) {
        assert.ok(true, 'The test environment does not support the DOM API required to run this test.');
        return;
      }
      let component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            component = this;
          }
        }),
        template: "<p>Hi, mom!</p>"
      });
      this.render("{{hi-mom}}");
      assert.ok((0, _views.getViewClientRects)(component) instanceof ClientRectListCtor);
    }
    ['@test getViewBoundingClientRect'](assert) {
      if (!hasGetBoundingClientRect || !ClientRectCtor) {
        assert.ok(true, 'The test environment does not support the DOM API required to run this test.');
        return;
      }
      let component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            component = this;
          }
        }),
        template: "<p>Hi, mom!</p>"
      });
      this.render("{{hi-mom}}");
      assert.ok((0, _views.getViewBoundingClientRect)(component) instanceof ClientRectCtor);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/web-component-fallback-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components test: web component fallback', class extends _internalTestHelpers.RenderingTestCase {
    ['@test custom elements are rendered']() {
      let template = "<foo-bar some-attr=\"123\">hello</foo-bar>";
      this.render(template);
      this.assertHTML(template);
      this.assertStableRerender();
    }
    ['@test custom elements can have bound attributes']() {
      let template = "<foo-bar some-attr=\"{{this.name}}\">hello</foo-bar>";
      this.render(template, {
        name: 'Robert'
      });
      this.assertHTML("<foo-bar some-attr=\"Robert\">hello</foo-bar>");
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Kris'));
      this.assertHTML("<foo-bar some-attr=\"Kris\">hello</foo-bar>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Robert'));
      this.assertHTML("<foo-bar some-attr=\"Robert\">hello</foo-bar>");
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/components/will-destroy-element-hook-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Component willDestroyElement hook', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it calls willDestroyElement when removed by if'](assert) {
      let didInsertElementCount = 0;
      let willDestroyElementCount = 0;
      let FooBarComponent = _helpers.Component.extend({
        didInsertElement() {
          didInsertElementCount++;
          assert.notEqual(this.element.parentNode, null, 'precond component is in DOM');
        },
        willDestroyElement() {
          willDestroyElementCount++;
          assert.notEqual(this.element.parentNode, null, 'has not been removed from DOM yet');
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if this.switch}}{{foo-bar}}{{/if}}', {
        switch: true
      });
      assert.equal(didInsertElementCount, 1, 'didInsertElement was called once');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'switch', false));
      assert.equal(willDestroyElementCount, 1, 'willDestroyElement was called once');
      this.assertText('');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/content-test", ["internal-test-helpers", "@ember/object", "@ember/debug", "@ember/object/computed", "@ember/object/proxy", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _debug, _computed, _proxy, _views, _helpers) {
  "use strict";

  const EMPTY = Object.freeze({});
  const LITERALS = [['foo', 'foo', '"foo"'], [undefined, EMPTY], [null, EMPTY], [true, 'true'], [false, 'false'], [0, '0'], [-0, '0', '-0'], [1, '1'], [-1, '-1'], [0.0, '0', '0.0'], [0.5, '0.5', '0.5'], [0.5, '0.5', '0.500000000000000000000000000000'],
  // Kris Selden: that is a good one because it is above that 3 bit area,
  // but the shifted < 0 check doesn't return true:
  // https://github.com/glimmerjs/glimmer-vm/blob/761e78b2bef5de8b9b19ae5fb296380c21959ef8/packages/%40glimmer/opcode-compiler/lib/opcode-builder/encoder.ts#L277
  [536870912, '536870912'],
  // Kris Selden: various other 10000000 and 1111111 combos
  [4294967296, '4294967296'], [4294967295, '4294967295'], [4294967294, '4294967294'], [536870913, '536870913'], [536870911, '536870911'], [268435455, '268435455']];
  let i = Number.MAX_SAFE_INTEGER;
  while (i > 1) {
    LITERALS.push([i, "" + i, "" + i]);
    i = Math.round(i / 2);
  }
  i = Number.MIN_SAFE_INTEGER;
  while (i < -1) {
    LITERALS.push([i, "" + i, "" + i]);
    i = Math.round(i / 2);
  }
  class StaticContentTest extends _internalTestHelpers.RenderingTestCase {
    ['@test it can render a static text node']() {
      this.render('hello');
      let text1 = this.assertTextNode(this.firstChild, 'hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let text2 = this.assertTextNode(this.firstChild, 'hello');
      this.assertSameNode(text1, text2);
    }
    ['@test it can render a static element']() {
      this.render('<p>hello</p>');
      let p1 = this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      let text1 = this.assertTextNode(this.firstChild.firstChild, 'hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      let p2 = this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      let text2 = this.assertTextNode(this.firstChild.firstChild, 'hello');
      this.assertSameNode(p1, p2);
      this.assertSameNode(text1, text2);
    }
    ['@test it can render a static template']() {
      let template = "\n    <div class=\"header\">\n      <h1>Welcome to Ember.js</h1>\n    </div>\n    <div class=\"body\">\n      <h2>Why you should use Ember.js?</h2>\n      <ol>\n        <li>It's great</li>\n        <li>It's awesome</li>\n        <li>It's Ember.js</li>\n      </ol>\n    </div>\n    <div class=\"footer\">\n      Ember.js is free, open source and always will be.\n    </div>\n  ";
      this.render(template);
      this.assertHTML(template);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertHTML(template);
    }
  }
  class StaticContentTestGenerator {
    constructor(cases, tag) {
      if (tag === void 0) {
        tag = '@test';
      }
      this.cases = cases;
      this.tag = tag;
    }
    generate(_ref) {
      let [value, expected, label] = _ref;
      let tag = this.tag;
      label = label || value;
      return {
        [tag + " rendering {{" + label + "}}"]() {
          this.render("{{" + label + "}}");
          if (expected === EMPTY) {
            this.assertHTML('');
          } else {
            this.assertHTML(expected);
          }
          this.assertStableRerender();
        },
        [tag + " rendering {{to-js " + label + "}}"](assert) {
          this.registerHelper('to-js', _ref2 => {
            let [actual] = _ref2;
            assert.strictEqual(actual, value);
            return actual;
          });
          this.render("{{to-js " + label + "}}");
          if (expected === EMPTY) {
            this.assertHTML('');
          } else {
            this.assertHTML(expected);
          }
          this.assertStableRerender();
        }
      };
    }
  }
  (0, _internalTestHelpers.applyMixins)(StaticContentTest, new StaticContentTestGenerator(LITERALS));
  (0, _internalTestHelpers.moduleFor)('Static content tests', StaticContentTest);
  class DynamicContentTest extends _internalTestHelpers.RenderingTestCase {
    /* abstract */
    renderPath( /* path, context = {} */
    ) {
      throw new Error('Not implemented: `renderValues`');
    }
    assertIsEmpty() {
      this.assert.strictEqual(this.firstChild, null);
    }

    /* abstract */
    assertContent( /* content */
    ) {
      throw new Error('Not implemented: `assertContent`');
    }
    ['@test it can render a dynamic path']() {
      this.renderPath('this.message', {
        message: 'hello'
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'goodbye'));
      this.assertContent('goodbye');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'message', 'hello'));
      this.assertContent('hello');
      this.assertInvariants();
    }
    ['@test resolves the string length properly']() {
      this.render('<p>{{this.foo.length}}</p>', {
        foo: undefined
      });
      this.assertHTML('<p></p>');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'foo'));
      this.assertHTML('<p>3</p>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', ''));
      this.assertHTML('<p>0</p>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', undefined));
      this.assertHTML('<p></p>');
    }
    ['@test resolves the array length properly']() {
      this.render('<p>{{this.foo.length}}</p>', {
        foo: undefined
      });
      this.assertHTML('<p></p>');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', [1, 2, 3]));
      this.assertHTML('<p>3</p>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', []));
      this.assertHTML('<p>0</p>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', undefined));
      this.assertHTML('<p></p>');
    }
    ['@test it can render a capitalized path with no deprecation']() {
      expectNoDeprecation();
      this.renderPath('this.CaptializedPath', {
        CaptializedPath: 'no deprecation'
      });
      this.assertContent('no deprecation');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'CaptializedPath', 'still no deprecation'));
      this.assertContent('still no deprecation');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'CaptializedPath', 'no deprecation'));
      this.assertContent('no deprecation');
      this.assertInvariants();
    }
    ['@test it can render undefined dynamic paths']() {
      this.renderPath('this.name', {});
      this.assertIsEmpty();
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'foo-bar'));
      this.assertContent('foo-bar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', undefined));
      this.assertIsEmpty();
    }
    ['@test it can render a deeply nested dynamic path']() {
      this.renderPath('this.a.b.c.d.e.f', {
        a: {
          b: {
            c: {
              d: {
                e: {
                  f: 'hello'
                }
              }
            }
          }
        }
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'a.b.c.d.e.f', 'goodbye'));
      this.assertContent('goodbye');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'a.b.c.d', {
        e: {
          f: 'aloha'
        }
      }));
      this.assertContent('aloha');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'a', {
          b: {
            c: {
              d: {
                e: {
                  f: 'hello'
                }
              }
            }
          }
        });
      });
      this.assertContent('hello');
      this.assertInvariants();
    }
    ['@test it can render a computed property']() {
      let Formatter = _object.default.extend({
        formattedMessage: (0, _object.computed)('message', function () {
          return this.get('message').toUpperCase();
        })
      });
      let m = Formatter.create({
        message: 'hello'
      });
      this.renderPath('this.m.formattedMessage', {
        m
      });
      this.assertContent('HELLO');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(m, 'message', 'goodbye'));
      this.assertContent('GOODBYE');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'm', Formatter.create({
        message: 'hello'
      })));
      this.assertContent('HELLO');
      this.assertInvariants();
    }
    ['@test it can render a computed property with nested dependency']() {
      let Formatter = _object.default.extend({
        formattedMessage: (0, _object.computed)('messenger.message', function () {
          return this.get('messenger.message').toUpperCase();
        })
      });
      let m = Formatter.create({
        messenger: {
          message: 'hello'
        }
      });
      this.renderPath('this.m.formattedMessage', {
        m
      });
      this.assertContent('HELLO');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(m, 'messenger.message', 'goodbye'));
      this.assertContent('GOODBYE');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'm', Formatter.create({
        messenger: {
          message: 'hello'
        }
      })));
      this.assertContent('HELLO');
      this.assertInvariants();
    }
    ['@test it can read from a proxy object']() {
      this.renderPath('this.proxy.name', {
        proxy: _proxy.default.create({
          content: {
            name: 'Tom Dale'
          }
        })
      });
      this.assertContent('Tom Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content.name', 'Yehuda Katz'));
      this.assertContent('Yehuda Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content', {
        name: 'Godfrey Chan'
      }));
      this.assertContent('Godfrey Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.name', 'Stefan Penner'));
      this.assertContent('Stefan Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content', null));
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy', _proxy.default.create({
        content: {
          name: 'Tom Dale'
        }
      })));
      this.assertContent('Tom Dale');
      this.assertInvariants();
    }
    ['@test it can read from a nested path in a proxy object']() {
      this.renderPath('this.proxy.name.last', {
        proxy: _proxy.default.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        })
      });
      this.assertContent('Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content.name.last', 'Cruise'));
      this.assertContent('Cruise');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content.name.first', 'Suri'));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content.name', {
        first: 'Yehuda',
        last: 'Katz'
      }));
      this.assertContent('Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content', {
        name: {
          first: 'Godfrey',
          last: 'Chan'
        }
      }));
      this.assertContent('Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.name', {
        first: 'Stefan',
        last: 'Penner'
      }));
      this.assertContent('Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy', null));
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy', _proxy.default.create({
        content: {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        }
      })));
      this.assertContent('Dale');
      this.assertInvariants();
    }
    ['@test it can read from a path flipping between a proxy and a real object']() {
      this.renderPath('this.proxyOrObject.name.last', {
        proxyOrObject: _proxy.default.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        })
      });
      this.assertContent('Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject', {
        name: {
          first: 'Tom',
          last: 'Dale'
        }
      }));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject.name.last', 'Cruise'));
      this.assertContent('Cruise');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject.name.first', 'Suri'));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject', {
        name: {
          first: 'Yehuda',
          last: 'Katz'
        }
      }));
      this.assertContent('Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject', _proxy.default.create({
        content: {
          name: {
            first: 'Godfrey',
            last: 'Chan'
          }
        }
      })));
      this.assertContent('Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject.content.name', {
        first: 'Stefan',
        last: 'Penner'
      }));
      this.assertContent('Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject', null));
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxyOrObject', _proxy.default.create({
        content: {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        }
      })));
      this.assertContent('Dale');
      this.assertInvariants();
    }
    ['@test it can read from a path flipping between a real object and a proxy']() {
      this.renderPath('this.objectOrProxy.name.last', {
        objectOrProxy: {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        }
      });
      this.assertContent('Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy', _proxy.default.create({
        content: {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        }
      })));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy.content.name.last', 'Cruise'));
      this.assertContent('Cruise');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy.content.name.first', 'Suri'));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy.content', {
        name: {
          first: 'Yehuda',
          last: 'Katz'
        }
      }));
      this.assertContent('Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy', {
        name: {
          first: 'Godfrey',
          last: 'Chan'
        }
      }));
      this.assertContent('Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy.name', {
        first: 'Stefan',
        last: 'Penner'
      }));
      this.assertContent('Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy', null));
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectOrProxy', {
        name: {
          first: 'Tom',
          last: 'Dale'
        }
      }));
      this.assertContent('Dale');
      this.assertInvariants();
    }
    ['@test it can read from a null object']() {
      let nullObject = Object.create(null);
      nullObject['message'] = 'hello';
      this.renderPath('this.nullObject.message', {
        nullObject
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(nullObject, 'message', 'goodbye'));
      this.assertContent('goodbye');
      this.assertInvariants();
      nullObject = Object.create(null);
      nullObject['message'] = 'hello';
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'nullObject', nullObject));
      this.assertContent('hello');
      this.assertInvariants();
    }
    ['@test it can render a readOnly property of a path']() {
      let Messenger = _object.default.extend({
        message: (0, _computed.readOnly)('a.b.c')
      });
      let messenger = Messenger.create({
        a: {
          b: {
            c: 'hello'
          }
        }
      });
      this.renderPath('this.messenger.message', {
        messenger
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(messenger, 'a.b.c', 'hi'));
      this.assertContent('hi');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'messenger.a.b', {
        c: 'goodbye'
      }));
      this.assertContent('goodbye');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'messenger', {
        message: 'hello'
      }));
      this.assertContent('hello');
      this.assertInvariants();
    }
    ['@test it can render a property on a function']() {
      let func = () => {};
      func.aProp = 'this is a property on a function';
      this.renderPath('this.func.aProp', {
        func
      });
      this.assertContent('this is a property on a function');
      this.assertStableRerender();

      // runTask(() => set(func, 'aProp', 'still a property on a function'));
      // this.assertContent('still a property on a function');
      // this.assertInvariants();

      // func = () => {};
      // func.aProp = 'a prop on a new function';

      // runTask(() => set(this.context, 'func', func));

      // this.assertContent('a prop on a new function');
      // this.assertInvariants();
    }
  }

  class DynamicContentTestGenerator {
    constructor(cases, tag) {
      if (tag === void 0) {
        tag = '@test';
      }
      this.cases = cases;
      this.tag = tag;
    }
    generate(_ref3) {
      let [value, expected, label] = _ref3;
      let tag = this.tag;
      label = label || value;
      if (expected === EMPTY) {
        return {
          [tag + " rendering " + label]() {
            this.renderPath('this.value', {
              value
            });
            this.assertIsEmpty();
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
            this.assertContent('hello');
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', value));
            this.assertIsEmpty();
          }
        };
      } else {
        return {
          [tag + " rendering " + label]() {
            this.renderPath('this.value', {
              value
            });

            // NaN is unstable, not worth optimizing for in the VM
            let wasNaN = typeof value === 'number' && isNaN(value);
            this.assertContent(expected);
            if (!wasNaN) {
              this.assertStableRerender();
            }
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
            this.assertContent('hello');
            if (!wasNaN) {
              this.assertInvariants();
            }
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', value));
            this.assertContent(expected);
            if (!wasNaN) {
              this.assertInvariants();
            }
          }
        };
      }
    }
  }
  const SharedContentTestCases = new DynamicContentTestGenerator([...LITERALS, [NaN, 'NaN'], [new Date(2000, 0, 1), String(new Date(2000, 0, 1)), 'a Date object'], [Infinity, 'Infinity'], [1 / -0, '-Infinity'], [{
    foo: 'bar'
  }, '[object Object]', "{ foo: 'bar' }"], [{
    toString() {
      return 'foo';
    }
  }, 'foo', 'an object with a custom toString function'], [{
    valueOf() {
      return 1;
    }
  }, '[object Object]', 'an object with a custom valueOf function'],
  // Escaping tests
  ['<b>Max</b><b>James</b>', '<b>Max</b><b>James</b>']]);
  let GlimmerContentTestCases = new DynamicContentTestGenerator([[Object.create(null), EMPTY, 'an object with no toString'], [Symbol('debug'), 'Symbol(debug)', 'a symbol']]);
  (0, _internalTestHelpers.applyMixins)(DynamicContentTest, SharedContentTestCases, GlimmerContentTestCases);
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (content position)', class extends DynamicContentTest {
    renderPath(path, context) {
      if (context === void 0) {
        context = {};
      }
      this.render("{{" + path + "}}", context);
    }
    assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one text node');
      this.assertTextNode(this.firstChild, content);
      // this.takeSnapshot();
    }

    ['@test it can render empty safe strings [GH#16314]']() {
      this.render('before {{this.value}} after', {
        value: (0, _helpers.htmlSafe)('hello')
      });
      this.assertHTML('before hello after');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', (0, _helpers.htmlSafe)('')));
      this.assertHTML('before <!----> after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', (0, _helpers.htmlSafe)('hello')));
      this.assertHTML('before hello after');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (content concat)', class extends DynamicContentTest {
    renderPath(path, context) {
      if (context === void 0) {
        context = {};
      }
      this.render("{{concat \"\" " + path + " \"\"}}", context);
    }
    assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one text node');
      this.assertTextNode(this.firstChild, content);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (inside an element)', class extends DynamicContentTest {
    renderPath(path, context) {
      if (context === void 0) {
        context = {};
      }
      this.render("<p>{{" + path + "}}</p>", context);
    }
    assertIsEmpty() {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <p> tag');
      this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      this.assertText('');
    }
    assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <p> tag');
      this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      this.assertText(content);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (attribute position)', class extends DynamicContentTest {
    renderPath(path, context) {
      if (context === void 0) {
        context = {};
      }
      this.render("<div data-foo=\"{{" + path + "}}\"></div>", context);
    }
    assertIsEmpty() {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <div> tag');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: ''
      });
    }
    assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <div> tag');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': content
        },
        content: ''
      });
    }
  });
  class TrustedContentTest extends DynamicContentTest {
    assertIsEmpty() {
      this.assert.strictEqual(this.firstChild, null);
    }
    assertContent(content) {
      this.assertHTML(content);
    }
    assertStableRerender() {
      this.takeSnapshot();
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      super.assertInvariants();
    }
    assertInvariants() {
      // If it's not stable, we will wipe out all the content and replace them,
      // so there are no invariants
    }
  }
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (trusted)', class extends TrustedContentTest {
    renderPath(path, context) {
      if (context === void 0) {
        context = {};
      }
      this.render("{{{" + path + "}}}", context);
    }
    ['@test updating trusted curlies']() {
      this.render('{{{this.htmlContent}}}{{{this.nested.htmlContent}}}', {
        htmlContent: '<b>Max</b>',
        nested: {
          htmlContent: '<b>James</b>'
        }
      });
      this.assertContent('<b>Max</b><b>James</b>');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'htmlContent', '<i>M</i><u>a</u><s>x</s>'));
      this.assertContent('<i>M</i><u>a</u><s>x</s><b>James</b>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'nested.htmlContent', 'Jammie'));
      this.assertContent('<i>M</i><u>a</u><s>x</s>Jammie');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'htmlContent', '<b>Max</b>');
        (0, _object.set)(this.context, 'nested', {
          htmlContent: '<i>James</i>'
        });
      });
      this.assertContent('<b>Max</b><i>James</i>');
    }
    ['@test empty content in trusted curlies [GH#14978]']() {
      this.render('before {{{this.value}}} after', {
        value: 'hello'
      });
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', undefined));
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', null));
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', ''));
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', (0, _helpers.htmlSafe)('')));
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 'hello'));
      this.assertContent('before hello after');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (integration)', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can render a dynamic template']() {
      let template = "\n      <div class=\"header\">\n        <h1>Welcome to {{this.framework}}</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use {{this.framework}}?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's {{this.framework}}</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        {{this.framework}} is free, open source and always will be.\n      </div>\n    ";
      let ember = "\n      <div class=\"header\">\n        <h1>Welcome to Ember.js</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use Ember.js?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's Ember.js</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        Ember.js is free, open source and always will be.\n      </div>\n    ";
      let react = "\n      <div class=\"header\">\n        <h1>Welcome to React</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use React?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's React</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        React is free, open source and always will be.\n      </div>\n    ";
      this.render(template, {
        framework: 'Ember.js'
      });
      this.assertHTML(ember);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertHTML(ember);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'framework', 'React'));
      this.assertHTML(react);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'framework', 'Ember.js'));
      this.assertHTML(ember);
    }
    ['@test it should evaluate to nothing if part of the path is `undefined`']() {
      this.render('{{this.foo.bar.baz.bizz}}', {
        foo: {}
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: {
          baz: {
            bizz: 'Hey!'
          }
        }
      }));
      this.assertText('Hey!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {}));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: {
          baz: {
            bizz: 'Hello!'
          }
        }
      }));
      this.assertText('Hello!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {}));
      this.assertText('');
    }
    ['@test it should evaluate to nothing if part of the path is a primative']() {
      this.render('{{this.foo.bar.baz.bizz}}', {
        foo: {
          bar: true
        }
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: false
      }));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: 'Haha'
      }));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: null
      }));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: undefined
      }));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: 1
      }));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: {
          baz: {
            bizz: 'Hello!'
          }
        }
      }));
      this.assertText('Hello!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: true
      }));
      this.assertText('');
    }
    ['@test can set dynamic href']() {
      this.render('<a href={{this.model.url}}>Example</a>', {
        model: {
          url: 'http://example.com'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://example.com'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://example.com'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.url', 'http://linkedin.com'));
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://linkedin.com'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        url: 'http://example.com'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://example.com'
        }
      });
    }
    ['@test quoteless class attributes update correctly']() {
      this.render('<div class={{if this.fooBar "foo-bar"}}>hello</div>', {
        fooBar: true
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', false));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', true));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
    }
    ['@test quoted class attributes update correctly'](assert) {
      this.render('<div class="{{if this.fooBar "foo-bar"}}">hello</div>', {
        fooBar: true
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', false));
      assert.equal(this.firstChild.className, '');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'fooBar', true));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
    }
    ['@test unquoted class attribute can contain multiple classes']() {
      this.render('<div class={{this.model.classes}}>hello</div>', {
        model: {
          classes: 'foo bar baz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.classes', 'fizz bizz'));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        classes: 'foo bar baz'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
    }
    ['@test unquoted class attribute']() {
      this.render('<div class={{this.model.foo}}>hello</div>', {
        model: {
          foo: 'foo'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.foo', 'fizz'));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: 'foo'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
    }
    ['@test quoted class attribute']() {
      this.render('<div class="{{this.model.foo}}">hello</div>', {
        model: {
          foo: 'foo'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.foo', 'fizz'));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: 'foo'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
    }
    ['@test quoted class attribute can contain multiple classes']() {
      this.render('<div class="{{this.model.classes}}">hello</div>', {
        model: {
          classes: 'foo bar baz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.classes', 'fizz bizz'));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        classes: 'foo bar baz'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
    }
    ['@test class attribute concats bound values']() {
      this.render('<div class="{{this.model.foo}} {{this.model.bar}} {{this.model.bizz}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar',
          bizz: 'bizz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.foo', 'fizz'));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bar bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.bar', null));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: 'foo',
        bar: 'bar',
        bizz: 'bizz'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar bizz')
        }
      });
    }
    ['@test class attribute accepts nested helpers, and updates']() {
      this.render("<div class=\"{{if this.model.hasSize this.model.size}} {{if this.model.hasShape this.model.shape}}\">hello</div>", {
        model: {
          size: 'large',
          hasSize: true,
          hasShape: false,
          shape: 'round'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.hasShape', true));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large round')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.hasSize', false));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('round')
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        size: 'large',
        hasSize: true,
        hasShape: false,
        shape: 'round'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large')
        }
      });
    }
    ['@test Multiple dynamic classes']() {
      this.render('<div class="{{this.model.foo}} {{this.model.bar}} {{this.model.fizz}} {{this.model.baz}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar',
          fizz: 'fizz',
          baz: 'baz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar fizz baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar fizz baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model.foo', null);
        (0, _object.set)(this.context, 'model.fizz', null);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model', {
          foo: 'foo',
          bar: 'bar',
          fizz: 'fizz',
          baz: 'baz'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar fizz baz')
        }
      });
    }
    ['@test classes are ordered: See issue #9912']() {
      this.render('<div class="{{this.model.foo}}  static   {{this.model.bar}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   bar'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   bar'
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model.bar', null);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   '
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model', {
          foo: 'foo',
          bar: 'bar'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   bar'
        }
      });
    }
  });
  let warnings, originalWarn;
  class StyleTest extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      warnings = [];
      originalWarn = (0, _debug.getDebugFunction)('warn');
      (0, _debug.setDebugFunction)('warn', function (message, test) {
        if (!test) {
          warnings.push(message);
        }
      });
    }
    teardown() {
      super.teardown(...arguments);
      (0, _debug.setDebugFunction)('warn', originalWarn);
    }
    assertStyleWarning(style) {
      this.assert.deepEqual(warnings, [(0, _views.constructStyleDeprecationMessage)(style)]);
    }
    assertNoWarning() {
      this.assert.deepEqual(warnings, []);
    }
  }
  (0, _internalTestHelpers.moduleFor)('Inline style tests', class extends StyleTest {
    ['@test can set dynamic style']() {
      this.render('<div style={{this.model.style}}></div>', {
        model: {
          style: (0, _helpers.htmlSafe)('width: 60px;')
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'width: 60px;'
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'width: 60px;'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.style', 'height: 60px;'));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'height: 60px;'
        }
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.style', null));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        style: 'width: 60px;'
      }));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'width: 60px;'
        }
      });
    }
  });
  if (false /* DEBUG */) {
    (0, _internalTestHelpers.moduleFor)('Inline style tests - warnings', class extends StyleTest {
      ['@test specifying <div style={{this.userValue}}></div> generates a warning']() {
        let userValue = 'width: 42px';
        this.render('<div style={{this.userValue}}></div>', {
          userValue
        });
        this.assertStyleWarning(userValue);
      }
      ['@test specifying `attributeBindings: ["style"]` generates a warning']() {
        let FooBarComponent = _helpers.Component.extend({
          attributeBindings: ['style']
        });
        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        let userValue = 'width: 42px';
        this.render('{{foo-bar style=this.userValue}}', {
          userValue
        });
        this.assertStyleWarning(userValue);
      }
      ['@test specifying `<div style={{{this.userValue}}}></div>` works properly without a warning']() {
        this.render('<div style={{{this.userValue}}}></div>', {
          userValue: 'width: 42px'
        });
        this.assertNoWarning();
      }
      ['@test specifying `<div style={{this.userValue}}></div>` works properly with a SafeString']() {
        this.render('<div style={{this.userValue}}></div>', {
          userValue: new _helpers.SafeString('width: 42px')
        });
        this.assertNoWarning();
      }
      ['@test null value do not generate htmlsafe warning']() {
        this.render('<div style={{this.userValue}}></div>', {
          userValue: null
        });
        this.assertNoWarning();
      }
      ['@test undefined value do not generate htmlsafe warning']() {
        this.render('<div style={{this.userValue}}></div>');
        this.assertNoWarning();
      }
      ['@test no warnings are triggered when a safe string is quoted']() {
        this.render('<div style="{{this.userValue}}"></div>', {
          userValue: new _helpers.SafeString('width: 42px')
        });
        this.assertNoWarning();
      }
      ['@test binding warning is triggered when an unsafe string is quoted']() {
        let userValue = 'width: 42px';
        this.render('<div style="{{this.userValue}}"></div>', {
          userValue
        });
        this.assertStyleWarning(userValue);
      }
      ['@test binding warning is triggered when a safe string for a complete property is concatenated in place']() {
        let userValue = 'width: 42px';
        this.render('<div style="color: green; {{this.userValue}}"></div>', {
          userValue: new _helpers.SafeString('width: 42px')
        });
        this.assertStyleWarning("color: green; " + userValue);
      }
      ['@test binding warning is triggered when a safe string for a value is concatenated in place']() {
        let userValue = '42px';
        this.render('<div style="color: green; width: {{this.userValue}}"></div>', {
          userValue: new _helpers.SafeString(userValue)
        });
        this.assertStyleWarning("color: green; width: " + userValue);
      }
      ['@test binding warning is triggered when a safe string for a property name is concatenated in place']() {
        let userValue = 'width';
        this.render('<div style="color: green; {{this.userProperty}}: 42px"></div>', {
          userProperty: new _helpers.SafeString(userValue)
        });
        this.assertStyleWarning("color: green; " + userValue + ": 42px");
      }
    });
  }
});
define("@ember/-internals/glimmer/tests/integration/custom-component-manager-test", ["ember-babel", "internal-test-helpers", "@glimmer/manager", "@ember/object", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _manager, _object, _glimmer) {
  "use strict";

  var _templateObject;
  const BasicComponentManager = _object.default.extend({
    capabilities: (0, _manager.componentCapabilities)('3.13'),
    createComponent(factory, args) {
      return factory.create({
        args
      });
    },
    updateComponent(component, args) {
      (0, _object.set)(component, 'args', args);
    },
    getContext(component) {
      return component;
    }
  });

  /* eslint-disable */
  function createBasicManager(owner) {
    return BasicComponentManager.create({
      owner
    });
  }
  function createInstrumentedManager(owner) {
    return InstrumentedComponentManager.create({
      owner
    });
  }
  /* eslint-enable */

  let InstrumentedComponentManager;
  class ComponentManagerTest extends _internalTestHelpers.RenderingTestCase {
    constructor(assert) {
      super(...arguments);
      InstrumentedComponentManager = _object.default.extend({
        capabilities: (0, _manager.componentCapabilities)('3.13', {
          destructor: true,
          asyncLifecycleCallbacks: true
        }),
        createComponent(factory, args) {
          assert.step('createComponent');
          return factory.create({
            args
          });
        },
        updateComponent(component, args) {
          assert.step('updateComponent');
          (0, _object.set)(component, 'args', args);
        },
        destroyComponent(component) {
          assert.step('destroyComponent');
          component.destroy();
        },
        getContext(component) {
          assert.step('getContext');
          return component;
        },
        didCreateComponent(component) {
          assert.step('didCreateComponent');
          component.didRender();
        },
        didUpdateComponent(component) {
          assert.step('didUpdateComponent');
          component.didUpdate();
        }
      });
    }
  }
  (0, _internalTestHelpers.moduleFor)('Component Manager - Curly Invocation', class extends ComponentManagerTest {
    ['@test it can render a basic component with custom component manager']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} world</p>",
        ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertHTML("<p>hello world</p>");
    }
    ['@test it can render a basic component with custom component manager with a factory']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(() => BasicComponentManager.create(), _object.default.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} world</p>",
        ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertHTML("<p>hello world</p>");
    }
    ['@test it can have no template context']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: (0, _manager.componentCapabilities)('3.13'),
          createComponent() {
            return null;
          },
          updateComponent() {},
          getContext() {
            return null;
          }
        });
      }, {});
      this.registerComponent('foo-bar', {
        template: "<p>{{@greeting}} world</p>",
        ComponentClass
      });
      this.render('{{foo-bar greeting="hello"}}');
      this.assertHTML("<p>hello world</p>");
    }
    ['@test it can discover component manager through inheritance - ES Classes']() {
      class Base {}
      (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: (0, _manager.componentCapabilities)('3.13'),
          createComponent(Factory, args) {
            return new Factory(args);
          },
          updateComponent() {},
          getContext(component) {
            return component;
          }
        });
      }, Base);
      class Child extends Base {}
      class Grandchild extends Child {
        constructor() {
          super();
          this.name = 'grandchild';
        }
      }
      this.registerComponent('foo-bar', {
        template: "{{this.name}}",
        ComponentClass: Grandchild
      });
      this.render('{{foo-bar}}');
      this.assertHTML("grandchild");
    }
    ['@test it can discover component manager through inheritance - Ember Object']() {
      let Parent = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend());
      let Child = Parent.extend();
      let Grandchild = Child.extend({
        init() {
          this._super(...arguments);
          this.name = 'grandchild';
        }
      });
      this.registerComponent('foo-bar', {
        template: "{{this.name}}",
        ComponentClass: Grandchild
      });
      this.render('{{foo-bar}}');
      this.assertHTML("grandchild");
    }
    ['@test it can customize the template context']() {
      let customContext = {
        greeting: 'goodbye'
      };
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: (0, _manager.componentCapabilities)('3.13'),
          createComponent(factory) {
            return factory.create();
          },
          getContext() {
            return customContext;
          },
          updateComponent() {}
        });
      }, _object.default.extend({
        greeting: 'hello',
        count: 1234
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} world {{this.count}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertHTML("<p>goodbye world </p>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(customContext, 'greeting', 'sayonara'));
      this.assertHTML("<p>sayonara world </p>");
    }
    ['@test it can set arguments on the component instance']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar firstName="Yehuda" lastName="Katz"}}');
      this.assertHTML("<p>Yehuda Katz</p>");
    }
    ['@test arguments are updated if they change']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar firstName=this.firstName lastName=this.lastName}}', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        firstName: 'Chad',
        lastName: 'Hietala'
      }));
      this.assertHTML("<p>Chad Hietala</p>");
    }
    ['@test it can set positional params on the component instance']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.positional.[]', function () {
          return this.args.positional[0] + ' ' + this.args.positional[1];
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar "Yehuda" "Katz"}}');
      this.assertHTML("<p>Yehuda Katz</p>");
    }
    ['@test positional params are updated if they change (computed, arr tag)']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.positional.[]', function () {
          return this.args.positional[0] + ' ' + this.args.positional[1];
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar this.firstName this.lastName}}', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        firstName: 'Chad',
        lastName: 'Hietala'
      }));
      this.assertHTML("<p>Chad Hietala</p>");
    }
    ['@test positional params are updated if they change (computed, individual tags)']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.positional.0', 'args.positional.1', function () {
          return this.args.positional[0] + ' ' + this.args.positional[1];
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar this.firstName this.lastName}}', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        firstName: 'Chad',
        lastName: 'Hietala'
      }));
      this.assertHTML("<p>Chad Hietala</p>");
    }
    ['@test positional params are updated if they change (native)']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, class extends _object.default {
        get salutation() {
          return this.args.positional[0] + ' ' + this.args.positional[1];
        }
      });
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar this.firstName this.lastName}}', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        firstName: 'Chad',
        lastName: 'Hietala'
      }));
      this.assertHTML("<p>Chad Hietala</p>");
    }
    ['@test it can opt-in to running destructor'](assert) {
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: (0, _manager.componentCapabilities)('3.13', {
            destructor: true
          }),
          createComponent(factory) {
            assert.step('createComponent');
            return factory.create();
          },
          getContext(component) {
            return component;
          },
          updateComponent() {},
          destroyComponent(component) {
            assert.step('destroyComponent');
            component.destroy();
          }
        });
      }, _object.default.extend({
        greeting: 'hello',
        destroy() {
          assert.step('component.destroy()');
          this._super(...arguments);
        }
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} world</p>",
        ComponentClass
      });
      this.render('{{#if this.show}}{{foo-bar}}{{/if}}', {
        show: true
      });
      this.assertHTML("<p>hello world</p>");
      (0, _internalTestHelpers.runTask)(() => this.context.set('show', false));
      this.assertText('');
      assert.verifySteps(['createComponent', 'destroyComponent', 'component.destroy()']);
    }
    ['@test it can opt-in to running async lifecycle hooks'](assert) {
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: (0, _manager.componentCapabilities)('3.13', {
            asyncLifecycleCallbacks: true,
            updateHook: true
          }),
          createComponent(factory, args) {
            assert.step('createComponent');
            return factory.create({
              args
            });
          },
          updateComponent(component, args) {
            assert.step('updateComponent');
            (0, _object.set)(component, 'args', args);
          },
          destroyComponent(component) {
            assert.step('destroyComponent');
            component.destroy();
          },
          getContext(component) {
            assert.step('getContext');
            return component;
          },
          didCreateComponent() {
            assert.step('didCreateComponent');
          },
          didUpdateComponent() {
            assert.step('didUpdateComponent');
          }
        });
      }, _object.default.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} {{@name}}</p>",
        ComponentClass
      });
      this.render('{{foo-bar name=this.name}}', {
        name: 'world'
      });
      this.assertHTML("<p>hello world</p>");
      assert.verifySteps(['createComponent', 'getContext', 'didCreateComponent']);
      (0, _internalTestHelpers.runTask)(() => this.context.set('name', 'max'));
      this.assertHTML("<p>hello max</p>");
      assert.verifySteps(['updateComponent', 'didUpdateComponent']);
    }
    '@test capabilities helper function must be used to generate capabilities'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: {
            asyncLifecycleCallbacks: true,
            destructor: true,
            update: false
          },
          createComponent(factory, args) {
            assert.step('createComponent');
            return factory.create({
              args
            });
          },
          updateComponent(component, args) {
            assert.step('updateComponent');
            (0, _object.set)(component, 'args', args);
          },
          destroyComponent(component) {
            assert.step('destroyComponent');
            component.destroy();
          },
          getContext(component) {
            assert.step('getContext');
            return component;
          },
          didCreateComponent() {
            assert.step('didCreateComponent');
          },
          didUpdateComponent() {
            assert.step('didUpdateComponent');
          }
        });
      }, _object.default.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} {{@name}}</p>",
        ComponentClass
      });
      assert.throws(() => {
        this.render('{{foo-bar name=this.name}}', {
          name: 'world'
        });
      }, /Custom component managers must have a `capabilities` property that is the result of calling the `capabilities\('3.13'\)` \(imported via `import \{ capabilities \} from '@ember\/component';`\). /);
      assert.verifySteps([]);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Component Manager - Angle Invocation', class extends ComponentManagerTest {
    ['@test it can render a basic component with custom component manager']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} world</p>",
        ComponentClass
      });
      this.render('<FooBar />');
      this.assertHTML("<p>hello world</p>");
    }
    ['@test it can set arguments on the component instance']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('<FooBar @firstName="Yehuda" @lastName="Katz" />');
      this.assertHTML("<p>Yehuda Katz</p>");
    }
    ['@test it can pass attributes']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend());
      this.registerComponent('foo-bar', {
        template: "<p ...attributes>Hello world!</p>",
        ComponentClass
      });
      this.render('<FooBar data-test="foo" />');
      this.assertHTML("<p data-test=\"foo\">Hello world!</p>");
    }
    ['@test arguments are updated if they change']() {
      let ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _object.default.extend({
        salutation: (0, _object.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.salutation}}</p>",
        ComponentClass
      });
      this.render('<FooBar @firstName={{this.firstName}} @lastName={{this.lastName}} />', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, {
        firstName: 'Chad',
        lastName: 'Hietala'
      }));
      this.assertHTML("<p>Chad Hietala</p>");
    }
    ['@test updating attributes triggers updateComponent and didUpdateComponent'](assert) {
      let TestManager = _object.default.extend({
        capabilities: (0, _manager.componentCapabilities)('3.13', {
          destructor: true,
          asyncLifecycleCallbacks: true,
          updateHook: true
        }),
        createComponent(factory, args) {
          assert.step('createComponent');
          return factory.create({
            args
          });
        },
        updateComponent(component, args) {
          assert.step('updateComponent');
          (0, _object.set)(component, 'args', args);
        },
        destroyComponent(component) {
          component.destroy();
        },
        getContext(component) {
          assert.step('getContext');
          return component;
        },
        didCreateComponent(component) {
          assert.step('didCreateComponent');
          component.didRender();
        },
        didUpdateComponent(component) {
          assert.step('didUpdateComponent');
          component.didUpdate();
        }
      });
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return TestManager.create();
      }, _object.default.extend({
        didRender() {},
        didUpdate() {}
      }));
      this.registerComponent('foo-bar', {
        template: "<p ...attributes>Hello world!</p>",
        ComponentClass
      });
      this.render('<FooBar data-test={{this.value}} />', {
        value: 'foo'
      });
      this.assertHTML("<p data-test=\"foo\">Hello world!</p>");
      assert.verifySteps(['createComponent', 'getContext', 'didCreateComponent']);
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'bar'));
      assert.verifySteps(['updateComponent', 'didUpdateComponent']);
    }
    ['@test updateComponent fires consistently with or without args'](assert) {
      let updated = [];
      class TestManager {
        constructor() {
          this.capabilities = (0, _manager.componentCapabilities)('3.13', {
            updateHook: true
          });
        }
        static create() {
          return new TestManager();
        }
        createComponent(_factory, args) {
          assert.step('createComponent');
          return {
            id: args.named.id || 'no-id'
          };
        }
        updateComponent(component) {
          assert.step('updateComponent');
          updated.push(component);
        }
        getContext(component) {
          assert.step('getContext');
          return component;
        }
      }
      let ComponentClass = (0, _glimmer.setComponentManager)(() => new TestManager(), {});
      this.registerComponent('foo-bar', {
        template: '{{yield}}',
        ComponentClass
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          [<FooBar>{{this.value}}</FooBar>]\n          [<FooBar @id=\"static-id\">{{this.value}}</FooBar>]\n          [<FooBar @id={{this.id}}>{{this.value}}</FooBar>]\n        "]))), {
        id: 'dynamic-id',
        value: 'Hello World'
      });
      this.assertHTML("[Hello World][Hello World][Hello World]");
      assert.deepEqual(updated, []);
      assert.verifySteps(['createComponent', 'getContext', 'createComponent', 'getContext', 'createComponent', 'getContext']);
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'bar'));
      assert.deepEqual(updated, [{
        id: 'no-id'
      }, {
        id: 'static-id'
      }, {
        id: 'dynamic-id'
      }]);
      assert.verifySteps(['updateComponent', 'updateComponent', 'updateComponent']);
    }
    ['@test updating arguments does not trigger updateComponent or didUpdateComponent if `updateHook` is false'](assert) {
      class TestManager {
        constructor() {
          this.capabilities = (0, _manager.componentCapabilities)('3.13', {
            /* implied: updateHook: false */
          });
        }
        createComponent() {
          assert.step('createComponent');
          return {};
        }
        getContext(component) {
          assert.step('getContext');
          return component;
        }
        updateComponent() {
          throw new Error('updateComponent called unexpectedly');
        }
        didUpdateComponent() {
          throw new Error('didUpdateComponent called unexpectedly');
        }
      }
      let ComponentClass = (0, _glimmer.setComponentManager)(() => new TestManager(), {});
      this.registerComponent('foo-bar', {
        template: "<p ...attributes>Hello world!</p>",
        ComponentClass
      });
      this.render('<FooBar data-test={{this.value}} />', {
        value: 'foo'
      });
      this.assertHTML("<p data-test=\"foo\">Hello world!</p>");
      assert.verifySteps(['createComponent', 'getContext']);
      (0, _internalTestHelpers.runTask)(() => this.context.set('value', 'bar'));
      assert.verifySteps([]);
    }
    '@test capabilities helper function must be used to generate capabilities'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      let ComponentClass = (0, _glimmer.setComponentManager)(() => {
        return _object.default.create({
          capabilities: {
            asyncLifecycleCallbacks: true,
            destructor: true,
            update: false
          },
          createComponent(factory, args) {
            assert.step('createComponent');
            return factory.create({
              args
            });
          },
          updateComponent(component, args) {
            assert.step('updateComponent');
            (0, _object.set)(component, 'args', args);
          },
          destroyComponent(component) {
            assert.step('destroyComponent');
            component.destroy();
          },
          getContext(component) {
            assert.step('getContext');
            return component;
          },
          didCreateComponent() {
            assert.step('didCreateComponent');
          },
          didUpdateComponent() {
            assert.step('didUpdateComponent');
          }
        });
      }, _object.default.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{this.greeting}} {{@name}}</p>",
        ComponentClass
      });
      assert.throws(() => {
        this.render('<FooBar @name={{this.name}} />', {
          name: 'world'
        });
      }, /Custom component managers must have a `capabilities` property that is the result of calling the `capabilities\('3.13'\)` \(imported via `import \{ capabilities \} from '@ember\/component';`\). /);
      assert.verifySteps([]);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/custom-helper-test", ["ember-babel", "internal-test-helpers", "@glimmer/compiler", "@glimmer/syntax", "@ember/template-factory", "@ember/-internals/glimmer/index", "@glimmer/manager", "@glimmer/runtime"], function (_emberBabel, _internalTestHelpers, _compiler, _syntax, _templateFactory, _index, _manager, _runtime) {
  "use strict";

  var _templateObject;
  // eslint-disable-next-line ember-internal/require-yuidoc-access
  /**
   * The template-compiler does not support strict mode at this time.
   * precompile from ember-template-compiler returns a string and
   * not a template-factory, so it doesn't help with strict-mode testing.
   *
   * We also can't import from `@ember/template-compiler` because it
   * doesn't exist to this kind of test, otherwise we'd be able to use
   * precompileTemplate, which would be perfect :D
   *
   * Copied(ish) from https://github.com/NullVoxPopuli/ember-repl/blob/main/addon/hbs.ts#L51
   */
  function precompileTemplate(source, _ref) {
    let {
      moduleName,
      scope = {}
    } = _ref;
    let locals = (0, _syntax.getTemplateLocals)(source);
    let options = {
      strictMode: true,
      moduleName,
      locals,
      isProduction: false,
      meta: {
        moduleName
      }
    };

    // Copied from @glimmer/compiler/lib/compiler#precompile
    let [block, usedLocals] = (0, _compiler.precompileJSON)(source, options);
    let usedScope = usedLocals.map(key => scope[key]);
    let blockJSON = JSON.stringify(block);
    let templateJSONObject = {
      id: moduleName,
      block: blockJSON,
      moduleName: moduleName != null ? moduleName : '(unknown template module)',
      scope: () => usedScope,
      isStrictMode: true
    };
    let factory = (0, _templateFactory.createTemplateFactory)(templateJSONObject);
    return factory;
  }
  (0, _internalTestHelpers.moduleFor)('Custom Helper test', class extends _internalTestHelpers.RenderingTestCase {
    ['@test works with strict-mode']() {
      class Custom extends _index.Helper {
        compute(_ref2) {
          let [value] = _ref2;
          return value + "-custom";
        }
      }
      let template = (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{ (Custom 'my-test') }}\n      "])));
      let templateFactory = precompileTemplate(template, {
        moduleName: 'strict-mode',
        scope: {
          Custom
        }
      });
      let TestComponent = (0, _manager.setComponentTemplate)(templateFactory, (0, _runtime.templateOnlyComponent)());
      this.render("<this.TestComponent />", {
        TestComponent
      });
      this.assertText('my-test-custom');
      this.assertStableRerender();
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/custom-modifier-manager-test", ["internal-test-helpers", "@ember/-internals/glimmer", "@glimmer/manager", "@ember/object", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/debug-stack"], function (_internalTestHelpers, _glimmer, _manager, _object, _metal, _debugStack) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  class ModifierManagerTest extends _internalTestHelpers.RenderingTestCase {
    '@test throws a useful error when missing capabilities'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.registerModifier('foo-bar', (0, _manager.setModifierManager)(() => {
        return {
          createModifier() {},
          installModifier() {},
          updateModifier() {},
          destroyModifier() {}
        };
      }, {}));
      assert.throws(() => {
        this.render('<h1 {{foo-bar}}>hello world</h1>');
      }, /Custom modifier managers must have a `capabilities` property /);
    }
    '@test can register a custom element modifier and render it'(assert) {
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement() {
          assert.ok(true, 'Called didInsertElement');
        }
      }));
      this.render('<h1 {{foo-bar}}>hello world</h1>');
      this.assertHTML("<h1>hello world</h1>");
    }
    '@test custom lifecycle hooks'(assert) {
      assert.expect(9);
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didUpdate(_ref) {
          let [truthy] = _ref;
          assert.ok(true, 'Called didUpdate');
          assert.equal(truthy, 'true', 'gets updated args');
        },
        didInsertElement(_ref2) {
          let [truthy] = _ref2;
          assert.ok(true, 'Called didInsertElement');
          assert.equal(truthy, true, 'gets initial args');
        },
        willDestroyElement() {
          assert.ok(true, 'Called willDestroyElement');
        }
      }));
      this.render('{{#if this.truthy}}<h1 {{foo-bar this.truthy}}>hello world</h1>{{/if}}', {
        truthy: true
      });
      this.assertHTML("<h1>hello world</h1>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'truthy', 'true'));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'truthy', false));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'truthy', true));
    }
    '@test associates manager even through an inheritance structure'(assert) {
      assert.expect(5);
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      ModifierClass = ModifierClass.extend({
        didInsertElement(_ref3) {
          let [truthy] = _ref3;
          this._super(...arguments);
          assert.ok(true, 'Called didInsertElement');
          assert.equal(truthy, true, 'gets initial args');
        }
      });
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement(_ref4) {
          let [truthy] = _ref4;
          this._super(...arguments);
          assert.ok(true, 'Called didInsertElement');
          assert.equal(truthy, true, 'gets initial args');
        }
      }));
      this.render('<h1 {{foo-bar this.truthy}}>hello world</h1>', {
        truthy: true
      });
      this.assertHTML("<h1>hello world</h1>");
    }
    '@test can give consistent access to underlying DOM element'(assert) {
      assert.expect(4);
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        savedElement: undefined,
        didInsertElement(positional) {
          // consume first positional argument (ensures updates run)
          positional[0];
          assert.equal(this.element.tagName, 'H1');
          this.set('savedElement', this.element);
        },
        didUpdate() {
          assert.equal(this.element, this.savedElement);
        },
        willDestroyElement() {
          assert.equal(this.element, this.savedElement);
        }
      }));
      this.render('<h1 {{foo-bar this.truthy}}>hello world</h1>', {
        truthy: true
      });
      this.assertHTML("<h1>hello world</h1>");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'truthy', 'true'));
    }
    '@test lifecycle hooks are autotracked by default'(assert) {
      let TrackedClass = _object.default.extend({
        count: (0, _metal.tracked)({
          value: 0
        })
      });
      let trackedOne = TrackedClass.create();
      let trackedTwo = TrackedClass.create();
      let insertCount = 0;
      let updateCount = 0;
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement() {
          // track the count of the first item
          trackedOne.count;
          insertCount++;
        },
        didUpdate() {
          // track the count of the second item
          trackedTwo.count;
          updateCount++;
        }
      }));
      this.render('<h1 {{foo-bar this.truthy}}>hello world</h1>');
      this.assertHTML("<h1>hello world</h1>");
      assert.equal(insertCount, 1);
      assert.equal(updateCount, 0);
      (0, _internalTestHelpers.runTask)(() => trackedTwo.count++);
      assert.equal(updateCount, 0);
      (0, _internalTestHelpers.runTask)(() => trackedOne.count++);
      assert.equal(updateCount, 1);
      (0, _internalTestHelpers.runTask)(() => trackedOne.count++);
      assert.equal(updateCount, 1);
      (0, _internalTestHelpers.runTask)(() => trackedTwo.count++);
      assert.equal(updateCount, 2);
    }
    '@test provides a helpful assertion when mutating a value that was consumed already'() {
      var _class, _descriptor;
      let Person = (_class = class Person {
        constructor() {
          _initializerDefineProperty(this, "name", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "name", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'bob';
        }
      }), _class);
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, class {
        static create() {
          return new this();
        }
        didInsertElement() {}
        didUpdate() {}
        willDestroyElement() {}
      });
      this.registerModifier('foo-bar', class MyModifier extends ModifierClass {
        didInsertElement(_ref5) {
          let [person] = _ref5;
          person.name;
          person.name = 'sam';
        }
      });
      let expectedMessage = (0, _debugStack.backtrackingMessageFor)('name', 'Person', {
        renderTree: ['\\(instance of a `foo-bar` modifier\\)'],
        includeTopLevel: false
      });
      expectAssertion(() => {
        this.render('<h1 {{foo-bar this.person}}>hello world</h1>', {
          person: new Person()
        });
      }, expectedMessage);
    }
    '@test capabilities helper function must be used to generate capabilities'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      class OverrideCustomModifierManager extends this.CustomModifierManager {
        constructor() {
          super(...arguments);
          this.capabilities = {
            disableAutoTracking: false,
            useArgsProxy: true,
            passFactoryToCreate: false
          };
        }
      }
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new OverrideCustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {
          assert.step('didInsertElement');
        },
        didUpdate() {
          assert.step('didUpdate');
        },
        willDestroyElement() {
          assert.step('willDestroyElement');
        }
      }));
      this.registerModifier('foo-bar', ModifierClass.extend());
      assert.throws(() => {
        this.render('<h1 {{foo-bar}}>hello world</h1>');
      }, /Custom modifier managers must have a `capabilities` property that is the result of calling the `capabilities\('3.22'\)` \(imported via `import \{ capabilities \} from '@ember\/modifier';`\). /);
      assert.verifySteps([]);
    }
  }
  (0, _internalTestHelpers.moduleFor)('Basic Custom Modifier Manager: 3.22', class extends ModifierManagerTest {
    constructor() {
      super(...arguments);
      this.CustomModifierManager = class CustomModifierManager {
        constructor(owner) {
          this.capabilities = (0, _manager.modifierCapabilities)('3.22');
          this.owner = owner;
        }
        createModifier(Modifier, args) {
          return Modifier.create(args);
        }
        installModifier(instance, element, args) {
          instance.element = element;
          let {
            positional,
            named
          } = args;
          instance.didInsertElement(positional, named);
        }
        updateModifier(instance, args) {
          let {
            positional,
            named
          } = args;
          instance.didUpdate(positional, named);
        }
        destroyModifier(instance) {
          instance.willDestroyElement();
        }
      };
    }
    '@test modifers only track positional arguments they consume'(assert) {
      let insertCount = 0;
      let updateCount = 0;
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement(positional) {
          insertCount++;

          // consume the second positional
          positional[1];
        },
        didUpdate(positional) {
          updateCount++;

          // consume the second positional
          positional[1];
        }
      }));
      this.render('<h1 {{foo-bar this.positionOne this.positionTwo bar=this.bar qux=this.qux}}>hello world</h1>', {
        positionOne: 'first!!!',
        positionTwo: 'second :(',
        bar: 'bar',
        qux: 'quz'
      });
      this.assertHTML("<h1>hello world</h1>");
      assert.equal(insertCount, 1);
      assert.equal(updateCount, 0);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'positionOne', 'no first?'));
      assert.equal(updateCount, 0);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'positionTwo', 'YASSSSSSS!!!'));
      assert.equal(updateCount, 1);
    }
    '@test modifers only track named arguments they consume'(assert) {
      let insertCount = 0;
      let updateCount = 0;
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new this.CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {},
        didUpdate() {},
        willDestroyElement() {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement(_positional, named) {
          insertCount++;

          // consume qux
          named.qux;
        },
        didUpdate(_positiona, named) {
          updateCount++;

          // consume qux
          named.qux;
        }
      }));
      this.render('<h1 {{foo-bar bar=this.bar qux=this.qux}}>hello world</h1>', {
        bar: 'bar',
        qux: 'quz'
      });
      this.assertHTML("<h1>hello world</h1>");
      assert.equal(insertCount, 1);
      assert.equal(updateCount, 0);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'bar', 'other bar'));
      assert.equal(updateCount, 0);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'qux', 'quuuuxxxxxx'));
      assert.equal(updateCount, 1);
    }
    '@test Can resolve a modifier'() {
      this.registerModifier('replace', (0, _internalTestHelpers.defineSimpleModifier)((element, _ref6) => {
        let [text] = _ref6;
        return element.innerHTML = text != null ? text : 'Hello, world!';
      }));

      // BUG: this should work according to the RFC
      // this.render(
      //   '[<div {{modifier "replace"}}>Nope</div>][<div {{modifier (modifier "replace") "wow"}}>Nope</div>]'
      // );
      this.render('[<div {{(modifier "replace")}}>Nope</div>][<div {{(modifier "replace") "wow"}}>Nope</div>]');
      this.assertText('[Hello, world!][wow]');
      this.assertStableRerender();
    }
    '@test Cannot dynamically resolve a modifier'(assert) {
      this.registerModifier('replace', (0, _internalTestHelpers.defineSimpleModifier)(element => element.innerHTML = 'Hello, world!'));
      if (false /* DEBUG */) {
        expectAssertion(() => this.render(
        // BUG: this should work according to the RFC
        // '<div {{modifier this.name}}>Nope</div>',
        '<div {{(modifier this.name)}}>Nope</div>', {
          name: 'replace'
        }), /Passing a dynamic string to the `\(modifier\)` keyword is disallowed\./);
      } else {
        assert.expect(0);
      }
    }
    '@test Can be curried'() {
      let val = (0, _internalTestHelpers.defineSimpleModifier)((element, _ref7) => {
        let [text] = _ref7;
        return element.innerHTML = text;
      });
      this.registerComponent('foo', {
        template: '<div {{@value}}></div>'
      });
      this.registerComponent('bar', {
        template: '<Foo @value={{modifier this.val "Hello, world!"}}/>',
        ComponentClass: _glimmer.Component.extend({
          val
        })
      });
      this.render('<Bar/>');
      this.assertText('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a dynamic modifier with a nested dynamic helper'() {
      let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'Hello, world!');
      let bar = (0, _internalTestHelpers.defineSimpleModifier)((element, _ref8) => {
        let [value] = _ref8;
        return element.innerHTML = value;
      });
      this.registerComponent('baz', {
        template: '<div {{this.bar (this.foo)}}></div>',
        ComponentClass: _glimmer.Component.extend({
          tagName: '',
          foo,
          bar
        })
      });
      this.render('<Baz/>');
      this.assertHTML('<div>Hello, world!</div>');
      this.assertStableRerender();
    }
  });
  (0, _internalTestHelpers.moduleFor)('Rendering test: non-interactive custom modifiers', class extends _internalTestHelpers.RenderingTestCase {
    getBootOptions() {
      return {
        isInteractive: false
      };
    }
    ["@test doesn't trigger lifecycle hooks when non-interactive: modifierCapabilities('3.22')"](assert) {
      class CustomModifierManager {
        constructor(owner) {
          this.capabilities = (0, _manager.modifierCapabilities)('3.22');
          this.owner = owner;
        }
        createModifier(Modifier, args) {
          return Modifier.create(args);
        }
        installModifier(instance, element, args) {
          instance.element = element;
          let {
            positional,
            named
          } = args;
          instance.didInsertElement(positional, named);
        }
        updateModifier(instance, args) {
          let {
            positional,
            named
          } = args;
          instance.didUpdate(positional, named);
        }
        destroyModifier(instance) {
          instance.willDestroyElement();
        }
      }
      let ModifierClass = (0, _manager.setModifierManager)(owner => {
        return new CustomModifierManager(owner);
      }, _object.default.extend({
        didInsertElement() {
          assert.ok(false);
        },
        didUpdate() {
          assert.ok(false);
        },
        willDestroyElement() {
          assert.ok(false);
        }
      }));
      this.registerModifier('foo-bar', ModifierClass);
      this.render('<h1 {{foo-bar this.baz}}>hello world</h1>');
      (0, _internalTestHelpers.runTask)(() => this.context.set('baz', 'Hello'));
      this.assertHTML('<h1>hello world</h1>');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/event-dispatcher-test", ["internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/runloop"], function (_internalTestHelpers, _helpers, _runloop) {
  "use strict";

  let canDataTransfer = Boolean(document.createEvent('HTMLEvents').dataTransfer);
  function fireNativeWithDataTransfer(node, type, dataTransfer) {
    let event = document.createEvent('HTMLEvents');
    event.initEvent(type, true, true);
    event.dataTransfer = dataTransfer;
    node.dispatchEvent(event);
  }
  function triggerEvent(node, event) {
    switch (event) {
      case 'focusin':
        return node.focus();
      case 'focusout':
        return node.blur();
      default:
        return node.trigger(event);
    }
  }
  const SUPPORTED_EMBER_EVENTS = {
    touchstart: 'touchStart',
    touchmove: 'touchMove',
    touchend: 'touchEnd',
    touchcancel: 'touchCancel',
    keydown: 'keyDown',
    keyup: 'keyUp',
    keypress: 'keyPress',
    mousedown: 'mouseDown',
    mouseup: 'mouseUp',
    contextmenu: 'contextMenu',
    click: 'click',
    dblclick: 'doubleClick',
    focusin: 'focusIn',
    focusout: 'focusOut',
    submit: 'submit',
    input: 'input',
    change: 'change',
    dragstart: 'dragStart',
    drag: 'drag',
    dragenter: 'dragEnter',
    dragleave: 'dragLeave',
    dragover: 'dragOver',
    drop: 'drop',
    dragend: 'dragEnd'
  };
  (0, _internalTestHelpers.moduleFor)('EventDispatcher', class extends _internalTestHelpers.RenderingTestCase {
    ['@test event handler methods are called when event is triggered'](assert) {
      let receivedEvent;
      let browserEvent;
      this.registerComponent('x-button', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'button'
        }, Object.keys(SUPPORTED_EMBER_EVENTS).map(browerEvent => ({
          [SUPPORTED_EMBER_EVENTS[browerEvent]](event) {
            receivedEvent = event;
          }
        })).reduce((result, singleEventHandler) => ({
          ...result,
          ...singleEventHandler
        }), {}))
      });
      this.render("{{x-button}}");
      let elementNode = this.$('button');
      let element = elementNode[0];
      for (browserEvent in SUPPORTED_EMBER_EVENTS) {
        receivedEvent = null;
        (0, _internalTestHelpers.runTask)(() => triggerEvent(elementNode, browserEvent));
        assert.ok(receivedEvent, browserEvent + " event was triggered");
        assert.strictEqual(receivedEvent.target, element);
      }
    }
    ['@test event listeners are called when event is triggered'](assert) {
      let receivedEvent;
      let browserEvent;
      this.registerComponent('x-button', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'button',
          init() {
            this._super();
            Object.keys(SUPPORTED_EMBER_EVENTS).forEach(browserEvent => {
              this.on(SUPPORTED_EMBER_EVENTS[browserEvent], event => receivedEvent = event);
            });
          }
        })
      });
      this.render("{{x-button}}");
      let elementNode = this.$('button');
      let element = elementNode[0];
      for (browserEvent in SUPPORTED_EMBER_EVENTS) {
        receivedEvent = null;
        (0, _internalTestHelpers.runTask)(() => triggerEvent(elementNode, browserEvent));
        assert.ok(receivedEvent, browserEvent + " event was triggered");
        assert.strictEqual(receivedEvent.target, element);
      }
    }
    ['@test events bubble view hierarchy for form elements'](assert) {
      let receivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change(event) {
            receivedEvent = event;
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{x-foo}}");
      (0, _internalTestHelpers.runTask)(() => this.$('#is-done').trigger('change'));
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    }
    ['@test case insensitive events'](assert) {
      let receivedEvent;
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          clicked(event) {
            receivedEvent = event;
          }
        }),
        template: "<button id=\"is-done\" onclick={{action this.clicked}}>my button</button>"
      });
      this.render("{{x-bar}}");
      (0, _internalTestHelpers.runTask)(() => this.$('#is-done').trigger('click'));
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    }
    ['@test case sensitive events'](assert) {
      let receivedEvent;
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          clicked(event) {
            receivedEvent = event;
          }
        }),
        template: "<button id=\"is-done\" onClick={{action this.clicked}}>my button</button>"
      });
      this.render("{{x-bar}}");
      (0, _internalTestHelpers.runTask)(() => this.$('#is-done').trigger('click'));
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    }
    ['@test events bubble to parent view'](assert) {
      let receivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change(event) {
            receivedEvent = event;
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          change() {}
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{#x-foo}}{{x-bar}}{{/x-foo}}");
      (0, _internalTestHelpers.runTask)(() => this.$('#is-done').trigger('change'));
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    }
    ['@test events bubbling up can be prevented by returning false'](assert) {
      let hasReceivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change() {
            hasReceivedEvent = true;
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          change() {
            return false;
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{#x-foo}}{{x-bar}}{{/x-foo}}");
      (0, _internalTestHelpers.runTask)(() => this.$('#is-done').trigger('change'));
      assert.notOk(hasReceivedEvent, 'change event has not been received');
    }
    ['@test events bubbling up can be prevented by calling stopPropagation()'](assert) {
      let hasReceivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change() {
            hasReceivedEvent = true;
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          change(e) {
            e.stopPropagation();
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{#x-foo}}{{x-bar}}{{/x-foo}}");
      (0, _internalTestHelpers.runTask)(() => this.$('#is-done').trigger('change'));
      assert.notOk(hasReceivedEvent, 'change event has not been received');
    }
    ['@test event handlers are wrapped in a run loop'](assert) {
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change() {
            assert.ok((0, _runloop._getCurrentRunLoop)(), 'a run loop should have started');
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{x-foo}}");
      this.$('#is-done').trigger('click');
    }
  });
  (0, _internalTestHelpers.moduleFor)('EventDispatcher#setup', class extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      this.dispatcher = this.owner.lookup('event_dispatcher:main');
    }
    getBootOptions() {
      return {
        skipEventDispatcher: true
      };
    }
    ['@test additional events can be specified'](assert) {
      this.dispatcher.setup({
        myevent: 'myEvent'
      });
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          myEvent() {
            assert.ok(true, 'custom event was triggered');
          }
        }),
        template: "<p>Hello!</p>"
      });
      this.render("{{x-foo}}");
      this.$('div').trigger('myevent');
    }
    ['@test a rootElement can be specified'](assert) {
      this.element.innerHTML = '<div id="app"></div>';
      // this.$().append('<div id="app"></div>');
      this.dispatcher.setup({
        myevent: 'myEvent'
      }, '#app');
      assert.ok(this.$('#app').hasClass('ember-application'), 'custom rootElement was used');
      assert.equal(this.dispatcher.rootElement, '#app', 'the dispatchers rootElement was updated');
    }
    ['@test default events can be disabled via `customEvents`'](assert) {
      this.dispatcher.setup({
        click: null
      });
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          click() {
            assert.ok(false, 'click method was called');
          },
          null() {
            assert.ok(false, 'null method was called');
          },
          doubleClick() {
            assert.ok(true, 'a non-disabled event is still handled properly');
          }
        }),
        template: "<p>Hello!</p>"
      });
      this.render("{{x-foo}}");
      this.$('div').trigger('click');
      this.$('div').trigger('dblclick');
    }
    ['@test throws if specified rootElement does not exist'](assert) {
      assert.throws(() => {
        this.dispatcher.setup({
          myevent: 'myEvent'
        }, '#app');
      });
    }
  });
  if (canDataTransfer) {
    (0, _internalTestHelpers.moduleFor)('EventDispatcher - Event Properties', class extends _internalTestHelpers.RenderingTestCase {
      ['@test dataTransfer property is added to drop event'](assert) {
        let receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            drop(event) {
              receivedEvent = event;
            }
          })
        });
        this.render("{{x-foo}}");
        fireNativeWithDataTransfer(this.$('div')[0], 'drop', 'success');
        assert.equal(receivedEvent.dataTransfer, 'success');
      }
    });
  }
});
define("@ember/-internals/glimmer/tests/integration/helpers/array-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{array}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test returns an array']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (array \"Sergio\") as |people|}}\n        {{#each people as |personName|}}\n          {{personName}}\n        {{/each}}\n      {{/let}}"]))));
      this.assertText('Sergio');
      this.assertStableRerender();
    }
    ['@test can have more than one value']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let (array \"Sergio\" \"Robert\") as |people|}}\n        {{#each people as |personName|}}\n          {{personName}},\n        {{/each}}\n      {{/let}}"]))));
      this.assertText('Sergio,Robert,');
      this.assertStableRerender();
    }
    ['@test binds values when variables are used']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{#let (array this.personOne) as |people|}}\n              {{#each people as |personName|}}\n                {{personName}}\n              {{/each}}\n            {{/let}}"]))), {
        personOne: 'Tom'
      });
      this.assertText('Tom');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personOne', 'Yehuda'));
      this.assertText('Yehuda');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personOne', 'Tom'));
      this.assertText('Tom');
    }
    ['@test binds multiple values when variables are used']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{#let (array this.personOne this.personTwo) as |people|}}\n              {{#each people as |personName|}}\n                {{personName}},\n              {{/each}}\n            {{/let}}"]))), {
        personOne: 'Tom',
        personTwo: 'Yehuda'
      });
      this.assertText('Tom,Yehuda,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personOne', 'Sergio'));
      this.assertText('Sergio,Yehuda,');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Tom'));
      this.assertText('Sergio,Tom,');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'personOne', 'Tom');
        (0, _object.set)(this.context, 'personTwo', 'Yehuda');
      });
      this.assertText('Tom,Yehuda,');
    }
    ['@test array helpers can be nested']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{#let (array (array this.personOne this.personTwo)) as |listOfPeople|}}\n              {{#each listOfPeople as |people|}}\n                List:\n                {{#each people as |personName|}}\n                  {{personName}},\n                {{/each}}\n              {{/each}}\n            {{/let}}"]))), {
        personOne: 'Tom',
        personTwo: 'Yehuda'
      });
      this.assertText('List:Tom,Yehuda,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personOne', 'Chad'));
      this.assertText('List:Chad,Yehuda,');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Balint'));
      this.assertText('List:Chad,Balint,');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'personOne', 'Tom');
        (0, _object.set)(this.context, 'personTwo', 'Yehuda');
      });
      this.assertText('List:Tom,Yehuda,');
    }
    ['@test should yield hash of an array of internal properties']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
          this.model = {
            personOne: 'Chad'
          };
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash people=(array this.model.personOne))}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#foo-bar as |values|}}\n        {{#each values.people as |personName|}}\n          {{personName}}\n        {{/each}}\n      {{/foo-bar}}"]))));
      this.assertText('Chad');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model.personOne', 'Godfrey'));
      this.assertText('Godfrey');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model', {
        personOne: 'Chad'
      }));
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model.personOne', 'Godfrey'));
      this.assertText('Godfrey');
    }
    ['@test should yield hash of an array of internal and external properties']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
          this.model = {
            personOne: 'Chad'
          };
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash people=(array this.model.personOne this.personTwo))}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#foo-bar personTwo=this.model.personTwo as |values|}}\n          {{#each values.people as |personName|}}\n            {{personName}},\n          {{/each}}\n        {{/foo-bar}}"]))), {
        model: {
          personTwo: 'Tom'
        }
      });
      this.assertText('Chad,Tom,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(fooBarInstance, 'model.personOne', 'Godfrey');
        (0, _object.set)(this.context, 'model.personTwo', 'Yehuda');
      });
      this.assertText('Godfrey,Yehuda,');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(fooBarInstance, 'model', {
          personOne: 'Chad'
        });
        (0, _object.set)(this.context, 'model', {
          personTwo: 'Tom'
        });
      });
      this.assertText('Chad,Tom,');
    }
    ['@test should render when passing as argument to a component invocation']() {
      let FooBarComponent = _helpers.Component.extend({});
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.people as |personName|}}\n          {{personName}},\n        {{/each}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{foo-bar people=(array \"Tom\" this.personTwo)}}"]))), {
        personTwo: 'Chad'
      });
      this.assertText('Tom,Chad,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Godfrey'));
      this.assertText('Tom,Godfrey,');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Chad'));
      this.assertText('Tom,Chad,');
    }
    ['@test should return an entirely new array when any argument change']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each this.people as |personName|}}\n          {{personName}},\n        {{/each}}"])))
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{foo-bar people=(array \"Tom\" this.personTwo)}}"]))), {
        personTwo: 'Chad'
      });
      let firstArray = fooBarInstance.people;
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Godfrey'));
      this.assert.ok(firstArray !== fooBarInstance.people, 'should have created an entirely new array');
    }
    ['@test capture array values in JS to assert deep equal']() {
      let captured;
      this.registerHelper('capture', function (_ref) {
        let [array] = _ref;
        captured = array;
        return 'captured';
      });
      this.render("{{capture (array 'Tom' this.personTwo)}}", {
        personTwo: 'Godfrey'
      });
      this.assert.deepEqual(captured, ['Tom', 'Godfrey']);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Robert'));
      this.assert.deepEqual(captured, ['Tom', 'Robert']);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'personTwo', 'Godfrey'));
      this.assert.deepEqual(captured, ['Tom', 'Godfrey']);
    }
    ['@test GH18693 properties in hash can be accessed from the array']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#each (array (hash some=\"thing\")) as |item|}}\n          {{item.some}}\n        {{/each}}"]))));
      this.assertText('thing');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/closure-action-test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _runloop, _object, _helpers) {
  "use strict";

  var _templateObject;
  (0, _internalTestHelpers.moduleFor)('Helpers test: closure {{action}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test action should be called']() {
      let outerActionCalled = false;
      let component;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        outerSubmit() {
          outerActionCalled = true;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action this.outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        component.fireAction();
      });
      this.assert.ok(outerActionCalled, 'the action was called');
    }
    ['@test an error is triggered when bound action function is undefined']() {
      this.registerComponent('inner-component', {
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        template: '{{inner-component submit=(action this.somethingThatIsUndefined)}}'
      });
      expectAssertion(() => {
        this.render('{{outer-component}}');
      }, /Action passed is null or undefined in \(action[^)]*\) from .*\./);
    }
    ['@test an error is triggered when bound action being passed in is a non-function']() {
      this.registerComponent('inner-component', {
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          nonFunctionThing: {}
        }),
        template: '{{inner-component submit=(action this.nonFunctionThing)}}'
      });
      expectAssertion(() => {
        this.render('{{outer-component}}');
      }, /An action could not be made for `.*` in .*\. Please confirm that you are using either a quoted action name \(i\.e\. `\(action '.*'\)`\) or a function available in .*\./);
    }
    ['@test [#12718] a nice error is shown when a bound action function is undefined and it is passed as @foo']() {
      this.registerComponent('inner-component', {
        template: '<button id="inner-button" {{action (action @external-action)}}>Click me</button>'
      });
      this.registerComponent('outer-component', {
        template: '{{inner-component}}'
      });
      expectAssertion(() => {
        this.render('{{outer-component}}');
      }, /Action passed is null or undefined in \(action[^)]*\) from .*\./);
    }
    ['@test action value is returned']() {
      let expectedValue = 'terrible tom';
      let returnedValue;
      let innerComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          returnedValue = this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        outerSubmit() {
          return expectedValue;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action this.outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(returnedValue, expectedValue, 'action can return to caller');
    }
    ['@test action should be called on the correct scope']() {
      let innerComponent;
      let outerComponent;
      let actualComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          outerComponent = this;
        },
        isOuterComponent: true,
        outerSubmit() {
          actualComponent = this;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action this.outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(actualComponent, outerComponent, 'action has the correct context');
      this.assert.ok(actualComponent.isOuterComponent, 'action has the correct context');
    }
    ['@test arguments to action are passed, curry']() {
      let first = 'mitch';
      let second = 'martin';
      let third = 'matt';
      let fourth = 'wacky wycats';
      let innerComponent;
      let actualArgs;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit(fourth);
        }
      });
      let OuterComponent = _helpers.Component.extend({
        third,
        outerSubmit() {
          actualArgs = [...arguments];
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action (action this.outerSubmit \"" + first + "\") \"" + second + "\" this.third)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.deepEqual(actualArgs, [first, second, third, fourth], 'action has the correct args');
    }
    ['@test `this` can be passed as an argument']() {
      let value = {};
      let component;
      let innerComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        actions: {
          outerAction(incomingValue) {
            value = incomingValue;
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action "outerAction" this)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.strictEqual(value, component, 'the component is passed at `this`');
    }
    ['@test arguments to action are bound']() {
      let value = 'lazy leah';
      let innerComponent;
      let outerComponent;
      let actualArg;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          outerComponent = this;
        },
        value: '',
        outerSubmit(incomingValue) {
          actualArg = incomingValue;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action this.outerSubmit this.value)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.strictEqual(actualArg, '', 'action has the correct first arg');
      (0, _internalTestHelpers.runTask)(() => {
        outerComponent.set('value', value);
      });
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.strictEqual(actualArg, value, 'action has the correct first arg');
    }
    ['@test array arguments are passed correctly to action']() {
      let first = 'foo';
      let second = [3, 5];
      let third = [4, 9];
      let actualFirst;
      let actualSecond;
      let actualThird;
      let innerComponent;
      let outerComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit(second, third);
        }
      });
      let OuterComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          outerComponent = this;
        },
        outerSubmit(incomingFirst, incomingSecond, incomingThird) {
          actualFirst = incomingFirst;
          actualSecond = incomingSecond;
          actualThird = incomingThird;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action this.outerSubmit this.first)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        outerComponent.set('first', first);
        outerComponent.set('second', second);
      });
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(actualFirst, first, 'action has the correct first arg');
      this.assert.equal(actualSecond, second, 'action has the correct second arg');
      this.assert.equal(actualThird, third, 'action has the correct third arg');
    }
    ['@test mut values can be wrapped in actions, are settable']() {
      let newValue = 'trollin trek';
      let innerComponent;
      let outerComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit(newValue);
        }
      });
      let OuterComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          outerComponent = this;
        },
        outerMut: 'patient peter'
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action (mut this.outerMut))}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(outerComponent.get('outerMut'), newValue, 'mut value is set');
    }
    ['@test mut values can be wrapped in actions, are settable with a curry']() {
      let newValue = 'trollin trek';
      let innerComponent;
      let outerComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          outerComponent = this;
        },
        outerMut: 'patient peter'
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action (mut this.outerMut) '" + newValue + "')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(outerComponent.get('outerMut'), newValue, 'mut value is set');
    }
    ['@test action can create closures over actions']() {
      let first = 'raging robert';
      let second = 'mild machty';
      let returnValue = 'butch brian';
      let actualFirst;
      let actualSecond;
      let actualReturnedValue;
      let innerComponent;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          actualReturnedValue = this.attrs.submit(second);
        }
      });
      let OuterComponent = _helpers.Component.extend({
        actions: {
          outerAction(incomingFirst, incomingSecond) {
            actualFirst = incomingFirst;
            actualSecond = incomingSecond;
            return returnValue;
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'outerAction' '" + first + "')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(actualReturnedValue, returnValue, 'return value is present');
      this.assert.equal(actualFirst, first, 'first argument is correct');
      this.assert.equal(actualSecond, second, 'second argument is correct');
    }
    ['@test provides a helpful error if an action is not present']() {
      let InnerComponent = _helpers.Component.extend({});
      let OuterComponent = _helpers.Component.extend({
        actions: {
          something() {
            // this is present to ensure `actions` hash is present
            // a different error is triggered if `actions` is missing
            // completely
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'doesNotExist')}}"
      });
      expectAssertion(() => {
        this.render('{{outer-component}}');
      }, /An action named 'doesNotExist' was not found in /);
    }
    ['@test provides a helpful error if actions hash is not present']() {
      let InnerComponent = _helpers.Component.extend({});
      let OuterComponent = _helpers.Component.extend({});
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'doesNotExist')}}"
      });
      expectAssertion(() => {
        this.render('{{outer-component}}');
      }, /An action named 'doesNotExist' was not found in /);
    }
    ['@test action can create closures over actions with target']() {
      let innerComponent;
      let actionCalled = false;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        otherComponent: (0, _object.computed)(function () {
          return {
            actions: {
              outerAction() {
                actionCalled = true;
              }
            }
          };
        })
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'outerAction' target=this.otherComponent)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.ok(actionCalled, 'action called on otherComponent');
    }
    ['@test value can be used with action over actions']() {
      let newValue = 'yelping yehuda';
      let innerComponent;
      let actualValue;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit({
            readProp: newValue
          });
        }
      });
      let OuterComponent = _helpers.Component.extend({
        outerContent: {
          readProp: newValue
        },
        actions: {
          outerAction(incomingValue) {
            actualValue = incomingValue;
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'outerAction' value=\"readProp\")}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(actualValue, newValue, 'value is read');
    }
    ['@test action will read the value of a first property']() {
      let newValue = 'irate igor';
      let innerComponent;
      let actualValue;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit({
            readProp: newValue
          });
        }
      });
      let OuterComponent = _helpers.Component.extend({
        outerAction(incomingValue) {
          actualValue = incomingValue;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action this.outerAction value=\"readProp\")}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(actualValue, newValue, 'property is read');
    }
    ['@test action will read the value of a curried first argument property']() {
      let newValue = 'kissing kris';
      let innerComponent;
      let actualValue;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        objectArgument: {
          readProp: newValue
        },
        outerAction(incomingValue) {
          actualValue = incomingValue;
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action this.outerAction this.objectArgument value=\"readProp\")}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.equal(actualValue, newValue, 'property is read');
    }
    ['@test action closure does not get auto-mut wrapped'](assert) {
      let first = 'raging robert';
      let second = 'mild machty';
      let returnValue = 'butch brian';
      let innerComponent;
      let actualFirst;
      let actualSecond;
      let actualReturnedValue;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.get('submit')(second);
          this.get('attrs-submit')(second);
          let attrsSubmitReturnValue = this.attrs['attrs-submit'](second);
          let submitReturnValue = this.attrs.submit(second);
          assert.equal(attrsSubmitReturnValue, submitReturnValue, 'both attrs.foo and foo should behave the same');
          return submitReturnValue;
        }
      });
      let MiddleComponent = _helpers.Component.extend({});
      let OuterComponent = _helpers.Component.extend({
        actions: {
          outerAction(incomingFirst, incomingSecond) {
            actualFirst = incomingFirst;
            actualSecond = incomingSecond;
            return returnValue;
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('middle-component', {
        ComponentClass: MiddleComponent,
        template: "{{inner-component attrs-submit=@submit submit=this.submit}}"
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{middle-component submit=(action 'outerAction' '" + first + "')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        actualReturnedValue = innerComponent.fireAction();
      });
      this.assert.equal(actualFirst, first, 'first argument is correct');
      this.assert.equal(actualSecond, second, 'second argument is correct');
      this.assert.equal(actualReturnedValue, returnValue, 'return value is present');
    }
    ['@test action should be called within a run loop']() {
      let innerComponent;
      let capturedRunLoop;
      let InnerComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          innerComponent = this;
        },
        fireAction() {
          this.attrs.submit();
        }
      });
      let OuterComponent = _helpers.Component.extend({
        actions: {
          submit() {
            capturedRunLoop = (0, _runloop._getCurrentRunLoop)();
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'submit')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        innerComponent.fireAction();
      });
      this.assert.ok(capturedRunLoop, 'action is called within a run loop');
    }
    ['@test closure action with `(mut undefinedThing)` works properly [GH#13959]']() {
      let component;
      let ExampleComponent = _helpers.Component.extend({
        label: undefined,
        init() {
          this._super(...arguments);
          component = this;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button onclick={{action (mut this.label) "Clicked!"}}>{{if this.label this.label "Click me"}}</button>'
      });
      this.render('{{example-component}}');
      this.assertText('Click me');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('label', 'Dun clicked');
      });
      this.assertText('Dun clicked');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('label', undefined);
      });
      this.assertText('Click me');
    }
    ['@test closure actions does not cause component hooks to fire unnecessarily [GH#14305] [GH#14654]'](assert) {
      let clicked = 0;
      let didReceiveAttrsFired = 0;
      let ClickMeComponent = _helpers.Component.extend({
        tagName: 'button',
        click() {
          this.get('onClick').call(undefined, ++clicked);
        },
        didReceiveAttrs() {
          didReceiveAttrsFired++;
        }
      });
      this.registerComponent('click-me', {
        ComponentClass: ClickMeComponent
      });
      let outer;
      let OuterComponent = _helpers.Component.extend({
        clicked: 0,
        actions: {
          'on-click': function () {
            this.incrementProperty('clicked');
          }
        },
        init() {
          this._super();
          outer = this;
          this.set('onClick', () => this.incrementProperty('clicked'));
        }
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <div id=\"counter\">clicked: {{this.clicked}}; foo: {{this.foo}}</div>\n\n        {{click-me id=\"string-action\" onClick=(action \"on-click\")}}\n        {{click-me id=\"function-action\" onClick=(action this.onClick)}}\n        {{click-me id=\"mut-action\" onClick=(action (mut this.clicked))}}\n      "])))
      });
      this.render('{{outer-component foo=this.foo}}', {
        foo: 1
      });
      this.assertText('clicked: 0; foo: 1');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('clicked: 0; foo: 1');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 2));
      this.assertText('clicked: 0; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => this.$('#string-action').click());
      this.assertText('clicked: 1; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => this.$('#function-action').click());
      this.assertText('clicked: 2; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(outer, 'onClick', function () {
        outer.incrementProperty('clicked');
      }));
      this.assertText('clicked: 2; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => this.$('#function-action').click());
      this.assertText('clicked: 3; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(() => this.$('#mut-action').click());
      this.assertText('clicked: 4; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/concat-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{concat}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it concats static arguments']() {
      this.render("{{concat \"foo\" \" \" \"bar\" \" \" \"baz\"}}");
      this.assertText('foo bar baz');
    }
    ['@test it updates for bound arguments']() {
      this.render("{{concat this.model.first this.model.second}}", {
        model: {
          first: 'one',
          second: 'two'
        }
      });
      this.assertText('onetwo');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('onetwo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.first', 'three'));
      this.assertText('threetwo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.second', 'four'));
      this.assertText('threefour');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        first: 'one',
        second: 'two'
      }));
      this.assertText('onetwo');
    }
    ['@test it can be used as a sub-expression']() {
      this.render("{{concat (concat this.model.first this.model.second) (concat this.model.third this.model.fourth)}}", {
        model: {
          first: 'one',
          second: 'two',
          third: 'three',
          fourth: 'four'
        }
      });
      this.assertText('onetwothreefour');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('onetwothreefour');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.first', 'five'));
      this.assertText('fivetwothreefour');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model.second', 'six');
        (0, _object.set)(this.context, 'model.third', 'seven');
      });
      this.assertText('fivesixsevenfour');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model', {
          first: 'one',
          second: 'two',
          third: 'three',
          fourth: 'four'
        });
      });
      this.assertText('onetwothreefour');
    }
    ['@test it can be used as input for other helpers']() {
      this.registerHelper('x-eq', _ref => {
        let [actual, expected] = _ref;
        return actual === expected;
      });
      this.render("{{#if (x-eq (concat this.model.first this.model.second) \"onetwo\")}}Truthy!{{else}}False{{/if}}", {
        model: {
          first: 'one',
          second: 'two'
        }
      });
      this.assertText('Truthy!');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Truthy!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.first', 'three'));
      this.assertText('False');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        first: 'one',
        second: 'two'
      }));
      this.assertText('Truthy!');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/custom-helper-test", ["internal-test-helpers", "@ember/-internals/glimmer", "@ember/object"], function (_internalTestHelpers, _glimmer, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: custom helpers', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it cannot override built-in syntax']() {
      this.registerHelper('array', () => 'Nope');
      expectAssertion(() => {
        this.render("{{array this.foo 'LOL'}}", {
          foo: true
        });
      }, /You attempted to overwrite the built-in helper "array" which is not allowed. Please rename the helper./);
    }
    ['@test it can resolve custom simple helpers with or without dashes']() {
      this.registerHelper('hello', () => 'hello');
      this.registerHelper('hello-world', () => 'hello world');
      this.render('{{hello}} | {{hello-world}}');
      this.assertText('hello | hello world');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello | hello world');
    }
    ['@test it does not resolve helpers with a `.` (period)'](assert) {
      if (!false /* DEBUG */) {
        assert.ok(true, 'nothing to do in prod builds, assertion is stripped');
        return;
      }
      this.registerHelper('hello.world', () => 'hello world');

      // cannot use `expectAssertion` because the error is thrown in glimmer-vm
      // (and doesn't go through Ember's own assertion internals)
      assert.throws(() => {
        this.render('{{hello.world}}');
      }, /Attempted to resolve a value in a strict mode template, but that value was not in scope: hello/);
    }
    ['@test it can resolve custom class-based helpers with or without dashes']() {
      this.registerHelper('hello', {
        compute() {
          return 'hello';
        }
      });
      this.registerHelper('hello-world', {
        compute() {
          return 'hello world';
        }
      });
      this.render('{{hello}} | {{hello-world}}');
      this.assertText('hello | hello world');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello | hello world');
    }
    ['@test throws if `this._super` is not called from `init`']() {
      this.registerHelper('hello-world', {
        init() {}
      });
      expectAssertion(() => {
        this.render('{{hello-world}}');
      }, /You must call `super.init\(...arguments\);` or `this._super\(...arguments\)` when overriding `init` on a framework object. Please update .*/);
    }
    ['@test class-based helper can recompute a new value'](assert) {
      let destroyCount = 0;
      let computeCount = 0;
      let helper;
      this.registerHelper('hello-world', {
        init() {
          this._super(...arguments);
          helper = this;
        },
        compute() {
          return ++computeCount;
        },
        destroy() {
          destroyCount++;
          this._super();
        }
      });
      this.render('{{hello-world}}');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      this.assertText('2');
      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    }
    ['@test class-based helper lifecycle'](assert) {
      let hooks = [];
      let helper;
      this.registerHelper('hello-world', {
        init() {
          this._super(...arguments);
          hooks.push('init');
          helper = this;
        },
        compute() {
          hooks.push('compute');
        },
        willDestroy() {
          hooks.push('willDestroy');
          this._super();
        },
        destroy() {
          hooks.push('destroy');
          this._super();
        }
      });
      this.render('{{#if this.show}}{{hello-world}}{{/if}}', {
        show: true
      });
      assert.deepEqual(hooks, ['init', 'compute']);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.deepEqual(hooks, ['init', 'compute']);
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      assert.deepEqual(hooks, ['init', 'compute', 'compute']);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'show', false));
      assert.deepEqual(hooks, ['init', 'compute', 'compute', 'destroy', 'willDestroy']);
    }
    ['@test class-based helper with static arguments can recompute a new value'](assert) {
      let destroyCount = 0;
      let computeCount = 0;
      let helper;
      this.registerHelper('hello-world', {
        init() {
          this._super(...arguments);
          helper = this;
        },
        compute() {
          return ++computeCount;
        },
        destroy() {
          destroyCount++;
          this._super();
        }
      });
      this.render('{{hello-world "whut"}}');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      this.assertText('2');
      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    }

    // https://github.com/emberjs/ember.js/issues/14774
    ['@test class-based helper with static arguments can recompute a new value without a runloop'](assert) {
      let destroyCount = 0;
      let computeCount = 0;
      let helper;
      this.registerHelper('hello-world', {
        init() {
          this._super(...arguments);
          helper = this;
        },
        compute() {
          return ++computeCount;
        },
        destroy() {
          destroyCount++;
          this._super();
        }
      });
      this.render('{{hello-world "whut"}}');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('1');
      helper.recompute();
      this.assertText('2');
      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    }
    ['@test helper params can be returned']() {
      this.registerHelper('hello-world', values => {
        return values;
      });
      this.render('{{#each (hello-world this.model) as |item|}}({{item}}){{/each}}', {
        model: ['bob']
      });
      this.assertText('(bob)');
    }
    ['@test helper hash can be returned']() {
      this.registerHelper('hello-world', (_, hash) => {
        return hash.model;
      });
      this.render("{{get (hello-world model=this.model) 'name'}}", {
        model: {
          name: 'bob'
        }
      });
      this.assertText('bob');
    }
    ['@test simple helper is called for param changes'](assert) {
      let computeCount = 0;
      this.registerHelper('hello-world', _ref => {
        let [value] = _ref;
        computeCount++;
        return value + "-value";
      });
      this.render('{{hello-world this.model.name}}', {
        model: {
          name: 'bob'
        }
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.name', 'sal'));
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        name: 'bob'
      }));
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 3, 'compute is called exactly 3 times');
    }
    ['@test class-based helper compute is called for param changes'](assert) {
      let createCount = 0;
      let computeCount = 0;
      this.registerHelper('hello-world', {
        init() {
          this._super(...arguments);
          createCount++;
        },
        compute(_ref2) {
          let [value] = _ref2;
          computeCount++;
          return value + "-value";
        }
      });
      this.render('{{hello-world this.model.name}}', {
        model: {
          name: 'bob'
        }
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.name', 'sal'));
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        name: 'bob'
      }));
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 3, 'compute is called exactly 3 times');
      assert.strictEqual(createCount, 1, 'helper is only created once');
    }
    ['@test simple helper receives params, hash']() {
      this.registerHelper('hello-world', (_params, _hash) => {
        return "params: " + JSON.stringify(_params) + ", hash: " + JSON.stringify(_hash);
      });
      this.render('{{hello-world this.model.name "rich" first=this.model.age last="sam"}}', {
        model: {
          name: 'bob',
          age: 42
        }
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.name', 'sal'));
      this.assertText('params: ["sal","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.age', 28));
      this.assertText('params: ["sal","rich"], hash: {"first":28,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        name: 'bob',
        age: 42
      }));
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
    }
    ['@test class-based helper receives params, hash']() {
      this.registerHelper('hello-world', {
        compute(_params, _hash) {
          return "params: " + JSON.stringify(_params) + ", hash: " + JSON.stringify(_hash);
        }
      });
      this.render('{{hello-world this.model.name "rich" first=this.model.age last="sam"}}', {
        model: {
          name: 'bob',
          age: 42
        }
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.name', 'sal'));
      this.assertText('params: ["sal","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.age', 28));
      this.assertText('params: ["sal","rich"], hash: {"first":28,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        name: 'bob',
        age: 42
      }));
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
    }
    ['@test class-based helper usable in subexpressions']() {
      this.registerHelper('join-words', {
        compute(params) {
          return params.join(' ');
        }
      });
      this.render("{{join-words \"Who\"\n                   (join-words \"overcomes\" \"by\")\n                   this.model.reason\n                   (join-words (join-words \"hath overcome but\" \"half\"))\n                   (join-words \"his\" (join-words \"foe\"))}}", {
        model: {
          reason: 'force'
        }
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.reason', 'Nickleback'));
      this.assertText('Who overcomes by Nickleback hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        reason: 'force'
      }));
      this.assertText('Who overcomes by force hath overcome but half his foe');
    }
    ['@test parameterless helper is usable in subexpressions']() {
      this.registerHelper('should-show', () => {
        return true;
      });
      this.render("{{#if (should-show)}}true{{/if}}");
      this.assertText('true');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('true');
    }
    ['@test parameterless helper is usable in attributes']() {
      this.registerHelper('foo-bar', () => {
        return 'baz';
      });
      this.render("<div data-foo-bar=\"{{foo-bar}}\"></div>");
      this.assertHTML('<div data-foo-bar="baz"></div>');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertHTML('<div data-foo-bar="baz"></div>');
    }
    ['@test simple helper not usable with a block'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.registerHelper('some-helper', () => {});
      assert.throws(() => {
        this.render("{{#some-helper}}{{/some-helper}}");
      }, /Attempted to resolve `some-helper`, which was expected to be a component, but nothing was found./);
    }
    ['@test class-based helper not usable with a block'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.registerHelper('some-helper', {
        compute() {}
      });
      assert.throws(() => {
        this.render("{{#some-helper}}{{/some-helper}}");
      }, /Attempted to resolve `some-helper`, which was expected to be a component, but nothing was found./);
    }
    ['@test simple helper not usable within element'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.registerHelper('some-helper', () => {});
      assert.throws(() => {
        this.render("<div {{some-helper}}></div>");
      }, /Attempted to resolve `some-helper`, which was expected to be a modifier, but nothing was found./);
    }
    ['@test class-based helper not usable within element'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.registerHelper('some-helper', {
        compute() {}
      });
      assert.throws(() => {
        this.render("<div {{some-helper}}></div>");
      }, /Attempted to resolve `some-helper`, which was expected to be a modifier, but nothing was found./);
    }
    ['@test class-based helper is torn down'](assert) {
      let destroyCalled = 0;
      this.registerHelper('some-helper', {
        destroy() {
          destroyCalled++;
          this._super(...arguments);
        },
        compute() {
          return 'must define a compute';
        }
      });
      this.render("{{some-helper}}");
      (0, _internalTestHelpers.runDestroy)(this.component);
      assert.strictEqual(destroyCalled, 1, 'destroy called once');
    }
    ['@test class-based helper used in subexpression can recompute']() {
      let helper;
      let phrase = 'overcomes by';
      this.registerHelper('dynamic-segment', {
        init() {
          this._super(...arguments);
          helper = this;
        },
        compute() {
          return phrase;
        }
      });
      this.registerHelper('join-words', {
        compute(params) {
          return params.join(' ');
        }
      });
      this.render("{{join-words \"Who\"\n                   (dynamic-segment)\n                   \"force\"\n                   (join-words (join-words \"hath overcome but\" \"half\"))\n                   (join-words \"his\" (join-words \"foe\"))}}");
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Who overcomes by force hath overcome but half his foe');
      phrase = 'believes his';
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      this.assertText('Who believes his force hath overcome but half his foe');
      phrase = 'overcomes by';
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      this.assertText('Who overcomes by force hath overcome but half his foe');
    }
    ['@test class-based helper used in subexpression can recompute component']() {
      let helper;
      let phrase = 'overcomes by';
      this.registerHelper('dynamic-segment', {
        init() {
          this._super(...arguments);
          helper = this;
        },
        compute() {
          return phrase;
        }
      });
      this.registerHelper('join-words', {
        compute(params) {
          return params.join(' ');
        }
      });
      this.registerComponent('some-component', {
        template: '{{@first}} {{@second}} {{@third}} {{@fourth}} {{@fifth}}'
      });
      this.render("{{some-component first=\"Who\"\n                   second=(dynamic-segment)\n                   third=\"force\"\n                   fourth=(join-words (join-words \"hath overcome but\" \"half\"))\n                   fifth=(join-words \"his\" (join-words \"foe\"))}}");
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Who overcomes by force hath overcome but half his foe');
      phrase = 'believes his';
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      this.assertText('Who believes his force hath overcome but half his foe');
      phrase = 'overcomes by';
      (0, _internalTestHelpers.runTask)(() => helper.recompute());
      this.assertText('Who overcomes by force hath overcome but half his foe');
    }
    ['@test class-based helper used in subexpression is destroyed'](assert) {
      let destroyCount = 0;
      this.registerHelper('dynamic-segment', {
        phrase: 'overcomes by',
        init() {
          this._super(...arguments);
        },
        compute() {
          return this.phrase;
        },
        destroy() {
          destroyCount++;
          this._super(...arguments);
        }
      });
      this.registerHelper('join-words', {
        compute(params) {
          return params.join(' ');
        }
      });
      this.render("{{join-words \"Who\"\n                   (dynamic-segment)\n                   \"force\"\n                   (join-words (join-words \"hath overcome but\" \"half\"))\n                   (join-words \"his\" (join-words \"foe\"))}}");
      (0, _internalTestHelpers.runDestroy)(this.component);
      assert.equal(destroyCount, 1, 'destroy is called after a view is destroyed');
    }
    ['@test simple helper can be invoked manually via `owner.factoryFor(...).create().compute()'](assert) {
      this.registerHelper('some-helper', () => {
        assert.ok(true, 'some-helper helper invoked');
        return 'lolol';
      });
      let instance = this.owner.factoryFor('helper:some-helper').create();
      assert.equal(typeof instance.compute, 'function', 'expected instance.compute to be present');
      assert.equal(instance.compute(), 'lolol', 'can invoke `.compute`');
    }
    ['@test class-based helper can be invoked manually via `owner.factoryFor(...).create().compute()'](assert) {
      this.registerHelper('some-helper', {
        compute() {
          assert.ok(true, 'some-helper helper invoked');
          return 'lolol';
        }
      });
      let instance = this.owner.factoryFor('helper:some-helper').create();
      assert.equal(typeof instance.compute, 'function', 'expected instance.compute to be present');
      assert.equal(instance.compute(), 'lolol', 'can invoke `.compute`');
    }
    ['@test class-based helper in native ES syntax receives owner'](assert) {
      let testContext = this;
      this.add('helper:hello-world', class extends _glimmer.Helper {
        constructor(owner) {
          super(owner);
          assert.equal(owner, testContext.owner, 'owner was passed as a constructor argument');
        }
        compute() {
          return 'huzza!';
        }
      });
      this.render('{{hello-world}}');
      this.assertText('huzza!');
    }
    '@test Can resolve a helper'() {
      this.registerHelper('hello-world', _ref3 => {
        let [text] = _ref3;
        return text != null ? text : 'Hello, world!';
      });
      this.render('[{{helper "hello-world"}}][{{helper (helper "hello-world") "wow"}}]');
      this.assertText('[Hello, world!][wow]');
      this.assertStableRerender();
    }
    '@test Cannot dynamically resolve a helper'(assert) {
      this.registerHelper('hello-world', () => 'Hello, world!');
      if (false /* DEBUG */) {
        expectAssertion(() => this.render('{{helper this.name}}', {
          name: 'hello-world'
        }), /Passing a dynamic string to the `\(helper\)` keyword is disallowed\./);
      } else {
        assert.expect(0);
      }
    }
    '@test Can use a curried dynamic helper'() {
      let val = (0, _internalTestHelpers.defineSimpleHelper)(value => value);
      this.registerComponent('foo', {
        template: '{{@value}}'
      });
      this.registerComponent('bar', {
        template: '<Foo @value={{helper this.val "Hello, world!"}}/>',
        ComponentClass: _glimmer.Component.extend({
          val
        })
      });
      this.render('<Bar/>');
      this.assertText('Hello, world!');
      this.assertStableRerender();
    }
    '@test Can use a dynamic helper with nested helpers'() {
      let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'world!');
      let bar = (0, _internalTestHelpers.defineSimpleHelper)(value => 'Hello, ' + value);
      this.registerComponent('baz', {
        template: '{{this.bar (this.foo)}}',
        ComponentClass: _glimmer.Component.extend({
          foo,
          bar
        })
      });
      this.render('<Baz/>');
      this.assertText('Hello, world!');
      this.assertStableRerender();
    }
    ['@test helpers are not computed eagerly when used with if expressions'](assert) {
      this.registerHelper('is-ok', () => 'hello');
      this.registerHelper('throws-error', () => assert.ok(false, 'helper was computed eagerly'));
      this.render('{{if true (is-ok) (throws-error)}}');
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello');
    }
  });
  if (false /* DEBUG */) {
    class HelperMutatingArgsTests extends _internalTestHelpers.RenderingTestCase {
      buildCompute() {
        return (params, hash) => {
          this.assert.throws(() => {
            params.push('foo');

            // cannot assert error message as it varies by platform
          });

          this.assert.throws(() => {
            hash.foo = 'bar';

            // cannot assert error message as it varies by platform
          });

          this.assert.throws(() => {
            hash.someUnusedHashProperty = 'bar';

            // cannot assert error message as it varies by platform
          });
        };
      }

      ['@test cannot mutate params - no positional specified / named specified']() {
        this.render('{{test-helper foo=this.bar}}', {
          bar: 'derp'
        });
      }
      ['@test cannot mutate params - positional specified / no named specified']() {
        this.render('{{test-helper this.bar}}', {
          bar: 'derp'
        });
      }
      ['@test cannot mutate params - positional specified / named specified']() {
        this.render('{{test-helper this.bar foo=this.qux}}', {
          bar: 'derp',
          qux: 'baz'
        });
      }
      ['@test cannot mutate params - no positional specified / no named specified']() {
        this.render('{{test-helper}}', {
          bar: 'derp',
          qux: 'baz'
        });
      }
    }
    (0, _internalTestHelpers.moduleFor)('Helpers test: mutation triggers errors - class based helper', class extends HelperMutatingArgsTests {
      constructor() {
        super(...arguments);
        let compute = this.buildCompute();
        this.registerHelper('test-helper', {
          compute
        });
      }
    });
    (0, _internalTestHelpers.moduleFor)('Helpers test: mutation triggers errors - simple helper', class extends HelperMutatingArgsTests {
      constructor() {
        super(...arguments);
        let compute = this.buildCompute();
        this.registerHelper('test-helper', compute);
      }
    });
    (0, _internalTestHelpers.moduleFor)('Helpers test: argument-less helper invocation in named arguments position', class extends _internalTestHelpers.RenderingTestCase {
      constructor() {
        super(...arguments);
        this.registerComponent('bar', {
          template: '[{{is-string @content}}][{{@content}}]'
        });
        this.registerHelper('is-string', _ref4 => {
          let [value] = _ref4;
          return typeof value === 'string';
        });
      }
      ['@test invoking an argument-less helper without parens in named argument position throws'](assert) {
        this.registerHelper('foo', () => 'Hello, world!');
        assert.throws(() => this.render('<Bar @content={{foo}} />', {
          foo: 'Not it!'
        }), "A resolved helper cannot be passed as a named argument as the syntax is " + "ambiguously a pass-by-reference or invocation. Use the " + "`{{helper 'foo-helper}}` helper to pass by reference or explicitly " + "invoke the helper with parens: `{{(fooHelper)}}`.");
      }
      ['@test invoking an argument-less helper with parens in named argument position']() {
        this.registerHelper('foo', () => 'Hello, world!');
        expectNoDeprecation(() => this.render('<Bar @content={{(foo)}} />', {
          foo: 'Not it!'
        }));
        this.assertText('[true][Hello, world!]');
        this.assertStableRerender();
      }
      ['@test invoking an argument-less helper with quotes in named argument position']() {
        this.registerHelper('foo', () => 'Hello, world!');
        expectNoDeprecation(() => this.render('<Bar @content="{{foo}}" />', {
          foo: 'Not it!'
        }));
        this.assertText('[true][Hello, world!]');
        this.assertStableRerender();
      }
      ['@test passing a local helper in named argument position']() {
        let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'Hello, world!');
        expectNoDeprecation(() => this.render("{{#let this.foo as |foo|}}<Bar @content={{foo}} />{{/let}}", {
          foo
        }));
        this.assertText('[false][Hello, world!]');
        this.assertStableRerender();
      }

      // TODO: this one really should work, and there is a passing test in glimmer-vm,
      // but somehow it doesn't work here. This is almost certainly a VM bug as something
      // is trying to call `block.compile()` but `block` is the reference for `this.foo`.
      // So the execution stack is probably off-by-one or something.

      ['@test invoking a local helper with parens in named argument position']() {
        let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'Hello, world!');
        expectNoDeprecation(() => this.render("{{#let this.foo as |foo|}}<Bar @content={{(foo)}} />{{/let}}", {
          foo
        }));
        this.assertText('[true][Hello, world!]');
        this.assertStableRerender();
      }
      ['@skip invoking a helper with quotes in named argument position']() {
        let foo = (0, _internalTestHelpers.defineSimpleHelper)(() => 'Hello, world!');
        expectNoDeprecation(() => this.render("{{#let this.foo as |foo|}}<Bar @content=\"{{foo}}\" />{{/let}}", {
          foo
        }));
        this.assertText('[true][Hello, world!]');
        this.assertStableRerender();
      }
    });
  }
});
define("@ember/-internals/glimmer/tests/integration/helpers/default-helper-manager-test", ["internal-test-helpers", "@ember/-internals/glimmer", "@ember/object"], function (_internalTestHelpers, _glimmer, _object) {
  "use strict";

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  (0, _internalTestHelpers.moduleFor)('Helpers test: default helper manager', class extends _internalTestHelpers.RenderingTestCase {
    '@test plain functions can be used as helpers'() {
      function hello() {
        return 'hello';
      }
      this.render('{{(this.hello)}}', {
        hello
      });
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello');
    }
    '@test positional arguments are passed as function arguments'(assert) {
      function hello() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        assert.deepEqual(args, [1, 2, 3]);
        return args.length;
      }
      this.render('{{(this.hello 1 2 3)}}', {
        hello
      });
      this.assertText('3');
    }
    '@test tracks changes to positional arguments'(assert) {
      let count = 0;
      function hello(firstArgument) {
        count++;
        return firstArgument;
      }
      this.render('{{(this.hello this.foo)}}', {
        hello,
        foo: 123
      });
      assert.strictEqual(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 456));
      assert.equal(count, 2, 'rendered twice');
      this.assertText('456');
    }
    '@test named arguments are passed as the last function argument'(assert) {
      function hello(positional, named) {
        assert.strictEqual(positional, 'foo');
        return named.foo;
      }
      this.render('{{(this.hello "foo" foo="bar")}}', {
        hello
      });
      this.assertText('bar');
    }
    '@test tracks changes to named arguments'(assert) {
      let count = 0;
      function hello(named) {
        count++;
        return named.foo;
      }
      this.render('{{(this.hello foo=this.foo)}}', {
        hello,
        foo: 123
      });
      assert.strictEqual(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 456));
      assert.equal(count, 2, 'rendered twice');
      this.assertText('456');
    }
    '@test plain functions passed as component arguments can be used as helpers'() {
      function hello() {
        return 'hello';
      }
      this.registerComponent('foo-bar', {
        template: '{{(@hello)}}'
      });
      this.render("<FooBar @hello={{this.hello}} />", {
        hello
      });
      this.assertText('hello');
    }
    '@test plain functions stored as class properties can be used as helpers'() {
      this.registerComponent('foo-bar', {
        template: '{{(this.hello)}}',
        ComponentClass: class ComponentClass extends _glimmer.Component {
          constructor() {
            super(...arguments);
            this.hello = () => {
              return 'hello';
            };
          }
        }
      });
      this.render("<FooBar />");
      this.assertText('hello');
    }
    '@test class methods can be used as helpers'() {
      this.registerComponent('foo-bar', {
        template: '{{(this.hello)}}',
        ComponentClass: class extends _glimmer.Component {
          hello() {
            return 'hello';
          }
        }
      });
      this.render("<FooBar />");
      this.assertText('hello');
    }
    '@test actions can be used as helpers'() {
      var _class2;
      this.registerComponent('foo-bar', {
        template: '{{(this.hello)}}',
        ComponentClass: (_class2 = class _class2 extends _glimmer.Component {
          constructor() {
            super(...arguments);
            this.someProperty = 'hello';
          }
          hello() {
            return this.someProperty;
          }
        }, _applyDecoratedDescriptor(_class2.prototype, "hello", [_object.action], Object.getOwnPropertyDescriptor(_class2.prototype, "hello"), _class2.prototype), _class2)
      });
      this.render("<FooBar />");
      this.assertText('hello');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/element-action-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/array", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _array, _views, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
  function getActionAttributes(element) {
    let attributes = element.attributes;
    let actionAttrs = [];
    for (let i = 0; i < attributes.length; i++) {
      let attr = attributes.item(i);
      if (attr.name.indexOf('data-ember-action-') === 0) {
        actionAttrs.push(attr.name);
      }
    }
    return actionAttrs;
  }
  function getActionIds(element) {
    return getActionAttributes(element).map(attribute => attribute.slice('data-ember-action-'.length));
  }
  (0, _internalTestHelpers.moduleFor)('Helpers test: element action', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it can call an action on its enclosing component']() {
      let fooCallCount = 0;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          foo() {
            fooCallCount++;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "foo"}}>Click me</button>'
      });
      this.render('{{example-component}}');
      this.assert.equal(fooCallCount, 0, 'foo has not been called');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assert.equal(fooCallCount, 0, 'foo has not been called');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.equal(fooCallCount, 1, 'foo has been called 1 time');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.equal(fooCallCount, 2, 'foo has been called 2 times');
    }
    ['@test it can call an action with parameters']() {
      let fooArgs = [];
      let component;
      let ExampleComponent = _helpers.Component.extend({
        member: 'a',
        init() {
          this._super(...arguments);
          component = this;
        },
        actions: {
          foo(thing) {
            fooArgs.push(thing);
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "foo" this.member}}>Click me</button>'
      });
      this.render('{{example-component}}');
      this.assert.deepEqual(fooArgs, [], 'foo has not been called');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assert.deepEqual(fooArgs, [], 'foo has not been called');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.deepEqual(fooArgs, ['a'], 'foo has not been called');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('member', 'b');
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.deepEqual(fooArgs, ['a', 'b'], 'foo has been called with an updated value');
    }
    ['@test it should output a marker attribute with a guid']() {
      this.render('<button {{action "show"}}>me the money</button>');
      let button = this.$('button');
      let attributes = getActionAttributes(button[0]);
      this.assert.ok(button.attr('data-ember-action').match(''), 'An empty data-ember-action attribute was added');
      this.assert.ok(attributes[0].match(/data-ember-action-\d+/), 'A data-ember-action-xyz attribute with a guid was added');
    }
    ['@test it should allow alternative events to be handled']() {
      let showCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          show() {
            showCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<div id="show" {{action "show" on="mouseUp"}}></div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#show').trigger('mouseup');
      });
      this.assert.ok(showCalled, 'show action was called on mouseUp');
    }
    ['@test inside a yield, the target points at the original target']() {
      let targetWatted = false;
      let innerWatted = false;
      let TargetComponent = _helpers.Component.extend({
        actions: {
          wat() {
            targetWatted = true;
          }
        }
      });
      let InnerComponent = _helpers.Component.extend({
        actions: {
          wat() {
            innerWatted = true;
          }
        }
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: '{{yield}}'
      });
      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#inner-component}}\n          <button {{action \"wat\"}}>Wat me!</button>\n        {{/inner-component}}\n      "])))
      });
      this.render('{{target-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.ok(targetWatted, 'the correct target was watted');
      this.assert.notOk(innerWatted, 'the inner target was not watted');
    }
    ['@test it should allow a target to be specified']() {
      let targetWatted = false;
      let TargetComponent = _helpers.Component.extend({
        actions: {
          wat() {
            targetWatted = true;
          }
        }
      });
      let OtherComponent = _helpers.Component.extend({});
      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: '{{yield this}}'
      });
      this.registerComponent('other-component', {
        ComponentClass: OtherComponent,
        template: '<a {{action "wat" target=this.anotherTarget}}>Wat?</a>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#target-component as |parent|}}\n            {{other-component anotherTarget=parent}}\n          {{/target-component}}\n        "]))));
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.equal(targetWatted, true, 'the specified target was watted');
    }
    ['@test it should lazily evaluate the target']() {
      let firstEdit = 0;
      let secondEdit = 0;
      let component;
      let first = {
        edit() {
          firstEdit++;
        }
      };
      let second = {
        edit() {
          secondEdit++;
        }
      };
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        theTarget: first
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "edit" target=this.theTarget}}>Edit</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.equal(firstEdit, 1);
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(component, 'theTarget', second);
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.equal(firstEdit, 1);
      this.assert.equal(secondEdit, 1);
    }
    ['@test it should register an event handler']() {
      let editHandlerWasCalled = false;
      let shortcutHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          edit() {
            editHandlerWasCalled = true;
          },
          shortcut() {
            shortcutHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys="alt"}}>click me</a> <div {{action "shortcut" allowedKeys="any"}}>click me too</div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a[data-ember-action]').trigger('click', {
          altKey: true
        });
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('div[data-ember-action]').trigger('click', {
          ctrlKey: true
        });
      });
      this.assert.equal(shortcutHandlerWasCalled, true, 'the "any" shortcut\'s event handler was called');
    }
    ['@test it handles whitelisted bound modifier keys']() {
      let editHandlerWasCalled = false;
      let shortcutHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        altKey: 'alt',
        anyKey: 'any',
        actions: {
          edit() {
            editHandlerWasCalled = true;
          },
          shortcut() {
            shortcutHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys=this.altKey}}>click me</a> <div {{action "shortcut" allowedKeys=this.anyKey}}>click me too</div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a[data-ember-action]').trigger('click', {
          altKey: true
        });
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('div[data-ember-action]').trigger('click', {
          ctrlKey: true
        });
      });
      this.assert.equal(shortcutHandlerWasCalled, true, 'the "any" shortcut\'s event handler was called');
    }
    ['@test it handles whitelisted bound modifier keys with current value']() {
      let editHandlerWasCalled = false;
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        acceptedKeys: 'alt',
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys=this.acceptedKeys}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a[data-ember-action]').trigger('click', {
          altKey: true
        });
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
      editHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        component.set('acceptedKeys', '');
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.$('div[data-ember-action]').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the event handler was not called');
    }
    ['@test should be able to use action more than once for the same event within a view']() {
      let editHandlerWasCalled = false;
      let deleteHandlerWasCalled = false;
      let originalHandlerWasCalled = false;
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        actions: {
          edit() {
            editHandlerWasCalled = true;
          },
          delete() {
            deleteHandlerWasCalled = true;
          }
        },
        click() {
          originalHandlerWasCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit"}}>edit</a><a id="delete" href="#" {{action "delete"}}>delete</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called (due to bubbling)');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#delete').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called (due to bubbling)');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.wrap(component.element).click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    }
    ['@test the event should not bubble if `bubbles=false` is passed']() {
      let editHandlerWasCalled = false;
      let deleteHandlerWasCalled = false;
      let originalHandlerWasCalled = false;
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        actions: {
          edit() {
            editHandlerWasCalled = true;
          },
          delete() {
            deleteHandlerWasCalled = true;
          }
        },
        click() {
          originalHandlerWasCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=false}}>edit</a><a id="delete" href="#" {{action "delete" bubbles=false}}>delete</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#delete').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.wrap(component.element).click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    }
    ['@test the event should not bubble if `bubbles=false` is passed bound']() {
      let editHandlerWasCalled = false;
      let deleteHandlerWasCalled = false;
      let originalHandlerWasCalled = false;
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        isFalse: false,
        actions: {
          edit() {
            editHandlerWasCalled = true;
          },
          delete() {
            deleteHandlerWasCalled = true;
          }
        },
        click() {
          originalHandlerWasCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=this.isFalse}}>edit</a><a id="delete" href="#" {{action "delete" bubbles=this.isFalse}}>delete</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#delete').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.wrap(component.element).click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    }
    ['@test the bubbling depends on the bound parameter']() {
      let editHandlerWasCalled = false;
      let originalHandlerWasCalled = false;
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        shouldBubble: false,
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        },
        click() {
          originalHandlerWasCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=this.shouldBubble}}>edit</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        component.set('shouldBubble', true);
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    }
    ['@test multiple actions with bubbles=false for same event are called but prevent bubbling']() {
      let clickAction1WasCalled = false;
      let clickAction2WasCalled = false;
      let eventHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          clicked1() {
            clickAction1WasCalled = true;
          },
          clicked2() {
            clickAction2WasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <a href=\"#\"\n          {{action \"clicked1\" on=\"click\" bubbles=false}}\n          {{action \"clicked2\" on=\"click\" bubbles=false}}\n        >click me</a>"]))),
        click() {
          eventHandlerWasCalled = true;
        }
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').trigger('click');
      });
      this.assert.ok(clickAction1WasCalled, 'the first clicked action was called');
      this.assert.ok(clickAction2WasCalled, 'the second clicked action was called');
      this.assert.notOk(eventHandlerWasCalled, 'event did not bubble up');
    }
    ['@test it should work properly in an #each block']() {
      let editHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        items: (0, _array.A)([1, 2, 3, 4]),
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#each this.items as |item|}}<a href="#" {{action "edit"}}>click me</a>{{/each}}'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
    }
    ['@test it should work properly in a {{#let foo as |bar|}} block']() {
      let editHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        something: {
          ohai: 'there'
        },
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#let this.something as |somethingElse|}}<a href="#" {{action "edit"}}>click me</a>{{/let}}'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
    }
    ['@test it should unregister event handlers when an element action is removed'](assert) {
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          edit() {}
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#if this.isActive}}<a href="#" {{action "edit"}}>click me</a>{{/if}}'
      });
      this.render('{{example-component isActive=this.isActive}}', {
        isActive: true
      });
      assert.equal(this.$('a[data-ember-action]').length, 1, 'The element is rendered');
      let actionId;
      actionId = getActionIds(this.$('a[data-ember-action]')[0])[0];
      assert.ok(_views.ActionManager.registeredActions[actionId], 'An action is registered');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(this.$('a[data-ember-action]').length, 1, 'The element is still present');
      assert.ok(_views.ActionManager.registeredActions[actionId], 'The action is still registered');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isActive', false));
      assert.strictEqual(this.$('a[data-ember-action]').length, 0, 'The element is removed');
      assert.ok(!_views.ActionManager.registeredActions[actionId], 'The action is unregistered');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'isActive', true));
      assert.equal(this.$('a[data-ember-action]').length, 1, 'The element is rendered');
      actionId = getActionIds(this.$('a[data-ember-action]')[0])[0];
      assert.ok(_views.ActionManager.registeredActions[actionId], 'A new action is registered');
    }
    ['@test it should capture events from child elements and allow them to trigger the action']() {
      let editHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<div {{action "edit"}}><button>click me</button></div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.ok(editHandlerWasCalled, 'event on a child target triggered the action of its parent');
    }
    ['@test it should allow bubbling of events from action helper to original parent event']() {
      let editHandlerWasCalled = false;
      let originalHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        },
        click() {
          originalHandlerWasCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit"}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.ok(editHandlerWasCalled && originalHandlerWasCalled, 'both event handlers were called');
    }
    ['@test it should not bubble an event from action helper to original parent event if `bubbles=false` is passed']() {
      let editHandlerWasCalled = false;
      let originalHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        },
        click() {
          originalHandlerWasCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" bubbles=false}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.ok(editHandlerWasCalled, 'the child event handler was called');
      this.assert.notOk(originalHandlerWasCalled, 'the parent handler was not called');
    }
    ['@test it should allow "send" as the action name (#594)']() {
      let sendHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          send() {
            sendHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "send"}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.ok(sendHandlerWasCalled, 'the event handler was called');
    }
    ['@test it should send the view, event, and current context to the action']() {
      let passedTarget;
      let passedContext;
      let targetThis;
      let TargetComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          targetThis = this;
        },
        actions: {
          edit(context) {
            passedTarget = this === targetThis;
            passedContext = context;
          }
        }
      });
      let aContext;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          aContext = this;
        }
      });
      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: '{{yield this}}'
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#target-component as |aTarget|}}\n          <a id=\"edit\" href=\"#\" {{action \"edit\" this target=aTarget}}>click me</a>\n        {{/target-component}}\n        "])))
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('#edit').click();
      });
      this.assert.ok(passedTarget, 'the action is called with the target as this');
      this.assert.strictEqual(passedContext, aContext, 'the parameter is passed along');
    }
    ['@test it should only trigger actions for the event they were registered on']() {
      let editHandlerWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          edit() {
            editHandlerWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit"}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.ok(editHandlerWasCalled, 'the event handler was called on click');
      editHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').trigger('mouseover');
      });
      this.assert.notOk(editHandlerWasCalled, 'the event handler was not called on mouseover');
    }
    ['@test it should allow multiple contexts to be specified']() {
      let passedContexts;
      let models = [_object.default.create(), _object.default.create()];
      let ExampleComponent = _helpers.Component.extend({
        modelA: models[0],
        modelB: models[1],
        actions: {
          edit() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            passedContexts = args;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "edit" this.modelA this.modelB}}>click me</button>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.deepEqual(passedContexts, models, 'the action was called with the passed contexts');
    }
    ['@test it should allow multiple contexts to be specified mixed with string args']() {
      let passedContexts;
      let model = _object.default.create();
      let ExampleComponent = _helpers.Component.extend({
        model: model,
        actions: {
          edit() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            passedContexts = args;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "edit" "herp" this.model}}>click me</button>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.deepEqual(passedContexts, ['herp', model], 'the action was called with the passed contexts');
    }
    ['@test it should not trigger action with special clicks']() {
      let showCalled = false;
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        actions: {
          show() {
            showCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "show" href=true}}>Howdy</button>'
      });
      this.render('{{example-component}}');
      let assert = this.assert;
      let checkClick = (prop, value, expected) => {
        showCalled = false;
        let event = this.wrap(component.element).findAll('button').trigger('click', {
          [prop]: value
        })[0];
        if (expected) {
          assert.ok(showCalled, "should call action with " + prop + ":" + value);
          assert.ok(event.defaultPrevented, 'should prevent default');
        } else {
          assert.notOk(showCalled, "should not call action with " + prop + ":" + value);
          assert.notOk(event.defaultPrevented, 'should not prevent default');
        }
      };
      checkClick('ctrlKey', true, false);
      checkClick('altKey', true, false);
      checkClick('metaKey', true, false);
      checkClick('shiftKey', true, false);
      checkClick('button', 0, true);
      checkClick('button', 1, false);
      checkClick('button', 2, false);
      checkClick('button', 3, false);
      checkClick('button', 4, false);
    }
    ['@test it can trigger actions for keyboard events']() {
      let showCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          show() {
            showCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<input type="text" {{action "show" on="keyUp"}}>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('input').trigger('keyup', {
          char: 'a',
          which: 65
        });
      });
      this.assert.ok(showCalled, 'the action was called with keyup');
    }
    ['@test a quoteless parameter should allow dynamic lookup of the actionName']() {
      let lastAction;
      let actionOrder = [];
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        hookMeUp: 'rock',
        actions: {
          rock() {
            lastAction = 'rock';
            actionOrder.push('rock');
          },
          paper() {
            lastAction = 'paper';
            actionOrder.push('paper');
          },
          scissors() {
            lastAction = 'scissors';
            actionOrder.push('scissors');
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="bound-param" {{action this.hookMeUp}}>Whistle tips go woop woooop</a>'
      });
      this.render('{{example-component}}');
      let test = this;
      let testBoundAction = propertyValue => {
        (0, _internalTestHelpers.runTask)(() => {
          component.set('hookMeUp', propertyValue);
        });
        (0, _internalTestHelpers.runTask)(() => {
          this.wrap(component.element).findAll('#bound-param').click();
        });
        test.assert.ok(lastAction, propertyValue, "lastAction set to " + propertyValue);
      };
      testBoundAction('rock');
      testBoundAction('paper');
      testBoundAction('scissors');
      this.assert.deepEqual(actionOrder, ['rock', 'paper', 'scissors'], 'action name was looked up properly');
    }
    ['@test a quoteless string parameter should resolve actionName, including path']() {
      let lastAction;
      let actionOrder = [];
      let component;
      let ExampleComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          component = this;
        },
        allactions: (0, _array.A)([{
          title: 'Rock',
          name: 'rock'
        }, {
          title: 'Paper',
          name: 'paper'
        }, {
          title: 'Scissors',
          name: 'scissors'
        }]),
        actions: {
          rock() {
            lastAction = 'rock';
            actionOrder.push('rock');
          },
          paper() {
            lastAction = 'paper';
            actionOrder.push('paper');
          },
          scissors() {
            lastAction = 'scissors';
            actionOrder.push('scissors');
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#each this.allactions as |allaction|}}<a id="{{allaction.name}}" {{action allaction.name}}>{{allaction.title}}</a>{{/each}}'
      });
      this.render('{{example-component}}');
      let test = this;
      let testBoundAction = propertyValue => {
        (0, _internalTestHelpers.runTask)(() => {
          this.wrap(component.element).findAll("#" + propertyValue).click();
        });
        test.assert.ok(lastAction, propertyValue, "lastAction set to " + propertyValue);
      };
      testBoundAction('rock');
      testBoundAction('paper');
      testBoundAction('scissors');
      this.assert.deepEqual(actionOrder, ['rock', 'paper', 'scissors'], 'action name was looked up properly');
    }
    ['@test a quoteless function parameter should be called, including arguments']() {
      let submitCalled = false;
      let incomingArg;
      let arg = 'rough ray';
      let ExampleComponent = _helpers.Component.extend({
        submit(actualArg) {
          incomingArg = actualArg;
          submitCalled = true;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: "<a {{action this.submit '" + arg + "'}}>Hi</a>"
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').click();
      });
      this.assert.ok(submitCalled, 'submit function called');
      this.assert.equal(incomingArg, arg, 'argument passed');
    }
    ['@test a quoteless parameter that does not resolve to a value asserts']() {
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          ohNoeNotValid() {}
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="oops-bound-param" {{action this.ohNoeNotValid}}>Hi</a>'
      });
      expectAssertion(() => {
        this.render('{{example-component}}');
      }, 'You specified a quoteless path, `this.ohNoeNotValid`, to the {{action}} helper ' + 'which did not resolve to an action name (a string). ' + 'Perhaps you meant to use a quoted actionName? (e.g. {{action "ohNoeNotValid"}}).');
    }
    ['@test allows multiple actions on a single element']() {
      let clickActionWasCalled = false;
      let doubleClickActionWasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          clicked() {
            clickActionWasCalled = true;
          },
          doubleClicked() {
            doubleClickActionWasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <a href=\"#\"\n          {{action \"clicked\" on=\"click\"}}\n          {{action \"doubleClicked\" on=\"doubleClick\"}}\n        >click me</a>"])))
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').trigger('click');
      });
      this.assert.ok(clickActionWasCalled, 'the clicked action was called');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').trigger('dblclick');
      });
      this.assert.ok(doubleClickActionWasCalled, 'the doubleClicked action was called');
    }
    ['@test allows multiple actions for same event on a single element']() {
      let clickAction1WasCalled = false;
      let clickAction2WasCalled = false;
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          clicked1() {
            clickAction1WasCalled = true;
          },
          clicked2() {
            clickAction2WasCalled = true;
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <a href=\"#\"\n          {{action \"clicked1\" on=\"click\"}}\n          {{action \"clicked2\" on=\"click\"}}\n        >click me</a>"])))
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('a').trigger('click');
      });
      this.assert.ok(clickAction1WasCalled, 'the first clicked action was called');
      this.assert.ok(clickAction2WasCalled, 'the second clicked action was called');
    }
    ['@test it should respect preventDefault option if provided']() {
      let ExampleComponent = _helpers.Component.extend({
        actions: {
          show() {}
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "show" preventDefault=false}}>Hi</a>'
      });
      this.render('{{example-component}}');
      let event;
      (0, _internalTestHelpers.runTask)(() => {
        event = this.$('a').click()[0];
      });
      this.assert.equal(event.defaultPrevented, false, 'should not preventDefault');
    }
    ['@test it should respect preventDefault option if provided bound']() {
      let component;
      let ExampleComponent = _helpers.Component.extend({
        shouldPreventDefault: false,
        init() {
          this._super(...arguments);
          component = this;
        },
        actions: {
          show() {}
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "show" preventDefault=this.shouldPreventDefault}}>Hi</a>'
      });
      this.render('{{example-component}}');
      let event;
      (0, _internalTestHelpers.runTask)(() => {
        event = this.$('a').trigger(event)[0];
      });
      this.assert.equal(event.defaultPrevented, false, 'should not preventDefault');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('shouldPreventDefault', true);
        event = this.$('a').trigger('click')[0];
      });
      this.assert.equal(event.defaultPrevented, true, 'should preventDefault');
    }
    ['@test it should target the proper component when `action` is in yielded block [GH #12409]']() {
      let outerActionCalled = false;
      let innerClickCalled = false;
      let OuterComponent = _helpers.Component.extend({
        actions: {
          hey() {
            outerActionCalled = true;
          }
        }
      });
      let MiddleComponent = _helpers.Component.extend({});
      let InnerComponent = _helpers.Component.extend({
        click() {
          innerClickCalled = true;
          this.action();
        }
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#middle-component}}\n          {{inner-component action=(action \"hey\")}}\n        {{/middle-component}}\n      "])))
      });
      this.registerComponent('middle-component', {
        ComponentClass: MiddleComponent,
        template: '{{yield}}'
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <button>Click Me</button>\n        {{yield}}\n      "])))
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.ok(outerActionCalled, 'the action fired on the proper target');
      this.assert.ok(innerClickCalled, 'the click was triggered');
    }
    ['@test element action with (mut undefinedThing) works properly']() {
      let component;
      let ExampleComponent = _helpers.Component.extend({
        label: undefined,
        init() {
          this._super(...arguments);
          component = this;
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action (mut this.label) "Clicked!"}}>{{if this.label this.label "Click me"}}</button>'
      });
      this.render('{{example-component}}');
      this.assertText('Click me');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('label', 'Dun clicked');
      });
      this.assertText('Dun clicked');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(() => {
        component.set('label', undefined);
      });
      this.assertText('Click me');
    }
    ['@test it supports non-registered actions [GH#14888]']() {
      this.render("\n      {{#if this.show}}\n        <button id='ddButton' {{action (mut this.show) false}}>\n          Show ({{this.show}})\n        </button>\n      {{/if}}\n    ", {
        show: true
      });
      this.assert.equal(this.$('button').text().trim(), 'Show (true)');
      // We need to focus in to simulate an actual click.
      (0, _internalTestHelpers.runTask)(() => {
        document.getElementById('ddButton').focus();
        document.getElementById('ddButton').click();
      });
    }
    ["@test action handler that shifts element attributes doesn't trigger multiple invocations"]() {
      let actionCount = 0;
      let ExampleComponent = _helpers.Component.extend({
        selected: false,
        actions: {
          toggleSelected() {
            actionCount++;
            this.toggleProperty('selected');
          }
        }
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button class="{{if this.selected \'selected\'}}" {{action "toggleSelected"}}>Toggle Selected</button>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.equal(actionCount, 1, 'Click action only fired once.');
      this.assert.ok(this.$('button').hasClass('selected'), "Element with action handler has properly updated it's conditional class");
      (0, _internalTestHelpers.runTask)(() => {
        this.$('button').click();
      });
      this.assert.equal(actionCount, 2, 'Second click action only fired once.');
      this.assert.ok(!this.$('button').hasClass('selected'), "Element with action handler has properly updated it's conditional class");
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/fn-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers"], function (_object, _internalTestHelpers, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{fn}}', class extends _internalTestHelpers.RenderingTestCase {
    beforeEach() {
      this.registerHelper('invoke', function (_ref) {
        let [fn] = _ref;
        return fn();
      });
      let testContext = this;
      this.registerComponent('stash', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            testContext.stashedFn = this.stashedFn;
          }
        })
      });
    }
    '@test updates when arguments change'() {
      this.render("{{invoke (fn this.myFunc this.arg1 this.arg2)}}", {
        myFunc(arg1, arg2) {
          return "arg1: " + arg1 + ", arg2: " + arg2;
        },
        arg1: 'foo',
        arg2: 'bar'
      });
      this.assertText('arg1: foo, arg2: bar');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg1', 'qux'));
      this.assertText('arg1: qux, arg2: bar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg2', 'derp'));
      this.assertText('arg1: qux, arg2: derp');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'arg1', 'foo');
        (0, _object.set)(this.context, 'arg2', 'bar');
      });
      this.assertText('arg1: foo, arg2: bar');
    }
    '@test updates when the function changes'() {
      let func1 = (arg1, arg2) => "arg1: " + arg1 + ", arg2: " + arg2;
      let func2 = (arg1, arg2) => "arg2: " + arg2 + ", arg1: " + arg1;
      this.render("{{invoke (fn this.myFunc this.arg1 this.arg2)}}", {
        myFunc: func1,
        arg1: 'foo',
        arg2: 'bar'
      });
      this.assertText('arg1: foo, arg2: bar');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'myFunc', func2));
      this.assertText('arg2: bar, arg1: foo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'myFunc', func1));
      this.assertText('arg1: foo, arg2: bar');
    }
    '@test a stashed fn result update arguments when invoked'(assert) {
      this.render("{{stash stashedFn=(fn this.myFunc this.arg1 this.arg2)}}", {
        myFunc(arg1, arg2) {
          return "arg1: " + arg1 + ", arg2: " + arg2;
        },
        arg1: 'foo',
        arg2: 'bar'
      });
      assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg1', 'qux'));
      assert.equal(this.stashedFn(), 'arg1: qux, arg2: bar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg2', 'derp'));
      assert.equal(this.stashedFn(), 'arg1: qux, arg2: derp');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'arg1', 'foo');
        (0, _object.set)(this.context, 'arg2', 'bar');
      });
      assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
    }
    '@test a stashed fn result invokes the correct function when the bound function changes'(assert) {
      let func1 = (arg1, arg2) => "arg1: " + arg1 + ", arg2: " + arg2;
      let func2 = (arg1, arg2) => "arg2: " + arg2 + ", arg1: " + arg1;
      this.render("{{stash stashedFn=(fn this.myFunc this.arg1 this.arg2)}}", {
        myFunc: func1,
        arg1: 'foo',
        arg2: 'bar'
      });
      assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'myFunc', func2));
      assert.equal(this.stashedFn(), 'arg2: bar, arg1: foo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'myFunc', func1));
      assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
    }
    '@test there is no `this` context within the callback'(assert) {
      if (false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      this.render("{{stash stashedFn=(fn this.myFunc this.arg1)}}", {
        myFunc() {
          assert.strictEqual(this, null, 'this is bound to null in production builds');
        }
      });
      this.stashedFn();
    }
    '@test can use `this` if bound prior to passing to fn'(assert) {
      this.render("{{stash stashedFn=(fn (action this.myFunc) this.arg1)}}", {
        myFunc(arg1) {
          return "arg1: " + arg1 + ", arg2: " + this.arg2;
        },
        arg1: 'foo',
        arg2: 'bar'
      });
      assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
    }
    '@test partially applies each layer when nested [GH#17959]'() {
      this.render("{{invoke (fn (fn (fn this.myFunc this.arg1) this.arg2) this.arg3)}}", {
        myFunc(arg1, arg2, arg3) {
          return "arg1: " + arg1 + ", arg2: " + arg2 + ", arg3: " + arg3;
        },
        arg1: 'foo',
        arg2: 'bar',
        arg3: 'qux'
      });
      this.assertText('arg1: foo, arg2: bar, arg3: qux');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg1', 'qux'));
      this.assertText('arg1: qux, arg2: bar, arg3: qux');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg2', 'derp'));
      this.assertText('arg1: qux, arg2: derp, arg3: qux');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arg3', 'huzzah'));
      this.assertText('arg1: qux, arg2: derp, arg3: huzzah');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'arg1', 'foo');
        (0, _object.set)(this.context, 'arg2', 'bar');
        (0, _object.set)(this.context, 'arg3', 'qux');
      });
      this.assertText('arg1: foo, arg2: bar, arg3: qux');
    }
    '@test can be used on the result of `mut`'() {
      this.render("{{this.arg1}}{{stash stashedFn=(fn (mut this.arg1) this.arg2)}}", {
        arg1: 'foo',
        arg2: 'bar'
      });
      this.assertText('foo');
      (0, _internalTestHelpers.runTask)(() => this.stashedFn());
      this.assertText('bar');
    }
    '@test can be used on the result of `mut` with a falsy value'() {
      this.render("{{this.arg1}}{{stash stashedFn=(fn (mut this.arg1) this.arg2)}}", {
        arg1: 'foo',
        arg2: false
      });
      this.assertText('foo');
      (0, _internalTestHelpers.runTask)(() => this.stashedFn());
      this.assertText('false');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/get-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/glimmerish-component"], function (_internalTestHelpers, _object, _helpers, _glimmerishComponent) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{get}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test should be able to get an object value with a static key']() {
      this.render("[{{get this.colors 'apple'}}] [{{if true (get this.colors 'apple')}}]", {
        colors: {
          apple: 'red'
        }
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors.apple', 'green'));
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', {
        apple: 'red'
      }));
      this.assertText('[red] [red]');
    }
    ['@test should be able to get an object value with nested static key']() {
      this.render("[{{get this.colors \"apple.gala\"}}] [{{if true (get this.colors \"apple.gala\")}}]", {
        colors: {
          apple: {
            gala: 'red and yellow'
          }
        }
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors.apple.gala', 'yellow and red striped'));
      this.assertText('[yellow and red striped] [yellow and red striped]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', {
        apple: {
          gala: 'red and yellow'
        }
      }));
      this.assertText('[red and yellow] [red and yellow]');
    }
    ['@test should be able to get an object value with a number']() {
      this.render("[{{get this.items 1}}][{{get this.items 2}}][{{get this.items 3}}]", {
        indexes: [1, 2, 3],
        items: {
          1: 'First',
          2: 'Second',
          3: 'Third'
        }
      });
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items.1', 'Qux'));
      this.assertText('[Qux][Second][Third]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items', {
        1: 'First',
        2: 'Second',
        3: 'Third'
      }));
      this.assertText('[First][Second][Third]');
    }
    ['@test should be able to get an array value with a number']() {
      this.render("[{{get this.numbers 0}}][{{get this.numbers 1}}][{{get this.numbers 2}}]", {
        numbers: [1, 2, 3]
      });
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'numbers', [3, 2, 1]));
      this.assertText('[3][2][1]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'numbers', [1, 2, 3]));
      this.assertText('[1][2][3]');
    }
    ['@test should be able to get an object value with a path evaluating to a number']() {
      this.render("{{#each this.indexes as |index|}}[{{get this.items index}}]{{/each}}", {
        indexes: [1, 2, 3],
        items: {
          1: 'First',
          2: 'Second',
          3: 'Third'
        }
      });
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items.1', 'Qux'));
      this.assertText('[Qux][Second][Third]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items', {
        1: 'First',
        2: 'Second',
        3: 'Third'
      }));
      this.assertText('[First][Second][Third]');
    }
    ['@test should be able to get an array value with a path evaluating to a number']() {
      this.render("{{#each this.numbers as |num index|}}[{{get this.numbers index}}]{{/each}}", {
        numbers: [1, 2, 3]
      });
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'numbers', [3, 2, 1]));
      this.assertText('[3][2][1]');
    }
    ['@test should be able to get an object value with a bound/dynamic key']() {
      this.render("[{{get this.colors this.key}}] [{{if true (get this.colors this.key)}}]", {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: 'apple'
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'banana'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'colors.apple', 'green');
        (0, _object.set)(this.context, 'colors.banana', 'purple');
      });
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'apple'));
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', {
        apple: 'red'
      }));
      this.assertText('[red] [red]');
    }
    ['@test should be able to get an object value with nested dynamic key']() {
      this.render("[{{get this.colors this.key}}] [{{if true (get this.colors this.key)}}]", {
        colors: {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          },
          banana: 'yellow'
        },
        key: 'apple.gala'
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'apple.mcintosh'));
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'banana'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'apple.gala'));
      this.assertText('[red and yellow] [red and yellow]');
    }
    ['@test should be able to get an object value with subexpression returning nested key']() {
      this.render("[{{get this.colors (concat 'apple' '.' 'gala')}}] [{{if true (get this.colors (concat 'apple' '.' 'gala'))}}]", {
        colors: {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          }
        },
        key: 'apple.gala'
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors.apple.gala', 'yellow and red striped'));
      this.assertText('[yellow and red striped] [yellow and red striped]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors.apple.gala', 'yellow-redish'));
      this.assertText('[yellow-redish] [yellow-redish]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', {
        apple: {
          gala: 'red and yellow',
          mcintosh: 'red'
        }
      }));
      this.assertText('[red and yellow] [red and yellow]');
    }
    ['@test should be able to get an object value with a get helper as the key']() {
      this.render("[{{get this.colors (get this.possibleKeys this.key)}}] [{{if true (get this.colors (get this.possibleKeys this.key))}}]", {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: 'key1',
        possibleKeys: {
          key1: 'apple',
          key2: 'banana'
        }
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'key2'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'colors.apple', 'green');
        (0, _object.set)(this.context, 'colors.banana', 'purple');
      });
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'key1'));
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', {
        apple: 'red',
        banana: 'yellow'
      }));
      this.assertText('[red] [red]');
    }
    ['@test should be able to get an object value with a get helper value as a bound/dynamic key']() {
      this.render("[{{get (get this.possibleValues this.objectKey) this.key}}] [{{if true (get (get this.possibleValues this.objectKey) this.key)}}]", {
        possibleValues: {
          colors1: {
            apple: 'red',
            banana: 'yellow'
          },
          colors2: {
            apple: 'green',
            banana: 'purple'
          }
        },
        objectKey: 'colors1',
        key: 'apple'
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors2'));
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors1'));
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'banana'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors2'));
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors1'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'apple'));
    }
    ['@test should be able to get an object value with a get helper as the value and a get helper as the key']() {
      this.render("[{{get (get this.possibleValues this.objectKey) (get this.possibleKeys this.key)}}] [{{if true (get (get this.possibleValues this.objectKey) (get this.possibleKeys this.key))}}]", {
        possibleValues: {
          colors1: {
            apple: 'red',
            banana: 'yellow'
          },
          colors2: {
            apple: 'green',
            banana: 'purple'
          }
        },
        objectKey: 'colors1',
        possibleKeys: {
          key1: 'apple',
          key2: 'banana'
        },
        key: 'key1'
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors2'));
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors1'));
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'key2'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'objectKey', 'colors2'));
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'objectKey', 'colors1');
        (0, _object.set)(this.context, 'key', 'key1');
      });
      this.assertText('[red] [red]');
    }
    ['@test the result of a get helper can be yielded']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
          this.mcintosh = 'red';
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (get this.colors this.mcintosh)}}"
      });
      this.render("{{#foo-bar colors=this.colors as |value|}}{{value}}{{/foo-bar}}", {
        colors: {
          red: 'banana'
        }
      });
      this.assertText('banana');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('banana');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(fooBarInstance, 'mcintosh', 'yellow');
        (0, _object.set)(this.context, 'colors', {
          yellow: 'bus'
        });
      });
      this.assertText('bus');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(fooBarInstance, 'mcintosh', 'red');
        (0, _object.set)(this.context, 'colors', {
          red: 'banana'
        });
      });
      this.assertText('banana');
    }
    ['@test should handle object values as nulls']() {
      this.render("[{{get this.colors 'apple'}}] [{{if true (get this.colors 'apple')}}]", {
        colors: null
      });
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', {
        apple: 'green',
        banana: 'purple'
      }));
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'colors', null));
      this.assertText('[] []');
    }
    ['@test should handle object keys as nulls']() {
      this.render("[{{get this.colors this.key}}] [{{if true (get this.colors this.key)}}]", {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: null
      });
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'banana'));
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', null));
      this.assertText('[] []');
    }
    ['@test should handle object values and keys as nulls']() {
      this.render("[{{get this.colors 'apple'}}] [{{if true (get this.colors this.key)}}]", {
        colors: null,
        key: null
      });
      this.assertText('[] []');
    }
    ['@test get helper value should be updatable using <Input> and (mut) - static key'](assert) {
      this.render("<Input @type='text' @value={{mut (get this.source 'banana')}} id='get-input'/>", {
        source: {
          banana: 'banana'
        }
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'source.banana', 'yellow'));
      assert.strictEqual(this.$('#get-input').val(), 'yellow');
      (0, _internalTestHelpers.runTask)(() => this.$('#get-input').val('some value').trigger('change'));
      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual((0, _object.get)(this.context, 'source.banana'), 'some value');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'source', {
        banana: 'banana'
      }));
      assert.strictEqual(this.$('#get-input').val(), 'banana');
    }
    ['@test get helper value should be updatable using <Input> and (mut) - dynamic key'](assert) {
      this.render("<Input @type='text' @value={{mut (get this.source this.key)}} id='get-input'/>", {
        source: {
          apple: 'apple',
          banana: 'banana'
        },
        key: 'banana'
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'source.banana', 'yellow'));
      assert.strictEqual(this.$('#get-input').val(), 'yellow');
      (0, _internalTestHelpers.runTask)(() => this.$('#get-input').val('some value').trigger('change'));
      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual((0, _object.get)(this.context, 'source.banana'), 'some value');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'apple'));
      assert.strictEqual(this.$('#get-input').val(), 'apple');
      (0, _internalTestHelpers.runTask)(() => this.$('#get-input').val('some other value').trigger('change'));
      assert.strictEqual(this.$('#get-input').val(), 'some other value');
      assert.strictEqual((0, _object.get)(this.context, 'source.apple'), 'some other value');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'key', 'banana');
        (0, _object.set)(this.context, 'source', {
          banana: 'banana'
        });
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
    }
    ['@test get helper value should be updatable using <Input> and (mut) - dynamic nested key'](assert) {
      this.render("<Input @type='text' @value={{mut (get this.source this.key)}} id='get-input'/>", {
        source: {
          apple: {
            gala: 'gala',
            mcintosh: 'mcintosh'
          },
          banana: 'banana'
        },
        key: 'apple.mcintosh'
      });
      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'source.apple.mcintosh', 'red'));
      assert.strictEqual(this.$('#get-input').val(), 'red');
      (0, _internalTestHelpers.runTask)(() => this.$('#get-input').val('some value').trigger('change'));
      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual((0, _object.get)(this.context, 'source.apple.mcintosh'), 'some value');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'apple.gala'));
      assert.strictEqual(this.$('#get-input').val(), 'gala');
      (0, _internalTestHelpers.runTask)(() => this.$('#get-input').val('some other value').trigger('change'));
      assert.strictEqual(this.$('#get-input').val(), 'some other value');
      assert.strictEqual((0, _object.get)(this.context, 'source.apple.gala'), 'some other value');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'key', 'banana'));
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(() => this.$('#get-input').val('yet another value').trigger('change'));
      assert.strictEqual(this.$('#get-input').val(), 'yet another value');
      assert.strictEqual((0, _object.get)(this.context, 'source.banana'), 'yet another value');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'key', 'apple.mcintosh');
        (0, _object.set)(this.context, 'source', {
          apple: {
            gala: 'gala',
            mcintosh: 'mcintosh'
          },
          banana: 'banana'
        });
      });
      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
    }
    '@test should be able to get an object value with a path from this.args in a glimmer component'() {
      class PersonComponent extends _glimmerishComponent.default {
        constructor() {
          super(...arguments);
          this.options = ['first', 'last', 'age'];
        }
      }
      this.registerComponent('person-wrapper', {
        ComponentClass: PersonComponent,
        template: '{{#each this.options as |option|}}{{get this.args option}}{{/each}}'
      });
      this.render('<PersonWrapper @first={{this.first}} @last={{this.last}} @age={{this.age}}/>', {
        first: 'miguel',
        last: 'andrade'
      });
      this.assertText('miguelandrade');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('miguelandrade');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'age', 30));
      this.assertText('miguelandrade30');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/hash-test", ["internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/object"], function (_internalTestHelpers, _helpers, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{hash}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test returns a hash with the right key-value']() {
      this.render("{{#let (hash name=\"Sergio\") as |person|}}{{person.name}}{{/let}}");
      this.assertText('Sergio');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Sergio');
    }
    ['@test can have more than one key-value']() {
      this.render("{{#let (hash name=\"Sergio\" lastName=\"Arbeo\") as |person|}}{{person.name}} {{person.lastName}}{{/let}}");
      this.assertText('Sergio Arbeo');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Sergio Arbeo');
    }
    ['@test binds values when variables are used']() {
      this.render("{{#let (hash name=this.model.firstName lastName=\"Arbeo\") as |person|}}{{person.name}} {{person.lastName}}{{/let}}", {
        model: {
          firstName: 'Marisa'
        }
      });
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.firstName', 'Sergio'));
      this.assertText('Sergio Arbeo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        firstName: 'Marisa'
      }));
      this.assertText('Marisa Arbeo');
    }
    ['@test binds multiple values when variables are used']() {
      this.render("{{#let (hash name=this.model.firstName lastName=this.model.lastName) as |person|}}{{person.name}} {{person.lastName}}{{/let}}", {
        model: {
          firstName: 'Marisa',
          lastName: 'Arbeo'
        }
      });
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.firstName', 'Sergio'));
      this.assertText('Sergio Arbeo');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.lastName', 'Smith'));
      this.assertText('Sergio Smith');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        firstName: 'Marisa',
        lastName: 'Arbeo'
      }));
      this.assertText('Marisa Arbeo');
    }
    ['@test hash helpers can be nested']() {
      this.render("{{#let (hash person=(hash name=this.model.firstName)) as |ctx|}}{{ctx.person.name}}{{/let}}", {
        model: {
          firstName: 'Balint'
        }
      });
      this.assertText('Balint');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Balint');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.firstName', 'Chad'));
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        firstName: 'Balint'
      }));
      this.assertText('Balint');
    }
    ['@test should yield hash of internal properties']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
          this.model = {
            firstName: 'Chad'
          };
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash firstName=this.model.firstName)}}"
      });
      this.render("{{#foo-bar as |values|}}{{values.firstName}}{{/foo-bar}}");
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model.firstName', 'Godfrey'));
      this.assertText('Godfrey');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model', {
        firstName: 'Chad'
      }));
      this.assertText('Chad');
    }
    ['@test should yield hash of internal and external properties']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
          this.model = {
            firstName: 'Chad'
          };
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash firstName=this.model.firstName lastName=this.lastName)}}"
      });
      this.render("{{#foo-bar lastName=this.model.lastName as |values|}}{{values.firstName}} {{values.lastName}}{{/foo-bar}}", {
        model: {
          lastName: 'Hietala'
        }
      });
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(fooBarInstance, 'model.firstName', 'Godfrey');
        (0, _object.set)(this.context, 'model.lastName', 'Chan');
      });
      this.assertText('Godfrey Chan');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(fooBarInstance, 'model', {
          firstName: 'Chad'
        });
        (0, _object.set)(this.context, 'model', {
          lastName: 'Hietala'
        });
      });
      this.assertText('Chad Hietala');
    }
    ['@test works with computeds']() {
      let FooBarComponent = _helpers.Component.extend({
        fullName: (0, _object.computed)('hash.firstName', 'hash.lastName', function () {
          return this.hash.firstName + " " + this.hash.lastName;
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{this.fullName}}"
      });
      this.render("{{foo-bar hash=(hash firstName=this.firstName lastName=this.lastName)}}", {
        firstName: 'Chad',
        lastName: 'Hietala'
      });
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'firstName', 'Godfrey');
        (0, _object.set)(this.context, 'lastName', 'Chan');
      });
      this.assertText('Godfrey Chan');
    }
    ['@test works with computeds on non-defined properties']() {
      let instance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          expectDeprecation(() => {
            (0, _object.set)(this.hash, 'lastName', 'Hietala');
          }, /You set the '.*' property on a {{hash}} object/);
          instance = this;
        },
        fullName: (0, _object.computed)('hash.firstName', 'hash.lastName', function () {
          return this.hash.firstName + " " + this.hash.lastName;
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{this.fullName}}"
      });
      this.render("{{foo-bar hash=(hash firstName=this.firstName)}}", {
        firstName: 'Chad',
        lastName: 'Hietala'
      });
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'firstName', 'Godfrey');
      });

      // needs to be separate task because of the way classic components update args
      (0, _internalTestHelpers.runTask)(() => {
        expectDeprecation(() => {
          (0, _object.set)(instance.hash, 'lastName', 'Chan');
        }, /You set the '.*' property on a {{hash}} object/);
      });
      this.assertText('Godfrey Chan');
    }
    ['@test works when properties are set dynamically']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super();
          fooBarInstance = this;
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{this.hash.firstName}} {{this.hash.lastName}}"
      });
      this.render("{{foo-bar hash=(hash firstName=this.firstName)}}", {
        firstName: 'Chad'
      });
      this.assertText('Chad ');
      (0, _internalTestHelpers.runTask)(() => {
        expectDeprecation(() => {
          (0, _object.set)(fooBarInstance.hash, 'lastName', 'Hietala');
        }, /You set the '.*' property on a {{hash}} object/);
      });
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(() => {
        expectDeprecation(() => {
          (0, _object.set)(fooBarInstance.hash, 'firstName', 'Godfrey');
          (0, _object.set)(fooBarInstance.hash, 'lastName', 'Chan');
        }, /You set the '.*' property on a {{hash}} object/);
      });
      this.assertText('Godfrey Chan');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/helper-manager-test", ["@glimmer/manager", "internal-test-helpers", "@ember/-internals/metal", "@ember/object", "@ember/-internals/owner", "@ember/service", "@glimmer/destroyable", "@ember/-internals/glimmer/tests/utils/debug-stack"], function (_manager, _internalTestHelpers, _metal, _object, _owner, _service, _destroyable, _debugStack) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  class TestHelperManager {
    constructor(owner) {
      this.capabilities = (0, _manager.helperCapabilities)('3.23', {
        hasValue: true,
        hasDestroyable: true
      });
      this.owner = owner;
    }
    createHelper(Helper, args) {
      return new Helper(this.owner, args);
    }
    getValue(instance) {
      return instance.value();
    }
    getDestroyable(instance) {
      return instance;
    }
    getDebugName() {
      return 'TEST_HELPER';
    }
  }
  class TestHelper {
    constructor(owner, args) {
      (0, _owner.setOwner)(this, owner);
      this.args = args;
      (0, _destroyable.registerDestructor)(this, () => this.willDestroy());
    }
    willDestroy() {}

    // HelperInstance
    compute() {}
    destroy() {}
  }
  (0, _manager.setHelperManager)(owner => new TestHelperManager(owner), TestHelper);
  (0, _internalTestHelpers.moduleFor)('Helpers test: helper managers', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it works']() {
      this.registerCustomHelper('hello', class extends TestHelper {
        value() {
          return 'hello';
        }
      });
      this.render('{{hello}}');
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello');
    }
    ['@test tracks changes to named arguments'](assert) {
      let count = 0;
      this.registerCustomHelper('hello', class extends TestHelper {
        value() {
          count++;
          return this.args.named.foo;
        }
      });
      this.render('{{hello foo=this.foo}}', {
        foo: 123
      });
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 456));
      assert.equal(count, 2, 'rendered twice');
      this.assertText('456');
    }
    ['@test tracks changes to positional arguments'](assert) {
      let count = 0;
      this.registerCustomHelper('hello', class extends TestHelper {
        value() {
          count++;
          return this.args.positional[0];
        }
      });
      this.render('{{hello this.foo}}', {
        foo: 123
      });
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 456));
      assert.equal(count, 2, 'rendered twice');
      this.assertText('456');
    }
    ['@test tracks changes to tracked properties'](assert) {
      var _class2, _descriptor;
      let count = 0;
      let instance;
      this.registerCustomHelper('hello', (_class2 = class _class2 extends TestHelper {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "foo", _descriptor, this);
          instance = this;
        }
        value() {
          count++;
          return this.foo;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "foo", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 123;
        }
      }), _class2));
      this.render('{{hello}}');
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.equal(count, 1, 'rendered once');
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => instance.foo = 456);
      assert.equal(count, 2, 'rendered twice');
      this.assertText('456');
    }
    ['@test services can be injected']() {
      var _class4, _descriptor2;
      this.registerService('hello', _service.default.extend({
        value: 'hello'
      }));
      this.registerCustomHelper('hello', (_class4 = class _class4 extends TestHelper {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "hello", _descriptor2, this);
        }
        value() {
          return this.hello.value;
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class4.prototype, "hello", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class4));
      this.render('{{hello}}');
      this.assertText('hello');
    }
    ['@test destroyable is associated correctly'](assert) {
      this.registerCustomHelper('hello', class extends TestHelper {
        value() {
          return 'hello';
        }
        willDestroy() {
          assert.ok(true, 'destructor called');
        }
      });
      this.render('{{hello}}');
      this.assertText('hello');
    }
    ['@test debug name is used for backtracking message']() {
      var _class6, _descriptor3;
      this.registerCustomHelper('hello', (_class6 = class _class6 extends TestHelper {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "foo", _descriptor3, this);
        }
        value() {
          this.foo;
          this.foo = 456;
        }
      }, _descriptor3 = _applyDecoratedDescriptor(_class6.prototype, "foo", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 123;
        }
      }), _class6));
      let expectedMessage = (0, _debugStack.backtrackingMessageFor)('foo', '.*', {
        renderTree: ['\\(result of a `TEST_HELPER` helper\\)']
      });
      expectAssertion(() => {
        this.render('{{hello}}');
      }, expectedMessage);
    }
    ['@test asserts against using both `hasValue` and `hasScheduledEffect`'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        (0, _manager.helperCapabilities)('3.23', {
          hasValue: true,
          hasScheduledEffect: true
        });
      }, /You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted./);
    }
    ['@test asserts requiring either `hasValue` or `hasScheduledEffect`'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        (0, _manager.helperCapabilities)('3.23', {});
      }, /You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted./);
    }
    ['@test asserts against using `hasScheduledEffect`'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        (0, _manager.helperCapabilities)('3.23', {
          hasScheduledEffect: true
        });
      }, /The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead/);
    }
    ['@test asserts against using incorrect version for capabilities'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        (0, _manager.helperCapabilities)('aoeu', {
          hasScheduledEffect: true
        });
      }, /Invalid helper manager compatibility specified/);
    }
    ['@test helper manager and modifier manager can be associated with the same value']() {
      (0, _manager.setModifierManager)(() => ({}), TestHelper);
      this.registerCustomHelper('hello', class extends TestHelper {
        value() {
          return 'hello';
        }
      });
      this.render('{{hello}}');
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello');
    }
    '@test capabilities helper function must be used to generate capabilities'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      class OverrideTestHelperManager extends TestHelperManager {
        constructor() {
          super(...arguments);
          this.capabilities = {
            hasValue: true,
            hasDestroyable: true,
            hasScheduledEffect: false
          };
        }
      }
      class TestHelper {
        // HelperInstance
        compute() {}
        destroy() {}
      }
      (0, _manager.setHelperManager)(owner => new OverrideTestHelperManager(owner), TestHelper);
      this.registerCustomHelper('hello', class extends TestHelper {
        value() {
          return 'hello';
        }
      });
      assert.throws(() => {
        this.render('{{hello}}');
      }, /Custom helper managers must have a `capabilities` property that is the result of calling the `capabilities\('3.23'\)` \(imported via `import \{ capabilities \} from '@ember\/helper';`\). /);
      assert.verifySteps([]);
    }
    '@test custom helpers gives helpful assertion when reading then mutating a tracked value within constructor'() {
      var _class9, _descriptor4;
      this.registerCustomHelper('hello', (_class9 = class _class9 extends TestHelper {
        constructor() {
          super(...arguments);

          // first read the tracked property
          _initializerDefineProperty(this, "foo", _descriptor4, this);
          this.foo;

          // then attempt to update the tracked property
          this.foo = 456;
        }
        value() {
          return this.foo;
        }
      }, _descriptor4 = _applyDecoratedDescriptor(_class9.prototype, "foo", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 123;
        }
      }), _class9));
      let expectedMessage = (0, _debugStack.backtrackingMessageFor)('foo');
      expectAssertion(() => {
        this.render('{{hello}}');
      }, expectedMessage);
    }
    '@test custom helpers gives helpful assertion when reading then mutating a tracked value within value'() {
      var _class11, _descriptor5;
      this.registerCustomHelper('hello', (_class11 = class _class11 extends TestHelper {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "foo", _descriptor5, this);
        }
        value() {
          // first read the tracked property
          this.foo;

          // then attempt to update the tracked property
          this.foo = 456;
        }
      }, _descriptor5 = _applyDecoratedDescriptor(_class11.prototype, "foo", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 123;
        }
      }), _class11));
      let expectedMessage = (0, _debugStack.backtrackingMessageFor)('foo', '.*', {
        renderTree: ['\\(result of a `TEST_HELPER` helper\\)']
      });
      expectAssertion(() => {
        this.render('{{hello}}');
      }, expectedMessage);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/if-unless-test", ["internal-test-helpers", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_internalTestHelpers, _sharedConditionalTests) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{if}} helpers (returning truthy values)', class extends _sharedConditionalTests.IfUnlessHelperTest {
    templateFor(_ref) {
      let {
        cond,
        truthy,
        falsy
      } = _ref;
      return "{{if (if " + cond + " " + cond + " false) " + truthy + " " + falsy + "}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{if}} helpers (returning falsy values)', class extends _sharedConditionalTests.IfUnlessHelperTest {
    templateFor(_ref2) {
      let {
        cond,
        truthy,
        falsy
      } = _ref2;
      return "{{if (if " + cond + " true " + cond + ") " + truthy + " " + falsy + "}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{if}} used with another helper', class extends _sharedConditionalTests.IfUnlessHelperTest {
    wrapperFor(templates) {
      return "{{concat " + templates.join(' ') + "}}";
    }
    templateFor(_ref3) {
      let {
        cond,
        truthy,
        falsy
      } = _ref3;
      return "(if " + cond + " " + truthy + " " + falsy + ")";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{if}} used in attribute position', class extends _sharedConditionalTests.IfUnlessHelperTest {
    wrapperFor(templates) {
      return "<div data-foo=\"" + templates.join('') + "\" />";
    }
    templateFor(_ref4) {
      let {
        cond,
        truthy,
        falsy
      } = _ref4;
      return "{{if " + cond + " " + truthy + " " + falsy + "}}";
    }
    textValue() {
      return this.$('div').attr('data-foo');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: inline {{if}} and {{unless}} without the inverse argument', class extends _sharedConditionalTests.IfUnlessHelperTest {
    templateFor(_ref5) {
      let {
        cond,
        truthy,
        falsy
      } = _ref5;
      return "{{if " + cond + " " + truthy + "}}{{unless " + cond + " " + falsy + "}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{unless}} helpers (returning truthy values)', class extends _sharedConditionalTests.IfUnlessHelperTest {
    templateFor(_ref6) {
      let {
        cond,
        truthy,
        falsy
      } = _ref6;
      return "{{unless (unless " + cond + " false " + cond + ") " + falsy + " " + truthy + "}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{unless}} helpers (returning falsy values)', class extends _sharedConditionalTests.IfUnlessHelperTest {
    templateFor(_ref7) {
      let {
        cond,
        truthy,
        falsy
      } = _ref7;
      return "{{unless (unless " + cond + " " + cond + " true) " + falsy + " " + truthy + "}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unless}} used with another helper', class extends _sharedConditionalTests.IfUnlessHelperTest {
    wrapperFor(templates) {
      return "{{concat " + templates.join(' ') + "}}";
    }
    templateFor(_ref8) {
      let {
        cond,
        truthy,
        falsy
      } = _ref8;
      return "(unless " + cond + " " + falsy + " " + truthy + ")";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unless}} used in attribute position', class extends _sharedConditionalTests.IfUnlessHelperTest {
    wrapperFor(templates) {
      return "<div data-foo=\"" + templates.join('') + "\" />";
    }
    templateFor(_ref9) {
      let {
        cond,
        truthy,
        falsy
      } = _ref9;
      return "{{unless " + cond + " " + falsy + " " + truthy + "}}";
    }
    textValue() {
      return this.$('div').attr('data-foo');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/invoke-helper-test", ["internal-test-helpers", "@glimmer/manager", "@ember/-internals/glimmer", "@ember/-internals/metal", "@ember/object", "@ember/-internals/owner", "@ember/service", "@glimmer/validator", "@glimmer/destroyable", "@glimmer/runtime"], function (_internalTestHelpers, _manager, _glimmer, _metal, _object, _owner, _service, _validator, _destroyable, _runtime) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('Helpers test: invokeHelper', class extends _internalTestHelpers.RenderingTestCase {
    '@test it works with a component'() {
      var _class, _descriptor;
      class PlusOneHelper extends _glimmer.Helper {
        compute(_ref) {
          let [num] = _ref;
          return num + 1;
        }
      }
      let PlusOne = (_class = class PlusOne extends _glimmer.Component {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "number", _descriptor, this);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class);
      this.registerComponent('plus-one', {
        template: "{{this.value}}",
        ComponentClass: PlusOne
      });
      this.render("<PlusOne @number={{this.value}} />", {
        value: 4
      });
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 5));
      this.assertText('6');
    }
    '@test it works with simple helpers'() {
      var _class3, _descriptor2;
      let PlusOneHelper = (0, _glimmer.helper)(_ref2 => {
        let [num] = _ref2;
        return num + 1;
      });
      let PlusOne = (_class3 = class PlusOne extends _glimmer.Component {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "number", _descriptor2, this);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class3);
      this.registerComponent('plus-one', {
        template: "{{this.value}}",
        ComponentClass: PlusOne
      });
      this.render("<PlusOne @number={{this.value}} />", {
        value: 4
      });
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 5));
      this.assertText('6');
    }
    '@test services can be injected if there is an owner'() {
      var _class5, _descriptor3, _class7, _descriptor4;
      let numberService;
      this.registerService('number', (_class5 = class _class5 extends _service.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "value", _descriptor3, this);
          numberService = this;
        }
      }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "value", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 4;
        }
      }), _class5));
      let PlusOneHelper = (_class7 = class PlusOneHelper extends _glimmer.Helper {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "number", _descriptor4, this);
        }
        compute() {
          return this.number.value + 1;
        }
      }, _descriptor4 = _applyDecoratedDescriptor(_class7.prototype, "number", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class7);
      class PlusOne extends _glimmer.Component {
        constructor() {
          super(...arguments);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }
      this.registerComponent('plus-one', {
        template: "{{this.value}}",
        ComponentClass: PlusOne
      });
      this.render("<PlusOne />");
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => numberService.value = 5);
      this.assertText('6');
    }
    '@test works if there is no owner'(assert) {
      class PlusOneHelper extends _glimmer.Helper {
        compute(_ref3) {
          let [num] = _ref3;
          return num + 1;
        }
      }
      class PlusOne {
        constructor(number) {
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
          this.number = number;
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }
      let instance = new PlusOne(4);
      assert.notOk((0, _owner.getOwner)(instance), 'no owner exists on the wrapper');
      assert.equal(instance.value, 5, 'helper works without an owner');
    }
    '@test tracking for arguments works for tracked properties'(assert) {
      var _class11, _descriptor5;
      let count = 0;
      class PlusOneHelper extends _glimmer.Helper {
        compute(_ref4) {
          let [num] = _ref4;
          count++;
          return num + 1;
        }
      }
      let PlusOne = (_class11 = class PlusOne {
        constructor(number) {
          _initializerDefineProperty(this, "number", _descriptor5, this);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
          this.number = number;
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }, _descriptor5 = _applyDecoratedDescriptor(_class11.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class11);
      let instance = new PlusOne(4);
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(count, 1, 'helper only called once');
      instance.number = 5;
      assert.equal(instance.value, 6, 'helper works');
      assert.equal(count, 2, 'helper called a second time');
    }
    '@test computeArgs only called when consumed values change'(assert) {
      var _class13, _descriptor6, _descriptor7;
      let count = 0;
      class PlusNHelper extends _glimmer.Helper {
        compute(_ref5, _ref6) {
          let [num] = _ref5;
          let {
            n
          } = _ref6;
          return num + n;
        }
      }
      let PlusN = (_class13 = class PlusN {
        constructor(number, n) {
          _initializerDefineProperty(this, "number", _descriptor6, this);
          _initializerDefineProperty(this, "n", _descriptor7, this);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusNHelper, () => {
            count++;
            return {
              positional: [this.number],
              named: {
                n: this.n
              }
            };
          });
          this.number = number;
          this.n = n;
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }, (_descriptor6 = _applyDecoratedDescriptor(_class13.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor7 = _applyDecoratedDescriptor(_class13.prototype, "n", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class13);
      let instance = new PlusN(4, 1);
      assert.equal(count, 0, 'computeArgs not called yet');
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(count, 1, 'computeArgs only called once');
      instance.number = 5;
      assert.equal(instance.value, 6, 'helper works');
      assert.equal(instance.value, 6, 'helper works');
      assert.equal(count, 2, 'computeArgs called a second time');
      instance.n = 5;
      assert.equal(instance.value, 10, 'helper works');
      assert.equal(instance.value, 10, 'helper works');
      assert.equal(count, 3, 'computeArgs called a third time');
    }
    '@test helper updates based on internal state changes'(assert) {
      var _class15, _descriptor8;
      let count = 0;
      let helper;
      let PlusOneHelper = (_class15 = class PlusOneHelper extends _glimmer.Helper {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "number", _descriptor8, this);
          helper = this;
        }
        compute() {
          count++;
          return this.number + 1;
        }
      }, _descriptor8 = _applyDecoratedDescriptor(_class15.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 4;
        }
      }), _class15);
      class PlusOne {
        constructor() {
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper);
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }
      let instance = new PlusOne();
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(count, 1, 'helper only called once');
      helper.number = 5;
      assert.equal(instance.value, 6, 'helper works');
      assert.equal(count, 2, 'helper called a second time');
    }
    '@test helper that with constant args is constant'(assert) {
      let count = 0;
      class PlusOneHelper extends _glimmer.Helper {
        compute(_ref7) {
          let [num] = _ref7;
          count++;
          return num + 1;
        }
      }
      class PlusOne {
        constructor(number) {
          this.number = void 0;
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
          this.number = number;
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }
      let instance = new PlusOne(4);
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(count, 1, 'helper only called once');
      instance.number = 5;
      assert.equal(instance.value, 5, 'helper works');
      assert.equal(count, 1, 'helper not called a second time');
    }
    '@test helper destroys correctly when context object is destroyed'(assert) {
      let context = {};
      let instance;
      class TestHelper extends _glimmer.Helper {
        constructor() {
          super(...arguments);
          instance = this;
        }

        // HelperInstance
        compute() {}
      }
      let cache = (0, _runtime.invokeHelper)(context, TestHelper);
      (0, _destroyable.registerDestructor)(context, () => assert.step('context'));
      (0, _destroyable.registerDestructor)(cache, () => assert.step('cache'));
      (0, _destroyable.registerDestructor)(instance, () => assert.step('instance'));
      (0, _internalTestHelpers.runTask)(() => (0, _destroyable.destroy)(context));
      assert.ok((0, _destroyable.isDestroyed)(context), 'context destroyed');
      assert.ok((0, _destroyable.isDestroyed)(cache), 'cache destroyed');
      assert.ok((0, _destroyable.isDestroyed)(instance), 'instance destroyed');
      assert.verifySteps(['instance', 'cache', 'context'], 'destructors ran in correct order');
    }
    '@test helper destroys correctly when helper cache is destroyed'(assert) {
      let context = {};
      let instance;
      class TestHelper extends _glimmer.Helper {
        constructor() {
          super(...arguments);
          instance = this;
        }
        compute() {}
      }
      let cache = (0, _runtime.invokeHelper)(context, TestHelper);
      (0, _destroyable.registerDestructor)(context, () => assert.step('context'));
      (0, _destroyable.registerDestructor)(cache, () => assert.step('cache'));
      (0, _destroyable.registerDestructor)(instance, () => assert.step('instance'));
      (0, _internalTestHelpers.runTask)(() => (0, _destroyable.destroy)(cache));
      assert.notOk((0, _destroyable.isDestroyed)(context), 'context NOT destroyed');
      assert.ok((0, _destroyable.isDestroyed)(cache), 'cache destroyed');
      assert.ok((0, _destroyable.isDestroyed)(instance), 'instance destroyed');
      assert.verifySteps(['instance', 'cache'], 'destructors ran in correct order');
    }
    '@test simple helper destroys correctly when context object is destroyed'(assert) {
      let context = {};
      let TestHelper = (0, _glimmer.helper)(() => {});
      let cache = (0, _runtime.invokeHelper)(context, TestHelper);
      (0, _destroyable.registerDestructor)(context, () => assert.step('context'));
      (0, _destroyable.registerDestructor)(cache, () => assert.step('cache'));
      (0, _internalTestHelpers.runTask)(() => (0, _destroyable.destroy)(context));
      assert.ok((0, _destroyable.isDestroyed)(context), 'context destroyed');
      assert.ok((0, _destroyable.isDestroyed)(cache), 'cache destroyed');
      assert.verifySteps(['cache', 'context'], 'destructors ran in correct order');
    }
    '@test throws an error if value is accessed after it is destroyed'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        let helper = (0, _runtime.invokeHelper)({}, class extends _glimmer.Helper {
          compute() {}
        });
        (0, _internalTestHelpers.runTask)(() => (0, _destroyable.destroy)(helper));
        (0, _validator.getValue)(helper);
      }, /You attempted to get the value of a helper after the helper was destroyed, which is not allowed/);
    }
    '@test asserts if no context object is passed'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }
      assert.throws(() => {
        (0, _runtime.invokeHelper)(undefined, class extends _glimmer.Helper {});
      }, /Expected a context object to be passed as the first parameter to invokeHelper, got undefined/);
    }
  });
  class TestHelperManager {
    constructor() {
      this.capabilities = (0, _manager.helperCapabilities)('3.23', {
        hasValue: true,
        hasDestroyable: true
      });
    }
    createHelper(Helper, args) {
      return new Helper(args);
    }
    getValue(instance) {
      return instance.value();
    }
    getDestroyable(instance) {
      return instance;
    }
  }
  class TestHelper {
    constructor(args) {
      this.args = args;
      (0, _destroyable.registerDestructor)(this, () => this.willDestroy());
    }
    willDestroy() {}

    // HelperInstance
    compute() {}
    destroy() {}
  }
  (0, _manager.setHelperManager)(owner => new TestHelperManager(owner), TestHelper);
  (0, _internalTestHelpers.moduleFor)('Helpers test: invokeHelper with custom helper managers', class extends _internalTestHelpers.RenderingTestCase {
    '@test it works with custom helper managers'() {
      var _class20, _descriptor9;
      class PlusOneHelper extends TestHelper {
        value() {
          return this.args.positional[0] + 1;
        }
      }
      let PlusOne = (_class20 = class PlusOne extends _glimmer.Component {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "number", _descriptor9, this);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }, _descriptor9 = _applyDecoratedDescriptor(_class20.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class20);
      this.registerComponent('plus-one', {
        template: "{{this.value}}",
        ComponentClass: PlusOne
      });
      this.render("<PlusOne @number={{this.value}} />", {
        value: 4
      });
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('5');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', 5));
      this.assertText('6');
    }
    '@test helper that accesses no args is constant'(assert) {
      var _class22, _descriptor10;
      let count = 0;
      class PlusOneHelper extends TestHelper {
        value() {
          count++;
          return 123;
        }
      }
      let PlusOne = (_class22 = class PlusOne {
        constructor(number) {
          _initializerDefineProperty(this, "number", _descriptor10, this);
          this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
            return {
              positional: [this.number]
            };
          });
          this.number = number;
        }
        get value() {
          return (0, _validator.getValue)(this.plusOne);
        }
      }, _descriptor10 = _applyDecoratedDescriptor(_class22.prototype, "number", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class22);
      let instance = new PlusOne(4);
      assert.equal(instance.value, 123, 'helper works');
      assert.equal(instance.value, 123, 'helper works');
      assert.equal(count, 1, 'helper only called once');
      instance.number = 5;
      assert.equal(instance.value, 123, 'helper works');
      assert.equal(count, 1, 'helper not called a second time');
    }
    '@test helper destroys correctly when context object is destroyed'(assert) {
      let context = {};
      let instance;
      class MyTestHelper extends TestHelper {
        constructor() {
          super(...arguments);
          instance = this;
        }
      }
      let cache = (0, _runtime.invokeHelper)(context, MyTestHelper);
      (0, _destroyable.registerDestructor)(context, () => assert.step('context'));
      (0, _destroyable.registerDestructor)(cache, () => assert.step('cache'));
      (0, _destroyable.registerDestructor)(instance, () => assert.step('instance'));
      (0, _internalTestHelpers.runTask)(() => (0, _destroyable.destroy)(context));
      assert.ok((0, _destroyable.isDestroyed)(context), 'context destroyed');
      assert.ok((0, _destroyable.isDestroyed)(cache), 'cache destroyed');
      assert.ok((0, _destroyable.isDestroyed)(instance), 'instance destroyed');
      assert.verifySteps(['instance', 'cache', 'context'], 'destructors ran in correct order');
    }
    '@test args are frozen in debug builds'(assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
      } else {
        assert.expect(1);
        class PlusOneHelper extends TestHelper {
          value() {
            assert.ok(Object.isFrozen(this.args), 'args are frozen');
            return 123;
          }
        }
        class PlusOne {
          constructor(number) {
            this.number = void 0;
            this.plusOne = (0, _runtime.invokeHelper)(this, PlusOneHelper, () => {
              return {
                positional: [this.number]
              };
            });
            this.number = number;
          }
          get value() {
            return (0, _validator.getValue)(this.plusOne);
          }
        }

        // get the value to trigger the assertion
        new PlusOne(4).value;
      }
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/log-test", ["internal-test-helpers"], function (_internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{log}}', class extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      var _this;
      /* eslint-disable no-console */
      super(...arguments);
      _this = this;
      this.originalLog = console.log;
      this.logCalls = [];
      console.log = function () {
        _this.logCalls.push(...arguments);
        /* eslint-enable no-console */
      };
    }

    teardown() {
      super.teardown();
      /* eslint-disable no-console */
      console.log = this.originalLog;
      /* eslint-enable no-console */
    }

    assertLog(values) {
      this.assertText('');
      this.assert.strictEqual(this.logCalls.length, values.length);
      for (let i = 0, len = values.length; i < len; i++) {
        this.assert.strictEqual(this.logCalls[i], values[i]);
      }
    }
    ['@test correctly logs primitives']() {
      this.render("{{log \"one\" 1 true}}");
      this.assertLog(['one', 1, true]);
    }
    ['@test correctly logs a property']() {
      this.render("{{log this.value}}", {
        value: 'one'
      });
      this.assertLog(['one']);
    }
    ['@test correctly logs multiple arguments']() {
      this.render("{{log \"my variable:\" this.value}}", {
        value: 'one'
      });
      this.assertLog(['my variable:', 'one']);
    }
    ['@test correctly logs `this`']() {
      this.render("{{log this}}");
      this.assertLog([this.context]);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/mut-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{mut}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test a simple mutable binding using `mut` propagates properly']() {
      let bottom;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            bottom = this;
          }
        }),
        template: '{{this.setMe}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{bottom-mut setMe=this.value}}'
      });
      this.render('{{middle-mut value=(mut this.val)}}', {
        val: 12
      });
      this.assertText('12', 'the data propagated downwards');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => bottom.attrs.setMe.update(13));
      this.assertText('13', 'the set took effect');
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 13, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 13, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(bottom, 'setMe', 14));
      this.assertText('14', 'the set took effect');
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 14, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'val', 12));
      this.assertText('12');
    }
    ['@test a simple mutable binding using `mut` inserts into the DOM']() {
      let bottom, middle;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            bottom = this;
          }
        }),
        template: '{{this.setMe}}'
      });
      this.registerComponent('middle-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            middle = this;
          }
        }),
        template: '{{bottom-mut setMe=(mut this.value)}}'
      });
      this.render('{{middle-mut value=(mut this.val)}}', {
        val: 12
      });
      this.assertText('12', 'the data propagated downwards');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => bottom.attrs.setMe.update(13));
      this.assertText('13', 'the set took effect');
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 13, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _object.get)(middle, 'value'), 13, "the set propagated to middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 13, "the set propagated to middle's attr");
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 13, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(bottom, 'setMe', 14));
      this.assertText('14', 'the set took effect');
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 14, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _object.get)(middle, 'value'), 14, "the set propagated to middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 14, "the set propagated to middle's attr");
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'val', 12));
      this.assertText('12');
    }
    ['@test passing a literal results in a assertion']() {
      this.registerComponent('bottom-mut', {
        template: '{{this.setMe}}'
      });
      expectAssertion(() => {
        this.render('{{bottom-mut setMe=(mut "foo bar")}}');
      }, 'You can only pass a path to mut');
    }
    ['@test passing the result of a helper invocation results in an assertion']() {
      this.registerComponent('bottom-mut', {
        template: '{{this.setMe}}'
      });
      expectAssertion(() => {
        this.render('{{bottom-mut setMe=(mut (concat "foo" " " "bar"))}}');
      }, 'You can only pass a path to mut');
    }

    // See https://github.com/emberjs/ember.js/commit/807a0cd for an explanation of this test
    ['@test using a string value through middle tier does not trigger assertion (due to the auto-mut transform)']() {
      let bottom;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            bottom = this;
          }
        }),
        template: '{{this.stuff}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{bottom-mut stuff=this.value}}'
      });
      this.render('{{middle-mut value="foo"}}');
      this.assert.equal((0, _object.get)(bottom, 'stuff'), 'foo', 'the data propagated');
      this.assertText('foo');
      this.assertStableRerender();

      // No U-R for this test
    }

    ['@test {{readonly}} of a {{mut}} is converted into an immutable binding']() {
      let middle, bottom;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            bottom = this;
          }
        }),
        template: '{{this.setMe}}'
      });
      this.registerComponent('middle-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            middle = this;
          }
        }),
        template: '{{bottom-mut setMe=(readonly this.value)}}'
      });
      this.render('{{middle-mut value=(mut this.val)}}', {
        val: 12
      });
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => middle.attrs.value.update(13));
      this.assert.strictEqual((0, _object.get)(middle, 'value'), 13, "the set took effect on middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 13, "the set took effect on middle's attr");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(middle, 'value', 14));
      this.assert.strictEqual((0, _object.get)(middle, 'value'), 14, "the set took effect on middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 14, "the set took effect on middle's attr");
      this.assert.strictEqual(bottom.attrs.setMe, 14, 'the mutable binding has been converted to an immutable cell');
      this.assertText('14');
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'val', 12));
      this.assertText('12');
    }
    ['@test mutable bindings work inside of yielded content']() {
      this.registerComponent('bottom-mut', {
        template: '{{yield}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{#bottom-mut}}{{@model.name}}{{/bottom-mut}}'
      });
      this.render('{{middle-mut model=(mut this.model)}}', {
        model: {
          name: 'Matthew Beale'
        }
      });
      this.assertText('Matthew Beale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.name', 'Joel Kang'));
      this.assertText('Joel Kang');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        name: 'Matthew Beale'
      }));
      this.assertText('Matthew Beale');
    }
    ['@test a simple mutable binding using {{mut}} is available in hooks']() {
      let bottom;
      let willRender = [];
      let didInsert = [];
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          willRender() {
            willRender.push((0, _object.get)(this, 'setMe'));
          },
          didInsertElement() {
            didInsert.push((0, _object.get)(this, 'setMe'));
            bottom = this;
          }
        }),
        template: '{{this.setMe}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{bottom-mut setMe=(mut this.value)}}'
      });
      this.render('{{middle-mut value=(mut this.val)}}', {
        val: 12
      });
      this.assert.deepEqual(willRender, [12], 'willReceive is [12]');
      this.assert.deepEqual(didInsert, [12], 'didInsert is [12]');
      this.assertText('12');
      this.assertStableRerender();
      this.assert.deepEqual(willRender, [12], 'willReceive is [12]');
      this.assert.deepEqual(didInsert, [12], 'didInsert is [12]');
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 12, 'the data propagated');
      (0, _internalTestHelpers.runTask)(() => bottom.attrs.setMe.update(13));
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 13, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 13, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(bottom, 'setMe', 14));
      this.assert.strictEqual((0, _object.get)(bottom, 'setMe'), 14, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _object.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'val', 12));
      this.assertText('12');
    }
    ['@test a mutable binding with a backing computed property and attribute present in the root of the component is updated when the upstream property invalidates #11023']() {
      let bottom, middle;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          thingy: null,
          didInsertElement() {
            bottom = this;
          }
        }),
        template: '{{this.thingy}}'
      });
      this.registerComponent('middle-mut', {
        ComponentClass: _helpers.Component.extend({
          baseValue: 12,
          val: (0, _object.computed)('baseValue', function () {
            return this.get('baseValue');
          }),
          didInsertElement() {
            middle = this;
          }
        }),
        template: '{{bottom-mut thingy=(mut this.val)}}'
      });
      this.render('{{middle-mut}}');
      this.assert.strictEqual((0, _object.get)(bottom, 'thingy'), 12, 'data propagated');
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(middle, 'baseValue', 13));
      this.assert.strictEqual((0, _object.get)(middle, 'val'), 13, 'the set took effect');
      this.assert.strictEqual(bottom.attrs.thingy.value, 13, "the set propagated down to bottom's attrs");
      this.assert.strictEqual((0, _object.get)(bottom, 'thingy'), 13, "the set propagated down to bottom's prop");
      this.assertText('13');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(middle, 'baseValue', 12));
      this.assertText('12');
    }
    ['@test automatic mutable bindings exposes a mut cell in attrs']() {
      let inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            inner = this;
          }
        }),
        template: '{{this.foo}}'
      });
      this.registerComponent('x-outer', {
        template: '{{x-inner foo=this.bar}}'
      });
      this.render('{{x-outer bar=this.baz}}', {
        baz: 'foo'
      });
      this.assertText('foo');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => inner.attrs.foo.update('bar'));
      this.assert.equal(inner.attrs.foo.value, 'bar');
      this.assert.equal((0, _object.get)(inner, 'foo'), 'bar');
      this.assertText('bar');
      (0, _internalTestHelpers.runTask)(() => inner.attrs.foo.update('foo'));
      this.assertText('foo');
    }
    ['@test automatic mutable bindings tolerate undefined non-stream inputs and attempts to set them']() {
      let inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            inner = this;
          }
        }),
        template: '{{@model}}'
      });
      this.registerComponent('x-outer', {
        template: '{{x-inner model=this.nonexistent}}'
      });
      this.render('{{x-outer}}');
      this.assertText('');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => inner.attrs.model.update(42));
      this.assert.equal(inner.attrs.model.value, 42);
      this.assert.equal((0, _object.get)(inner, 'model'), 42);
      this.assertText('42');
      (0, _internalTestHelpers.runTask)(() => inner.attrs.model.update(undefined));
      this.assertText('');
    }
    ['@test automatic mutable bindings tolerate constant non-stream inputs and attempts to set them']() {
      let inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            inner = this;
          }
        }),
        template: 'hello{{@model}}'
      });
      this.registerComponent('x-outer', {
        // Use `this.x` here instead of `@x` to let `x-inner` mutate `this.x`.
        // `@x` points to the literal binding from `x-outer`, which is of
        // course immutable.
        template: '{{x-inner model=this.x}}'
      });
      this.render('{{x-outer x="foo"}}');
      this.assertText('hellofoo');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => inner.attrs.model.update(42));
      this.assert.equal(inner.attrs.model.value, 42);
      this.assert.equal((0, _object.get)(inner, 'model'), 42);
      this.assertText('hello42');
      (0, _internalTestHelpers.runTask)(() => inner.attrs.model.update('foo'));
      this.assertText('hellofoo');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Mutable Bindings used in Computed Properties that are bound as attributeBindings', class extends _internalTestHelpers.RenderingTestCase {
    ['@test an attribute binding of a computed property of a 2-way bound attr recomputes when the attr changes']() {
      let input, output;
      this.registerComponent('x-input', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            input = this;
          }
        })
      });
      this.registerComponent('x-output', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['style'],
          didInsertElement() {
            output = this;
          },
          style: (0, _object.computed)('height', function () {
            let height = this.get('height');
            return (0, _helpers.htmlSafe)("height: " + height + "px;");
          }),
          height: 20
        }),
        template: '{{this.height}}'
      });
      this.render('{{x-output height=this.height}}{{x-input height=(mut this.height)}}', {
        height: 60
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 60px;')
        },
        content: '60'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => input.attrs.height.update(35));
      this.assert.strictEqual((0, _object.get)(output, 'height'), 35, 'the set took effect');
      this.assert.strictEqual((0, _object.get)(this.context, 'height'), 35, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 35px;')
        },
        content: '35'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(input, 'height', 36));
      this.assert.strictEqual((0, _object.get)(output, 'height'), 36, 'the set took effect');
      this.assert.strictEqual((0, _object.get)(this.context, 'height'), 36, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 36px;')
        },
        content: '36'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'height', 60));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 60px;')
        },
        content: '60'
      });
      this.assert.strictEqual((0, _object.get)(input, 'height'), 60);
    }
    ['@test an attribute binding of a computed property with a setter of a 2-way bound attr recomputes when the attr changes']() {
      let input, output;
      this.registerComponent('x-input', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            input = this;
          }
        })
      });
      this.registerComponent('x-output', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['style'],
          didInsertElement() {
            output = this;
          },
          style: (0, _object.computed)('height', 'width', function () {
            let height = this.get('height');
            let width = this.get('width');
            return (0, _helpers.htmlSafe)("height: " + height + "px; width: " + width + "px;");
          }),
          height: 20,
          width: (0, _object.computed)('height', {
            get() {
              return this.get('height') * 2;
            },
            set(keyName, width) {
              this.set('height', width / 2);
              return width;
            }
          })
        }),
        template: '{{this.width}}x{{this.height}}'
      });
      this.render('{{x-output width=this.width}}{{x-input width=(mut this.width)}}', {
        width: 70
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 35px; width: 70px;')
        },
        content: '70x35'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(input, 'width', 80));
      this.assert.strictEqual((0, _object.get)(output, 'width'), 80, 'the set took effect');
      this.assert.strictEqual((0, _object.get)(this.context, 'width'), 80, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 40px; width: 80px;')
        },
        content: '80x40'
      });
      (0, _internalTestHelpers.runTask)(() => input.attrs.width.update(90));
      this.assert.strictEqual((0, _object.get)(output, 'width'), 90, 'the set took effect');
      this.assert.strictEqual((0, _object.get)(this.context, 'width'), 90, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 45px; width: 90px;')
        },
        content: '90x45'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'width', 70));
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 35px; width: 70px;')
        },
        content: '70x35'
      });
      this.assert.strictEqual((0, _object.get)(input, 'width'), 70);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/readonly-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{readonly}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test {{readonly}} of a path should work']() {
      let component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            component = this;
          }
        }),
        template: '{{this.value}}'
      });
      this.render('{{foo-bar value=(readonly this.val)}}', {
        val: 12
      });
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'value', 13));
      this.assert.notOk(component.attrs.value.update);
      this.assertText('13', 'local property is updated');
      this.assert.equal((0, _object.get)(this.context, 'val'), 12, 'upstream attribute is not updated');

      // No U-R
    }

    '@test passing an action to {{readonly}} avoids mutable cell wrapping'(assert) {
      assert.expect(4);
      let outer, inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            inner = this;
          }
        })
      });
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            outer = this;
          }
        }),
        template: '{{x-inner onClick=(readonly this.onClick)}}'
      });
      this.render('{{x-outer onClick=(action this.doIt)}}', {
        doIt() {
          assert.ok(true, 'action was called');
        }
      });
      assert.equal(typeof outer.attrs.onClick, 'function', 'function itself is present in outer component attrs');
      outer.attrs.onClick();
      assert.equal(typeof inner.attrs.onClick, 'function', 'function itself is present in inner component attrs');
      inner.attrs.onClick();
    }
    '@test updating a {{readonly}} property from above works'(assert) {
      let component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            component = this;
          }
        }),
        template: '{{this.value}}'
      });
      this.render('{{foo-bar value=(readonly this.thing)}}', {
        thing: 'initial'
      });
      this.assertText('initial');
      this.assertStableRerender();
      assert.strictEqual(component.attrs.value, 'initial', 'no mutable cell');
      assert.strictEqual((0, _object.get)(component, 'value'), 'initial', 'no mutable cell');
      assert.strictEqual(this.context.thing, 'initial');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'thing', 'updated!'));
      this.assertText('updated!');
      assert.strictEqual(component.attrs.value, 'updated!', 'passed down value was set in attrs');
      assert.strictEqual((0, _object.get)(component, 'value'), 'updated!', 'passed down value was set');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'thing', 'initial'));
      this.assertText('initial');
    }
    '@test updating a nested path of a {{readonly}}'(assert) {
      let component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            component = this;
          }
        }),
        template: '{{this.value.prop}}'
      });
      this.render('{{foo-bar value=(readonly this.thing)}}', {
        thing: {
          prop: 'initial'
        }
      });
      this.assertText('initial');
      this.assertStableRerender();
      assert.notOk(component.attrs.value.update, 'no update available');
      assert.deepEqual((0, _object.get)(component, 'value'), {
        prop: 'initial'
      });
      assert.deepEqual(this.context.thing, {
        prop: 'initial'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'value.prop', 'updated!'));
      this.assertText('updated!', 'nested path is updated');
      assert.deepEqual((0, _object.get)(component, 'value'), {
        prop: 'updated!'
      });
      assert.deepEqual(this.context.thing, {
        prop: 'updated!'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'value.prop', 'initial'));
      this.assertText('initial');
    }
    ['@test {{readonly}} of a string renders correctly']() {
      let component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            component = this;
          }
        }),
        template: '{{this.value}}'
      });
      this.render('{{foo-bar value=(readonly "12")}}');
      this.assertText('12');
      this.assertStableRerender();
      this.assert.notOk(component.attrs.value.update);
      this.assert.strictEqual((0, _object.get)(component, 'value'), '12');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'value', '13'));
      this.assertText('13', 'local property is updated');
      this.assert.strictEqual((0, _object.get)(component, 'value'), '13');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(component, 'value', '12'));
      this.assertText('12');
    }
    ['@test {{mut}} of a {{readonly}} mutates only the middle and bottom tiers']() {
      let middle, bottom;
      this.registerComponent('x-bottom', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            bottom = this;
          }
        }),
        template: '{{this.bar}}'
      });
      this.registerComponent('x-middle', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement() {
            middle = this;
          }
        }),
        template: '{{this.foo}} {{x-bottom bar=(mut this.foo)}}'
      });
      this.render('{{x-middle foo=(readonly this.val)}}', {
        val: 12
      });
      this.assertText('12 12');
      this.assertStableRerender();
      this.assert.equal((0, _object.get)(bottom, 'bar'), 12, "bottom's local bar received the value");
      this.assert.equal((0, _object.get)(middle, 'foo'), 12, "middle's local foo received the value");

      // updating the mut-cell directly
      (0, _internalTestHelpers.runTask)(() => bottom.attrs.bar.update(13));
      this.assert.equal((0, _object.get)(bottom, 'bar'), 13, "bottom's local bar was updated after set of bottom's bar");
      this.assert.equal((0, _object.get)(middle, 'foo'), 13, "middle's local foo was updated after set of bottom's bar");
      this.assertText('13 13');
      this.assert.equal((0, _object.get)(this.context, 'val'), 12, 'But context val is not updated');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(bottom, 'bar', 14));
      this.assert.equal((0, _object.get)(bottom, 'bar'), 14, "bottom's local bar was updated after set of bottom's bar");
      this.assert.equal((0, _object.get)(middle, 'foo'), 14, "middle's local foo was updated after set of bottom's bar");
      this.assertText('14 14');
      this.assert.equal((0, _object.get)(this.context, 'val'), 12, 'But context val is not updated');
      this.assert.notOk(middle.attrs.foo.update, "middle's foo attr is not a mutable cell");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(middle, 'foo', 15));
      this.assertText('15 15');
      this.assert.equal((0, _object.get)(middle, 'foo'), 15, "set of middle's foo took effect");
      this.assert.equal((0, _object.get)(bottom, 'bar'), 15, "bottom's local bar was updated after set of middle's foo");
      this.assert.equal((0, _object.get)(this.context, 'val'), 12, 'Context val remains unchanged');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'val', 10));
      this.assertText('10 10');
      this.assert.equal((0, _object.get)(bottom, 'bar'), 10, "bottom's local bar was updated after set of context's val");
      this.assert.equal((0, _object.get)(middle, 'foo'), 10, "middle's local foo was updated after set of context's val");

      // setting as a normal property
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(bottom, 'bar', undefined));
      this.assertText(' ');
      this.assert.equal((0, _object.get)(bottom, 'bar'), undefined, "bottom's local bar was updated to a falsy value");
      this.assert.equal((0, _object.get)(middle, 'foo'), undefined, "middle's local foo was updated to a falsy value");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'val', 12));
      this.assertText('12 12', 'bottom and middle were both reset');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/tracked-test", ["ember-babel", "@ember/object", "@ember/array", "@ember/array/mutable", "@ember/-internals/metal", "@ember/service", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _object, _array, _mutable, _metal, _service, _internalTestHelpers, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
  (0, _internalTestHelpers.moduleFor)('Helper Tracked Properties', class extends _internalTestHelpers.RenderingTestCase {
    '@test tracked properties rerender when updated'(assert) {
      let computeCount = 0;
      let PersonComponent = _helpers.Component.extend({
        name: (0, _metal.tracked)({
          value: 'bob'
        }),
        updateName() {
          this.name = 'sal';
        }
      });
      this.registerComponent('person', {
        ComponentClass: PersonComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <button onclick={{action this.updateName}}>\n              {{hello-world this.name}}\n            </button>\n          "])))
      });
      this.registerHelper('hello-world', _ref => {
        let [value] = _ref;
        computeCount++;
        return value + "-value";
      });
      this.render('<Person/>');
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
    }
    '@test nested tracked properties rerender when updated'(assert) {
      let computeCount = 0;
      let Person = _object.default.extend({
        name: (0, _metal.tracked)({
          value: 'bob'
        })
      });
      this.registerHelper('hello-world', _ref2 => {
        let [value] = _ref2;
        computeCount++;
        return value + "-value";
      });
      this.render('{{hello-world this.model.name}}', {
        model: Person.create()
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.context.model.name = 'sal');
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
    }
    '@test getters update when dependent properties are invalidated'(assert) {
      let computeCount = 0;
      let PersonComponent = _helpers.Component.extend({
        first: (0, _metal.tracked)({
          value: 'Rob'
        }),
        last: (0, _metal.tracked)({
          value: 'Jackson'
        }),
        full: (0, _metal.nativeDescDecorator)({
          get() {
            return this.first + " " + this.last;
          }
        }),
        updatePerson() {
          this.first = 'Kris';
          this.last = 'Selden';
        }
      });
      this.registerComponent('person', {
        ComponentClass: PersonComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <button onclick={{action this.updatePerson}}>\n              {{hello-world this.full}}\n            </button>\n          "])))
      });
      this.registerHelper('hello-world', _ref3 => {
        let [value] = _ref3;
        computeCount++;
        return value;
      });
      this.render('<Person/>');
      this.assertText('Rob Jackson');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Rob Jackson');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('Kris Selden');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
    }
    '@test array properties rerender when updated'() {
      let NumListComponent = _helpers.Component.extend({
        numbers: (0, _metal.tracked)({
          initializer: () => (0, _array.A)([1, 2, 3])
        }),
        addNumber() {
          this.numbers.pushObject(4);
        }
      });
      this.registerComponent('num-list', {
        ComponentClass: NumListComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <button {{action this.addNumber}}>\n              {{join this.numbers}}\n            </button>\n          "])))
      });
      this.registerHelper('join', _ref4 => {
        let [value] = _ref4;
        return value.join(', ');
      });
      this.render('<NumList />');
      this.assertText('1, 2, 3');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1, 2, 3, 4');
    }
    '@test custom ember array properties rerender when updated'() {
      let CustomArray = _object.default.extend(_mutable.default, {
        init() {
          this._super(...arguments);
          this._vals = [1, 2, 3];
        },
        objectAt(index) {
          return this._vals[index];
        },
        replace(start, deleteCount, items) {
          if (items === void 0) {
            items = [];
          }
          this._vals.splice(start, deleteCount, ...items);
          (0, _metal.notifyPropertyChange)(this, '[]');
        },
        join() {
          return this._vals.join(...arguments);
        },
        get length() {
          return this._vals.length;
        }
      });
      let NumListComponent = _helpers.Component.extend({
        numbers: (0, _metal.tracked)({
          initializer: () => CustomArray.create()
        }),
        addNumber() {
          this.numbers.pushObject(4);
        }
      });
      this.registerComponent('num-list', {
        ComponentClass: NumListComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            <button {{action this.addNumber}}>\n              {{join this.numbers}}\n            </button>\n          "])))
      });
      this.registerHelper('join', _ref5 => {
        let [value] = _ref5;
        return value.join(', ');
      });
      this.render('<NumList />');
      this.assertText('1, 2, 3');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('1, 2, 3, 4');
    }
    '@test nested getters update when dependent properties are invalidated'(assert) {
      let computeCount = 0;
      let Person = _object.default.extend({
        first: (0, _metal.tracked)({
          value: 'Rob'
        }),
        last: (0, _metal.tracked)({
          value: 'Jackson'
        }),
        full: (0, _metal.nativeDescDecorator)({
          get() {
            return this.first + " " + this.last;
          }
        })
      });
      this.registerHelper('hello-world', _ref6 => {
        let [value] = _ref6;
        computeCount++;
        return value;
      });
      this.render('{{hello-world this.model.full}}', {
        model: Person.create()
      });
      this.assertText('Rob Jackson');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Rob Jackson');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => {
        this.context.model.first = 'Kris';
        this.context.model.last = 'Selden';
      });
      this.assertText('Kris Selden');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
    }
    '@test functional helpers autotrack based on non-argument tracked props that are accessed'(assert) {
      let computeCount = 0;
      let currentUserService;
      this.registerService('current-user', _service.default.extend({
        name: (0, _metal.tracked)({
          value: 'bob'
        }),
        init() {
          this._super(...arguments);
          currentUserService = this;
        }
      }));
      this.registerComponent('person', {
        ComponentClass: _helpers.Component.extend({
          currentUser: (0, _service.service)('current-user')
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{hello-world this.currentUser}}\n          "])))
      });
      this.registerHelper('hello-world', _ref7 => {
        let [service] = _ref7;
        computeCount++;
        return service.name + "-value";
      });
      this.render('<Person/>');
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => currentUserService.name = 'sal');
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
    }
    '@test class based helpers are autotracked'(assert) {
      let computeCount = 0;
      let TrackedClass = _object.default.extend({
        value: (0, _metal.tracked)({
          value: 'bob'
        })
      });
      let trackedInstance = TrackedClass.create();
      this.registerComponent('person', {
        ComponentClass: _helpers.Component.extend(),
        template: (0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{hello-world}}"])))
      });
      this.registerHelper('hello-world', {
        compute() {
          computeCount++;
          return trackedInstance.value + "-value";
        }
      });
      this.render('<Person/>');
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(() => trackedInstance.value = 'sal');
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
    }
    '@test each-in autotracks non-tracked values correctly'() {
      let obj = _object.default.create({
        value: 'bob'
      });
      this.registerComponent('person', {
        ComponentClass: _helpers.Component.extend({
          obj
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{#each-in this.obj as |key value|}}\n              {{value}}-{{key}}\n            {{/each-in}}\n          "])))
      });
      this.render('<Person/>');
      this.assertText('bob-value');
      (0, _internalTestHelpers.runTask)(() => obj.set('value', 'sal'));
      this.assertText('sal-value');
    }
    '@test each-in autotracks arrays acorrectly'() {
      let obj = _object.default.create({
        arr: (0, _array.A)([1])
      });
      this.registerComponent('person', {
        ComponentClass: _helpers.Component.extend({
          obj
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{#each-in this.obj as |key arr|}}\n              {{#each arr as |v|}}{{v}}{{/each}}\n            {{/each-in}}\n          "])))
      });
      this.render('<Person/>');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => obj.arr.pushObject(2));
      this.assertText('12');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/unbound-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/array", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _object, _array, _helpers) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3;
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unbound}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test should be able to output a property without binding']() {
      this.render("<div id=\"first\">{{unbound this.content.anUnboundString}}</div>", {
        content: {
          anUnboundString: 'No spans here, son.'
        }
      });
      this.assertText('No spans here, son.');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('No spans here, son.');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'content.anUnboundString', 'HEY'));
      this.assertText('No spans here, son.');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'content', {
        anUnboundString: 'No spans here, son.'
      }));
      this.assertText('No spans here, son.');
    }
    ['@test should be able to use unbound helper in #each helper']() {
      this.render("<ul>{{#each this.items as |item|}}<li>{{unbound item}}</li>{{/each}}</ul>", {
        items: (0, _array.A)(['a', 'b', 'c', 1, 2, 3])
      });
      this.assertText('abc123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('abc123');
    }
    ['@test should be able to use unbound helper in #each helper (with objects)']() {
      this.render("<ul>{{#each this.items as |item|}}<li>{{unbound item.wham}}</li>{{/each}}</ul>", {
        items: (0, _array.A)([{
          wham: 'bam'
        }, {
          wham: 1
        }])
      });
      this.assertText('bam1');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bam1');
      (0, _internalTestHelpers.runTask)(() => this.context.items.setEach('wham', 'HEY'));
      this.assertText('bam1');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'items', (0, _array.A)([{
        wham: 'bam'
      }, {
        wham: 1
      }])));
      this.assertText('bam1');
    }
    ['@test it should assert unbound cannot be called with multiple arguments']() {
      let willThrow = () => {
        this.render("{{unbound this.foo this.bar}}", {
          foo: 'BORK',
          bar: 'BLOOP'
        });
      };
      expectAssertion(willThrow, /unbound helper cannot be called with multiple params or hash params/);
    }
    ['@test should render on attributes']() {
      this.render("<a href=\"{{unbound this.model.foo}}\"></a>", {
        model: {
          foo: 'BORK'
        }
      });
      this.assertHTML('<a href="BORK"></a>');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertHTML('<a href="BORK"></a>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.foo', 'OOF'));
      this.assertHTML('<a href="BORK"></a>');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: 'BORK'
      }));
      this.assertHTML('<a href="BORK"></a>');
    }
    ['@test should property escape unsafe hrefs']() {
      let unsafeUrls = (0, _array.A)([{
        name: 'Bob',
        url: 'javascript:bob-is-cool'
      }, {
        name: 'James',
        url: 'vbscript:james-is-cool'
      }, {
        name: 'Richard',
        url: 'javascript:richard-is-cool'
      }]);
      this.render("<ul>{{#each this.people as |person|}}<li><a href=\"{{unbound person.url}}\">{{person.name}}</a></li>{{/each}}</ul>", {
        people: unsafeUrls
      });
      let escapedHtml = (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>\n          <a href=\"unsafe:javascript:bob-is-cool\">Bob</a>\n        </li>\n        <li>\n          <a href=\"unsafe:vbscript:james-is-cool\">James</a>\n        </li>\n        <li>\n          <a href=\"unsafe:javascript:richard-is-cool\">Richard</a>\n        </li>\n      </ul>\n    "])));
      this.assertHTML(escapedHtml);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertHTML(escapedHtml);
      (0, _internalTestHelpers.runTask)(() => this.context.people.setEach('url', 'http://google.com'));
      this.assertHTML(escapedHtml);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'people', unsafeUrls));
      this.assertHTML(escapedHtml);
    }
    ['@skip helper form updates on parent re-render']() {
      this.render("{{unbound this.foo}}", {
        foo: 'BORK'
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'OOF'));
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('OOF');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', ''));
      this.assertText('OOF');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'BORK'));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('BORK');
    }

    // semantics here is not guaranteed
    ['@test sexpr form does not update no matter what']() {
      this.registerHelper('capitalize', args => args[0].toUpperCase());
      this.render("{{capitalize (unbound this.foo)}}", {
        foo: 'bork'
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'oof');
        this.rerender();
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'blip'));
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'bork');
        this.rerender();
      });
      this.assertText('BORK');
    }
    ['@test sexpr in helper form does not update on parent re-render']() {
      this.registerHelper('capitalize', params => params[0].toUpperCase());
      this.registerHelper('doublize', params => params[0] + " " + params[0]);
      this.render("{{capitalize (unbound (doublize this.foo))}}", {
        foo: 'bork'
      });
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'oof');
        this.rerender();
      });
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', 'blip'));
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'foo', 'bork');
        this.rerender();
      });
      this.assertText('BORK BORK');
    }
    ['@test should be able to render an unbound helper invocation']() {
      this.registerHelper('repeat', (_ref, _ref2) => {
        let [value] = _ref;
        let {
          count
        } = _ref2;
        let a = [];
        while (a.length < count) {
          a.push(value);
        }
        return a.join('');
      });
      this.render("{{unbound (repeat this.foo count=this.bar)}} {{repeat this.foo count=this.bar}} {{unbound (repeat this.foo count=2)}} {{repeat this.foo count=4}}", {
        foo: 'X',
        bar: 5
      });
      this.assertText('XXXXX XXXXX XX XXXX');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('XXXXX XXXXX XX XXXX');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'bar', 1));
      this.assertText('XXXXX X XX XXXX');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'bar', 5));
      this.assertText('XXXXX XXXXX XX XXXX');
    }
    ['@test should be able to render an bound helper invocation mixed with static values']() {
      this.registerHelper('surround', _ref3 => {
        let [prefix, value, suffix] = _ref3;
        return prefix + "-" + value + "-" + suffix;
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{unbound (surround this.model.prefix this.model.value \"bar\")}} {{surround this.model.prefix this.model.value \"bar\"}} {{unbound (surround \"bar\" this.model.value this.model.suffix)}} {{surround \"bar\" this.model.value this.model.suffix}}"]))), {
        model: {
          prefix: 'before',
          value: 'core',
          suffix: 'after'
        }
      });
      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.setProperties)(this.context.model, {
          prefix: 'beforeChanged',
          value: 'coreChanged',
          suffix: 'afterChanged'
        });
      });
      this.assertText('before-core-bar beforeChanged-coreChanged-bar bar-core-after bar-coreChanged-afterChanged');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'model', {
          prefix: 'before',
          value: 'core',
          suffix: 'after'
        });
      });
      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
    }
    ['@test should be able to render unbound forms of multi-arg helpers']() {
      this.registerHelper('fauxconcat', params => params.join(''));
      this.render("{{fauxconcat this.model.foo this.model.bar this.model.bing}} {{unbound (fauxconcat this.model.foo this.model.bar this.model.bing)}}", {
        model: {
          foo: 'a',
          bar: 'b',
          bing: 'c'
        }
      });
      this.assertText('abc abc');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('abc abc');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.bar', 'X'));
      this.assertText('aXc abc');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: 'a',
        bar: 'b',
        bing: 'c'
      }));
      this.assertText('abc abc');
    }
    async ['@test should be able to render an unbound helper invocation for helpers with dependent keys']() {
      this.registerHelper('capitalizeName', {
        destroy() {
          this.removeObserver('value.firstName', this, this.recompute);
          this._super(...arguments);
        },
        compute(_ref4) {
          let [value] = _ref4;
          if (this.value) {
            this.removeObserver('value.firstName', this, this.recompute);
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          return value ? (0, _object.get)(value, 'firstName').toUpperCase() : '';
        }
      });
      this.registerHelper('concatNames', {
        destroy() {
          this.teardown();
          this._super(...arguments);
        },
        teardown() {
          this.removeObserver('value.firstName', this, this.recompute);
          this.removeObserver('value.lastName', this, this.recompute);
        },
        compute(_ref5) {
          let [value] = _ref5;
          if (this.value) {
            this.teardown();
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          this.addObserver('value.lastName', this, this.recompute);
          return (value ? (0, _object.get)(value, 'firstName') : '') + (value ? (0, _object.get)(value, 'lastName') : '');
        }
      });
      this.render("{{capitalizeName this.person}} {{unbound (capitalizeName this.person)}} {{concatNames this.person}} {{unbound (concatNames this.person)}}", {
        person: {
          firstName: 'shooby',
          lastName: 'taylor'
        }
      });
      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'person.firstName', 'sally'));
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('SALLY SHOOBY sallytaylor shoobytaylor');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'person', {
        firstName: 'shooby',
        lastName: 'taylor'
      }));
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
    }
    ['@test should be able to render an unbound helper invocation in #each helper']() {
      this.registerHelper('capitalize', params => params[0].toUpperCase());
      this.render("{{#each this.people as |person|}}{{capitalize person.firstName}} {{unbound (capitalize person.firstName)}}{{/each}}", {
        people: (0, _array.A)([{
          firstName: 'shooby',
          lastName: 'taylor'
        }, {
          firstName: 'cindy',
          lastName: 'taylor'
        }])
      });
      this.assertText('SHOOBY SHOOBYCINDY CINDY');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('SHOOBY SHOOBYCINDY CINDY');
      (0, _internalTestHelpers.runTask)(() => this.context.people.setEach('firstName', 'chad'));
      this.assertText('CHAD SHOOBYCHAD CINDY');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'people', (0, _array.A)([{
        firstName: 'shooby',
        lastName: 'taylor'
      }, {
        firstName: 'cindy',
        lastName: 'taylor'
      }])));
      this.assertText('SHOOBY SHOOBYCINDY CINDY');
    }
    async ['@test should be able to render an unbound helper invocation with bound hash options']() {
      this.registerHelper('capitalizeName', {
        destroy() {
          this.removeObserver('value.firstName', this, this.recompute);
          this._super(...arguments);
        },
        compute(_ref6) {
          let [value] = _ref6;
          if (this.value) {
            this.removeObserver('value.firstName', this, this.recompute);
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          return value ? (0, _object.get)(value, 'firstName').toUpperCase() : '';
        }
      });
      this.registerHelper('concatNames', {
        destroy() {
          this.teardown();
          this._super(...arguments);
        },
        teardown() {
          this.removeObserver('value.firstName', this, this.recompute);
          this.removeObserver('value.lastName', this, this.recompute);
        },
        compute(_ref7) {
          let [value] = _ref7;
          if (this.value) {
            this.teardown();
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          this.addObserver('value.lastName', this, this.recompute);
          return (value ? (0, _object.get)(value, 'firstName') : '') + (value ? (0, _object.get)(value, 'lastName') : '');
        }
      });
      this.render("{{capitalizeName this.person}} {{unbound (capitalizeName this.person)}} {{concatNames this.person}} {{unbound (concatNames this.person)}}", {
        person: {
          firstName: 'shooby',
          lastName: 'taylor'
        }
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'person.firstName', 'sally'));
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertText('SALLY SHOOBY sallytaylor shoobytaylor');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'person', {
        firstName: 'shooby',
        lastName: 'taylor'
      }));
      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
    }
    ['@test should be able to render bound form of a helper inside unbound form of same helper']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#if (unbound this.model.foo)}}\n        {{#if this.model.bar}}true{{/if}}\n        {{#unless this.model.bar}}false{{/unless}}\n      {{/if}}\n      {{#unless (unbound this.model.notfoo)}}\n        {{#if this.model.bar}}true{{/if}}\n        {{#unless this.model.bar}}false{{/unless}}\n      {{/unless}}"]))), {
        model: {
          foo: true,
          notfoo: false,
          bar: true
        }
      });
      this.assertText('truetrue');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('truetrue');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.bar', false));
      this.assertText('falsefalse');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        foo: true,
        notfoo: false,
        bar: true
      }));
      this.assertText('truetrue');
    }
    ['@test yielding unbound does not update']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          fooBarInstance = this;
        },
        model: {
          foo: 'bork'
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (unbound this.model.foo)}}"
      });
      this.render("{{#foo-bar as |value|}}{{value}}{{/foo-bar}}");
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model.foo', 'oof'));
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model', {
        foo: 'bork'
      }));
      this.assertText('bork');
    }
    ['@test yielding unbound hash does not update']() {
      let fooBarInstance;
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          fooBarInstance = this;
        },
        model: {
          foo: 'bork'
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (unbound (hash foo=this.model.foo))}}"
      });
      this.render("{{#foo-bar as |value|}}{{value.foo}}{{/foo-bar}}");
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model.foo', 'oof'));
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(fooBarInstance, 'model', {
        foo: 'bork'
      }));
      this.assertText('bork');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/unique-id-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/helper", "@glimmer/validator"], function (_emberBabel, _internalTestHelpers, _object, _helper, _validator) {
  "use strict";

  var _templateObject, _templateObject2;
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unique-id}} JS', class extends _internalTestHelpers.AbstractTestCase {
    constructor(assert) {
      super(assert);
      this.assert = assert;
    }
    ['@test it can be invoked as a JS function']() {
      let first = (0, _helper.uniqueId)();
      let second = (0, _helper.uniqueId)();
      this.assert.notStrictEqual(first, second, "different invocations of uniqueId should produce different values");
    }
    ['@test it can be invoked via invokeHelper']() {
      let first = (0, _validator.getValue)((0, _helper.invokeHelper)({}, _helper.uniqueId));
      let second = (0, _validator.getValue)((0, _helper.invokeHelper)({}, _helper.uniqueId));
      this.assert.notStrictEqual(first, second, "different invocations of uniqueId should produce different values");
    }
  });
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unique-id}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it generates a unique id (string) each time']() {
      let {
        first,
        second
      } = this.render("<p>{{unique-id}}</p><p>{{unique-id}}</p>", () => {
        let first = this.asElement(this.firstChild);
        let second = this.asElement(this.nthChild(1));
        return {
          first: this.asTextContent(first.firstChild),
          second: this.asTextContent(second.firstChild)
        };
      });
      this.assert.notStrictEqual(first, second, "different invocations of {{unique-id}} should produce different values");
    }
    ["@test when unique-id is used with #let, it remains stable when it's used"]() {
      let {
        first,
        second
      } = this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#let (unique-id) as |id|}}\n          <p>{{id}}</p><p>{{id}}</p>\n        {{/let}}\n      "]))), () => {
        let first = this.asElement(this.firstChild);
        let second = this.asElement(this.nthChild(1));
        return {
          first: this.asTextContent(first.firstChild),
          second: this.asTextContent(second.firstChild)
        };
      });
      this.assert.strictEqual(first, second, "when unique-id is used as a variable, it remains the same");
    }
    ["@test unique-id doesn't change if it's concatenated with a value that does change"]() {
      class Elements {
        constructor(label, input, assert) {
          this.label = label;
          this.input = input;
          this.assert = assert;
        }
        id(regex) {
          let forAttr = this.label.getAttribute('for');
          this.assert.strictEqual(forAttr, this.input.getAttribute('id'), "the label's 'for' attribute should be the same as the input's 'id' attribute");
          let match = forAttr.match(regex);
          this.assert.ok(match, 'the id starts with the prefix');
          return match[1];
        }
      }
      let {
        elements,
        id
      } = this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#let (unique-id) as |id|}}\n            <label for=\"{{this.prefix}}-{{id}}\">Enable Feature</label>\n            <input id=\"{{this.prefix}}-{{id}}\" type=\"checkbox\">\n          {{/let}}"]))), {
        prefix: 'app'
      }, () => {
        let label = this.asElement(this.firstChild, 'label');
        let input = this.asElement(this.nthChild(1), 'input');
        let elements = new Elements(label, input, this.assert);
        return {
          elements,
          id: elements.id(/^app-(.*)$/)
        };
      });
      this.update({
        prefix: 'melanie'
      }, () => {
        let newId = elements.id(/^melanie-(.*)$/);
        this.assert.strictEqual(id, newId, "the unique-id part of a concatenated attribute shouldn't change just because a dynamic part of it changed");
      });
    }
    ['@test it only generates valid selectors']() {
      let iterations = 1000;
      let reNumericStart = /^\d/;
      let template = '<p>{{unique-id}}</p>'.repeat(iterations);
      super.render(template);
      for (let i = 0; i < iterations; i++) {
        let textNode = this.nthChild(i).firstChild;
        let text = textNode.data;
        this.assert.false(reNumericStart.test(text), "{{unique-id}} should produce valid selectors" + text);
      }
    }
    render(template) {
      // If there are three parameters to `render`, the second parameter is the
      // template's arguments.
      let args = (arguments.length <= 1 ? 0 : arguments.length - 1) === 2 ? arguments.length <= 1 ? undefined : arguments[1] : {};
      // If there are two parameters to `render`, the second parameter is the
      // postcondition. Otherwise, the third parameter is the postcondition.
      let postcondition = (arguments.length <= 1 ? 0 : arguments.length - 1) === 2 ? arguments.length <= 2 ? undefined : arguments[2] : arguments.length <= 1 ? undefined : arguments[1];
      super.render(template, args);
      let result = postcondition();
      this.assertStableRerender();
      return result;
    }
    update(args, postcondition) {
      (0, _internalTestHelpers.runTask)(() => (0, _object.setProperties)(this.context, args));
      postcondition();
      this.assertStableRerender();
    }
    asElement(node, tag) {
      this.assert.ok(node !== null && node.nodeType === 1);
      if (tag) {
        this.assert.strictEqual(node.tagName.toLowerCase(), tag, "Element is <" + tag + ">");
      }
      return node;
    }
    asTextNode(node) {
      this.assert.ok(node !== null && node.nodeType === 3);
      return node;
    }
    asTextContent(node) {
      let data = this.asTextNode(node).data;
      this.assert.ok(data.trim().length > 0, "The text node has content");
      return data;
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/helpers/yield-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _object, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{yield}} helper', class extends _internalTestHelpers.RenderingTestCase {
    ['@test can yield to a default block']() {
      this.registerComponent('yield-comp', {
        template: '[In layout:] {{yield}}'
      });
      this.render('{{#yield-comp}}[In Block:] {{this.object.title}}{{/yield-comp}}', {
        object: {
          title: 'Seattle'
        }
      });
      this.assertText('[In layout:] [In Block:] Seattle');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'object.title', 'Vancouver'));
      this.assertText('[In layout:] [In Block:] Vancouver');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'object', {
        title: 'Seattle'
      }));
      this.assertText('[In layout:] [In Block:] Seattle');
    }
    ['@test can yield to a named block']() {
      // This test fails when the default Ember component backing class is used:
      this.registerComponent('yield-comp', {
        template: '[In layout:] {{yield to="block"}}'

        // It passes with no backing class:
        // ComponentClass: null,

        // And it passes using `GlimmerishComponent`:
        // ComponentClass: require('../../utils/glimmerish-component').default,
      });

      this.render('<YieldComp><:block>[In block:] {{this.object.title}}</:block></YieldComp>', {
        object: {
          title: 'Seattle'
        }
      });
      this.assertText('[In layout:] [In block:] Seattle');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'object.title', 'Vancouver'));
      this.assertText('[In layout:] [In block:] Vancouver');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'object', {
        title: 'Seattle'
      }));
      this.assertText('[In layout:] [In block:] Seattle');
    }
    ['@test <:else> and <:inverse> named blocks']() {
      this.registerComponent('yielder', {
        template: '[:else][{{has-block "else"}}][{{yield to="else"}}]' + '[:inverse][{{has-block "inverse"}}][{{yield to="inverse"}}]'
      });
      this.render('[<Yielder />]' + '[<Yielder><:else>Hello</:else></Yielder>]' + '[<Yielder><:inverse>Goodbye</:inverse></Yielder>]');
      this.assertText('[[:else][false][][:inverse][false][]]' + '[[:else][true][Hello][:inverse][true][Hello]]' + '[[:else][true][Goodbye][:inverse][true][Goodbye]]');
      this.assertStableRerender();
    }
    ['@test templates should yield to block inside a nested component']() {
      this.registerComponent('outer-comp', {
        template: '<div>[In layout:] {{yield}}</div>'
      });
      this.registerComponent('inner-comp', {
        template: '{{#outer-comp}}[In Block:] {{this.object.title}}{{/outer-comp}}'
      });
      this.render('{{inner-comp object=this.object}}', {
        object: {
          title: 'Seattle'
        }
      });
      this.assertText('[In layout:] [In Block:] Seattle');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'object.title', 'Vancouver'));
      this.assertText('[In layout:] [In Block:] Vancouver');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'object', {
        title: 'Seattle'
      }));
      this.assertText('[In layout:] [In Block:] Seattle');
    }
    ['@test templates should yield to block, when the yield is embedded in a each helper']() {
      let list = [1, 2, 3];
      this.registerComponent('outer-comp', {
        template: '{{#each this.list as |item|}}{{yield}}{{/each}}'
      });
      this.render('{{#outer-comp list=this.list}}Hello{{/outer-comp}}', {
        list: list
      });
      this.assertText('HelloHelloHello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'list', [4, 5]));
      this.assertText('HelloHello');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'list', list));
      this.assertText('HelloHelloHello');
    }
    ['@test templates should yield to block, when the yield is embedded in a if helper']() {
      this.registerComponent('outer-comp', {
        template: '{{#if this.boolean}}{{yield}}{{/if}}'
      });
      this.render('{{#outer-comp boolean=this.boolean}}Hello{{/outer-comp}}', {
        boolean: true
      });
      this.assertText('Hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boolean', false));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boolean', true));
      this.assertText('Hello');
    }
    ['@test simple curlies inside of a yielded block should work when the yield is nested inside of another view']() {
      this.registerComponent('kiwi-comp', {
        template: '{{#if this.falsy}}{{else}}{{yield}}{{/if}}'
      });
      this.render('{{#kiwi-comp}}{{this.text}}{{/kiwi-comp}}', {
        text: 'ohai'
      });
      this.assertText('ohai');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'portland'));
      this.assertText('portland');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'ohai'));
      this.assertText('ohai');
    }
    ['@test nested simple curlies inside of a yielded block should work when the yield is nested inside of another view']() {
      this.registerComponent('parent-comp', {
        template: '{{#if this.falsy}}{{else}}{{yield}}{{/if}}'
      });
      this.registerComponent('child-comp', {
        template: '{{#if this.falsy}}{{else}}{{this.text}}{{/if}}'
      });
      this.render('{{#parent-comp}}{{child-comp text=this.text}}{{/parent-comp}}', {
        text: 'ohai'
      });
      this.assertText('ohai');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'portland'));
      this.assertText('portland');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'ohai'));
      this.assertText('ohai');
    }
    ['@test yielding to a non-existent block is not an error']() {
      this.registerComponent('yielding-comp', {
        template: 'Hello:{{yield}}'
      });
      this.registerComponent('outer-comp', {
        template: '{{yielding-comp}} {{this.title}}'
      });
      this.render('{{outer-comp title=this.title}}', {
        title: 'Mr. Selden'
      });
      this.assertText('Hello: Mr. Selden');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'title', 'Mr. Chag'));
      this.assertText('Hello: Mr. Chag');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'title', 'Mr. Selden'));
      this.assertText('Hello: Mr. Selden');
    }
    ['@test yield uses the original context']() {
      let KiwiCompComponent = _helpers.Component.extend({
        boundText: 'Inner'
      });
      this.registerComponent('kiwi-comp', {
        ComponentClass: KiwiCompComponent,
        template: '<p>{{this.boundText}}</p><p>{{yield}}</p>'
      });
      this.render('{{#kiwi-comp}}{{this.boundText}}{{/kiwi-comp}}', {
        boundText: 'Original'
      });
      this.assertText('InnerOriginal');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'Otherworld'));
      this.assertText('InnerOtherworld');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'Original'));
      this.assertText('InnerOriginal');
    }
    ["@test outer block param doesn't mask inner component property"]() {
      let KiwiCompComponent = _helpers.Component.extend({
        boundText: 'Inner'
      });
      this.registerComponent('kiwi-comp', {
        ComponentClass: KiwiCompComponent,
        template: '<p>{{this.boundText}}</p><p>{{yield}}</p>'
      });
      this.render('{{#let this.boundText as |item|}}{{#kiwi-comp}}{{item}}{{/kiwi-comp}}{{/let}}', {
        boundText: 'Outer'
      });
      this.assertText('InnerOuter');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'Otherworld'));
      this.assertText('InnerOtherworld');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'Outer'));
      this.assertText('InnerOuter');
    }
    ["@test inner block param doesn't mask yield property"]() {
      let KiwiCompComponent = _helpers.Component.extend({
        boundText: 'Inner'
      });
      this.registerComponent('kiwi-comp', {
        ComponentClass: KiwiCompComponent,
        template: '{{#let this.boundText as |item|}}<p>{{item}}</p><p>{{yield}}</p>{{/let}}'
      });
      this.render('{{#kiwi-comp}}{{this.item}}{{/kiwi-comp}}', {
        item: 'Outer'
      });
      this.assertText('InnerOuter');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'item', 'Otherworld'));
      this.assertText('InnerOtherworld');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'item', 'Outer'));
      this.assertText('InnerOuter');
    }
    ['@test can bind a block param to a component and use it in yield']() {
      this.registerComponent('kiwi-comp', {
        template: '<p>{{this.content}}</p><p>{{yield}}</p>'
      });
      this.render('{{#let this.boundText as |item|}}{{#kiwi-comp content=item}}{{item}}{{/kiwi-comp}}{{/let}}', {
        boundText: 'Outer'
      });
      this.assertText('OuterOuter');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'Update'));
      this.assertText('UpdateUpdate');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'Outer'));
      this.assertText('OuterOuter');
    }

    // INUR not need with no data update
    ['@test yield should not introduce a view'](assert) {
      let ParentCompComponent = _helpers.Component.extend({
        isParentComponent: true
      });
      let ChildCompComponent = _helpers.Component.extend({
        didReceiveAttrs() {
          this._super();
          let parentView = this.get('parentView');
          assert.ok(parentView.get('isParentComponent'));
        }
      });
      this.registerComponent('parent-comp', {
        ComponentClass: ParentCompComponent,
        template: '{{yield}}'
      });
      this.registerComponent('child-comp', {
        ComponentClass: ChildCompComponent
      });
      this.render('{{#parent-comp}}{{child-comp}}{{/parent-comp}}');
    }
    ['@test yield with nested components (#3220)']() {
      this.registerComponent('inner-component', {
        template: '{{yield}}'
      });
      this.registerComponent('outer-component', {
        template: '{{#inner-component}}<span>{{yield}}</span>{{/inner-component}}'
      });
      this.render('{{#outer-component}}Hello {{this.boundText}}{{/outer-component}}', {
        boundText: 'world'
      });
      this.assertText('Hello world');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'update'));
      this.assertText('Hello update');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'boundText', 'world'));
      this.assertText('Hello world');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/input-test", ["internal-test-helpers", "@ember/object"], function (_internalTestHelpers, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Input element tests', class extends _internalTestHelpers.RenderingTestCase {
    runAttributeTest(attributeName, values) {
      let template = "<input " + attributeName + "={{this.value}}>";
      this.render(template, {
        value: values[0]
      });
      this.assertAttributeHasValue(attributeName, values[0], attributeName + " is set on initial render");
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertAttributeHasValue(attributeName, values[0], attributeName + " is set on noop rerender");
      this.setComponentValue(values[1]);
      this.assertAttributeHasValue(attributeName, values[1], attributeName + " is set on rerender");
      this.setComponentValue(values[0]);
      this.assertAttributeHasValue(attributeName, values[0], attributeName + " can be set back to the initial value");
    }
    runPropertyTest(propertyName, values) {
      let attributeName = propertyName;
      let template = "<input " + attributeName + "={{this.value}}>";
      this.render(template, {
        value: values[0]
      });
      this.assertPropertyHasValue(propertyName, values[0], propertyName + " is set on initial render");
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertPropertyHasValue(propertyName, values[0], propertyName + " is set on noop rerender");
      this.setComponentValue(values[1]);
      this.assertPropertyHasValue(propertyName, values[1], propertyName + " is set on rerender");
      this.setComponentValue(values[0]);
      this.assertPropertyHasValue(propertyName, values[0], propertyName + " can be set back to the initial value");
    }
    runFalsyValueProperty(values) {
      let value = 'value';
      let template = "<input value={{this.value}}>";
      this.render(template, {
        value: values[0]
      });
      this.assertPropertyHasValue(value, '', value + " is set on initial render");
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertPropertyHasValue(value, '', value + " is set on noop rerender");
      this.setComponentValue(values[1]);
      this.assertPropertyHasValue(value, values[1], value + " is set on rerender");
      this.setComponentValue(values[0]);
      this.assertPropertyHasValue(value, '', value + " can be set back to the initial value");
    }
    ['@test input disabled attribute']() {
      let model = {
        model: {
          value: false
        }
      };
      this.render("<input disabled={{this.model.value}}>", model);
      this.assert.equal(this.$inputElement().prop('disabled'), false);
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assert.equal(this.$inputElement().prop('disabled'), false);
      (0, _internalTestHelpers.runTask)(() => this.context.set('model.value', true));
      this.assert.equal(this.$inputElement().prop('disabled'), true);
      this.assertHTML('<input disabled="">'); // Note the DOM output is <input disabled>

      (0, _internalTestHelpers.runTask)(() => this.context.set('model.value', 'wat'));
      this.assert.equal(this.$inputElement().prop('disabled'), true);
      this.assertHTML('<input disabled="">'); // Note the DOM output is <input disabled>

      (0, _internalTestHelpers.runTask)(() => this.context.set('model', {
        value: false
      }));
      this.assert.equal(this.$inputElement().prop('disabled'), false);
      this.assertHTML('<input>');
    }
    ['@test input value attribute']() {
      this.runPropertyTest('value', ['foo', 'bar']);
    }
    ['@test input placeholder attribute']() {
      this.runAttributeTest('placeholder', ['foo', 'bar']);
    }
    ['@test input name attribute']() {
      this.runAttributeTest('name', ['nam', 'name']);
    }
    ['@test input maxlength attribute']() {
      this.runAttributeTest('maxlength', [2, 3]);
    }
    ['@test input size attribute']() {
      this.runAttributeTest('size', [2, 3]);
    }
    ['@test input tabindex attribute']() {
      this.runAttributeTest('tabindex', [2, 3]);
    }
    ['@test null input value']() {
      this.runFalsyValueProperty([null, 'hello']);
    }
    ['@test undefined input value']() {
      this.runFalsyValueProperty([undefined, 'hello']);
    }
    ['@test undefined `toString` method as input value']() {
      this.runFalsyValueProperty([Object.create(null), 'hello']);
    }
    ['@test cursor position is not lost when updating content']() {
      let template = "<input value={{this.value}}>";
      this.render(template, {
        value: 'hola'
      });
      this.setDOMValue('hello');
      this.setSelectionRange(1, 3);
      this.setComponentValue('hello');
      this.assertSelectionRange(1, 3);

      // Note: We should eventually get around to testing reseting, however
      // browsers handle `selectionStart` and `selectionEnd` differently
      // when are synthetically testing movement of the cursor.
    }

    ['@test input can be updated multiple times']() {
      let template = "<input value={{this.value}}>";
      this.render(template, {
        value: 'hola'
      });
      this.assertValue('hola', 'Value is initialised');
      this.setComponentValue('');
      this.assertValue('', 'Value is set in the DOM');
      this.setDOMValue('hola');
      this.setComponentValue('hola');
      this.assertValue('hola', 'Value is updated the first time');
      this.setComponentValue('');
      this.assertValue('', 'Value is updated the second time');
    }
    ['@test DOM is SSOT if value is set']() {
      let template = "<input value={{this.value}}>";
      this.render(template, {
        value: 'hola'
      });
      this.assertValue('hola', 'Value is initialised');
      this.setComponentValue('hello');
      this.assertValue('hello', 'Value is initialised');
      this.setDOMValue('hola');
      this.assertValue('hola', 'DOM is used');
      this.setComponentValue('bye');
      this.assertValue('bye', 'Value is used');

      // Simulates setting the input to the same value as it already is which won't cause a rerender

      this.setDOMValue('hola');
      this.assertValue('hola', 'DOM is used');
      this.setComponentValue('hola');
      this.assertValue('hola', 'Value is used');
    }
    ['@test GH18211 input checked attribute, without a value, works with the action helper']() {
      this.render("<input type=\"checkbox\" checked {{action \"someAction\"}}>", {
        actions: {
          someAction() {}
        }
      });
      this.assertPropertyHasValue('checked', true);
    }
    ['@test GH18211 input checked attribute, with a value, works with the action helper']() {
      this.render("<input type=\"checkbox\" checked={{true}} {{action \"someAction\"}}>", {
        actions: {
          someAction() {}
        }
      });
      this.assertPropertyHasValue('checked', true);
    }
    ['@test GH18211 input checked attribute, without a value, works with attributes with values']() {
      this.render("<input type=\"checkbox\" checked click={{action \"someAction\"}}>", {
        actions: {
          someAction() {}
        }
      });
      this.assertPropertyHasValue('checked', true);
    }
    ['@test GH18211 input checked attribute, without a value, works with event attributes']() {
      this.render("<input type=\"checkbox\" checked onclick={{action \"someAction\"}}>", {
        actions: {
          someAction() {}
        }
      });
      this.assertPropertyHasValue('checked', true);
    }

    // private helpers and assertions
    setDOMValue(value) {
      this.inputElement().value = value;
    }
    setComponentValue(value) {
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'value', value));
    }
    setSelectionRange(start, end) {
      this.inputElement().selectionStart = start;
      this.inputElement().selectionEnd = end;
    }
    inputElement() {
      return this.$inputElement()[0];
    }
    $inputElement() {
      return this.$('input');
    }
    assertValue(value, message) {
      this.assertPropertyHasValue('value', value, message);
    }
    assertAttributeHasValue(attribute, value, message) {
      this.assert.equal(this.$inputElement().attr(attribute), value, attribute + " " + message);
    }
    assertPropertyHasValue(property, value, message) {
      this.assert.equal(this.$inputElement().prop(property), value, property + " " + message);
    }
    assertSelectionRange(start, end) {
      this.assert.equal(this.inputElement().selectionStart, start);
      this.assert.equal(this.inputElement().selectionEnd, end);
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/modifiers/on-test", ["internal-test-helpers", "@glimmer/manager", "@glimmer/runtime", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _manager, _runtime, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('{{on}} Modifier', class extends _internalTestHelpers.RenderingTestCase {
    beforeEach() {
      // might error if getOnManagerInstance fails
      this.startingCounters = this.getOnManagerInstance().counters;
    }
    getOnManagerInstance() {
      // leveraging private APIs, this can be deleted if these APIs change
      // but it has been useful to verify some internal details
      return (0, _manager.getInternalModifierManager)(_runtime.on);
    }
    assertCounts(expected) {
      let {
        counters
      } = this.getOnManagerInstance();
      this.assert.deepEqual(counters, {
        adds: expected.adds + this.startingCounters.adds,
        removes: expected.removes + this.startingCounters.removes
      }, "counters have incremented by " + JSON.stringify(expected));
    }
    ['@test it adds an event listener'](assert) {
      let count = 0;
      this.render('<button {{on "click" this.callback}}>Click Me</button>', {
        callback() {
          count++;
        }
      });
      assert.equal(count, 0, 'not called on initial render');
      this.assertStableRerender();
      this.assertCounts({
        adds: 1,
        removes: 0
      });
      assert.equal(count, 0, 'not called on a rerender');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 1, 'has been called 1 time');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 2, 'has been called 2 times');
      this.assertCounts({
        adds: 1,
        removes: 0
      });
    }
    '@test passes the event to the listener'(assert) {
      let event;
      this.render('<button {{on "click" this.callback}}>Click Me</button>', {
        callback(evt) {
          event = evt;
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.strictEqual(event.target, this.element.querySelector('button'), 'has a valid event with a target');
      this.assertCounts({
        adds: 1,
        removes: 0
      });
    }
    '@test the listener callback is bound'(assert) {
      let first = 0;
      let second = 0;
      let firstCallback = () => first++;
      let secondCallback = () => second++;
      this.render('<button {{on "click" this.callback}}>Click Me</button>', {
        callback: firstCallback
      });
      assert.equal(first, 0, 'precond - first not called on initial render');
      assert.equal(second, 0, 'precond - second not called on initial render');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(first, 1, 'first has been called 1 time');
      assert.equal(second, 0, 'second not called on initial render');
      (0, _internalTestHelpers.runTask)(() => this.context.set('callback', secondCallback));
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(first, 1, 'first has been called 1 time');
      assert.equal(second, 1, 'second has been called 1 times');
      this.assertCounts({
        adds: 2,
        removes: 1
      });
    }
    '@test setting once named argument ensures the callback is only called once'(assert) {
      let count = 0;
      this.render('<button {{on "click" this.callback once=true}}>Click Me</button>', {
        callback() {
          count++;
        }
      });
      assert.equal(count, 0, 'not called on initial render');
      this.assertStableRerender();
      assert.equal(count, 0, 'not called on a rerender');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 1, 'has been called 1 time');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 1, 'has been called 1 times');
      this.assertCounts({
        adds: 1,
        removes: 0
      });
    }
    '@test changing from `once=false` to `once=true` ensures the callback can only be called once'(assert) {
      let count = 0;
      this.render('<button {{on "click" this.callback once=this.once}}>Click Me</button>', {
        callback() {
          count++;
        },
        once: false
      });
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 1, 'has been called 1 time');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 2, 'has been called 2 times');
      (0, _internalTestHelpers.runTask)(() => this.context.set('once', true));
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 3, 'has been called 3 time');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 3, 'is not called again');
      this.assertCounts({
        adds: 2,
        removes: 1
      });
    }
    '@test by default bubbling is used (capture: false)'(assert) {
      this.render("\n            <div class=\"outer\" {{on 'click' this.handleOuterClick}}>\n              <div class=\"inner\" {{on 'click' this.handleInnerClick}}></div>\n            </div>\n          ", {
        handleOuterClick() {
          assert.step('outer clicked');
        },
        handleInnerClick() {
          assert.step('inner clicked');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.$('.inner').click());
      assert.verifySteps(['inner clicked', 'outer clicked'], 'uses capture: false by default');
    }
    '@test specifying capture named argument uses capture semantics'(assert) {
      this.render("\n            <div class=\"outer\" {{on 'click' this.handleOuterClick capture=true}}>\n              <div class=\"inner\" {{on 'click' this.handleInnerClick}}></div>\n            </div>\n          ", {
        handleOuterClick() {
          assert.step('outer clicked');
        },
        handleInnerClick() {
          assert.step('inner clicked');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.$('.inner').click());
      assert.verifySteps(['outer clicked', 'inner clicked'], 'capture works');
    }
    '@test can use capture and once together'(assert) {
      this.render("\n            <div class=\"outer\" {{on 'click' this.handleOuterClick once=true capture=true}}>\n              <div class=\"inner\" {{on 'click' this.handleInnerClick}}></div>\n            </div>\n          ", {
        handleOuterClick() {
          assert.step('outer clicked');
        },
        handleInnerClick() {
          assert.step('inner clicked');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.$('.inner').click());
      assert.verifySteps(['outer clicked', 'inner clicked'], 'capture works');
      (0, _internalTestHelpers.runTask)(() => this.$('.inner').click());
      assert.verifySteps(['inner clicked'], 'once works');
    }
    '@test it removes the modifier when the element is removed'(assert) {
      let count = 0;
      this.render('{{#if this.showButton}}<button {{on "click" this.callback}}>Click Me</button>{{/if}}', {
        callback() {
          count++;
        },
        showButton: true
      });
      this.assertCounts({
        adds: 1,
        removes: 0
      });
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(count, 1, 'has been called 1 time');
      (0, _internalTestHelpers.runTask)(() => this.context.set('showButton', false));
      this.assertCounts({
        adds: 1,
        removes: 1
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Rendering test: non-interactive `on` modifier', class extends _internalTestHelpers.RenderingTestCase {
    getBootOptions() {
      return {
        isInteractive: false
      };
    }
    beforeEach() {
      // might error if getOnManagerInstance fails
      this.startingCounters = this.getOnManagerInstance().counters;
    }
    getOnManagerInstance() {
      // leveraging private APIs, this can be deleted if these APIs change
      // but it has been useful to verify some internal details
      return (0, _manager.getInternalModifierManager)(_runtime.on);
    }
    assertCounts(expected) {
      let {
        counters
      } = this.getOnManagerInstance();
      this.assert.deepEqual(counters, {
        adds: expected.adds + this.startingCounters.adds,
        removes: expected.removes + this.startingCounters.removes
      }, "counters have incremented by " + JSON.stringify(expected));
    }
    ["@test doesn't trigger lifecycle hooks when non-interactive"](assert) {
      this.registerComponent('foo-bar2', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          fire() {
            assert.ok(false);
          }
        }),
        template: "<button {{on 'click' this.fire}}>Fire!</button>"
      });
      this.render('{{#if this.showButton}}<FooBar2 />{{/if}}', {
        showButton: true
      });
      this.assertHTML('<button>Fire!</button>');
      this.assertCounts({
        adds: 0,
        removes: 0
      });
      this.$('button').click();
      (0, _internalTestHelpers.runTask)(() => this.context.set('showButton', false));
      this.assertCounts({
        adds: 0,
        removes: 0
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/mount-test", ["internal-test-helpers", "@ember/debug", "@ember/object", "@ember/-internals/owner", "@ember/controller", "@ember/engine", "@ember/-internals/glimmer/tests/utils/debug-stack", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _debug, _object, _owner, _controller, _engine, _debugStack, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('{{mount}} single param assertion', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it asserts that only a single param is passed']() {
      expectAssertion(() => {
        this.render('{{mount "chat" "foo"}}');
      }, /You can only pass a single positional argument to the {{mount}} helper, e.g. {{mount "chat-engine"}}./i);
    }
  });
  (0, _internalTestHelpers.moduleFor)('{{mount}} assertions', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it asserts when an invalid engine name is provided']() {
      expectAssertion(() => {
        this.render('{{mount this.engineName}}', {
          engineName: {}
        });
      }, /Invalid engine name '\[object Object\]' specified, engine name must be either a string, null or undefined./i);
    }
    ['@test it asserts that the specified engine is registered']() {
      expectAssertion(() => {
        this.render('{{mount "chat"}}');
      }, /You used `{{mount 'chat'}}`, but the engine 'chat' can not be found./i);
    }
  });
  (0, _internalTestHelpers.moduleFor)('{{mount}} test', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      let engineRegistrations = this.engineRegistrations = {};
      this.add('engine:chat', _engine.default.extend({
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          Object.keys(engineRegistrations).forEach(fullName => {
            this.register(fullName, engineRegistrations[fullName]);
          });
        }
      }));
      this.addTemplate('index', '{{mount "chat"}}');
    }
    ['@test it boots an engine, instantiates its application controller, and renders its application template'](assert) {
      this.engineRegistrations['template:application'] = (0, _helpers.compile)('<h2>Chat here, {{this.username}}</h2>', {
        moduleName: 'my-app/templates/application.hbs'
      });
      let controller;
      this.engineRegistrations['controller:application'] = _controller.default.extend({
        username: 'dgeb',
        init() {
          this._super();
          controller = this;
        }
      });
      return this.visit('/').then(() => {
        assert.ok(controller, "engine's application controller has been instantiated");
        let engineInstance = (0, _owner.getOwner)(controller);
        assert.strictEqual((0, _engine.getEngineParent)(engineInstance), this.applicationInstance, 'engine instance has the application instance as its parent');
        this.assertInnerHTML('<h2>Chat here, dgeb</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'username', 'chancancode'));
        this.assertInnerHTML('<h2>Chat here, chancancode</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'username', 'dgeb'));
        this.assertInnerHTML('<h2>Chat here, dgeb</h2>');
      });
    }
    async ['@test it emits a useful backtracking re-render assertion message'](assert) {
      if (!_debug.DEBUG) {
        assert.ok(true, 'nothing to do in prod builds, assertion is stripped');
        return;
      }
      this.router.map(function () {
        this.route('route-with-mount');
      });
      this.addTemplate('index', '');
      this.addTemplate('route-with-mount', '{{mount "chat"}}');
      this.engineRegistrations['template:application'] = (0, _helpers.compile)('hi {{this.person.name}} [{{component-with-backtracking-set person=this.person}}]', {
        moduleName: 'my-app/templates/application.hbs'
      });
      this.engineRegistrations['controller:application'] = _controller.default.extend({
        person: {
          name: 'Alex',
          toString() {
            return "Person (" + this.name + ")";
          }
        }
      });
      this.engineRegistrations['template:components/component-with-backtracking-set'] = (0, _helpers.compile)('[component {{person.name}}]', {
        moduleName: 'my-app/templates/components/component-with-backtracking-set.hbs'
      });
      this.engineRegistrations['component:component-with-backtracking-set'] = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          this.set('person.name', 'Ben');
        }
      });
      let expectedBacktrackingMessage = (0, _debugStack.backtrackingMessageFor)('name', 'Person \\(Ben\\)', {
        renderTree: ['application', 'route-with-mount', 'chat', 'this.person.name']
      });
      await this.visit('/');
      return assert.rejectsAssertion(this.visit('/route-with-mount'), expectedBacktrackingMessage);
    }
    ['@test it renders with a bound engine name']() {
      this.router.map(function () {
        this.route('bound-engine-name');
      });
      let controller;
      this.add('controller:bound-engine-name', _controller.default.extend({
        engineName: null,
        init() {
          this._super();
          controller = this;
        }
      }));
      this.addTemplate('bound-engine-name', '{{mount this.engineName}}');
      this.add('engine:foo', _engine.default.extend({
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('<h2>Foo Engine</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
      this.add('engine:bar', _engine.default.extend({
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('<h2>Bar Engine</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
      return this.visit('/bound-engine-name').then(() => {
        this.assertInnerHTML('<!---->');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'engineName', 'foo'));
        this.assertInnerHTML('<h2>Foo Engine</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'engineName', undefined));
        this.assertInnerHTML('<!---->');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'engineName', 'foo'));
        this.assertInnerHTML('<h2>Foo Engine</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'engineName', 'bar'));
        this.assertInnerHTML('<h2>Bar Engine</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'engineName', 'foo'));
        this.assertInnerHTML('<h2>Foo Engine</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'engineName', null));
        this.assertInnerHTML('<!---->');
      });
    }
    ['@test it declares the event dispatcher as a singleton']() {
      this.router.map(function () {
        this.route('engine-event-dispatcher-singleton');
      });
      let controller;
      let component;
      this.add('controller:engine-event-dispatcher-singleton', _controller.default.extend({
        init() {
          this._super(...arguments);
          controller = this;
        }
      }));
      this.addTemplate('engine-event-dispatcher-singleton', '{{mount "foo"}}');
      this.add('engine:foo', _engine.default.extend({
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('<h2>Foo Engine: {{tagless-component}}</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
          this.register('component:tagless-component', _helpers.Component.extend({
            tagName: '',
            init() {
              this._super(...arguments);
              component = this;
            }
          }));
          this.register('template:components/tagless-component', (0, _helpers.compile)('Tagless Component', {
            moduleName: 'my-app/templates/components/tagless-component.hbs'
          }));
        }
      }));
      return this.visit('/engine-event-dispatcher-singleton').then(() => {
        this.assertInnerHTML('<h2>Foo Engine: Tagless Component</h2>');
        let controllerOwnerEventDispatcher = (0, _owner.getOwner)(controller).lookup('event_dispatcher:main');
        let taglessComponentOwnerEventDispatcher = (0, _owner.getOwner)(component).lookup('event_dispatcher:main');
        this.assert.strictEqual(controllerOwnerEventDispatcher, taglessComponentOwnerEventDispatcher);
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('{{mount}} params tests', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.add('engine:paramEngine', _engine.default.extend({
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('<h2>Param Engine: {{@model.foo}}</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
    }
    ['@test it renders with static parameters']() {
      this.router.map(function () {
        this.route('engine-params-static');
      });
      this.addTemplate('engine-params-static', '{{mount "paramEngine" model=(hash foo="bar")}}');
      return this.visit('/engine-params-static').then(() => {
        this.assertInnerHTML('<h2>Param Engine: bar</h2>');
      });
    }
    ['@test it renders with bound parameters']() {
      this.router.map(function () {
        this.route('engine-params-bound');
      });
      let controller;
      this.add('controller:engine-params-bound', _controller.default.extend({
        boundParamValue: null,
        init() {
          this._super();
          controller = this;
        }
      }));
      this.addTemplate('engine-params-bound', '{{mount "paramEngine" model=(hash foo=this.boundParamValue)}}');
      return this.visit('/engine-params-bound').then(() => {
        this.assertInnerHTML('<h2>Param Engine: </h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'boundParamValue', 'bar'));
        this.assertInnerHTML('<h2>Param Engine: bar</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'boundParamValue', undefined));
        this.assertInnerHTML('<h2>Param Engine: </h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'boundParamValue', 'bar'));
        this.assertInnerHTML('<h2>Param Engine: bar</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'boundParamValue', 'baz'));
        this.assertInnerHTML('<h2>Param Engine: baz</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'boundParamValue', 'bar'));
        this.assertInnerHTML('<h2>Param Engine: bar</h2>');
        (0, _internalTestHelpers.runTask)(() => (0, _object.set)(controller, 'boundParamValue', null));
        this.assertInnerHTML('<h2>Param Engine: </h2>');
      });
    }
    ['@test it renders contextual components passed as parameter values']() {
      this.router.map(function () {
        this.route('engine-params-contextual-component');
      });
      this.addComponent('foo-component', {
        template: "foo-component rendered! - {{app-bar-component}}"
      });
      this.addComponent('app-bar-component', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: 'rendered app-bar-component from the app'
      });
      this.add('engine:componentParamEngine', _engine.default.extend({
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          this._super(...arguments);
          this.register('template:application', (0, _helpers.compile)('{{@model.foo}}', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
      this.addTemplate('engine-params-contextual-component', '{{mount "componentParamEngine" model=(hash foo=(component "foo-component"))}}');
      return this.visit('/engine-params-contextual-component').then(() => {
        this.assertComponentElement(this.firstChild, {
          content: 'foo-component rendered! - rendered app-bar-component from the app'
        });
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/outlet-test", ["internal-test-helpers"], function (_internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('outlet view', class extends _internalTestHelpers.RenderingTestCase {
    constructor() {
      super(...arguments);
      let CoreOutlet = this.owner.factoryFor('view:-outlet');
      let outletTemplateFactory = this.owner.lookup('template:-outlet');
      let environment = this.owner.lookup('-environment:main');
      this.component = CoreOutlet.create({
        environment,
        template: outletTemplateFactory
      });
    }
    ['@test should not error when initial rendered template is undefined']() {
      let outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: undefined,
          template: undefined
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('');
    }
    ['@test should render the outlet when set after DOM insertion']() {
      let outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: undefined,
          template: undefined
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('');
      this.registerTemplate('application', 'HI{{outlet}}');
      outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          template: this.owner.lookup('template:application')(this.owner)
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('index', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'index',
          controller: {},
          template: this.owner.lookup('template:index')(this.owner)
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      this.assertText('HIBYE');
    }
    ['@test should render the outlet when set before DOM insertion']() {
      this.registerTemplate('application', 'HI{{outlet}}');
      let outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          template: this.owner.lookup('template:application')(this.owner)
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('index', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'index',
          controller: {},
          template: this.owner.lookup('template:index')(this.owner)
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      this.assertText('HIBYE');
    }
    ['@test outletState can pass through user code (liquid-fire initimate API) ']() {
      this.registerTemplate('outer', 'A{{#-with-dynamic-vars outletState=(identity (-get-dynamic-var "outletState"))}}B{{outlet}}D{{/-with-dynamic-vars}}E');
      this.registerTemplate('inner', 'C');

      // This looks like it doesn't do anything, but its presence
      // guarantees that the outletState gets converted from a reference
      // to a value and then back to a reference. That is what we're
      // testing here.
      this.registerHelper('identity', _ref => {
        let [a] = _ref;
        return a;
      });
      let outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'outer',
          controller: {},
          template: this.owner.lookup('template:outer')(this.owner)
        },
        outlets: {
          main: {
            render: {
              owner: this.owner,
              into: undefined,
              outlet: 'main',
              name: 'inner',
              controller: {},
              template: this.owner.lookup('template:inner')(this.owner)
            },
            outlets: Object.create(null)
          }
        }
      };
      (0, _internalTestHelpers.runTask)(() => this.component.setOutletState(outletState));
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('ABCDE');
      this.assertStableRerender();
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/refinements-test", ["ember-babel", "internal-test-helpers", "@ember/object"], function (_emberBabel, _internalTestHelpers, _object) {
  "use strict";

  var _templateObject;
  (0, _internalTestHelpers.moduleFor)('syntax refinements', class extends _internalTestHelpers.RenderingTestCase {
    ['@test block params should not be refined']() {
      this.registerHelper('foo', () => 'bar helper');
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#let this.var as |foo|}}\n        {{foo}}\n      {{/let}}\n\n      ---\n\n      {{#let this.var as |outlet|}}\n        {{outlet}}\n      {{/let}}\n\n      ---\n\n      {{#let this.var as |mount|}}\n        {{mount}}\n      {{/let}}\n\n      ---\n\n      {{#let this.var as |component|}}\n        {{component}}\n      {{/let}}\n\n      ---\n\n      {{#let this.var as |input|}}\n        {{input}}\n      {{/let}}\n\n      ---\n\n      {{#let this.var as |-with-dynamic-vars|}}\n        {{-with-dynamic-vars}}\n      {{/let}}\n\n      ---\n\n      {{#let this.var as |-in-element|}}\n        {{-in-element}}\n      {{/let}}"]))), {
        var: 'var'
      });
      this.assertText('var---var---var---var---var---var---var');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'var', 'RARRR!!!'));
      this.assertText('RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'var', 'var'));
      this.assertText('var---var---var---var---var---var---var');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/render-settled-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/runloop", "rsvp"], function (_emberBabel, _internalTestHelpers, _glimmer, _runloop, _rsvp) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3;
  (0, _internalTestHelpers.moduleFor)('renderSettled', class extends _internalTestHelpers.RenderingTestCase {
    ['@test resolves when no rendering is happening'](assert) {
      return (0, _glimmer.renderSettled)().then(() => {
        assert.ok(true, 'resolved even without rendering');
      });
    }
    ['@test resolves renderers exist but no runloops are triggered'](assert) {
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{this.foo}}"]))), {
        foo: 'bar'
      });
      return (0, _glimmer.renderSettled)().then(() => {
        assert.ok(true, 'resolved even without runloops');
      });
    }
    ['@test does not create extraneous promises'](assert) {
      let first = (0, _glimmer.renderSettled)();
      let second = (0, _glimmer.renderSettled)();
      assert.strictEqual(first, second);
      return (0, _rsvp.all)([first, second]);
    }
    ['@test resolves when rendering has completed (after property update)']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{this.foo}}"]))), {
        foo: 'bar'
      });
      this.assertText('bar');
      this.component.set('foo', 'baz');
      this.assertText('bar');
      return (0, _glimmer.renderSettled)().then(() => {
        this.assertText('baz');
      });
    }
    ['@test resolves in run loop when renderer has settled'](assert) {
      assert.expect(3);
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["{{this.foo}}"]))), {
        foo: 'bar'
      });
      this.assertText('bar');
      let promise;
      return (0, _runloop.run)(() => {
        (0, _runloop.schedule)('actions', null, () => {
          this.component.set('foo', 'set in actions');
          promise = (0, _glimmer.renderSettled)().then(() => {
            this.assertText('set in afterRender');
          });
          (0, _runloop.schedule)('afterRender', null, () => {
            this.component.set('foo', 'set in afterRender');
          });
        });

        // still not updated here
        this.assertText('bar');
        return promise;
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/svg-test", ["ember-babel", "internal-test-helpers", "@ember/object"], function (_emberBabel, _internalTestHelpers, _object) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14;
  (0, _internalTestHelpers.moduleFor)('SVG element tests', class extends _internalTestHelpers.RenderingTestCase {
    ['@test unquoted viewBox property is output'](assert) {
      let viewBoxString = '0 0 100 100';
      this.render('<div><svg viewBox={{this.model.viewBoxString}}></svg></div>', {
        model: {
          viewBoxString
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "])), viewBoxString));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "])), viewBoxString));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.viewBoxString', null));
      assert.equal(this.firstChild.getAttribute('svg'), null);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        viewBoxString
      }));
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "])), viewBoxString));
    }
    ['@test quoted viewBox property is output'](assert) {
      let viewBoxString = '0 0 100 100';
      this.render('<div><svg viewBox="{{this.model.viewBoxString}}"></svg></div>', {
        model: {
          viewBoxString
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "])), viewBoxString));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "])), viewBoxString));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.viewBoxString', null));
      assert.equal(this.firstChild.getAttribute('svg'), null);
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        viewBoxString
      }));
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "])), viewBoxString));
    }
    ['@test quoted viewBox property is concat']() {
      let viewBoxString = '100 100';
      this.render('<div><svg viewBox="0 0 {{this.model.viewBoxString}}"></svg></div>', {
        model: {
          viewBoxString
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"0 0 ", "\"></svg>\n      </div>\n    "])), viewBoxString));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"0 0 ", "\"></svg>\n      </div>\n    "])), viewBoxString));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.viewBoxString', '200 200'));
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"0 0 200 200\"></svg>\n      </div>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        viewBoxString
      }));
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg viewBox=\"0 0 ", "\"></svg>\n      </div>\n    "])), viewBoxString));
    }
    ['@test class is output']() {
      this.render("<div><svg class='{{this.model.color}} tall'></svg></div>", {
        model: {
          color: 'blue'
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg class=\"blue tall\"></svg>\n      </div>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg class=\"blue tall\"></svg>\n      </div>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model.color', 'yellow'));
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject13 || (_templateObject13 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg class=\"yellow tall\"></svg>\n      </div>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'model', {
        color: 'blue'
      }));
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject14 || (_templateObject14 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <div>\n        <svg class=\"blue tall\"></svg>\n      </div>\n    "]))));
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/syntax/each-in-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/object/proxy", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _object, _proxy, _sharedConditionalTests) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14;
  function EmptyFunction() {}
  function NonEmptyFunction() {}
  NonEmptyFunction.foo = 'bar';
  class EmptyConstructor {}
  class NonEmptyConstructor {}
  NonEmptyConstructor.foo = 'bar';
  class TogglingEachInTest extends _sharedConditionalTests.TogglingSyntaxConditionalsTest {
    templateFor(_ref) {
      let {
        cond,
        truthy,
        falsy
      } = _ref;
      return "{{#each-in " + cond + " as |key|}}" + truthy + "{{else}}" + falsy + "{{/each-in}}";
    }
  }
  class BasicEachInTest extends TogglingEachInTest {}
  class BasicSyntaxTest extends BasicEachInTest {
    get truthyValue() {
      return {
        'Not Empty': 1
      };
    }
    get falsyValue() {
      return {};
    }
  }
  class EachInProxyTest extends TogglingEachInTest {}
  (0, _internalTestHelpers.applyMixins)(BasicEachInTest, new _sharedConditionalTests.TruthyGenerator([{
    foo: 1
  }, _object.default.create({
    'Not Empty': 1
  }), [1], NonEmptyFunction, NonEmptyConstructor]), new _sharedConditionalTests.FalsyGenerator([null, undefined, false, '', 0, [], EmptyFunction, EmptyConstructor, {}, Object.create(null), Object.create({}), Object.create({
    'Not Empty': 1
  }), _object.default.create()]));
  (0, _internalTestHelpers.applyMixins)(EachInProxyTest, new _sharedConditionalTests.TruthyGenerator([_proxy.default.create({
    content: {
      'Not empty': 1
    }
  })]), new _sharedConditionalTests.FalsyGenerator([_proxy.default.create(), _proxy.default.create({
    content: null
  }), _proxy.default.create({
    content: {}
  }), _proxy.default.create({
    content: Object.create(null)
  }), _proxy.default.create({
    content: Object.create({})
  }), _proxy.default.create({
    content: Object.create({
      'Not Empty': 1
    })
  }), _proxy.default.create({
    content: _object.default.create()
  })]));

  // Truthy/Falsy tests
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with `ObjectProxy`', class extends EachInProxyTest {
    get truthyValue() {
      return _proxy.default.create({
        content: {
          'Not Empty': 1
        }
      });
    }
    get falsyValue() {
      return _proxy.default.create({
        content: null
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}}', BasicSyntaxTest);

  // Rendering tests
  class AbstractEachInTest extends _internalTestHelpers.RenderingTestCase {
    createHash( /* hash */
    ) {
      throw new Error('Not implemented: `createHash`');
    }
    makeHash(obj) {
      let {
        hash,
        delegate
      } = this.createHash(obj);
      this.hash = hash;
      this.delegate = delegate;
      return hash;
    }
    replaceHash(hash) {
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'hash', this.createHash(hash).hash));
    }
    clear() {
      return (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'hash', this.createHash({}).hash));
    }
    setProp(key, value) {
      return (0, _internalTestHelpers.runTask)(() => this.delegate.setProp(this.context, key, value));
    }
    updateNestedValue(key, innerKey, value) {
      return (0, _internalTestHelpers.runTask)(() => this.delegate.updateNestedValue(this.context, key, innerKey, value));
    }
    render(template, context) {
      if (context === void 0) {
        context = {};
      }
      if (this.hash !== undefined) {
        context.hash = this.hash;
      }
      if (this.type !== undefined) {
        context.type = this.type;
      }
      context.secretKey = 'asd';
      return super.render(template, context);
    }
  }
  class EachInTest extends AbstractEachInTest {
    ["@test it repeats the given block for each item in the hash"]() {
      this.makeHash({
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      });
      this.render("<ul>{{#each-in this.hash as |category count|}}<li>{{category}}: {{count}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      this.assertStableRerender();
      if (this.allowsSetProp) {
        // Not al backing data structures allow kvo tracking. Maps and Iterables don't
        this.setProp('Tweets', 100);
        this.assertText('Smartphones: 8203JavaScript Frameworks: InfinityTweets: 100');
      }
      this.clear();
      this.assertText('Empty!');
    }
    ["@test it can render sub-paths of each item"](assert) {
      this.makeHash({
        Smartphones: {
          reports: {
            unitsSold: 8203
          }
        },
        'JavaScript Frameworks': {
          reports: {
            unitsSold: Infinity
          }
        }
      });
      this.render("<ul>{{#each-in this.hash as |category data|}}<li>{{category}}: {{data.reports.unitsSold}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      this.assertStableRerender();
      if (this.allowsSetProp) {
        this.setProp('Tweets', {
          reports: {
            unitsSold: 100
          }
        });
        this.assertText('Smartphones: 8203JavaScript Frameworks: InfinityTweets: 100');
      }
      (0, _internalTestHelpers.runTask)(() => this.updateNestedValue('Smartphones', 'reports.unitsSold', 8204));
      assert.ok(this.textValue().indexOf('Smartphones: 8204') > -1);
      this.clear();
      this.assertText('Empty!');
    }
    ["@test it can render duplicate items"]() {
      this.makeHash({
        Smartphones: 8203,
        Tablets: 8203,
        'JavaScript Frameworks': Infinity,
        Bugs: Infinity
      });
      this.render("<ul>{{#each-in this.hash key='@identity' as |category count|}}<li>{{category}}: {{count}}</li>{{/each-in}}</ul>");
      this.assertText('Smartphones: 8203Tablets: 8203JavaScript Frameworks: InfinityBugs: Infinity');
      this.assertStableRerender();
      if (this.allowsSetProp) {
        this.setProp('Smartphones', 100);
        this.setProp('Tweets', 443115);
        this.assertText('Smartphones: 100Tablets: 8203JavaScript Frameworks: InfinityBugs: InfinityTweets: 443115');
      }
      this.clear();
      this.assertText('');
    }
    ["@test it repeats the given block when the hash is dynamic"]() {
      let {
        hash: categories
      } = this.createHash({
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      });
      let {
        hash: otherCategories
      } = this.createHash({
        Emberinios: 533462,
        Tweets: 7323
      });
      let context = {
        hashes: {
          categories,
          otherCategories,
          type: 'categories'
        }
      };
      this.render("<ul>{{#each-in (get this.hashes this.hashes.type) as |category count|}}<li>{{category}}: {{count}}</li>{{else}}Empty!{{/each-in}}</ul>", context);
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(context, 'hashes.type', 'otherCategories'));
      this.assertText('Emberinios: 533462Tweets: 7323');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(context, 'hashes.type', 'categories'));
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(context, 'hashes.type', 'nonExistent'));
      this.clear();
      this.assertText('Empty!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(context, 'hashes.type', 'categories'));
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
    }
    ['@test keying off of `undefined` does not render']() {
      this.makeHash({});
      this.render("{{#each-in this.hash as |key value|}}{{key}}: {{value.baz}}{{else}}Empty!{{/each-in}}");
      this.assertText('Empty!');
      this.assertStableRerender();
      this.replaceHash({
        bar: {
          baz: 'Here!'
        }
      });
      this.assertText('bar: Here!');
      this.clear();
      this.assertText('Empty!');
    }
    ["@test it can render items with a key of empty string"]() {
      this.makeHash({
        '': 'empty-string',
        a: 'a'
      });
      this.render("<ul>{{#each-in this.hash as |key value|}}<li>{{key}}: {{value}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText(': empty-stringa: a');
      this.assertStableRerender();
      this.clear();
      this.assertText('Empty!');
    }
    ["@test it can render items that contain keys with periods in them"]() {
      this.makeHash({
        'period.key': 'a',
        'other.period.key': 'b'
      });
      this.render("<ul>{{#each-in this.hash as |key value|}}<li>{{key}}: {{value}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText('period.key: aother.period.key: b');
      this.assertStableRerender();
      this.clear();
      this.assertText('Empty!');
    }
  }
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with POJOs', class extends EachInTest {
    constructor() {
      super(...arguments);
      this.allowsSetProp = true;
    }
    createHash(pojo) {
      return {
        hash: pojo,
        delegate: {
          setProp(context, key, value) {
            (0, _object.set)(context.hash, key, value);
          },
          updateNestedValue(context, key, innerKey, value) {
            let target = context.hash[key];
            (0, _object.set)(target, innerKey, value);
          }
        }
      };
    }
    ["@test it only iterates over an object's own properties"]() {
      let protoCategories = {
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      };
      let categories = Object.create(protoCategories);
      categories['Televisions'] = 183;
      categories['Alarm Clocks'] = 999;
      this.render("<ul>{{#each-in this.categories as |category count|}}<li>{{category}}: {{count}}</li>{{else}}Empty!{{/each-in}}</ul>", {
        categories
      });
      this.assertText('Televisions: 183Alarm Clocks: 999');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(protoCategories, 'Robots', 666);
        (0, _object.set)(categories, 'Tweets', 443115);
      });
      this.assertText('Televisions: 183Alarm Clocks: 999Tweets: 443115');
      categories = Object.create(protoCategories);
      categories['Televisions'] = 183;
      categories['Alarm Clocks'] = 999;
    }
    ["@test it does not observe direct property mutations (not going through set) on the object"]() {
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        {{#each-in this.categories as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    "]))), {
        categories: {
          Smartphones: 8203,
          'JavaScript Frameworks': Infinity
        }
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]))));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        let categories = (0, _object.get)(this.context, 'categories');
        delete categories.Smartphones;
      });
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => {
        let categories = (0, _object.get)(this.context, 'categories');
        categories['Emberinios'] = 123456;
      });
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'categories', {
          Emberinios: 123456
        });
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Emberinios: 123456</li>\n      </ul>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'categories', {
          Smartphones: 8203,
          'JavaScript Frameworks': Infinity
        });
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]))));
    }
    ['@test it skips holes in sparse arrays']() {
      let arr = [];
      arr[5] = 'foo';
      arr[6] = 'bar';
      this.render((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each-in this.arr as |key value|}}\n        [{{key}}:{{value}}]\n      {{/each-in}}"]))), {
        arr
      });
      this.assertText('[5:foo][6:bar]');
      this.assertStableRerender();
    }
    ['@test it iterate over array with `in` instead of walking over elements']() {
      let arr = [1, 2, 3];
      arr.foo = 'bar';
      this.render((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each-in this.arr as |key value|}}\n        [{{key}}:{{value}}]\n      {{/each-in}}"]))), {
        arr
      });
      this.assertText('[0:1][1:2][2:3][foo:bar]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[0:1][1:2][2:3][foo:bar]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(arr, 'zomg', 'lol');
      });
      this.assertText('[0:1][1:2][2:3][foo:bar][zomg:lol]');
      arr = [1, 2, 3];
      arr.foo = 'bar';
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arr', arr));
      this.assertText('[0:1][1:2][2:3][foo:bar]');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with EmberObjects', class extends EachInTest {
    constructor() {
      super(...arguments);
      this.allowsSetProp = true;
    }
    createHash(pojo) {
      let hash = _object.default.create(pojo);
      return {
        hash,
        delegate: {
          setProp(context, key, value) {
            (0, _object.set)(context, "hash." + key, value);
          },
          updateNestedValue(context, key, innerKey, value) {
            let target = (0, _object.get)(context.hash, key);
            (0, _object.set)(target, innerKey, value);
          }
        }
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with object proxies', class extends EachInTest {
    constructor() {
      super(...arguments);
      this.allowsSetProp = true;
    }
    createHash(pojo) {
      let hash = _proxy.default.create({
        content: pojo
      });
      return {
        hash,
        delegate: {
          setProp(context, key, value) {
            (0, _object.set)(context, "hash." + key, value);
          },
          updateNestedValue(context, key, innerKey, value) {
            let target = (0, _object.get)(context.hash, key);
            (0, _object.set)(target, innerKey, value);
          }
        }
      };
    }
    ['@test it iterates over the content, not the proxy']() {
      let content = {
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      };
      let proxy = _proxy.default.create({
        content,
        foo: 'bar'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        {{#each-in this.categories as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    "]))), {
        categories: proxy
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]))));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(proxy, 'content.Smartphones', 100);
        (0, _object.set)(proxy, 'content.Tweets', 443115);
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject9 || (_templateObject9 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(proxy, 'content', {
          Smartphones: 100,
          Tablets: 20
        });
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject10 || (_templateObject10 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>Tablets: 20</li>\n      </ul>\n    "]))));
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'categories', _proxy.default.create({
        content: {
          Smartphones: 8203,
          'JavaScript Frameworks': Infinity
        }
      })));
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject11 || (_templateObject11 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]))));
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with ES6 Maps', class extends EachInTest {
    createHash(pojo) {
      let map = new Map();
      Object.keys(pojo).forEach(key => {
        map.set(key, pojo[key]);
      });
      return {
        hash: map,
        delegate: {
          updateNestedValue(context, key, innerKey, value) {
            let target = context.hash.get(key);
            (0, _object.set)(target, innerKey, value);
          }
        }
      };
    }
    ["@test it supports having objects as keys on ES6 Maps"]() {
      let map = new Map();
      map.set({
        name: 'one'
      }, 'foo');
      map.set({
        name: 'two'
      }, 'bar');
      this.render((0, _internalTestHelpers.strip)(_templateObject12 || (_templateObject12 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        {{#each-in this.map key=\"@identity\" as |key value|}}\n          <li>{{key.name}}: {{value}}</li>\n        {{/each-in}}\n      </ul>"]))), {
        map
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject13 || (_templateObject13 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>one: foo</li>\n        <li>two: bar</li>\n      </ul>\n    "]))));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        let map = new Map();
        map.set({
          name: 'three'
        }, 'qux');
        (0, _object.set)(this.context, 'map', map);
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject14 || (_templateObject14 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      <ul>\n        <li>three: qux</li>\n      </ul>\n    "]))));
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with custom iterables', class extends EachInTest {
    createHash(pojo) {
      let ary = Object.keys(pojo).reduce((accum, key) => {
        return accum.concat([[key, pojo[key]]]);
      }, []);
      let iterable = {
        [Symbol.iterator]: () => makeIterator(ary)
      };
      return {
        hash: iterable,
        delegate: {
          updateNestedValue(context, key, innerKey, value) {
            let ary = Array.from(context.hash);
            let target = ary.find(_ref2 => {
              let [k] = _ref2;
              return k === key;
            })[1];
            (0, _object.set)(target, innerKey, value);
          }
        }
      };
    }
  });

  // Utils
  function makeIterator(ary) {
    let index = 0;
    return {
      next() {
        return index < ary.length ? {
          value: ary[index++],
          done: false
        } : {
          done: true
        };
      }
    };
  }
});
define("@ember/-internals/glimmer/tests/integration/syntax/each-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/object", "@ember/array", "@ember/array/proxy", "@ember/-internals/runtime", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _metal, _object, _array, _proxy, _runtime, _helpers, _sharedConditionalTests) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
  class ArrayDelegate {
    constructor(content, target) {
      this._array = content;
      this._target = target || this;
    }

    // The following methods are APIs used by the tests

    toArray() {
      return this._array.slice();
    }
    objectAt(idx) {
      return this._array[idx];
    }
    clear() {
      this._array.length = 0;
      this.arrayContentDidChange();
    }
    replace(idx, del, ins) {
      this._array.splice(idx, del, ...ins);
      this.arrayContentDidChange();
    }
    unshiftObject(obj) {
      this._array.unshift(obj);
      this.arrayContentDidChange();
    }
    unshiftObjects(arr) {
      this._array.unshift(...arr);
      this.arrayContentDidChange();
    }
    pushObject(obj) {
      this._array.push(obj);
      this.arrayContentDidChange();
    }
    pushObjects(arr) {
      this._array.push(...arr);
      this.arrayContentDidChange();
    }
    shiftObject() {
      let obj = this._array.shift();
      this.arrayContentDidChange();
      return obj;
    }
    popObject() {
      let obj = this._array.pop();
      this.arrayContentDidChange();
      return obj;
    }
    insertAt(idx, obj) {
      this._array.splice(idx, 0, obj);
      this.arrayContentDidChange();
    }
    removeAt(idx, len) {
      if (len === void 0) {
        len = 1;
      }
      this._array.splice(idx, len);
      this.arrayContentDidChange();
    }
    arrayContentDidChange() {
      (0, _metal.notifyPropertyChange)(this._target, '[]');
      (0, _metal.notifyPropertyChange)(this._target, 'length');
    }
    toString() {
      return "#<" + (this.constructor.name || 'UnknownArrayDelegate') + ">";
    }
    toJSON() {
      return this.toString();
    }
  }
  const makeSet = (() => {
    // IE11 does not support `new Set(items);`
    let set = new Set([1, 2, 3]);
    if (set.size === 3) {
      return items => new Set(items);
    } else {
      return items => {
        let s = new Set();
        items.forEach(value => s.add(value));
        return s;
      };
    }
  })();
  class SetDelegate extends ArrayDelegate {
    constructor(set) {
      let array = [];
      set.forEach(value => array.push(value));
      super(array, set);
      this._set = set;
    }
    arrayContentDidChange() {
      this._set.clear();
      this._array.forEach(value => this._set.add(value));
      super.arrayContentDidChange();
    }
  }
  class ForEachable extends ArrayDelegate {
    get length() {
      return this._array.length;
    }
    forEach(callback) {
      this._array.forEach(callback);
    }
  }
  let ArrayIterable;
  ArrayIterable = class extends ArrayDelegate {
    [Symbol.iterator]() {
      return this._array[Symbol.iterator]();
    }
  };
  class TogglingEachTest extends _sharedConditionalTests.TogglingSyntaxConditionalsTest {
    get truthyValue() {
      return ['non-empty'];
    }
    get falsyValue() {
      return [];
    }
  }
  class BasicEachTest extends TogglingEachTest {}
  const TRUTHY_CASES = [['hello'], (0, _array.A)(['hello']), makeSet(['hello']), new ForEachable(['hello']), _proxy.default.create({
    content: ['hello']
  }), _proxy.default.create({
    content: (0, _array.A)(['hello'])
  }), new ArrayIterable(['hello'])];
  const FALSY_CASES = [null, undefined, false, '', 0, [], (0, _array.A)([]), makeSet([]), new ForEachable([]), _proxy.default.create({
    content: []
  }), _proxy.default.create({
    content: (0, _array.A)([])
  }), new ArrayIterable([])];
  (0, _internalTestHelpers.applyMixins)(BasicEachTest, new _sharedConditionalTests.TruthyGenerator(TRUTHY_CASES), new _sharedConditionalTests.FalsyGenerator(FALSY_CASES), _sharedConditionalTests.ArrayTestCases);
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each}}', class extends BasicEachTest {
    templateFor(_ref) {
      let {
        cond,
        truthy,
        falsy
      } = _ref;
      return "{{#each " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each as}}', class extends BasicEachTest {
    templateFor(_ref2) {
      let {
        cond,
        truthy,
        falsy
      } = _ref2;
      return "{{#each " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    }
  });
  class EachEdgeCasesTest extends TogglingEachTest {}
  (0, _internalTestHelpers.applyMixins)(EachEdgeCasesTest, new _sharedConditionalTests.FalsyGenerator([true, 'hello', 1, Object, function () {}, {}, {
    foo: 'bar'
  }, Object.create(null), Object.create({}), Object.create({
    foo: 'bar'
  })]));
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each}}', class extends EachEdgeCasesTest {
    templateFor(_ref3) {
      let {
        cond,
        truthy,
        falsy
      } = _ref3;
      return "{{#each " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each as}}', class extends EachEdgeCasesTest {
    templateFor(_ref4) {
      let {
        cond,
        truthy,
        falsy
      } = _ref4;
      return "{{#each " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    }
  });
  class AbstractEachTest extends _internalTestHelpers.RenderingTestCase {
    /* abstract */
    createList( /* items */
    ) {
      throw new Error('Not implemented: `createList`');
    }
    makeList(items) {
      let {
        list,
        delegate
      } = this.createList(items);
      this.list = list;
      this.delegate = delegate;
    }
    replaceList(list) {
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'list', this.createList(list).list));
    }
    forEach(callback) {
      return this.delegate.toArray().forEach(callback);
    }
    objectAt(idx) {
      return this.delegate.objectAt(idx);
    }
    clear() {
      return this.delegate.clear();
    }
    replace(idx, del, ins) {
      return this.delegate.replace(idx, del, ins);
    }
    unshiftObject(obj) {
      return this.delegate.unshiftObject(obj);
    }
    unshiftObjects(arr) {
      return this.delegate.unshiftObjects(arr);
    }
    pushObject(obj) {
      return this.delegate.pushObject(obj);
    }
    pushObjects(arr) {
      return this.delegate.pushObjects(arr);
    }
    shiftObject() {
      return this.delegate.shiftObject();
    }
    popObject() {
      return this.delegate.popObject();
    }
    insertAt(idx, obj) {
      return this.delegate.insertAt(idx, obj);
    }
    removeAt(idx, len) {
      return this.delegate.removeAt(idx, len);
    }
    render(template, context) {
      if (context === void 0) {
        context = {};
      }
      if (this.list !== undefined) {
        context.list = this.list;
      }
      return super.render(template, context);
    }
  }
  class EachTest extends AbstractEachTest {
    /* single each */

    ['@test it repeats the given block for each item in the array']() {
      this.makeList([{
        text: 'hello'
      }]);
      this.render("{{#each this.list as |item|}}{{item.text}}{{else}}Empty{{/each}}");
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.objectAt(0), 'text', 'Hello'));
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(() => {
        this.pushObject({
          text: ' '
        });
        this.pushObject({
          text: 'World'
        });
      });
      this.assertText('Hello World');
      (0, _internalTestHelpers.runTask)(() => {
        this.pushObject({
          text: 'Earth'
        });
        this.removeAt(1);
        this.insertAt(1, {
          text: 'Globe'
        });
      });
      this.assertText('HelloGlobeWorldEarth');
      (0, _internalTestHelpers.runTask)(() => {
        this.pushObject({
          text: 'Planet'
        });
        this.removeAt(1);
        this.insertAt(1, {
          text: ' '
        });
        this.pushObject({
          text: ' '
        });
        this.pushObject({
          text: 'Earth'
        });
        this.removeAt(3);
      });
      this.assertText('Hello WorldPlanet Earth');
      (0, _internalTestHelpers.runTask)(() => {
        this.pushObject({
          text: 'Globe'
        });
        this.removeAt(1);
        this.insertAt(1, {
          text: ' '
        });
        this.pushObject({
          text: ' '
        });
        this.pushObject({
          text: 'World'
        });
        this.removeAt(2);
      });
      this.assertText('Hello Planet EarthGlobe World');
      (0, _internalTestHelpers.runTask)(() => this.replace(2, 4, [{
        text: 'my'
      }]));
      this.assertText('Hello my World');
      (0, _internalTestHelpers.runTask)(() => this.clear());
      this.assertText('Empty');
      this.replaceList([{
        text: 'hello'
      }]);
      this.assertText('hello');
    }
    ['@test it receives the index as the second parameter']() {
      this.makeList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.render("{{#each this.list as |item index|}}[{{index}}. {{item.text}}]{{/each}}");
      this.assertText('[0. hello][1. world]');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.insertAt(1, {
        text: 'my'
      }));
      this.assertText('[0. hello][1. my][2. world]');
      this.replaceList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.assertText('[0. hello][1. world]');
    }
    ['@test it accepts a string key']() {
      this.makeList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.render("{{#each this.list key='text' as |item|}}{{item.text}}{{/each}}");
      this.assertText('helloworld');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObject({
        text: 'again'
      }));
      this.assertText('helloworldagain');
      this.replaceList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.assertText('helloworld');
    }
    ['@test it accepts a numeric key']() {
      this.makeList([{
        id: 1
      }, {
        id: 2
      }]);
      this.render("{{#each this.list key='id' as |item|}}{{item.id}}{{/each}}");
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObject({
        id: 3
      }));
      this.assertText('123');
      this.replaceList([{
        id: 1
      }, {
        id: 2
      }]);
      this.assertText('12');
    }
    ['@test it can specify @index as the key']() {
      this.makeList([{
        id: 1
      }, {
        id: 2
      }]);
      this.render("{{#each this.list key='@index' as |item|}}{{item.id}}{{/each}}");
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObject({
        id: 3
      }));
      this.assertText('123');
      this.replaceList([{
        id: 1
      }, {
        id: 2
      }]);
      this.assertText('12');
    }
    ['@test it can specify @identity as the key for arrays of primitives']() {
      this.makeList([1, 2]);
      this.render("{{#each this.list key='@identity' as |item|}}{{item}}{{/each}}");
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObject(3));
      this.assertText('123');
      this.replaceList([1, 2]);
      this.assertText('12');
    }
    ['@test it can specify @identity as the key for mixed arrays of objects and primitives']() {
      this.makeList([1, {
        id: 2
      }, 3]);
      this.render("{{#each this.list key='@identity' as |item|}}{{if item.id item.id item}}{{/each}}");
      this.assertText('123');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.insertAt(2, {
        id: 4
      }));
      this.assertText('1243');
      this.replaceList([1, {
        id: 2
      }, 3]);
      this.assertText('123');
    }
    ['@test it can render duplicate primitive items']() {
      this.makeList(['a', 'a', 'a']);
      this.render("{{#each this.list as |item|}}{{item}}{{/each}}");
      this.assertText('aaa');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObject('a'));
      this.assertText('aaaa');
      (0, _internalTestHelpers.runTask)(() => this.pushObject('a'));
      this.assertText('aaaaa');
      this.replaceList(['a', 'a', 'a']);
      this.assertText('aaa');
    }
    ["@test updating and setting within #each"]() {
      this.makeList([{
        value: 1
      }, {
        value: 2
      }, {
        value: 3
      }]);
      let FooBarComponent = _helpers.Component.extend({
        init() {
          this._super(...arguments);
          this.isEven = true;
          this.tagName = 'li';
        },
        _isEven() {
          this.set('isEven', this.get('item.value') % 2 === 0);
        },
        didUpdate() {
          this._isEven();
        }
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{#if this.isEven}}{{this.item.value}}{{/if}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each this.list as |item|}}\n        <li>Prev</li>\n        {{foo-bar item=item}}\n        <li>Next</li>\n      {{/each}}\n    "]))));
      this.assertText('Prev1NextPrev2NextPrev3Next');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.objectAt(0), 'value', 3));
      this.assertText('PrevNextPrev2NextPrev3Next');
      this.replaceList([{
        value: 1
      }, {
        value: 2
      }, {
        value: 3
      }]);
      this.assertText('Prev1NextPrev2NextPrev3Next');
    }
    ['@test it can render duplicate objects']() {
      let duplicateItem = {
        text: 'foo'
      };
      this.makeList([duplicateItem, duplicateItem, {
        text: 'bar'
      }, {
        text: 'baz'
      }]);
      this.render("{{#each this.list as |item|}}{{item.text}}{{/each}}");
      this.assertText('foofoobarbaz');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObject(duplicateItem));
      this.assertText('foofoobarbazfoo');
      (0, _internalTestHelpers.runTask)(() => this.pushObject(duplicateItem));
      this.assertText('foofoobarbazfoofoo');
      this.replaceList([duplicateItem, duplicateItem, {
        text: 'bar'
      }, {
        text: 'baz'
      }]);
      this.assertText('foofoobarbaz');
    }
    ["@test it maintains DOM stability when condition changes between objects with the same keys"]() {
      this.makeList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.render("{{#each this.list key=\"text\" as |item|}}{{item.text}}{{/each}}");
      this.assertText('Hello world');
      this.takeSnapshot();
      (0, _internalTestHelpers.runTask)(() => {
        this.popObject();
        this.popObject();
        this.pushObject({
          text: ' '
        });
        this.pushObject({
          text: 'world'
        });
      });
      this.assertText('Hello world');
      this.assertInvariants();
      this.replaceList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.assertText('Hello world');
      this.assertInvariants();
    }
    ["@test it maintains DOM stability for stable keys when list is updated"]() {
      this.makeList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.render("{{#each this.list key=\"text\" as |item|}}{{item.text}}{{/each}}");
      this.assertText('Hello world');
      this.assertStableRerender();
      let oldSnapshot = this.takeSnapshot();
      (0, _internalTestHelpers.runTask)(() => {
        this.unshiftObject({
          text: ', '
        });
        this.unshiftObject({
          text: 'Hi'
        });
        this.pushObject({
          text: '!'
        });
        this.pushObject({
          text: 'earth'
        });
      });
      this.assertText('Hi, Hello world!earth');
      this.assertPartialInvariants(2, 5);
      this.replaceList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.assertText('Hello world');
      this.assertInvariants(oldSnapshot, this.takeSnapshot());
    }
    ["@test it renders all items with duplicate key values"]() {
      this.makeList([{
        text: 'Hello'
      }, {
        text: 'Hello'
      }, {
        text: 'Hello'
      }]);
      this.render("{{#each this.list key=\"text\" as |item|}}{{item.text}}{{/each}}");
      this.assertText('HelloHelloHello');
      (0, _internalTestHelpers.runTask)(() => {
        this.forEach(hash => (0, _object.set)(hash, 'text', 'Goodbye'));
      });
      this.assertText('GoodbyeGoodbyeGoodbye');
      this.replaceList([{
        text: 'Hello'
      }, {
        text: 'Hello'
      }, {
        text: 'Hello'
      }]);
      this.assertText('HelloHelloHello');
    }
    ['@test context is not changed to the inner scope inside an {{#each as}} block']() {
      this.makeList([{
        name: 'Chad'
      }, {
        name: 'Zack'
      }, {
        name: 'Asa'
      }]);
      this.render("{{this.name}}-{{#each this.list as |person|}}{{this.name}}{{/each}}-{{this.name}}", {
        name: 'Joel'
      });
      this.assertText('Joel-JoelJoelJoel-Joel');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.shiftObject());
      this.assertText('Joel-JoelJoel-Joel');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Godfrey'));
      this.assertText('Godfrey-GodfreyGodfrey-Godfrey');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Joel'));
      this.replaceList([{
        name: 'Chad'
      }, {
        name: 'Zack'
      }, {
        name: 'Asa'
      }]);
      this.assertText('Joel-JoelJoelJoel-Joel');
    }
    ['@test can access the item and the original scope']() {
      this.makeList([{
        name: 'Tom Dale'
      }, {
        name: 'Yehuda Katz'
      }, {
        name: 'Godfrey Chan'
      }]);
      this.render("{{#each this.list key=\"name\" as |person|}}[{{this.title}}: {{person.name}}]{{/each}}", {
        title: 'Seor Engineer'
      });
      this.assertText('[Seor Engineer: Tom Dale][Seor Engineer: Yehuda Katz][Seor Engineer: Godfrey Chan]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[Seor Engineer: Tom Dale][Seor Engineer: Yehuda Katz][Seor Engineer: Godfrey Chan]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.objectAt(1), 'name', 'Stefan Penner');
        this.removeAt(0);
        this.pushObject({
          name: 'Tom Dale'
        });
        this.insertAt(1, {
          name: 'Chad Hietala'
        });
        (0, _object.set)(this.context, 'title', 'Principal Engineer');
      });
      this.assertText('[Principal Engineer: Stefan Penner][Principal Engineer: Chad Hietala][Principal Engineer: Godfrey Chan][Principal Engineer: Tom Dale]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'title', 'Seor Engineer'));
      this.replaceList([{
        name: 'Tom Dale'
      }, {
        name: 'Yehuda Katz'
      }, {
        name: 'Godfrey Chan'
      }]);
      this.assertText('[Seor Engineer: Tom Dale][Seor Engineer: Yehuda Katz][Seor Engineer: Godfrey Chan]');
    }
    ['@test the scoped variable is not available outside the {{#each}} block.']() {
      this.makeList(['Yehuda']);
      this.render("{{name}}-{{#each this.list as |name|}}{{name}}{{/each}}-{{name}}");
      this.assertText('-Yehuda-');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('-Yehuda-');
      (0, _internalTestHelpers.runTask)(() => this.pushObjects([' ', 'Katz']));
      this.assertText('-Yehuda Katz-');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Tom'));
      this.assertText('-Yehuda Katz-');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Stef'));
      this.replaceList(['Yehuda']);
      this.assertText('-Yehuda-');
    }
    ['@test inverse template is displayed with context']() {
      this.makeList([]);
      this.render("{{#each this.list as |thing|}}Has Thing{{else}}No Thing {{this.otherThing}}{{/each}}", {
        otherThing: 'bar'
      });
      this.assertText('No Thing bar');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('No Thing bar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'otherThing', 'biz'));
      this.assertText('No Thing biz');
      (0, _internalTestHelpers.runTask)(() => this.pushObject('non-empty'));
      this.assertText('Has Thing');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'otherThing', 'baz'));
      this.assertText('Has Thing');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'otherThing', 'bar'));
      this.replaceList([]);
      this.assertText('No Thing bar');
    }
    ['@test content that are not initially present updates correctly GH#13983']() {
      // The root cause of this bug is that Glimmer did not call `didInitializeChildren`
      // on the inserted `TryOpcode`, causing that `TryOpcode` to have an uninitialized
      // tag. Currently the only way to observe this the "JUMP-IF-NOT-MODIFIED", i.e. by
      // wrapping it in an component.

      this.registerComponent('x-wrapper', {
        template: '{{yield}}'
      });
      this.makeList([]);
      this.render("{{#x-wrapper}}{{#each this.list as |obj|}}[{{obj.text}}]{{/each}}{{/x-wrapper}}");
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.pushObject({
        text: 'foo'
      }));
      this.assertText('[foo]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.objectAt(0), 'text', 'FOO'));
      this.assertText('[FOO]');
      (0, _internalTestHelpers.runTask)(() => this.pushObject({
        text: 'bar'
      }));
      this.assertText('[FOO][bar]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.objectAt(1), 'text', 'BAR'));
      this.assertText('[FOO][BAR]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.objectAt(1), 'text', 'baz'));
      this.assertText('[FOO][baz]');
      (0, _internalTestHelpers.runTask)(() => this.replace(1, 1, [{
        text: 'BAZ'
      }]));
      this.assertText('[FOO][BAZ]');
      this.replaceList([]);
      this.assertText('');
    }
    ['@test empty trusted content clears properly [GH#16314]']() {
      this.makeList(['hello']);
      this.render("before {{#each this.list as |value|}}{{{value}}}{{/each}} after");
      this.assertText('before hello after');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => this.pushObjects([null, ' world']));
      this.assertText('before hello world after');
      (0, _internalTestHelpers.runTask)(() => this.replace(1, 2, [undefined, ' world!']));
      this.assertText('before hello world! after');
      (0, _internalTestHelpers.runTask)(() => this.replace(1, 2, [(0, _helpers.htmlSafe)(''), ' world!!']));
      this.assertText('before hello world!! after');
      this.replaceList(['hello']);
      this.assertText('before hello after');
    }

    /* multi each */

    ['@test re-using the same variable with different {{#each}} blocks does not override each other']() {
      let admins = this.createList([{
        name: 'Tom Dale'
      }]);
      let users = this.createList([{
        name: 'Yehuda Katz'
      }]);
      this.render("Admin: {{#each this.admins key=\"name\" as |person|}}[{{person.name}}]{{/each}} User: {{#each this.users key=\"name\" as |person|}}[{{person.name}}]{{/each}}", {
        admins: admins.list,
        users: users.list
      });
      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
      (0, _internalTestHelpers.runTask)(() => {
        admins.delegate.pushObject({
          name: 'Godfrey Chan'
        });
        (0, _object.set)(users.delegate.objectAt(0), 'name', 'Stefan Penner');
      });
      this.assertText('Admin: [Tom Dale][Godfrey Chan] User: [Stefan Penner]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'admins', this.createList([{
          name: 'Tom Dale'
        }]).list);
        (0, _object.set)(this.context, 'users', this.createList([{
          name: 'Yehuda Katz'
        }]).list);
      });
      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
    }
    ["@test an outer {{#each}}'s scoped variable does not clobber an inner {{#each}}'s property if they share the same name - Issue #1315"]() {
      let content = this.createList(['X', 'Y']);
      let options = this.createList([{
        label: 'One',
        value: 1
      }, {
        label: 'Two',
        value: 2
      }]);
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each this.content as |value|}}\n        {{value}}-\n        {{#each this.options as |option|}}\n          {{option.value}}:{{option.label}}\n        {{/each}}\n      {{/each}}\n      "]))), {
        content: content.list,
        options: options.list
      });
      this.assertText('X-1:One2:TwoY-1:One2:Two');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        content.delegate.pushObject('Z');
        (0, _object.set)(options.delegate.objectAt(0), 'value', 0);
      });
      this.assertText('X-0:One2:TwoY-0:One2:TwoZ-0:One2:Two');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'content', this.createList(['X', 'Y']).list);
        (0, _object.set)(this.context, 'options', this.createList([{
          label: 'One',
          value: 1
        }, {
          label: 'Two',
          value: 2
        }]).list);
      });
      this.assertText('X-1:One2:TwoY-1:One2:Two');
    }
    ['@test the scoped variable is not available outside the {{#each}} block']() {
      let first = this.createList(['Limbo']);
      let fifth = this.createList(['Wrath']);
      let ninth = this.createList(['Treachery']);
      this.render("{{ring}}-{{#each this.first as |ring|}}{{ring}}-{{#each this.fifth as |ring|}}{{ring}}-{{#each this.ninth as |ring|}}{{ring}}-{{/each}}{{ring}}-{{/each}}{{ring}}-{{/each}}{{ring}}", {
        first: first.list,
        fifth: fifth.list,
        ninth: ninth.list
      });
      this.assertText('-Limbo-Wrath-Treachery-Wrath-Limbo-');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('-Limbo-Wrath-Treachery-Wrath-Limbo-');
      (0, _internalTestHelpers.runTask)(() => {
        fifth.delegate.insertAt(0, 'D');
      });
      this.assertText('-Limbo-D-Treachery-D-Wrath-Treachery-Wrath-Limbo-');
      (0, _internalTestHelpers.runTask)(() => {
        first.delegate.pushObject('I');
        ninth.delegate.replace(0, 1, ['K']);
      });
      this.assertText('-Limbo-D-K-D-Wrath-K-Wrath-Limbo-I-D-K-D-Wrath-K-Wrath-I-');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'first', this.createList(['Limbo']).list);
        (0, _object.set)(this.context, 'fifth', this.createList(['Wrath']).list);
        (0, _object.set)(this.context, 'ninth', this.createList(['Treachery']).list);
      });
      this.assertText('-Limbo-Wrath-Treachery-Wrath-Limbo-');
    }
    ['@test it should support {{#each this.name as |foo|}}, then {{#each foo as |bar|}}']() {
      let inner = this.createList(['caterpillar']);
      let outer = this.createList([inner.list]);
      this.render("{{#each this.name key=\"@index\" as |foo|}}{{#each foo as |bar|}}{{bar}}{{/each}}{{/each}}", {
        name: outer.list
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(() => {
        inner.delegate.replace(0, 1, ['lady']);
        outer.delegate.pushObject(this.createList(['bird']).list);
      });
      this.assertText('ladybird');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', this.createList([this.createList(['caterpillar']).list]).list));
      this.assertText('caterpillar');
    }
  }
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with native arrays', class extends EachTest {
    createList(items) {
      return {
        list: items,
        delegate: new ArrayDelegate(items, items)
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with emberA-wrapped arrays', class extends EachTest {
    createList(items) {
      let wrapped = (0, _array.A)(items);
      return {
        list: wrapped,
        delegate: wrapped
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with native Set', class extends EachTest {
    createList(items) {
      let set = makeSet(items);
      return {
        list: set,
        delegate: new SetDelegate(set)
      };
    }
    ['@test it can render duplicate primitive items'](assert) {
      assert.ok(true, 'not supported by Set');
    }
    ['@test it can render duplicate objects'](assert) {
      assert.ok(true, 'not supported by Set');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array-like objects implementing forEach', class extends EachTest {
    createList(items) {
      let forEachable = new ForEachable(items);
      return {
        list: forEachable,
        delegate: forEachable
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array-like objects implementing Symbol.iterator', class extends EachTest {
    createList(items) {
      let iterable = new ArrayIterable(items);
      return {
        list: iterable,
        delegate: iterable
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array proxies, modifying itself', class extends EachTest {
    createList(items) {
      let proxty = _proxy.default.create({
        content: (0, _array.A)(items)
      });
      return {
        list: proxty,
        delegate: proxty
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array proxies, replacing its content', class extends EachTest {
    createList(items) {
      let wrapped = (0, _array.A)(items);
      return {
        list: wrapped,
        delegate: _proxy.default.create({
          content: wrapped
        })
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array proxies, arrangedContent depends on external content', class extends EachTest {
    createList(items) {
      let wrapped = (0, _array.A)(items);
      let proxy = _proxy.default.extend({
        arrangedContent: (0, _object.computed)('wrappedItems.[]', function () {
          // Slice the items to ensure that updates must be propogated
          return this.wrappedItems.slice();
        })
      }).create({
        wrappedItems: wrapped
      });
      return {
        list: proxy,
        delegate: wrapped
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array proxies, content is updated after init', class extends EachTest {
    createList(items) {
      let wrapped = (0, _array.A)(items);
      let proxy = _proxy.default.extend({
        setup: (0, _metal.on)('init', function () {
          this.set('content', (0, _array.A)(wrapped));
        })
      }).create();
      return {
        list: proxy,
        delegate: wrapped
      };
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each as}} undefined path', class extends _internalTestHelpers.RenderingTestCase {
    ['@test keying off of `undefined` does not render']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each this.foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/each}}"]))), {
        foo: {}
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: {
          baz: ['Here!']
        }
      }));
      this.assertText('Here!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {}));
      this.assertText('');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with sparse arrays', class extends _internalTestHelpers.RenderingTestCase {
    ['@test it should itterate over holes']() {
      let sparseArray = [];
      sparseArray[3] = 'foo';
      sparseArray[4] = 'bar';
      this.render((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#each this.list as |value key|}}\n        [{{key}}:{{value}}]\n      {{/each}}"]))), {
        list: (0, _array.A)(sparseArray)
      });
      this.assertText('[0:][1:][2:][3:foo][4:bar]');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => {
        let list = (0, _object.get)(this.context, 'list');
        list.pushObject('baz');
      });
      this.assertText('[0:][1:][2:][3:foo][4:bar][5:baz]');
    }
  });

  /* globals MutationObserver: false */
  if (typeof MutationObserver === 'function') {
    (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each as}} DOM mutation test', class extends _internalTestHelpers.RenderingTestCase {
      constructor() {
        super(...arguments);
        this.observer = null;
      }
      observe(element) {
        let observer = this.observer = new MutationObserver(function () {});
        observer.observe(element, {
          childList: true,
          characterData: true
        });
      }
      teardown() {
        if (this.observer) {
          this.observer.disconnect();
        }
        super.teardown();
      }
      assertNoMutation() {
        this.assert.deepEqual(this.observer.takeRecords(), [], 'Expected no mutations');
      }
      expectMutations() {
        this.assert.ok(this.observer.takeRecords().length > 0, 'Expected some mutations');
      }
      ['@test {{#each}} should not mutate a subtree when the array has not changed [GH #14332]']() {
        let page = {
          title: 'Blog Posts'
        };
        let model = [{
          title: 'Rails is omakase'
        }, {
          title: 'Ember is omakase'
        }];
        this.render((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <h1>{{this.page.title}}</h1>\n\n          <ul id=\"posts\">\n            {{#each this.model as |post|}}\n              <li>{{post.title}}</li>\n            {{/each}}\n          </ul>\n          "]))), {
          page,
          model
        });
        this.assertHTML((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        <h1>Blog Posts</h1>\n\n        <ul id=\"posts\">\n          <li>Rails is omakase</li>\n          <li>Ember is omakase</li>\n        </ul>\n      "]))));
        this.observe(this.$('#posts')[0]);

        // MutationObserver is async
        return _runtime.RSVP.Promise.resolve(() => {
          this.assertStableRerender();
        }).then(() => {
          this.assertNoMutation();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'page', {
            title: 'Essays'
          }));
          this.assertHTML((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <h1>Essays</h1>\n\n          <ul id=\"posts\">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        "]))));
        }).then(() => {
          this.assertNoMutation();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context.page, 'title', 'Think Pieces'));
          this.assertHTML((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <h1>Think Pieces\u2122</h1>\n\n          <ul id=\"posts\">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        "]))));
        }).then(() => {
          // The last set is localized to the `page` object, so we do not expect Glimmer
          // to re-iterate the list
          this.assertNoMutation();
        });
      }
    });
  }
});
define("@ember/-internals/glimmer/tests/integration/syntax/if-unless-test", ["ember-babel", "internal-test-helpers", "@ember/array", "@ember/object", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _array, _object, _helpers, _sharedConditionalTests) {
  "use strict";

  var _templateObject, _templateObject2;
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#if}} with inverse', class extends _sharedConditionalTests.IfUnlessWithSyntaxTest {
    templateFor(_ref) {
      let {
        cond,
        truthy,
        falsy
      } = _ref;
      return "{{#if " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/if}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#unless}} with inverse', class extends _sharedConditionalTests.IfUnlessWithSyntaxTest {
    templateFor(_ref2) {
      let {
        cond,
        truthy,
        falsy
      } = _ref2;
      return "{{#unless " + cond + "}}" + falsy + "{{else}}" + truthy + "{{/unless}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#if}} and {{#unless}} without inverse', class extends _sharedConditionalTests.IfUnlessWithSyntaxTest {
    templateFor(_ref3) {
      let {
        cond,
        truthy,
        falsy
      } = _ref3;
      return "{{#if " + cond + "}}" + truthy + "{{/if}}{{#unless " + cond + "}}" + falsy + "{{/unless}}";
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#if}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test using `if` with an `{{each}}` destroys components when transitioning to and from inverse (GH #12267)'](assert) {
      let destroyedChildrenCount = 0;
      this.registerComponent('foo-bar', {
        template: '{{this.number}}',
        ComponentClass: _helpers.Component.extend({
          willDestroy() {
            this._super();
            destroyedChildrenCount++;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#if this.cond}}\n        {{#each this.numbers as |number|}}\n          {{foo-bar number=number}}\n        {{/each}}\n      {{else}}\n        Nothing Here!\n      {{/if}}"]))), {
        cond: true,
        numbers: (0, _array.A)([1, 2, 3])
      });
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', false));
      this.assertText('Nothing Here!');
      assert.equal(destroyedChildrenCount, 3, 'the children were properly destroyed');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', true));
      this.assertText('123');
    }
    ['@test looking up `undefined` property defaults to false']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#if this.foo.bar.baz}}\n        Here!\n      {{else}}\n        Nothing Here!\n      {{/if}}"]))), {
        foo: {}
      });
      this.assertText('Nothing Here!');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Nothing Here!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: {
          baz: true
        }
      }));
      this.assertText('Here!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {}));
      this.assertText('Nothing Here!');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/syntax/let-test", ["ember-babel", "internal-test-helpers", "@ember/object", "@ember/array", "@ember/object/proxy"], function (_emberBabel, _internalTestHelpers, _object, _array, _proxy) {
  "use strict";

  var _templateObject, _templateObject2;
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#let as}}', class extends _internalTestHelpers.RenderingTestCase {
    templateFor(_ref) {
      let {
        cond,
        truthy,
        falsy
      } = _ref;
      return "{{#let " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/let}}";
    }
    ['@test it renders the block if `undefined` is passed as an argument']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#let this.foo.bar.baz as |thing|}}\n          value: \"{{thing}}\"\n        {{/let}}"]))), {
        foo: {}
      });
      this.assertText('value: ""');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('value: ""');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {
        bar: {
          baz: 'Here!'
        }
      }));
      this.assertText('value: "Here!"');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'foo', {}));
      this.assertText('value: ""');
    }
    ['@test it renders the block if arguments are falsey']() {
      this.render("{{#let this.cond1 this.cond2 as |cond|}}value: \"{{this.cond1}}\"{{/let}}", {
        cond1: false
      });
      this.assertText('value: "false"');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('value: "false"');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', ''));
      this.assertText('value: ""');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', 0));
      this.assertText('value: "0"');
    }
    ['@test it yields multiple arguments in order']() {
      this.render("{{#let this.foo this.bar this.baz.name as |a b c|}}{{a}} {{b}} {{c}}{{/let}}", {
        foo: 'Seor Engineer',
        bar: '',
        baz: {
          name: 'Dale'
        }
      });
      this.assertText('Seor Engineer  Dale');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'bar', 'Tom'));
      this.assertText('Seor Engineer Tom Dale');
    }
    ['@test can access alias and original scope']() {
      this.render("{{#let this.person as |tom|}}{{this.title}}: {{tom.name}}{{/let}}", {
        title: 'Seor Engineer',
        person: {
          name: 'Tom Dale'
        }
      });
      this.assertText('Seor Engineer: Tom Dale');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Seor Engineer: Tom Dale');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'person.name', 'Yehuda Katz');
        (0, _object.set)(this.context, 'title', 'Principal Engineer');
      });
      this.assertText('Principal Engineer: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'person', {
          name: 'Tom Dale'
        });
        (0, _object.set)(this.context, 'title', 'Seor Engineer');
      });
      this.assertText('Seor Engineer: Tom Dale');
    }
    ['@test the scoped variable is not available outside the {{#let}} block.']() {
      this.render("{{name}}-{{#let this.other as |name|}}{{name}}{{/let}}-{{name}}", {
        other: 'Yehuda'
      });
      this.assertText('-Yehuda-');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('-Yehuda-');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'other', 'Chad'));
      this.assertText('-Chad-');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Tom'));
      this.assertText('-Chad-');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'other', 'Yehuda');
      });
      this.assertText('-Yehuda-');
    }
    ['@test can access alias of a proxy']() {
      this.render("{{#let this.proxy as |person|}}{{person.name}}{{/let}}", {
        proxy: _proxy.default.create({
          content: {
            name: 'Tom Dale'
          }
        })
      });
      this.assertText('Tom Dale');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Tom Dale');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.name', 'Yehuda Katz'));
      this.assertText('Yehuda Katz');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content', {
        name: 'Godfrey Chan'
      }));
      this.assertText('Godfrey Chan');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content.name', 'Stefan Penner'));
      this.assertText('Stefan Penner');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy.content', null));
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'proxy', _proxy.default.create({
        content: {
          name: 'Tom Dale'
        }
      })));
      this.assertText('Tom Dale');
    }
    ['@test can access alias of an array']() {
      this.render("{{#let this.arrayThing as |words|}}{{#each words as |word|}}{{word}}{{/each}}{{/let}}", {
        arrayThing: (0, _array.A)(['Hello', ' ', 'world'])
      });
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(() => {
        let array = (0, _object.get)(this.context, 'arrayThing');
        array.replace(0, 1, ['Goodbye']);
        (0, _array.removeAt)(array, 1);
        array.insertAt(1, ', ');
        array.pushObject('!');
      });
      this.assertText('Goodbye, world!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'arrayThing', ['Hello', ' ', 'world']));
      this.assertText('Hello world');
    }
    ['@test `attrs` can be used as a block param [GH#14678]']() {
      this.render('{{#let this.hash as |attrs|}}[{{this.hash.foo}}-{{attrs.foo}}]{{/let}}', {
        hash: {
          foo: 'foo'
        }
      });
      this.assertText('[foo-foo]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[foo-foo]');
      (0, _internalTestHelpers.runTask)(() => this.context.set('hash.foo', 'FOO'));
      this.assertText('[FOO-FOO]');
      (0, _internalTestHelpers.runTask)(() => this.context.set('hash.foo', 'foo'));
      this.assertText('[foo-foo]');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Syntax test: Multiple {{#let as}} helpers', class extends _internalTestHelpers.RenderingTestCase {
    ['@test re-using the same variable with different {{#let}} blocks does not override each other']() {
      this.render("Admin: {{#let this.admin as |person|}}{{person.name}}{{/let}} User: {{#let this.user as |person|}}{{person.name}}{{/let}}", {
        admin: {
          name: 'Tom Dale'
        },
        user: {
          name: 'Yehuda Katz'
        }
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'admin.name', 'Godfrey Chan');
        (0, _object.set)(this.context, 'user.name', 'Stefan Penner');
      });
      this.assertText('Admin: Godfrey Chan User: Stefan Penner');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'admin', {
          name: 'Tom Dale'
        });
        (0, _object.set)(this.context, 'user', {
          name: 'Yehuda Katz'
        });
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
    }
    ['@test the scoped variable is not available outside the {{#let}} block']() {
      this.render("{{ring}}-{{#let this.first as |ring|}}{{ring}}-{{#let this.fifth as |ring|}}{{ring}}-{{#let this.ninth as |ring|}}{{ring}}-{{/let}}{{ring}}-{{/let}}{{ring}}-{{/let}}{{ring}}", {
        first: 'Limbo',
        fifth: 'Wrath',
        ninth: 'Treachery'
      });
      this.assertText('-Limbo-Wrath-Treachery-Wrath-Limbo-');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('-Limbo-Wrath-Treachery-Wrath-Limbo-');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'fifth', 'D');
      });
      this.assertText('-Limbo-D-Treachery-D-Limbo-');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'first', 'I');
        (0, _object.set)(this.context, 'ninth', 'K');
      });
      this.assertText('-I-D-K-D-I-');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'first', 'Limbo');
        (0, _object.set)(this.context, 'fifth', 'Wrath');
        (0, _object.set)(this.context, 'ninth', 'Treachery');
      });
      this.assertText('-Limbo-Wrath-Treachery-Wrath-Limbo-');
    }
    ['@test it should support {{#let name as |foo|}}, then {{#let foo as |bar|}}']() {
      this.render("{{#let this.name as |foo|}}{{#let foo as |bar|}}{{bar}}{{/let}}{{/let}}", {
        name: 'caterpillar'
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'butterfly'));
      this.assertText('butterfly');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'caterpillar'));
      this.assertText('caterpillar');
    }
    ['@test updating the context should update the alias']() {
      this.render("{{#let this as |person|}}{{person.name}}{{/let}}", {
        name: 'Los Pivots'
      });
      this.assertText('Los Pivots');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('Los Pivots');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', "l'Pivots"));
      this.assertText("l'Pivots");
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'Los Pivots'));
      this.assertText('Los Pivots');
    }
    ['@test nested {{#let}} blocks should have access to root context']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{name}}\n        {{#let this.committer1.name as |name|}}\n          [{{name}}\n          {{#let this.committer2.name as |name|}}\n            [{{name}}]\n          {{/let}}\n          {{name}}]\n        {{/let}}\n        {{name}}\n        {{#let this.committer2.name as |name|}}\n          [{{name}}\n          {{#let this.committer1.name as |name|}}\n            [{{name}}]\n          {{/let}}\n          {{name}}]\n        {{/let}}\n        {{name}}\n      "]))), {
        name: 'ebryn',
        committer1: {
          name: 'trek'
        },
        committer2: {
          name: 'machty'
        }
      });
      this.assertText('[trek[machty]trek][machty[trek]machty]');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('[trek[machty]trek][machty[trek]machty]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'name', 'chancancode'));
      this.assertText('[trek[machty]trek][machty[trek]machty]');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'committer1', {
        name: 'krisselden'
      }));
      this.assertText('[krisselden[machty]krisselden][machty[krisselden]machty]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'committer1.name', 'wycats');
        (0, _object.set)(this.context, 'committer2', {
          name: 'rwjblue'
        });
      });
      this.assertText('[wycats[rwjblue]wycats][rwjblue[wycats]rwjblue]');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'name', 'ebryn');
        (0, _object.set)(this.context, 'committer1', {
          name: 'trek'
        });
        (0, _object.set)(this.context, 'committer2', {
          name: 'machty'
        });
      });
      this.assertText('[trek[machty]trek][machty[trek]machty]');
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/syntax/public-in-element-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/object"], function (_emberBabel, _internalTestHelpers, _glimmer, _object) {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
  (0, _internalTestHelpers.moduleFor)('{{in-element}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test allows rendering into an external element']() {
      let someElement = document.createElement('div');
      this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#in-element this.someElement}}\n            {{this.text}}\n          {{/in-element}}\n        "]))), {
        someElement,
        text: 'Whoop!'
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'Whoop!');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'Huzzah!!'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'Huzzah!!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'Whoop!'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'Whoop!');
    }
    ["@test it replaces the external element's content by default"]() {
      let someElement = document.createElement('div');
      someElement.appendChild(document.createTextNode('foo '));
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#in-element this.someElement insertBefore=undefined}}\n            {{this.text}}\n          {{/in-element}}\n        "]))), {
        someElement,
        text: 'bar'
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'bar');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'bar!!'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'bar!!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'bar'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'bar');
    }
    ['@test allows appending to the external element with insertBefore=null']() {
      let someElement = document.createElement('div');
      someElement.appendChild(document.createTextNode('foo '));
      this.render((0, _internalTestHelpers.strip)(_templateObject3 || (_templateObject3 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#in-element this.someElement insertBefore=null}}\n            {{this.text}}\n          {{/in-element}}\n        "]))), {
        someElement,
        text: 'bar'
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'foo bar');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'bar!!'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'foo bar!!');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'bar'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'foo bar');
    }
    ['@test does not allow insertBefore=non-null-value']() {
      let someElement = document.createElement('div');
      expectAssertion(() => {
        this.render((0, _internalTestHelpers.strip)(_templateObject4 || (_templateObject4 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{#in-element this.someElement insertBefore=\".foo\"}}\n              {{this.text}}\n            {{/in-element}}\n          "]))), {
          someElement,
          text: 'Whoop!'
        });
      }, /Can only pass null to insertBefore in in-element, received:/);
    }
    ['@test does not allow null as a destination element']() {
      let someElement = null;
      expectAssertion(() => {
        this.render((0, _internalTestHelpers.strip)(_templateObject5 || (_templateObject5 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{#in-element this.someElement}}\n              {{this.text}}\n            {{/in-element}}\n          "]))), {
          someElement,
          text: 'Whoop!'
        });
      }, /You cannot pass a null or undefined destination element to in-element/);
    }
    ['@test does not undefined as a destination element']() {
      let someElement = undefined;
      expectAssertion(() => {
        this.render((0, _internalTestHelpers.strip)(_templateObject6 || (_templateObject6 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n            {{#in-element this.someElement}}\n              {{this.text}}\n            {{/in-element}}\n          "]))), {
          someElement,
          text: 'Whoop!'
        });
      }, /You cannot pass a null or undefined destination element to in-element/);
    }
    ['@test components are cleaned up properly'](assert) {
      let hooks = [];
      let someElement = document.createElement('div');
      this.registerComponent('modal-display', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement() {
            hooks.push('didInsertElement');
          },
          willDestroyElement() {
            hooks.push('willDestroyElement');
          }
        }),
        template: "{{this.text}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7 || (_templateObject7 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          {{#if this.showModal}}\n            {{#in-element this.someElement}}\n              {{modal-display text=this.text}}\n            {{/in-element}}\n          {{/if}}\n        "]))), {
        someElement,
        text: 'Whoop!',
        showModal: false
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, '');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'showModal', true));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, {
        content: 'Whoop!'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'Huzzah!'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, {
        content: 'Huzzah!'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'Whoop!'));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, {
        content: 'Whoop!'
      });
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'showModal', false));
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, '');
      assert.deepEqual(hooks, ['didInsertElement', 'willDestroyElement']);
    }
    ['@test appending to the root element should not cause double clearing']() {
      this.render((0, _internalTestHelpers.strip)(_templateObject8 || (_templateObject8 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          Before\n          {{#in-element this.rootElement insertBefore=null}}\n            {{this.text}}\n          {{/in-element}}\n          After\n        "]))), {
        rootElement: this.element,
        text: 'Whoop!'
      });
      (0, _internalTestHelpers.equalTokens)(this.element, 'BeforeWhoop!<!---->After');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'text', 'Huzzah!'));
      (0, _internalTestHelpers.equalTokens)(this.element, 'BeforeHuzzah!<!---->After');

      // teardown happens in afterEach and should not cause double-clearing error
    }
  });
});
define("@ember/-internals/glimmer/tests/integration/syntax/with-dynamic-var-test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  var _templateObject, _templateObject2;
  (0, _internalTestHelpers.moduleFor)('{{-with-dynamic-var}}', class extends _internalTestHelpers.RenderingTestCase {
    ['@test does not allow setting values other than outletState']() {
      expectAssertion(() => {
        this.render((0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n        {{#-with-dynamic-vars foo=\"bar\"}}\n          {{-get-dynamic-var 'foo'}}\n        {{/-with-dynamic-vars}}\n      "]))));
      }, /Using `-with-dynamic-scope` is only supported for `outletState` \(you used `foo`\)./);
    }
    ['@test allows setting/getting outletState']() {
      // this is simply asserting that we can write and read outletState
      // the actual value being used here is not what is used in real life
      // feel free to change the value being set and asserted as needed
      this.render((0, _internalTestHelpers.strip)(_templateObject2 || (_templateObject2 = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n      {{#-with-dynamic-vars outletState=\"bar\"}}\n        {{-get-dynamic-var 'outletState'}}\n      {{/-with-dynamic-vars}}\n    "]))));
      this.assertText('bar');
    }
    ['@test does not allow getting values other than outletState']() {
      expectAssertion(() => {
        this.render("{{-get-dynamic-var 'foo'}}");
      }, /Using `-get-dynamic-scope` is only supported for `outletState` \(you used `foo`\)./);
    }
  });
});
define("@ember/-internals/glimmer/tests/unit/outlet-test", ["internal-test-helpers", "@ember/-internals/glimmer", "@ember/runloop"], function (_internalTestHelpers, _glimmer, _runloop) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Glimmer OutletView', class extends _internalTestHelpers.AbstractTestCase {
    ['@test render in the render queue'](assert) {
      let didAppendOutletView = 0;
      let expectedOutlet = '#foo.bar';
      let renderer = {
        appendOutletView(view, target) {
          didAppendOutletView++;
          assert.equal(view, outletView);
          assert.equal(target, expectedOutlet);
        }
      };
      let outletView = new _glimmer.OutletView({}, {
        lookup() {
          return renderer;
        }
      });
      (0, _runloop.run)(() => {
        assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (before appendTo)');
        outletView.appendTo(expectedOutlet);
        assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (sync after appendTo)');
        (0, _runloop.schedule)('actions', () => assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (in actions)'));
        (0, _runloop.schedule)('render', () => assert.equal(didAppendOutletView, 1, 'appendOutletView should be invoked in render'));
      });
    }
  });
});
define("@ember/-internals/glimmer/tests/unit/runtime-resolver-cache-test", ["@ember/-internals/environment", "internal-test-helpers", "@ember/object", "@ember/-internals/glimmer", "@ember/-internals/glimmer/tests/utils/helpers"], function (_environment, _internalTestHelpers, _object, _glimmer, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-glimmer runtime resolver cache', class extends _internalTestHelpers.RenderingTestCase {
    '@test a helper definition is only generated once'() {
      this.registerHelper('foo-bar', () => 'foo-bar helper!');
      this.registerHelper('baz-qux', () => 'baz-qux helper!');

      // snapshot counters
      this.getCacheCounters();
      this.render("\n          {{~#if this.cond~}}\n            {{foo-bar}}\n          {{~else~}}\n            {{baz-qux}}\n          {{~/if}}", {
        cond: true
      });
      this.assertText('foo-bar helper!');
      this.expectCacheChanges({
        helperDefinitionCount: 1,
        // from this.render
        templateCacheMisses: 1,
        // from debugRenderTree
        templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 1 : 0
      }, 'calculate foo-bar helper only');

      // show component-two for the first time
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', false));
      this.assertText('baz-qux helper!');
      this.expectCacheChanges({
        helperDefinitionCount: 1
      }, 'calculate baz-qux helper, misses cache');

      // show foo-bar again
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', true));
      this.assertText('foo-bar helper!');
      this.expectCacheChanges({}, 'toggle back to foo-bar cache hit');

      // show baz-qux again
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', false));
      this.assertText('baz-qux helper!');
      this.expectCacheChanges({}, 'toggle back to baz-qux cache hit');
    }
    '@test a component definition is only generated once'() {
      // static layout
      this.registerComponent('component-one', {
        template: 'One'
      });
      this.registerComponent('component-two', {
        ComponentClass: _helpers.Component.extend(),
        template: 'Two'
      });

      // snapshot counters
      this.getCacheCounters();

      // show component-one for the first time
      this.render("{{component this.componentName}}", {
        componentName: 'component-one'
      });
      this.assertText('One');
      this.expectCacheChanges({
        componentDefinitionCount: 1,
        // 1 from this.render, 1 from component-one
        templateCacheMisses: 2,
        // debugRenderTree
        templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 1 : 0
      }, 'test case component and component-one no change');

      // show component-two for the first time
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'component-two'));
      this.assertText('Two');
      this.expectCacheChanges({
        componentDefinitionCount: 1,
        templateCacheMisses: 1
      }, 'component-two first render');

      // show component-one again
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'component-one'));
      this.assertText('One');
      this.expectCacheChanges({}, 'toggle back to component-one no change');

      // show component-two again
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'componentName', 'component-two'));
      this.assertText('Two');
      this.expectCacheChanges({}, 'toggle back to component-two no change');
    }
    ['@test each template is only compiled once']() {
      // static layout
      this.registerComponent('component-one', {
        template: 'One'
      });

      // test directly import template factory onto late bound layout
      let Two = _helpers.Component.extend({
        layout: this.compile('Two')
      });
      this.registerComponent('component-two', {
        ComponentClass: Two
      });

      // inject layout onto component, share layout with component-one
      let Root = _helpers.Component.extend({
        layout: this.owner.lookup('template:components/component-one')
      });
      this.registerComponent('root-component', {
        ComponentClass: Root
      });

      // template instance shared between to template managers
      let rootFactory = this.owner.factoryFor('component:root-component');

      // snapshot counters
      this.getCacheCounters();

      // show component-one for the first time
      this.render("\n    {{~#if this.cond~}}\n      {{component-one}}\n    {{~else~}}\n      {{component-two}}\n    {{~/if}}", {
        cond: true
      });
      this.assertText('One');
      this.expectCacheChanges({
        componentDefinitionCount: 1,
        templateCacheMisses: 2,
        templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 1 : 0
      }, 'test case component and component-one no change');

      // show component-two for the first time
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', false));
      this.assertText('Two');
      this.expectCacheChanges({
        templateCacheMisses: 1,
        componentDefinitionCount: 1,
        templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 1 : 0
      }, 'component-two first render misses template cache');

      // show component-one again
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', true));
      this.assertText('One');
      this.expectCacheChanges({}, 'toggle back to component-one no change');

      // show component-two again
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', false));
      this.assertText('Two');
      this.expectCacheChanges({
        templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 2 : 1
      }, 'toggle back to component-two hits template cache');

      // render new root append
      let root = rootFactory.create();
      try {
        (0, _internalTestHelpers.runAppend)(root);
        this.assertText('TwoOne');
        // roots have different capabilities so this will hit
        this.expectCacheChanges({
          templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 2 : 1
        }, 'append root with component-one no change');

        // render new root append
        let root2 = rootFactory.create();
        try {
          (0, _internalTestHelpers.runAppend)(root2);
          this.assertText('TwoOneOne');
          this.expectCacheChanges({
            templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 2 : 1
          }, 'append another root no change');
        } finally {
          (0, _internalTestHelpers.runDestroy)(root2);
        }
      } finally {
        (0, _internalTestHelpers.runDestroy)(root);
      }
    }
    getCacheCounters() {
      let {
        componentDefinitionCount,
        helperDefinitionCount
      } = this.renderer._context.constants;
      return this._counters = {
        templateCacheHits: _glimmer.templateCacheCounters.cacheHit || 0,
        templateCacheMisses: _glimmer.templateCacheCounters.cacheMiss || 0,
        componentDefinitionCount,
        helperDefinitionCount
      };
    }
    expectCacheChanges(expected, message) {
      let lastState = this._counters;
      let state = this.getCacheCounters();
      let actual = diff(state, lastState);
      this.assert.deepEqual(actual, stripZeroes(expected), message);
    }
  });
  function stripZeroes(value) {
    let res = {};
    Object.keys(value).forEach(key => {
      if (value[key]) {
        res[key] = value[key];
      }
    });
    return res;
  }
  function diff(state, lastState) {
    let res = {};
    Object.keys(state).forEach(key => {
      let delta = state[key] - lastState[key];
      if (delta !== 0) {
        res[key] = state[key] - lastState[key];
      }
    });
    return res;
  }
});
define("@ember/-internals/glimmer/tests/unit/template-factory-test", ["@ember/-internals/environment", "internal-test-helpers", "@ember/-internals/glimmer", "ember-template-compiler", "@ember/-internals/glimmer/tests/utils/helpers"], function (_environment, _internalTestHelpers, _glimmer, _emberTemplateCompiler, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Template factory test', class extends _internalTestHelpers.RenderingTestCase {
    ['@test the template factory returned from precompile is the same as compile'](assert) {
      // snapshot counters
      this.getCacheCounters();
      let {
        owner
      } = this;
      let templateStr = 'Hello {{this.name}}';
      let options = {
        moduleName: 'my-app/templates/some-module.hbs'
      };
      let spec = (0, _emberTemplateCompiler.precompile)(templateStr, options);
      let body = "exports.default = template(" + spec + ");";
      let module = new Function('exports', 'template', body);
      let exports = {};
      module(exports, _glimmer.template);
      let Precompiled = exports['default'];
      let Compiled = (0, _emberTemplateCompiler.compile)(templateStr, options);
      assert.equal(typeof Precompiled, 'function', 'precompiled is a factory');
      assert.equal(typeof Compiled, 'function', 'compiled is a factory');
      this.expectCacheChanges({}, 'no changes');
      let precompiled = Precompiled(owner);
      this.expectCacheChanges({
        templateCacheMisses: 1
      }, 'misses 1');
      let compiled = Compiled(owner);
      this.expectCacheChanges({
        templateCacheMisses: 1
      }, 'misses 1');
      assert.ok(typeof precompiled.spec !== 'string', 'Spec has been parsed');
      assert.ok(typeof compiled.spec !== 'string', 'Spec has been parsed');
      this.registerComponent('x-precompiled', {
        ComponentClass: _helpers.Component.extend({
          layout: Precompiled
        })
      });
      this.registerComponent('x-compiled', {
        ComponentClass: _helpers.Component.extend({
          layout: Compiled
        })
      });
      this.render('{{x-precompiled name="precompiled"}} {{x-compiled name="compiled"}}');
      this.expectCacheChanges({
        templateCacheHits: _environment.ENV._DEBUG_RENDER_TREE ? 5 : 2,
        // from this.render
        templateCacheMisses: 1
      }, 'hits 2');
      this.assertText('Hello precompiled Hello compiled');
    }
    getCacheCounters() {
      return this._counters = {
        templateCacheHits: _glimmer.templateCacheCounters.cacheHit,
        templateCacheMisses: _glimmer.templateCacheCounters.cacheMiss
      };
    }
    expectCacheChanges(expected, message) {
      let lastState = this._counters;
      let state = this.getCacheCounters();
      let actual = diff(state, lastState);
      this.assert.deepEqual(actual, expected, message);
    }
  });
  function diff(state, lastState) {
    let res = {};
    Object.keys(state).forEach(key => {
      let delta = state[key] - lastState[key];
      if (delta !== 0) {
        res[key] = state[key] - lastState[key];
      }
    });
    return res;
  }
});
define("@ember/-internals/glimmer/tests/utils/debug-stack", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.backtrackingMessageFor = backtrackingMessageFor;
  _exports.debugStackMessageFor = debugStackMessageFor;
  function debugStackMessage(message, renderTree, includeTopLevel) {
    let topLevel = includeTopLevel ? '-top-level\n {4}' : '';
    return message + "[\\S\\s]*- While rendering:\n {2}" + topLevel + renderTree.join('\\n\\s*');
  }
  function debugStackMessageFor(message, _ref) {
    let {
      renderTree,
      includeTopLevel = true
    } = _ref;
    // Join with a regex that consumes all characters
    return new RegExp(debugStackMessage(message, renderTree, includeTopLevel));
  }
  function backtrackingMessageFor(key, obj, _temp) {
    let {
      renderTree,
      includeTopLevel = true
    } = _temp === void 0 ? {} : _temp;
    // Start off with standard backtracking assertion
    let message;
    if (obj) {
      message = "You attempted to update `" + key + "` on `" + obj + "`";
    } else {
      message = "You attempted to update `" + key + "`";
    }
    if (renderTree) {
      message = debugStackMessage(message + "[\\S\\s]*`" + key + "` was first used:", renderTree, includeTopLevel);
    }

    // Join with a regex that consumes all characters
    return new RegExp(message + "[\\S\\s]*Stack trace for the update:");
  }
});
define("@ember/-internals/glimmer/tests/utils/glimmerish-component", ["exports", "@glimmer/manager", "@ember/-internals/glimmer", "@ember/-internals/owner"], function (_exports, _manager, _glimmer, _owner) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class GlimmerishComponentManager {
    constructor(owner) {
      this.capabilities = (0, _manager.componentCapabilities)('3.13', {
        updateHook: false
      });
      this.owner = owner;
    }
    createComponent(Factory, args) {
      return new Factory(this.owner, args.named);
    }
    getContext(component) {
      return component;
    }
  }
  class GlimmerishComponent {
    constructor(owner, args) {
      (0, _owner.setOwner)(this, owner);
      this.args = args;
    }
  }
  (0, _glimmer.setComponentManager)(() => new GlimmerishComponentManager(), GlimmerishComponent);
  var _default = _exports.default = GlimmerishComponent;
});
define("@ember/-internals/glimmer/tests/utils/helpers", ["exports", "ember-template-compiler", "internal-test-helpers", "@ember/-internals/glimmer"], function (_exports, _emberTemplateCompiler, _internalTestHelpers, _glimmer) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "Component", {
    enumerable: true,
    get: function () {
      return _glimmer.Component;
    }
  });
  Object.defineProperty(_exports, "DOMChanges", {
    enumerable: true,
    get: function () {
      return _glimmer.DOMChanges;
    }
  });
  Object.defineProperty(_exports, "Helper", {
    enumerable: true,
    get: function () {
      return _glimmer.Helper;
    }
  });
  Object.defineProperty(_exports, "InertRenderer", {
    enumerable: true,
    get: function () {
      return _glimmer.InertRenderer;
    }
  });
  Object.defineProperty(_exports, "InteractiveRenderer", {
    enumerable: true,
    get: function () {
      return _glimmer.InteractiveRenderer;
    }
  });
  Object.defineProperty(_exports, "SafeString", {
    enumerable: true,
    get: function () {
      return _glimmer.SafeString;
    }
  });
  Object.defineProperty(_exports, "compile", {
    enumerable: true,
    get: function () {
      return _internalTestHelpers.compile;
    }
  });
  Object.defineProperty(_exports, "helper", {
    enumerable: true,
    get: function () {
      return _glimmer.helper;
    }
  });
  Object.defineProperty(_exports, "htmlSafe", {
    enumerable: true,
    get: function () {
      return _glimmer.htmlSafe;
    }
  });
  Object.defineProperty(_exports, "isHTMLSafe", {
    enumerable: true,
    get: function () {
      return _glimmer.isHTMLSafe;
    }
  });
  Object.defineProperty(_exports, "precompile", {
    enumerable: true,
    get: function () {
      return _emberTemplateCompiler.precompile;
    }
  });
});
define("@ember/-internals/glimmer/tests/utils/shared-conditional-tests", ["exports", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/object", "@ember/object/proxy", "@ember/array", "@ember/array/proxy", "@ember/-internals/glimmer/tests/utils/helpers"], function (_exports, _internalTestHelpers, _glimmer, _object, _proxy, _array, _proxy2, _helpers) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TruthyGenerator = _exports.TogglingSyntaxConditionalsTest = _exports.TogglingHelperConditionalsTest = _exports.TogglingConditionalsTest = _exports.StableTruthyGenerator = _exports.StableFalsyGenerator = _exports.ObjectTestCases = _exports.IfUnlessWithSyntaxTest = _exports.IfUnlessHelperTest = _exports.FalsyGenerator = _exports.BasicConditionalsTest = _exports.ArrayTestCases = void 0;
  /* eslint-disable no-new-wrappers */

  class AbstractConditionalsTest extends _internalTestHelpers.RenderingTestCase {
    get truthyValue() {
      return true;
    }
    get falsyValue() {
      return false;
    }
    wrapperFor(templates) {
      return templates.join('');
    }
    wrappedTemplateFor(options) {
      return this.wrapperFor([this.templateFor(options)]);
    }

    /* abstract */
    templateFor( /* { cond, truthy, falsy } */
    ) {
      // e.g. `{{#if ${cond}}}${truthy}{{else}}${falsy}{{/if}}`
      throw new Error('Not implemented: `templateFor`');
    }

    /* abstract */
    renderValues( /* ...values */
    ) {
      throw new Error('Not implemented: `renderValues`');
    }
  }
  class AbstractGenerator {
    constructor(cases) {
      this.cases = cases;
    }

    /* abstract */
    generate( /* value, idx */
    ) {
      throw new Error('Not implemented: `generate`');
    }
  }

  /*
    The test cases in this file generally follow the following pattern:
  
    1. Render with [ truthy, ...(other truthy variations), falsy, ...(other falsy variations) ]
    2. No-op rerender
    3. Make all of them falsy (through interior mutation)
    4. Make all of them truthy (through interior mutation, sometimes with some slight variations)
    5. Reset them to their original values (through replacement)
  */

  class TruthyGenerator extends AbstractGenerator {
    generate(value, idx) {
      return {
        ["@test it should consider " + JSON.stringify(value) + " truthy [" + idx + "]"]() {
          this.renderValues(value);
          this.assertText('T1');
          (0, _internalTestHelpers.runTask)(() => this.rerender());
          this.assertText('T1');
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.falsyValue));
          this.assertText('F1');
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', value));
          this.assertText('T1');
        }
      };
    }
  }
  _exports.TruthyGenerator = TruthyGenerator;
  class FalsyGenerator extends AbstractGenerator {
    generate(value, idx) {
      return {
        ["@test it should consider " + JSON.stringify(value) + " falsy [" + idx + "]"]() {
          this.renderValues(value);
          this.assertText('F1');
          (0, _internalTestHelpers.runTask)(() => this.rerender());
          this.assertText('F1');
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.truthyValue));
          this.assertText('T1');
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', value));
          this.assertText('F1');
        }
      };
    }
  }
  _exports.FalsyGenerator = FalsyGenerator;
  class StableTruthyGenerator extends TruthyGenerator {
    generate(value, idx) {
      return Object.assign(super.generate(value, idx), {
        ["@test it maintains DOM stability when condition changes from " + value + " to another truthy value and back [" + idx + "]"]() {
          this.renderValues(value);
          this.assertText('T1');
          this.takeSnapshot();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.truthyValue));
          this.assertText('T1');
          this.assertInvariants();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', value));
          this.assertText('T1');
          this.assertInvariants();
        }
      });
    }
  }
  _exports.StableTruthyGenerator = StableTruthyGenerator;
  class StableFalsyGenerator extends FalsyGenerator {
    generate(value, idx) {
      return Object.assign(super.generate(value), {
        ["@test it maintains DOM stability when condition changes from " + value + " to another falsy value and back [" + idx + "]"]() {
          this.renderValues(value);
          this.assertText('F1');
          this.takeSnapshot();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.falsyValue));
          this.assertText('F1');
          this.assertInvariants();
          (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', value));
          this.assertText('F1');
          this.assertInvariants();
        }
      });
    }
  }
  _exports.StableFalsyGenerator = StableFalsyGenerator;
  class ObjectProxyGenerator extends AbstractGenerator {
    generate(value, idx) {
      // This is inconsistent with our usual to-bool policy, but the current proxy implementation
      // simply uses !!content to determine truthiness
      if (value) {
        return {
          ["@test it should consider an object proxy with `" + JSON.stringify(value) + "` truthy [" + idx + "]"]() {
            this.renderValues(_proxy.default.create({
              content: value
            }));
            this.assertText('T1');
            (0, _internalTestHelpers.runTask)(() => this.rerender());
            this.assertText('T1');
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1.content', this.falsyValue));
            this.assertText('F1');
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', _proxy.default.create({
              content: value
            })));
            this.assertText('T1');
          }
        };
      } else {
        return {
          ["@test it should consider an object proxy with `" + JSON.stringify(value) + "` falsy [" + idx + "]"]() {
            this.renderValues(_proxy.default.create({
              content: value
            }));
            this.assertText('F1');
            (0, _internalTestHelpers.runTask)(() => this.rerender());
            this.assertText('F1');
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1.content', this.truthyValue));
            this.assertText('T1');
            (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', _proxy.default.create({
              content: value
            })));
            this.assertText('F1');
          }
        };
      }
    }
  }

  // Testing behaviors shared across all conditionals, i.e. {{#if}}, {{#unless}},
  // {{#each}}, {{#each-in}}, (if) and (unless)
  class BasicConditionalsTest extends AbstractConditionalsTest {
    ['@test it renders the corresponding block based on the conditional']() {
      this.renderValues(this.truthyValue, this.falsyValue);
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.falsyValue));
      this.assertText('F1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.truthyValue);
      });
      this.assertText('T1T2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.falsyValue);
      });
      this.assertText('T1F2');
    }
  }

  // Testing behaviors related to ember objects, object proxies, etc
  _exports.BasicConditionalsTest = BasicConditionalsTest;
  const ObjectTestCases = _exports.ObjectTestCases = {
    ['@test it considers object proxies without content falsy']() {
      this.renderValues(_proxy.default.create({
        content: {}
      }), _proxy.default.create({
        content: _object.default.create()
      }), _proxy.default.create({
        content: null
      }));
      this.assertText('T1T2F3');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1T2F3');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1.content', null);
        (0, _object.set)(this.context, 'cond2.content', null);
      });
      this.assertText('F1F2F3');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1.content', _object.default.create());
        (0, _object.set)(this.context, 'cond2.content', {});
        (0, _object.set)(this.context, 'cond3.content', {
          foo: 'bar'
        });
      });
      this.assertText('T1T2T3');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', _proxy.default.create({
          content: {}
        }));
        (0, _object.set)(this.context, 'cond2', _proxy.default.create({
          content: _object.default.create()
        }));
        (0, _object.set)(this.context, 'cond3', _proxy.default.create({
          content: null
        }));
      });
      this.assertText('T1T2F3');
    }
  };

  // Testing behaviors related to arrays and array proxies
  const ArrayTestCases = _exports.ArrayTestCases = {
    ['@test it considers empty arrays falsy']() {
      this.renderValues((0, _array.A)(['hello']), (0, _array.A)());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => (0, _array.removeAt)((0, _object.get)(this.context, 'cond1'), 0));
      this.assertText('F1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.get)(this.context, 'cond1').pushObject('hello');
        (0, _object.get)(this.context, 'cond2').pushObjects([1]);
      });
      this.assertText('T1T2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', (0, _array.A)(['hello']));
        (0, _object.set)(this.context, 'cond2', (0, _array.A)());
      });
      this.assertText('T1F2');
    },
    ['@test it considers array proxies without content falsy']() {
      this.renderValues(_proxy2.default.create({
        content: (0, _array.A)(['hello'])
      }), _proxy2.default.create({
        content: null
      }));
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1.content', null);
        (0, _object.set)(this.context, 'cond2.content', null);
      });
      this.assertText('F1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1.content', (0, _array.A)(['hello']));
        (0, _object.set)(this.context, 'cond2.content', (0, _array.A)([1]));
      });
      this.assertText('T1T2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', _proxy2.default.create({
          content: (0, _array.A)(['hello'])
        }));
        (0, _object.set)(this.context, 'cond2', _proxy2.default.create({
          content: null
        }));
      });
      this.assertText('T1F2');
    },
    ['@test it considers array proxies with empty arrays falsy']() {
      this.renderValues(_proxy2.default.create({
        content: (0, _array.A)(['hello'])
      }), _proxy2.default.create({
        content: (0, _array.A)()
      }));
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => (0, _array.removeAt)((0, _object.get)(this.context, 'cond1.content'), 0));
      this.assertText('F1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.get)(this.context, 'cond1.content').pushObject('hello');
        (0, _object.get)(this.context, 'cond2.content').pushObjects([1]);
      });
      this.assertText('T1T2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', _proxy2.default.create({
          content: (0, _array.A)(['hello'])
        }));
        (0, _object.set)(this.context, 'cond2', _proxy2.default.create({
          content: (0, _array.A)()
        }));
      });
      this.assertText('T1F2');
    }
  };
  const IfUnlessWithTestCases = [new StableTruthyGenerator([true, ' ', 'hello', 'false', 'null', 'undefined', 1, ['hello'], (0, _array.A)(['hello']), {}, {
    foo: 'bar'
  }, _object.default.create(), _object.default.create({
    foo: 'bar'
  }), _proxy.default.create({
    content: true
  }), Object, function () {}, async function () {}, new String('hello'), new String(''), new Boolean(true), new Boolean(false), new Date(), (0, _glimmer.htmlSafe)(' ')]), new StableFalsyGenerator([false, null, undefined, '', 0, [], (0, _array.A)(), _proxy.default.create({
    content: undefined
  }), (0, _glimmer.htmlSafe)('')]), new ObjectProxyGenerator([true, ' ', 'hello', 'false', 'null', 'undefined', 1, ['hello'], (0, _array.A)(['hello']), _proxy2.default.create({
    content: ['hello']
  }), _proxy2.default.create({
    content: []
  }), {}, {
    foo: 'bar'
  }, _object.default.create(), _object.default.create({
    foo: 'bar'
  }), _proxy.default.create({
    content: true
  }), _proxy.default.create({
    content: undefined
  }), new String('hello'), new String(''), new Boolean(true), new Boolean(false), new Date(), false, null, undefined, '', 0, [], (0, _array.A)()]), ObjectTestCases, ArrayTestCases];

  // Testing behaviors shared across the "toggling" conditionals, i.e. {{#if}},
  // {{#unless}}, {{#each}}, {{#each-in}}, (if) and (unless)
  class TogglingConditionalsTest extends BasicConditionalsTest {}

  // Testing behaviors shared across the (if) and (unless) helpers
  _exports.TogglingConditionalsTest = TogglingConditionalsTest;
  class TogglingHelperConditionalsTest extends TogglingConditionalsTest {
    renderValues() {
      let templates = [];
      let context = {};
      for (let i = 1; i <= arguments.length; i++) {
        templates.push(this.templateFor({
          cond: "this.cond" + i,
          truthy: "this.t" + i,
          falsy: "this.f" + i
        }));
        context["t" + i] = "T" + i;
        context["f" + i] = "F" + i;
        context["cond" + i] = i - 1 < 0 || arguments.length <= i - 1 ? undefined : arguments[i - 1];
      }
      let wrappedTemplate = this.wrapperFor(templates);
      this.render(wrappedTemplate, context);
    }
    ['@test it has access to the outer scope from both templates']() {
      let template = this.wrapperFor([this.templateFor({
        cond: 'this.cond1',
        truthy: 'this.truthy',
        falsy: 'this.falsy'
      }), this.templateFor({
        cond: 'this.cond2',
        truthy: 'this.truthy',
        falsy: 'this.falsy'
      })]);
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue,
        truthy: 'YES',
        falsy: 'NO'
      });
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'truthy', 'YASS');
        (0, _object.set)(this.context, 'falsy', 'NOPE');
      });
      this.assertText('YASSNOPE');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.falsyValue);
        (0, _object.set)(this.context, 'cond2', this.truthyValue);
      });
      this.assertText('NOPEYASS');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'truthy', 'YES');
        (0, _object.set)(this.context, 'falsy', 'NO');
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.falsyValue);
      });
      this.assertText('YESNO');
    }
    ['@test it does not update when the unbound helper is used']() {
      let template = this.wrapperFor([this.templateFor({
        cond: '(unbound this.cond1)',
        truthy: '"T1"',
        falsy: '"F1"'
      }), this.templateFor({
        cond: '(unbound this.cond2)',
        truthy: '"T2"',
        falsy: '"F2"'
      })]);
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.falsyValue));
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.truthyValue);
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.falsyValue);
      });
      this.assertText('T1F2');
    }
    ['@test evaluation should be lazy'](assert) {
      let truthyEvaluated;
      let falsyEvaluated;
      let withoutEvaluatingTruthy = callback => {
        truthyEvaluated = false;
        callback();
        assert.ok(!truthyEvaluated, 'x-truthy is not evaluated');
      };
      let withoutEvaluatingFalsy = callback => {
        falsyEvaluated = false;
        callback();
        assert.ok(!falsyEvaluated, 'x-falsy is not evaluated');
      };
      this.registerHelper('x-truthy', {
        compute() {
          truthyEvaluated = true;
          return 'T';
        }
      });
      this.registerHelper('x-falsy', {
        compute() {
          falsyEvaluated = true;
          return 'F';
        }
      });
      let template = this.wrappedTemplateFor({
        cond: 'this.cond',
        // pass values so the helpers don't eagerly compute
        truthy: '(x-truthy this.foo)',
        falsy: '(x-falsy this.foo)'
      });
      withoutEvaluatingFalsy(() => this.render(template, {
        cond: this.truthyValue
      }));
      this.assertText('T');
      withoutEvaluatingFalsy(() => (0, _internalTestHelpers.runTask)(() => this.rerender()));
      this.assertText('T');
      withoutEvaluatingTruthy(() => (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', this.falsyValue)));
      this.assertText('F');
      withoutEvaluatingTruthy(() => (0, _internalTestHelpers.runTask)(() => this.rerender()));
      this.assertText('F');
      withoutEvaluatingFalsy(() => (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', this.truthyValue)));
      this.assertText('T');
    }
  }
  _exports.TogglingHelperConditionalsTest = TogglingHelperConditionalsTest;
  class IfUnlessHelperTest extends TogglingHelperConditionalsTest {}
  _exports.IfUnlessHelperTest = IfUnlessHelperTest;
  (0, _internalTestHelpers.applyMixins)(IfUnlessHelperTest, ...IfUnlessWithTestCases);

  // Testing behaviors shared across the "toggling" syntatical constructs,
  // i.e. {{#if}}, {{#unless}}, {{#each}} and {{#each-in}}
  class TogglingSyntaxConditionalsTest extends TogglingConditionalsTest {
    renderValues() {
      let templates = [];
      let context = {};
      for (let i = 1; i <= arguments.length; i++) {
        templates.push(this.templateFor({
          cond: "this.cond" + i,
          truthy: "{{this.t}}" + i,
          falsy: "{{this.f}}" + i
        }));
        context["cond" + i] = i - 1 < 0 || arguments.length <= i - 1 ? undefined : arguments[i - 1];
      }
      let wrappedTemplate = this.wrapperFor(templates);
      this.render(wrappedTemplate, Object.assign({
        t: 'T',
        f: 'F'
      }, context));
    }
    ['@test it does not update when the unbound helper is used']() {
      let template = "" + this.templateFor({
        cond: '(unbound this.cond1)',
        truthy: 'T1',
        falsy: 'F1'
      }) + this.templateFor({
        cond: '(unbound this.cond2)',
        truthy: 'T2',
        falsy: 'F2'
      });
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond1', this.falsyValue));
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.truthyValue);
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.falsyValue);
      });
      this.assertText('T1F2');
    }
    ['@test it has access to the outer scope from both templates']() {
      let template = this.wrapperFor([this.templateFor({
        cond: 'this.cond1',
        truthy: '{{this.truthy}}',
        falsy: '{{this.falsy}}'
      }), this.templateFor({
        cond: 'this.cond2',
        truthy: '{{this.truthy}}',
        falsy: '{{this.falsy}}'
      })]);
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue,
        truthy: 'YES',
        falsy: 'NO'
      });
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'truthy', 'YASS');
        (0, _object.set)(this.context, 'falsy', 'NOPE');
      });
      this.assertText('YASSNOPE');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond1', this.falsyValue);
        (0, _object.set)(this.context, 'cond2', this.truthyValue);
      });
      this.assertText('NOPEYASS');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'truthy', 'YES');
        (0, _object.set)(this.context, 'falsy', 'NO');
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
        (0, _object.set)(this.context, 'cond2', this.falsyValue);
      });
      this.assertText('YESNO');
    }
    ['@test it updates correctly when enclosing another conditional']() {
      // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes
      let inner = this.templateFor({
        cond: 'this.inner',
        truthy: 'T-inner',
        falsy: 'F-inner'
      });
      let template = this.wrappedTemplateFor({
        cond: 'this.outer',
        truthy: inner,
        falsy: 'F-outer'
      });
      this.render(template, {
        outer: this.truthyValue,
        inner: this.truthyValue
      });
      this.assertText('T-inner');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('T-inner');

      // Changes the inner bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'inner', this.falsyValue));
      this.assertText('F-inner');

      // Now rerender the outer conditional, which require first clearing its bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'outer', this.falsyValue));
      this.assertText('F-outer');
    }
    ['@test it updates correctly when enclosing #each']() {
      // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes
      let template = this.wrappedTemplateFor({
        cond: 'this.outer',
        truthy: '{{#each this.inner as |text|}}{{text}}{{/each}}',
        falsy: 'F-outer'
      });
      this.render(template, {
        outer: this.truthyValue,
        inner: ['inner', '-', 'before']
      });
      this.assertText('inner-before');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('inner-before');

      // Changes the inner bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'inner', ['inner-after']));
      this.assertText('inner-after');

      // Now rerender the outer conditional, which require first clearing its bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'outer', this.falsyValue));
      this.assertText('F-outer');

      // Reset
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'inner', ['inner-again']);
        (0, _object.set)(this.context, 'outer', this.truthyValue);
      });
      this.assertText('inner-again');

      // Now clear the inner bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'inner', []));
      this.assertText('');

      // Now rerender the outer conditional, which require first clearing its bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'outer', this.falsyValue));
      this.assertText('F-outer');
    }
    ['@test it updates correctly when enclosing triple-curlies']() {
      // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes
      let template = this.wrappedTemplateFor({
        cond: 'this.outer',
        truthy: '{{{this.inner}}}',
        falsy: 'F-outer'
      });
      this.render(template, {
        outer: this.truthyValue,
        inner: '<b>inner</b>-<b>before</b>'
      });
      this.assertText('inner-before');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      this.assertText('inner-before');

      // Changes the inner bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'inner', '<p>inner-after</p>'));
      this.assertText('inner-after');

      // Now rerender the outer conditional, which require first clearing its bounds
      (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'outer', this.falsyValue));
      this.assertText('F-outer');
    }
    ['@test child conditional should not render children if parent conditional becomes false'](assert) {
      let childCreated = false;
      this.registerComponent('foo-bar', {
        template: 'foo-bar',
        ComponentClass: _helpers.Component.extend({
          init() {
            this._super(...arguments);
            childCreated = true;
          }
        })
      });
      let innerTemplate = this.templateFor({
        cond: 'this.cond2',
        truthy: '{{foo-bar}}',
        falsy: ''
      });
      let wrappedTemplate = this.wrappedTemplateFor({
        cond: 'this.cond1',
        truthy: innerTemplate,
        falsy: ''
      });
      this.render(wrappedTemplate, {
        cond1: this.truthyValue,
        cond2: this.falsyValue
      });
      assert.ok(!childCreated);
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => this.rerender());
      assert.ok(!childCreated);
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond2', this.truthyValue);
        (0, _object.set)(this.context, 'cond1', this.falsyValue);
      });
      assert.ok(!childCreated);
      this.assertText('');
      (0, _internalTestHelpers.runTask)(() => {
        (0, _object.set)(this.context, 'cond2', this.falsyValue);
        (0, _object.set)(this.context, 'cond1', this.truthyValue);
      });
      assert.ok(!childCreated);
      this.assertText('');
    }
    ['@test evaluation should be lazy'](assert) {
      let truthyEvaluated;
      let falsyEvaluated;
      let withoutEvaluatingTruthy = callback => {
        truthyEvaluated = false;
        callback();
        assert.ok(!truthyEvaluated, 'x-truthy is not evaluated');
      };
      let withoutEvaluatingFalsy = callback => {
        falsyEvaluated = false;
        callback();
        assert.ok(!falsyEvaluated, 'x-falsy is not evaluated');
      };
      this.registerHelper('x-truthy', {
        compute() {
          truthyEvaluated = true;
          return 'T';
        }
      });
      this.registerHelper('x-falsy', {
        compute() {
          falsyEvaluated = true;
          return 'F';
        }
      });
      let template = this.wrappedTemplateFor({
        cond: 'this.cond',
        truthy: '{{x-truthy}}',
        falsy: '{{x-falsy}}'
      });
      withoutEvaluatingFalsy(() => this.render(template, {
        cond: this.truthyValue
      }));
      this.assertText('T');
      withoutEvaluatingFalsy(() => (0, _internalTestHelpers.runTask)(() => this.rerender()));
      this.assertText('T');
      withoutEvaluatingTruthy(() => (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', this.falsyValue)));
      this.assertText('F');
      withoutEvaluatingTruthy(() => (0, _internalTestHelpers.runTask)(() => this.rerender()));
      this.assertText('F');
      withoutEvaluatingFalsy(() => (0, _internalTestHelpers.runTask)(() => (0, _object.set)(this.context, 'cond', this.truthyValue)));
      this.assertText('T');
    }
  }
  _exports.TogglingSyntaxConditionalsTest = TogglingSyntaxConditionalsTest;
  class IfUnlessWithSyntaxTest extends TogglingSyntaxConditionalsTest {}
  _exports.IfUnlessWithSyntaxTest = IfUnlessWithSyntaxTest;
  (0, _internalTestHelpers.applyMixins)(IfUnlessWithSyntaxTest, ...IfUnlessWithTestCases);
});
define("@ember/-internals/glimmer/tests/utils/string-test", ["internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers"], function (_internalTestHelpers, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('SafeString', class extends _internalTestHelpers.AbstractTestCase {
    ['@test htmlSafe should return an instance of SafeString']() {
      let safeString = (0, _helpers.htmlSafe)('you need to be more <b>bold</b>');
      this.assert.ok(safeString instanceof _helpers.SafeString, 'should be a SafeString');
    }
    ['@test htmlSafe should return an empty string for null']() {
      let safeString = (0, _helpers.htmlSafe)(null);
      this.assert.equal(safeString instanceof _helpers.SafeString, true, 'should be a SafeString');
      this.assert.equal(safeString.toString(), '', 'should return an empty string');
    }
    ['@test htmlSafe should return an instance of SafeString for an empty string']() {
      let safeString = (0, _helpers.htmlSafe)();
      this.assert.equal(safeString instanceof _helpers.SafeString, true, 'should be a SafeString');
      this.assert.equal(safeString.toString(), '', 'should return an empty string');
    }
  });
  (0, _internalTestHelpers.moduleFor)('SafeString isHTMLSafe', class extends _internalTestHelpers.AbstractTestCase {
    ['@test isHTMLSafe should detect SafeString']() {
      let safeString = (0, _helpers.htmlSafe)('<em>Emphasize</em> the important things.');
      this.assert.ok((0, _helpers.isHTMLSafe)(safeString));
    }
    ['@test isHTMLSafe should not detect SafeString on primatives']() {
      this.assert.notOk((0, _helpers.isHTMLSafe)('Hello World'));
      this.assert.notOk((0, _helpers.isHTMLSafe)({}));
      this.assert.notOk((0, _helpers.isHTMLSafe)([]));
      this.assert.notOk((0, _helpers.isHTMLSafe)(10));
      this.assert.notOk((0, _helpers.isHTMLSafe)(null));
    }
  });
});
define("@ember/-internals/meta/tests/listeners_test", ["internal-test-helpers", "@ember/-internals/meta"], function (_internalTestHelpers, _meta) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.meta listeners', class extends _internalTestHelpers.AbstractTestCase {
    ['@test basics'](assert) {
      let t = {};
      let m = (0, _meta.meta)({});
      m.addToListeners('hello', t, 'm', 0);
      let matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      assert.equal(matching[0], t);
      m.removeFromListeners('hello', t, 'm');
      matching = m.matchingListeners('hello');
      assert.equal(matching, undefined);
    }
    ['@test inheritance'](assert) {
      let matching;
      let target = {};
      let parent = {};
      let parentMeta = (0, _meta.meta)(parent);
      parentMeta.addToListeners('hello', target, 'm', 0);
      let child1 = Object.create(parent);
      let m1 = (0, _meta.meta)(child1);
      let child2 = Object.create(parent);
      let m2 = (0, _meta.meta)(child2);
      let child3 = Object.create(parent);
      let m3 = (0, _meta.meta)(child3);
      m3.removeFromListeners('hello', target, 'm');
      matching = m3.matchingListeners('hello');
      assert.deepEqual(matching, undefined, 'no listeners for child3');
      m3.addToListeners('hello', target, 'm', 0);
      matching = m3.matchingListeners('hello');
      assert.deepEqual(matching, [target, 'm', false], 'listener still exists for child1');
      m3.removeFromListeners('hello', target, 'm');
      matching = m3.matchingListeners('hello');
      assert.deepEqual(matching, undefined, 'no listeners for child3');
      matching = m1.matchingListeners('hello');
      assert.deepEqual(matching, [target, 'm', false], 'listener still exists for child1');
      matching = m2.matchingListeners('hello');
      assert.deepEqual(matching, [target, 'm', false], 'listener still exists for child2');
      m1.removeFromListeners('hello', target, 'm');
      matching = m1.matchingListeners('hello');
      assert.equal(matching, undefined, 'listener removed from child1');
      matching = m2.matchingListeners('hello');
      assert.deepEqual(matching, [target, 'm', false], 'listener still exists for child2');
      matching = parentMeta.matchingListeners('hello');
      assert.deepEqual(matching, [target, 'm', false], 'listener still present for parent');
    }
    ['@test deduplication'](assert) {
      let t = {};
      let m = (0, _meta.meta)({});
      m.addToListeners('hello', t, 'm', 0);
      m.addToListeners('hello', t, 'm', 0);
      let matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      assert.equal(matching[0], t);
    }
    ['@test parent caching'](assert) {
      if (false /* DEBUG */) {
        _meta.counters.flattenedListenersCalls = 0;
        _meta.counters.parentListenersUsed = 0;
      }
      class Class {}
      let classMeta = (0, _meta.meta)(Class.prototype);
      classMeta.addToListeners('hello', null, 'm', 0);
      let instance = new Class();
      let m = (0, _meta.meta)(instance);
      let matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      if (false /* DEBUG */) {
        assert.equal(_meta.counters.flattenedListenersCalls, 2);
        assert.equal(_meta.counters.parentListenersUsed, 1);
      }
      matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      if (false /* DEBUG */) {
        assert.equal(_meta.counters.flattenedListenersCalls, 3);
        assert.equal(_meta.counters.parentListenersUsed, 1);
      }
    }
    ['@test parent cache invalidation'](assert) {
      if (false /* DEBUG */) {
        _meta.counters.flattenedListenersCalls = 0;
        _meta.counters.parentListenersUsed = 0;
        _meta.counters.listenersInherited = 0;
      }
      class Class {}
      let classMeta = (0, _meta.meta)(Class.prototype);
      classMeta.addToListeners('hello', null, 'm', 0);
      let instance = new Class();
      let m = (0, _meta.meta)(instance);
      let matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      if (false /* DEBUG */) {
        assert.equal(_meta.counters.flattenedListenersCalls, 2);
        assert.equal(_meta.counters.parentListenersUsed, 1);
        assert.equal(_meta.counters.listenersInherited, 0);
      }
      m.addToListeners('hello', null, 'm2');
      matching = m.matchingListeners('hello');
      assert.equal(matching.length, 6);
      if (false /* DEBUG */) {
        assert.equal(_meta.counters.flattenedListenersCalls, 4);
        assert.equal(_meta.counters.parentListenersUsed, 1);
        assert.equal(_meta.counters.listenersInherited, 1);
      }
    }
    ['@test reopen after flatten'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(0);
        return;
      }

      // Ensure counter is zeroed
      _meta.counters.reopensAfterFlatten = 0;
      class Class1 {}
      let class1Meta = (0, _meta.meta)(Class1.prototype);
      class1Meta.addToListeners('hello', null, 'm', 0);
      let instance1 = new Class1();
      let m1 = (0, _meta.meta)(instance1);
      class Class2 {}
      let class2Meta = (0, _meta.meta)(Class2.prototype);
      class2Meta.addToListeners('hello', null, 'm', 0);
      let instance2 = new Class2();
      let m2 = (0, _meta.meta)(instance2);
      m1.matchingListeners('hello');
      m2.matchingListeners('hello');
      assert.equal(_meta.counters.reopensAfterFlatten, 0, 'no reopen calls yet');
      m1.addToListeners('world', null, 'm', 0);
      m2.addToListeners('world', null, 'm', 0);
      m1.matchingListeners('world');
      m2.matchingListeners('world');
      assert.equal(_meta.counters.reopensAfterFlatten, 1, 'reopen calls after invalidating parent cache');
      m1.addToListeners('world', null, 'm', 0);
      m2.addToListeners('world', null, 'm', 0);
      m1.matchingListeners('world');
      m2.matchingListeners('world');
      assert.equal(_meta.counters.reopensAfterFlatten, 1, 'no reopen calls after mutating leaf nodes');
      class1Meta.removeFromListeners('hello', null, 'm');
      class2Meta.removeFromListeners('hello', null, 'm');
      m1.matchingListeners('hello');
      m2.matchingListeners('hello');
      assert.equal(_meta.counters.reopensAfterFlatten, 2, 'one reopen call after mutating parents');
      class1Meta.addToListeners('hello', null, 'm', 0);
      m1.matchingListeners('hello');
      class2Meta.addToListeners('hello', null, 'm', 0);
      m2.matchingListeners('hello');
      assert.equal(_meta.counters.reopensAfterFlatten, 3, 'one reopen call after mutating parents and flattening out of order');
    }
    '@test removed listeners are removed from the underlying structure GH#1112213'(assert) {
      // this is using private API to confirm the underlying data structure is properly maintained
      // and should be changed to match the data structure as needed

      class Class1 {}
      let class1Meta = (0, _meta.meta)(Class1.prototype);
      class1Meta.addToListeners('hello', null, 'm', 0);
      let instance1 = new Class1();
      let m1 = (0, _meta.meta)(instance1);
      function listenerFunc() {}
      m1.removeFromListeners('hello', null, 'm', 0);
      m1.addToListeners('stringListener', null, 'm', 0);
      m1.addToListeners('functionListener', null, listenerFunc, 0);
      m1.removeFromListeners('functionListener', null, listenerFunc, 0);
      m1.removeFromListeners('stringListener', null, 'm', 0);
      assert.equal(m1.flattenedListeners().length, 1, 'instance listeners correctly removed, inherited listeners remain');
    }
  });
});
define("@ember/-internals/meta/tests/meta_test", ["internal-test-helpers", "@ember/-internals/meta"], function (_internalTestHelpers, _meta) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.meta', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should return the same hash for an object'](assert) {
      let obj = {};
      (0, _meta.meta)(obj).foo = 'bar';
      assert.equal((0, _meta.meta)(obj).foo, 'bar', 'returns same hash with multiple calls to Ember.meta()');
    }
    ['@test meta is not enumerable'](assert) {
      let proto, obj, props, prop;
      proto = {
        foo: 'bar'
      };
      (0, _meta.meta)(proto);
      obj = Object.create(proto);
      (0, _meta.meta)(obj);
      obj.bar = 'baz';
      props = [];
      for (prop in obj) {
        props.push(prop);
      }
      assert.deepEqual(props.sort(), ['bar', 'foo']);
      if (typeof JSON !== 'undefined' && 'stringify' in JSON) {
        try {
          JSON.stringify(obj);
        } catch (e) {
          assert.ok(false, 'meta should not fail JSON.stringify');
        }
      }
    }
  });
});
define("@ember/-internals/metal/tests/accessors/get_path_test", ["@ember/-internals/metal", "internal-test-helpers"], function (_metal, _internalTestHelpers) {
  "use strict";

  let obj;
  (0, _internalTestHelpers.moduleFor)('get with path', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        foothis: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        falseValue: false,
        emptyString: '',
        Wuz: {
          nar: 'foo'
        },
        nullValue: null
      };
    }
    teardown() {
      obj = undefined;
    }

    // ..........................................................
    // LOCAL PATHS
    //
    ['@test [obj, foo] -> obj.foo'](assert) {
      assert.deepEqual((0, _metal.get)(obj, 'foo'), obj.foo);
    }
    ['@test [obj, foo.bar] -> obj.foo.bar'](assert) {
      assert.deepEqual((0, _metal.get)(obj, 'foo.bar'), obj.foo.bar);
    }
    ['@test [obj, foothis.bar] -> obj.foothis.bar'](assert) {
      assert.deepEqual((0, _metal.get)(obj, 'foothis.bar'), obj.foothis.bar);
    }
    ['@test [obj, falseValue.notDefined] -> (undefined)'](assert) {
      assert.strictEqual((0, _metal.get)(obj, 'falseValue.notDefined'), undefined);
    }
    ['@test [obj, emptyString.length] -> 0'](assert) {
      assert.strictEqual((0, _metal.get)(obj, 'emptyString.length'), 0);
    }
    ['@test [obj, nullValue.notDefined] -> (undefined)'](assert) {
      assert.strictEqual((0, _metal.get)(obj, 'nullValue.notDefined'), undefined);
    }

    // ..........................................................
    // GLOBAL PATHS TREATED LOCAL WITH GET
    //

    ['@test [obj, Wuz] -> obj.Wuz'](assert) {
      assert.deepEqual((0, _metal.get)(obj, 'Wuz'), obj.Wuz);
    }
    ['@test [obj, Wuz.nar] -> obj.Wuz.nar'](assert) {
      assert.deepEqual((0, _metal.get)(obj, 'Wuz.nar'), obj.Wuz.nar);
    }
    ['@test [obj, Foo] -> (undefined)'](assert) {
      assert.strictEqual((0, _metal.get)(obj, 'Foo'), undefined);
    }
    ['@test [obj, Foo.bar] -> (undefined)'](assert) {
      assert.strictEqual((0, _metal.get)(obj, 'Foo.bar'), undefined);
    }
  });
});
define("@ember/-internals/metal/tests/accessors/get_properties_test", ["@ember/-internals/metal", "internal-test-helpers"], function (_metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('getProperties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test can retrieve a hash of properties from an object via an argument list or array of property names'](assert) {
      let obj = {
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      };
      assert.deepEqual((0, _metal.getProperties)(obj, 'firstName', 'lastName'), {
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, 'firstName', 'lastName'), {
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, 'lastName'), {
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj), {});
      assert.deepEqual((0, _metal.getProperties)(obj, ['firstName', 'lastName']), {
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, ['firstName']), {
        firstName: 'Steve'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, []), {});
    }
  });
});
define("@ember/-internals/metal/tests/accessors/get_test", ["@ember/-internals/environment", "@ember/object", "@ember/-internals/metal", "@ember/object/mixin", "internal-test-helpers", "@ember/runloop", "@glimmer/destroyable"], function (_environment, _object, _metal, _mixin, _internalTestHelpers, _runloop, _destroyable) {
  "use strict";

  function aget(x, y) {
    return x[y];
  }
  (0, _internalTestHelpers.moduleFor)('get', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should get arbitrary properties on an object'](assert) {
      let obj = {
        string: 'string',
        number: 23,
        boolTrue: true,
        boolFalse: false,
        nullValue: null
      };
      for (let key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        assert.equal((0, _metal.get)(obj, key), obj[key], key);
      }
    }
    ['@test should retrieve a number key on an object'](assert) {
      let obj = {
        1: 'first'
      };
      assert.equal((0, _metal.get)(obj, 1), 'first');
    }
    ['@test should retrieve an array index'](assert) {
      let arr = ['first', 'second'];
      assert.equal((0, _metal.get)(arr, 0), 'first');
      assert.equal((0, _metal.get)(arr, 1), 'second');
    }
    ['@test should retrieve an empty string key on an object'](assert) {
      let obj = {
        '': 'empty-string'
      };
      assert.equal((0, _metal.get)(obj, ''), 'empty-string');
    }
    ['@test should return undefined when passed an empty string if that key does not exist on an object'](assert) {
      let obj = {
        tomster: true
      };
      assert.equal((0, _metal.get)(obj, ''), undefined);
    }
    ['@test should not access a property more than once'](assert) {
      let count = 0;
      let obj = {
        get id() {
          return ++count;
        }
      };
      (0, _metal.get)(obj, 'id');
      assert.equal(count, 1);
    }
    ['@test should call unknownProperty on watched values if the value is undefined using getFromEmberMetal()/set()'](assert) {
      let obj = {
        unknownProperty(key) {
          assert.equal(key, 'foo', 'should pass key');
          return 'FOO';
        }
      };
      assert.equal((0, _metal.get)(obj, 'foo'), 'FOO', 'should return value from unknown');
    }
    ['@test should call unknownProperty on watched values if the value is undefined using accessors'](assert) {
      if (_environment.ENV.USES_ACCESSORS) {
        let obj = {
          unknownProperty(key) {
            assert.equal(key, 'foo', 'should pass key');
            return 'FOO';
          }
        };
        assert.equal(aget(obj, 'foo'), 'FOO', 'should return value from unknown');
      } else {
        assert.ok('SKIPPING ACCESSORS');
      }
    }
    ['@test get works with paths correctly'](assert) {
      let func = function () {};
      func.bar = 'awesome';
      let destroyedObj = _object.default.create({
        bar: 'great'
      });
      (0, _runloop.run)(() => destroyedObj.destroy());
      assert.equal((0, _metal.get)({
        foo: null
      }, 'foo.bar'), undefined);
      assert.equal((0, _metal.get)({
        foo: {
          bar: 'hello'
        }
      }, 'foo.bar.length'), 5);
      assert.equal((0, _metal.get)({
        foo: func
      }, 'foo.bar'), 'awesome');
      assert.equal((0, _metal.get)({
        foo: func
      }, 'foo.bar.length'), 7);
      assert.equal((0, _metal.get)({}, 'foo.bar.length'), undefined);
      assert.equal((0, _metal.get)(function () {}, 'foo.bar.length'), undefined);
      assert.equal((0, _metal.get)('', 'foo.bar.length'), undefined);
      assert.equal((0, _metal.get)({
        foo: destroyedObj
      }, 'foo.bar'), undefined);
    }
    ['@test warn on attempts to call get with no arguments']() {
      expectAssertion(function () {
        (0, _metal.get)('aProperty');
      }, /Get must be called with two arguments;/i);
    }
    ['@test warn on attempts to call get with only one argument']() {
      expectAssertion(function () {
        (0, _metal.get)('aProperty');
      }, /Get must be called with two arguments;/i);
    }
    ['@test warn on attempts to call get with more then two arguments']() {
      expectAssertion(function () {
        (0, _metal.get)({}, 'aProperty', true);
      }, /Get must be called with two arguments;/i);
    }
    ['@test warn on attempts to get a property of undefined']() {
      expectAssertion(function () {
        (0, _metal.get)(undefined, 'aProperty');
      }, /Cannot call get with 'aProperty' on an undefined object/i);
    }
    ['@test warn on attempts to get a property path of undefined']() {
      expectAssertion(function () {
        (0, _metal.get)(undefined, 'aProperty.on.aPath');
      }, /Cannot call get with 'aProperty.on.aPath' on an undefined object/);
    }
    ['@test warn on attempts to get a property of null']() {
      expectAssertion(function () {
        (0, _metal.get)(null, 'aProperty');
      }, /Cannot call get with 'aProperty' on an undefined object/);
    }
    ['@test warn on attempts to get a property path of null']() {
      expectAssertion(function () {
        (0, _metal.get)(null, 'aProperty.on.aPath');
      }, /Cannot call get with 'aProperty.on.aPath' on an undefined object/);
    }
    ['@test warn on attempts to use get with an unsupported property path']() {
      let obj = {};
      expectAssertion(() => (0, _metal.get)(obj, null), /The key provided to get must be a string or number, you passed null/);
      expectAssertion(() => (0, _metal.get)(obj, NaN), /The key provided to get must be a string or number, you passed NaN/);
      expectAssertion(() => (0, _metal.get)(obj, undefined), /The key provided to get must be a string or number, you passed undefined/);
      expectAssertion(() => (0, _metal.get)(obj, false), /The key provided to get must be a string or number, you passed false/);
    }

    // ..........................................................
    // BUGS
    //

    ['@test (regression) watched properties on unmodified inherited objects should still return their original value'](assert) {
      let MyMixin = _mixin.default.create({
        someProperty: 'foo',
        propertyDidChange: (0, _object.observer)('someProperty', () => {})
      });
      let baseObject = MyMixin.apply({});
      let theRealObject = Object.create(baseObject);
      assert.equal((0, _metal.get)(theRealObject, 'someProperty'), 'foo', 'should return the set value, not false');
      (0, _runloop.run)(() => (0, _destroyable.destroy)(baseObject));
    }
  });
});
define("@ember/-internals/metal/tests/accessors/set_path_test", ["@ember/-internals/environment", "@ember/-internals/metal", "internal-test-helpers"], function (_environment, _metal, _internalTestHelpers) {
  "use strict";

  let originalLookup = _environment.context.lookup;
  let lookup;
  let obj;
  function commonSetup() {
    _environment.context.lookup = lookup = {};
    obj = {
      foo: {
        bar: {
          baz: {
            biff: 'BIFF'
          }
        }
      }
    };
  }
  function commonTeardown() {
    _environment.context.lookup = originalLookup;
    obj = null;
  }
  (0, _internalTestHelpers.moduleFor)('set with path', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      commonSetup();
    }
    teardown() {
      commonTeardown();
    }
    ['@test [Foo, bar] -> Foo.bar'](assert) {
      lookup.Foo = {
        toString() {
          return 'Foo';
        }
      }; // Behave like an Ember.Namespace

      (0, _metal.set)(lookup.Foo, 'bar', 'baz');
      assert.equal((0, _metal.get)(lookup.Foo, 'bar'), 'baz');
    }

    // ..........................................................
    //
    // LOCAL PATHS

    ['@test [obj, foo] -> obj.foo'](assert) {
      (0, _metal.set)(obj, 'foo', 'BAM');
      assert.equal((0, _metal.get)(obj, 'foo'), 'BAM');
    }
    ['@test [obj, foo.bar] -> obj.foo.bar'](assert) {
      (0, _metal.set)(obj, 'foo.bar', 'BAM');
      assert.equal((0, _metal.get)(obj, 'foo.bar'), 'BAM');
    }
    ['@test ignores attempts to traverse through dangerous built-in Object properties'](assert) {
      class Inner {}
      class Example {
        constructor() {
          this.inner = new Inner();
        }
      }
      let example = new Example();
      assert.throws(() => {
        (0, _metal.set)(example, '__proto__.ohNo', 'polluted');
      }, /Property set failed: object in path "__proto__" could not be found./);
      assert.equal(Example.prototype.ohNo, undefined, 'check for prototype pollution');
      assert.throws(() => {
        (0, _metal.set)(example, 'constructor.ohNo', 'polluted');
      }, /Property set failed: object in path "constructor" could not be found./);
      assert.equal(Example.ohNo, undefined, 'check for prototype pollution');
      assert.throws(() => {
        (0, _metal.set)(example, 'inner.__proto__.ohNo', 'polluted');
      }, /Property set failed: object in path "inner.__proto__" could not be found./);
      assert.equal(Inner.prototype.ohNo, undefined, 'check for prototype pollution');
      assert.throws(() => {
        (0, _metal.set)(example, 'inner.constructor.ohNo', 'polluted');
      }, /Property set failed: object in path "inner.constructor" could not be found./);
      assert.equal(Inner.ohNo, undefined, 'check for prototype pollution');
    }
  });
  (0, _internalTestHelpers.moduleFor)('set with path - deprecated', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      commonSetup();
    }
    teardown() {
      commonTeardown();
    }

    // ..........................................................
    // DEPRECATED
    //
    ['@test [obj, bla.bla] gives a proper exception message'](assert) {
      let exceptionMessage = 'Property set failed: object in path "bla" could not be found.';
      try {
        (0, _metal.set)(obj, 'bla.bla', 'BAM');
      } catch (ex) {
        assert.equal(ex.message, exceptionMessage);
      }
    }
    ['@test set(xobj, foo.baz.bat, ...) -> EXCEPTION'](assert) {
      assert.throws(() => (0, _metal.set)(obj, 'foo.baz.bat', 'BAM'));
    }
    ['@test trySet(obj, foo.baz.bat, ...)'](assert) {
      (0, _metal.trySet)(obj, 'foo.baz.bat', 'BAM');
      assert.ok(true, 'does not raise');
    }
  });
});
define("@ember/-internals/metal/tests/accessors/set_test", ["@ember/object", "@ember/-internals/metal", "internal-test-helpers"], function (_object, _metal, _internalTestHelpers) {
  "use strict";

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  (0, _internalTestHelpers.moduleFor)('set', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should set arbitrary properties on an object'](assert) {
      let obj = {
        string: 'string',
        number: 23,
        boolTrue: true,
        boolFalse: false,
        nullValue: null,
        undefinedValue: undefined
      };
      let newObj = {};
      for (let key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        assert.equal((0, _metal.set)(newObj, key, obj[key]), obj[key], 'should return value');
        assert.ok(key in newObj, 'should have key');
        assert.ok(Object.prototype.hasOwnProperty.call(newObj, key), 'should have key');
        assert.equal((0, _metal.get)(newObj, key), obj[key], 'should set value');
      }
    }
    ['@test should set a number key on an object'](assert) {
      let obj = {};
      (0, _metal.set)(obj, 1, 'first');
      assert.equal(obj[1], 'first');
    }
    ['@test should set an array index'](assert) {
      let arr = ['first', 'second'];
      (0, _metal.set)(arr, 1, 'lol');
      assert.deepEqual(arr, ['first', 'lol']);
    }
    ['@test should call setUnknownProperty if defined and value is undefined'](assert) {
      let obj = {
        count: 0,
        unknownProperty() {
          assert.ok(false, 'should not invoke unknownProperty if setUnknownProperty is defined');
        },
        setUnknownProperty(key, value) {
          assert.equal(key, 'foo', 'should pass key');
          assert.equal(value, 'BAR', 'should pass key');
          this.count++;
          return 'FOO';
        }
      };
      assert.equal((0, _metal.set)(obj, 'foo', 'BAR'), 'BAR', 'should return set value');
      assert.equal(obj.count, 1, 'should have invoked');
    }
    ['@test warn on attempts to call set with undefined as object']() {
      expectAssertion(() => (0, _metal.set)(undefined, 'aProperty', 'BAM'), /Cannot call set with 'aProperty' on an undefined object./);
    }
    ['@test warn on attempts to call set with null as object']() {
      expectAssertion(() => (0, _metal.set)(null, 'aProperty', 'BAM'), /Cannot call set with 'aProperty' on an undefined object./);
    }
    ['@test warn on attempts to use set with an unsupported property path']() {
      let obj = {};
      expectAssertion(() => (0, _metal.set)(obj, null, 42), /The key provided to set must be a string or number, you passed null/);
      expectAssertion(() => (0, _metal.set)(obj, NaN, 42), /The key provided to set must be a string or number, you passed NaN/);
      expectAssertion(() => (0, _metal.set)(obj, undefined, 42), /The key provided to set must be a string or number, you passed undefined/);
      expectAssertion(() => (0, _metal.set)(obj, false, 42), /The key provided to set must be a string or number, you passed false/);
    }
    ['@test warn on attempts of calling set on a destroyed object']() {
      let obj = {
        isDestroyed: true
      };
      expectAssertion(() => (0, _metal.set)(obj, 'favoriteFood', 'hot dogs'), 'calling set on destroyed object: [object Object].favoriteFood = hot dogs');
    }
    ['@test does not trigger auto-run assertion for objects that have not been tagged'](assert) {
      let obj = {};
      (0, _metal.set)(obj, 'foo', 'bar');
      assert.equal(obj.foo, 'bar');
    }
    ['@test does not warn on attempts of calling set on a destroyed object with `trySet`'](assert) {
      let obj = {
        isDestroyed: true
      };
      (0, _metal.trySet)(obj, 'favoriteFood', 'hot dogs');
      assert.equal(obj.favoriteFood, undefined, 'does not set and does not error');
    }
    ['@test should work with native setters'](assert) {
      let count = 0;
      class Foo {
        constructor() {
          this.__foo = '';
        }
        get foo() {
          return this.__foo;
        }
        set foo(value) {
          count++;
          this.__foo = "computed " + value;
        }
      }
      let obj = new Foo();
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value');
      assert.equal(count, 1, 'should have native setter');
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed bar', 'should return new value');
    }
    ['@test should respect prototypical inheritance when subclasses override CPs'](assert) {
      let ParentClass = _object.default.extend({
        prop: (0, _metal.computed)({
          set(key, val) {
            assert.ok(false, 'incorrect setter called');
            this._val = val;
          }
        })
      });
      let SubClass = ParentClass.extend({
        set prop(val) {
          assert.ok(true, 'correct setter called');
          this._val = val;
        }
      });
      let instance = SubClass.create();
      instance.prop = 123;
    }
    ['@test should respect prototypical inheritance when subclasses override CPs with native classes'](assert) {
      var _class2;
      let ParentClass = (_class2 = class ParentClass extends _object.default {
        set prop(val) {
          assert.ok(false, 'incorrect setter called');
          this._val = val;
        }
      }, _applyDecoratedDescriptor(_class2.prototype, "prop", [_metal.computed], Object.getOwnPropertyDescriptor(_class2.prototype, "prop"), _class2.prototype), _class2);
      class SubClass extends ParentClass {
        set prop(val) {
          assert.ok(true, 'correct setter called');
          this._val = val;
        }
      }
      let instance = SubClass.create();
      instance.prop = 123;
    }
  });
});
define("@ember/-internals/metal/tests/alias_test", ["@ember/-internals/metal", "@ember/object", "@ember/array", "internal-test-helpers", "@glimmer/destroyable", "@glimmer/validator"], function (_metal, _object, _array, _internalTestHelpers, _destroyable, _validator) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  let obj, count;
  function incrementCount() {
    count++;
  }
  (0, _internalTestHelpers.moduleFor)('@ember/-internals/metal/alias', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = {
        foo: {
          faz: 'FOO'
        }
      };
      count = 0;
    }
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
        return (0, _internalTestHelpers.runLoopSettled)();
      }
    }
    ['@test should proxy get to alt key'](assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
    }
    ['@test should proxy set to alt key'](assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      (0, _metal.set)(obj, 'bar', 'BAR');
      assert.equal((0, _metal.get)(obj, 'foo.faz'), 'BAR');
    }
    async ['@test old dependent keys should not trigger property changes'](assert) {
      let obj1 = Object.create(null);
      (0, _metal.defineProperty)(obj1, 'foo', null, null);
      (0, _metal.defineProperty)(obj1, 'bar', (0, _metal.alias)('foo'));
      (0, _metal.defineProperty)(obj1, 'baz', (0, _metal.alias)('foo'));
      (0, _metal.defineProperty)(obj1, 'baz', (0, _metal.alias)('bar')); // redefine baz

      (0, _metal.addObserver)(obj1, 'baz', incrementCount);
      (0, _metal.set)(obj1, 'foo', 'FOO');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      (0, _metal.removeObserver)(obj1, 'baz', incrementCount);
      (0, _metal.set)(obj1, 'foo', 'OOF');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
    }
    ['@test nested aliases should trigger computed property invalidation [GH#19279]'](assert) {
      let AttributeModel = _object.default.extend({
        countAdditives: (0, _metal.alias)('additives.length'),
        additives: (0, _array.A)()
      });
      let RootModel = _object.default.extend({
        allAdditives: (0, _metal.computed)('metaAttributes.@each.countAdditives', function () {
          return this.metaAttributes.reduce((acc, el) => {
            return acc.concat(el.additives);
          }, []);
        }),
        metaAttributes: (0, _array.A)([AttributeModel.create()])
      });
      let model = RootModel.create();
      assert.equal(model.allAdditives.length, 0);
      model.metaAttributes[0].additives.pushObject('foo');
      assert.equal(model.allAdditives.length, 1);
    }
    async ["@test inheriting an observer of the alias from the prototype then\n    redefining the alias on the instance to another property dependent on same key\n    does not call the observer twice"](assert) {
      let obj1 = _object.default.extend({
        foo: null,
        bar: (0, _metal.alias)('foo'),
        baz: (0, _metal.alias)('foo'),
        incrementCount
      });
      (0, _metal.addObserver)(obj1.prototype, 'baz', null, 'incrementCount');
      let obj2 = obj1.create();
      (0, _metal.defineProperty)(obj2, 'baz', (0, _metal.alias)('bar')); // override baz

      (0, _metal.set)(obj2, 'foo', 'FOO');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      (0, _metal.removeObserver)(obj2, 'baz', null, 'incrementCount');
      (0, _metal.set)(obj2, 'foo', 'OOF');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
    }
    async ['@test an observer of the alias works if added after defining the alias'](assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      (0, _metal.addObserver)(obj, 'bar', incrementCount);
      (0, _metal.set)(obj, 'foo.faz', 'BAR');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
    }
    async ['@test an observer of the alias works if added before defining the alias'](assert) {
      (0, _metal.addObserver)(obj, 'bar', incrementCount);
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      (0, _metal.set)(obj, 'foo.faz', 'BAR');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
    }
    ['@test alias is dirtied if interior object of alias is set after consumption'](assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      (0, _metal.get)(obj, 'bar');
      let tag = (0, _metal.tagForProperty)(obj, 'bar');
      let tagValue = (0, _validator.valueForTag)(tag);
      (0, _metal.set)(obj, 'foo.faz', 'BAR');
      assert.ok(!(0, _validator.validateTag)(tag, tagValue), 'setting the aliased key should dirty the object');
    }
    ['@test setting alias on self should fail assertion']() {
      expectAssertion(() => (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('bar')), "Setting alias 'bar' on self");
    }
    ['@test property tags are bumped when the source changes [GH#17243]'](assert) {
      function assertPropertyTagChanged(obj, keyName, callback) {
        let tag = (0, _metal.tagForProperty)(obj, keyName);
        let before = (0, _validator.valueForTag)(tag);
        callback();
        assert.notOk((0, _validator.validateTag)(tag, before), "tagForProperty " + keyName + " should change");
      }
      function assertPropertyTagUnchanged(obj, keyName, callback) {
        let tag = (0, _metal.tagForProperty)(obj, keyName);
        let before = (0, _validator.valueForTag)(tag);
        callback();
        assert.ok((0, _validator.validateTag)(tag, before), "tagForProperty " + keyName + " should not change");
      }
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      assertPropertyTagUnchanged(obj, 'bar', () => {
        assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
      });
      assertPropertyTagChanged(obj, 'bar', () => {
        (0, _metal.set)(obj, 'foo.faz', 'BAR');
      });
      assertPropertyTagUnchanged(obj, 'bar', () => {
        assert.equal((0, _metal.get)(obj, 'bar'), 'BAR');
      });
      assertPropertyTagUnchanged(obj, 'bar', () => {
        (0, _metal.addObserver)(obj, 'bar', incrementCount);
        (0, _metal.removeObserver)(obj, 'bar', incrementCount);
      });
      assertPropertyTagChanged(obj, 'bar', () => {
        (0, _metal.set)(obj, 'foo.faz', 'FOO');
      });
      assertPropertyTagUnchanged(obj, 'bar', () => {
        assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
      });
    }
    ['@test nested aliases update their chained dependencies properly'](assert) {
      var _dec, _class, _descriptor, _dec2, _class3;
      let count = 0;
      let Inner = (_dec = (0, _metal.alias)('pojo'), (_class = class Inner {
        constructor() {
          _initializerDefineProperty(this, "aliased", _descriptor, this);
          this.pojo = {
            value: 123
          };
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "aliased", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class));
      let Outer = (_dec2 = (0, _metal.computed)('inner.aliased.value'), (_class3 = class Outer {
        constructor() {
          this.inner = new Inner();
        }
        get value() {
          count++;
          return this.inner.aliased.value;
        }
      }, _applyDecoratedDescriptor(_class3.prototype, "value", [_dec2], Object.getOwnPropertyDescriptor(_class3.prototype, "value"), _class3.prototype), _class3));
      let outer = new Outer();
      assert.equal(outer.value, 123, 'Property works');
      outer.value;
      assert.equal(count, 1, 'Property was properly cached');
      (0, _metal.set)(outer, 'inner.pojo.value', 456);
      assert.equal(outer.value, 456, 'Property was invalidated correctly');
    }
  });
});
define("@ember/-internals/metal/tests/cached/get_test", ["internal-test-helpers", "@ember/-internals/metal"], function (_internalTestHelpers, _metal) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('@cached decorator: get', class extends _internalTestHelpers.AbstractTestCase {
    '@test it works'() {
      var _class, _descriptor, _descriptor2;
      let assert = this.assert;
      let Person = (_class = class Person {
        constructor() {
          _initializerDefineProperty(this, "firstName", _descriptor, this);
          _initializerDefineProperty(this, "lastName", _descriptor2, this);
        }
        get fullName() {
          let fullName = this.firstName + " " + this.lastName;
          assert.step(fullName);
          return fullName;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "firstName", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'Jen';
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "lastName", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'Weber';
        }
      }), _applyDecoratedDescriptor(_class.prototype, "fullName", [_metal.cached], Object.getOwnPropertyDescriptor(_class.prototype, "fullName"), _class.prototype)), _class);
      let person = new Person();
      assert.verifySteps([], 'getter is not called after class initialization');
      assert.strictEqual(person.fullName, 'Jen Weber');
      assert.verifySteps(['Jen Weber'], 'getter was called after property access');
      assert.strictEqual(person.fullName, 'Jen Weber');
      assert.verifySteps([], 'getter was not called again after repeated property access');
      person.firstName = 'Kenneth';
      assert.verifySteps([], 'changing a property does not trigger an eager re-computation');
      assert.strictEqual(person.fullName, 'Kenneth Weber');
      assert.verifySteps(['Kenneth Weber'], 'accessing the property triggers a re-computation');
      assert.strictEqual(person.fullName, 'Kenneth Weber');
      assert.verifySteps([], 'getter was not called again after repeated property access');
      person.lastName = 'Larsen';
      assert.verifySteps([], 'changing a property does not trigger an eager re-computation');
      assert.strictEqual(person.fullName, 'Kenneth Larsen');
      assert.verifySteps(['Kenneth Larsen'], 'accessing the property triggers a re-computation');
    }
    '@test it has a separate cache per class instance'() {
      var _class3, _descriptor3, _descriptor4;
      let assert = this.assert;
      let Person = (_class3 = class Person {
        constructor(firstName, lastName) {
          _initializerDefineProperty(this, "firstName", _descriptor3, this);
          _initializerDefineProperty(this, "lastName", _descriptor4, this);
          this.firstName = firstName;
          this.lastName = lastName;
        }
        get fullName() {
          let fullName = this.firstName + " " + this.lastName;
          assert.step(fullName);
          return fullName;
        }
      }, (_descriptor3 = _applyDecoratedDescriptor(_class3.prototype, "firstName", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor4 = _applyDecoratedDescriptor(_class3.prototype, "lastName", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _applyDecoratedDescriptor(_class3.prototype, "fullName", [_metal.cached], Object.getOwnPropertyDescriptor(_class3.prototype, "fullName"), _class3.prototype)), _class3);
      let jen = new Person('Jen', 'Weber');
      let chris = new Person('Chris', 'Garrett');
      assert.verifySteps([], 'getter is not called after class initialization');
      assert.strictEqual(jen.fullName, 'Jen Weber');
      assert.verifySteps(['Jen Weber'], 'getter was called after property access');
      assert.strictEqual(jen.fullName, 'Jen Weber');
      assert.verifySteps([], 'getter was not called again after repeated property access');
      assert.strictEqual(chris.fullName, 'Chris Garrett', 'other instance has a different value');
      assert.verifySteps(['Chris Garrett'], 'getter was called after property access');
      assert.strictEqual(chris.fullName, 'Chris Garrett');
      assert.verifySteps([], 'getter was not called again after repeated property access');
      chris.lastName = 'Manson';
      assert.verifySteps([], 'changing a property does not trigger an eager re-computation');
      assert.strictEqual(jen.fullName, 'Jen Weber', 'other instance is unaffected');
      assert.verifySteps([], 'getter was not called again after repeated property access');
      assert.strictEqual(chris.fullName, 'Chris Manson');
      assert.verifySteps(['Chris Manson'], 'getter was called after property access');
      assert.strictEqual(jen.fullName, 'Jen Weber', 'other instance is unaffected');
      assert.verifySteps([], 'getter was not called again after repeated property access');
    }
  });
});
define("@ember/-internals/metal/tests/computed_decorator_test", ["@ember/object", "@ember/-internals/metal", "internal-test-helpers"], function (_object, _metal, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('computed - decorator - compatibility', class extends _internalTestHelpers.AbstractTestCase {
    ['@test computed can be used to compose new decorators'](assert) {
      var _class, _descriptor;
      let firstName = 'Diana';
      let firstNameAlias = (0, _metal.computed)('firstName', {
        get() {
          return this.firstName;
        }
      });
      let Class1 = (_class = class Class1 {
        constructor() {
          this.firstName = firstName;
          _initializerDefineProperty(this, "otherFirstName", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "otherFirstName", [firstNameAlias], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class);
      let Class2 = _object.default.extend({
        firstName,
        otherFirstName: firstNameAlias
      });
      let obj1 = new Class1();
      let obj2 = Class2.create();
      assert.equal(firstName, obj1.otherFirstName);
      assert.equal(firstName, obj2.otherFirstName);
    }
    ['@test decorator can still have a configuration object'](assert) {
      var _dec, _class3, _descriptor2;
      let Foo = (_dec = (0, _metal.computed)('foo', {
        get() {
          return this.bar;
        }
      }), (_class3 = class Foo {
        constructor() {
          this.bar = 'something';
          this.foo = 'else';
          _initializerDefineProperty(this, "baz", _descriptor2, this);
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "baz", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class3));
      let obj1 = new Foo();
      assert.equal('something', obj1.baz);
    }
    ['@test it works with functions'](assert) {
      var _dec2, _class5, _descriptor3;
      assert.expect(2);
      let Foo = (_dec2 = (0, _metal.computed)('first', 'last', function () {
        assert.equal(this.first, 'rob');
        assert.equal(this.last, 'jackson');
      }), (_class5 = class Foo {
        constructor() {
          this.first = 'rob';
          this.last = 'jackson';
          _initializerDefineProperty(this, "fullName", _descriptor3, this);
        }
      }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "fullName", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class5));
      let obj = new Foo();
      (0, _metal.get)(obj, 'fullName');
    }
    ['@test computed property can be defined and accessed on a class constructor'](assert) {
      var _class7, _class8;
      let count = 0;
      let Obj = (_class7 = (_class8 = class Obj {
        static get foo() {
          count++;
          return this.bar;
        }
      }, _class8.bar = 123, _class8), _applyDecoratedDescriptor(_class7, "foo", [_metal.computed], Object.getOwnPropertyDescriptor(_class7, "foo"), _class7), _class7);
      assert.equal(Obj.foo, 123, 'should return value');
      Obj.foo;
      assert.equal(count, 1, 'should only call getter once');
    }
    ['@test it works with computed desc'](assert) {
      var _dec3, _class9, _descriptor4;
      assert.expect(4);
      let expectedName = 'rob jackson';
      let expectedFirst = 'rob';
      let expectedLast = 'jackson';
      let Foo = (_dec3 = (0, _metal.computed)('first', 'last', {
        get() {
          assert.equal(this.first, expectedFirst, 'getter: first name matches');
          assert.equal(this.last, expectedLast, 'getter: last name matches');
          return this.first + " " + this.last;
        },
        set(key, name) {
          assert.equal(name, expectedName, 'setter: name matches');
          let [first, last] = name.split(' ');
          (0, _metal.setProperties)(this, {
            first,
            last
          });
          return name;
        }
      }), (_class9 = class Foo {
        constructor() {
          this.first = 'rob';
          this.last = 'jackson';
          _initializerDefineProperty(this, "fullName", _descriptor4, this);
        }
      }, _descriptor4 = _applyDecoratedDescriptor(_class9.prototype, "fullName", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class9));
      let obj = new Foo();
      (0, _metal.get)(obj, 'fullName');
      expectedName = 'yehuda katz';
      expectedFirst = 'yehuda';
      expectedLast = 'katz';
      (0, _metal.set)(obj, 'fullName', 'yehuda katz');
      assert.strictEqual((0, _metal.get)(obj, 'fullName'), expectedName, 'return value of getter is new value of property');
    }
    ['@test it throws if it receives a desc and decorates a getter/setter']() {
      expectAssertion(() => {
        var _dec4, _class11;
        let Foo = (_dec4 = (0, _metal.computed)('bar', {
          get() {
            return this.bar;
          }
        }), (_class11 = class Foo {
          constructor() {
            this.bar = void 0;
          }
          set foo(value) {
            (0, _metal.set)(this, 'bar', value);
          }
        }, _applyDecoratedDescriptor(_class11.prototype, "foo", [_dec4], Object.getOwnPropertyDescriptor(_class11.prototype, "foo"), _class11.prototype), _class11));
        new Foo();
      }, /Attempted to apply a computed property that already has a getter\/setter to a foo, but it is a method or an accessor./);
    }
    ['@test it throws if a CP is passed to it']() {
      expectAssertion(() => {
        var _dec5, _class13, _descriptor5;
        let Foo = (_dec5 = (0, _metal.computed)('bar', (0, _metal.computed)({
          get() {
            return this._foo;
          }
        })), (_class13 = class Foo {
          constructor() {
            this.bar = void 0;
            _initializerDefineProperty(this, "foo", _descriptor5, this);
          }
        }, _descriptor5 = _applyDecoratedDescriptor(_class13.prototype, "foo", [_dec5], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class13));
        new Foo();
      }, 'You attempted to pass a computed property instance to computed(). Computed property instances are decorator functions, and cannot be passed to computed() because they cannot be turned into decorators twice');
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed - decorator - usage tests', class extends _internalTestHelpers.AbstractTestCase {
    ['@test computed property asserts the presence of a getter']() {
      expectAssertion(() => {
        var _dec6, _class15;
        let TestObj = (_dec6 = (0, _metal.computed)(), (_class15 = class TestObj {
          nonGetter() {
            return true;
          }
        }, _applyDecoratedDescriptor(_class15.prototype, "nonGetter", [_dec6], Object.getOwnPropertyDescriptor(_class15.prototype, "nonGetter"), _class15.prototype), _class15));
        new TestObj();
      }, /Try converting it to a getter/);
    }
    ['@test computed property works with a getter'](assert) {
      var _class16;
      let TestObj = (_class16 = class TestObj {
        get someGetter() {
          return true;
        }
      }, _applyDecoratedDescriptor(_class16.prototype, "someGetter", [_metal.computed], Object.getOwnPropertyDescriptor(_class16.prototype, "someGetter"), _class16.prototype), _class16);
      let instance = new TestObj();
      assert.ok(instance.someGetter);
    }
    ['@test computed property with dependent key and getter'](assert) {
      var _dec7, _class17;
      let TestObj = (_dec7 = (0, _metal.computed)('other'), (_class17 = class TestObj {
        constructor() {
          this.other = true;
        }
        get someGetter() {
          return "" + this.other;
        }
      }, _applyDecoratedDescriptor(_class17.prototype, "someGetter", [_dec7], Object.getOwnPropertyDescriptor(_class17.prototype, "someGetter"), _class17.prototype), _class17));
      let instance = new TestObj();
      assert.equal(instance.someGetter, 'true');
      (0, _metal.set)(instance, 'other', false);
      assert.equal(instance.someGetter, 'false');
    }
    ['@test computed property can be accessed without `get`'](assert) {
      var _dec8, _class19;
      let count = 0;
      let Obj = (_dec8 = (0, _metal.computed)(), (_class19 = class Obj {
        get foo() {
          count++;
          return "computed foo";
        }
      }, _applyDecoratedDescriptor(_class19.prototype, "foo", [_dec8], Object.getOwnPropertyDescriptor(_class19.prototype, "foo"), _class19.prototype), _class19));
      let obj = new Obj();
      assert.equal(obj.foo, 'computed foo', 'should return value');
      assert.equal(count, 1, 'should have invoked computed property');
    }
    ['@test defining computed property should invoke property on get'](assert) {
      var _dec9, _class20;
      let count = 0;
      let Obj = (_dec9 = (0, _metal.computed)(), (_class20 = class Obj {
        get foo() {
          count++;
          return "computed foo";
        }
      }, _applyDecoratedDescriptor(_class20.prototype, "foo", [_dec9], Object.getOwnPropertyDescriptor(_class20.prototype, "foo"), _class20.prototype), _class20));
      let obj = new Obj();
      assert.equal(obj.foo, 'computed foo', 'should return value');
      assert.equal(count, 1, 'should have invoked computed property');
    }
    ['@test setter is invoked with correct parameters'](assert) {
      var _dec10, _class21;
      let count = 0;
      let Obj = (_dec10 = (0, _metal.computed)(), (_class21 = class Obj {
        constructor() {
          this.__foo = 'not set';
        }
        get foo() {
          return this.__foo;
        }
        set foo(value) {
          count++;
          this.__foo = "computed " + value;
        }
      }, _applyDecoratedDescriptor(_class21.prototype, "foo", [_dec10], Object.getOwnPropertyDescriptor(_class21.prototype, "foo"), _class21.prototype), _class21));
      let obj = new Obj();
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value with set()');
      assert.equal(count, 1, 'should have invoked computed property');
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed bar', 'should return new value with get()');
    }
    ['@test when not returning from setter, getter is called'](assert) {
      var _dec11, _class23;
      let count = 0;
      let Obj = (_dec11 = (0, _metal.computed)(), (_class23 = class Obj {
        constructor() {
          this.__foo = 'not set';
        }
        get foo() {
          count++;
          return this.__foo;
        }
        set foo(value) {
          this.__foo = "computed " + value;
        }
      }, _applyDecoratedDescriptor(_class23.prototype, "foo", [_dec11], Object.getOwnPropertyDescriptor(_class23.prototype, "foo"), _class23.prototype), _class23));
      let obj = new Obj();
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value with set()');
      assert.equal(count, 1, 'should have invoked getter');
    }
    ['@test when returning from setter, getter is not called'](assert) {
      var _dec12, _class25;
      let count = 0;
      let Obj = (_dec12 = (0, _metal.computed)(), (_class25 = class Obj {
        constructor() {
          this.__foo = 'not set';
        }
        get foo() {
          count++;
          return this.__foo;
        }
        set foo(value) {
          this.__foo = "computed " + value;
          // eslint-disable-next-line no-setter-return
          return this.__foo;
        }
      }, _applyDecoratedDescriptor(_class25.prototype, "foo", [_dec12], Object.getOwnPropertyDescriptor(_class25.prototype, "foo"), _class25.prototype), _class25));
      let obj = new Obj();
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value with set()');
      assert.equal(count, 0, 'should not have invoked getter');
    }
    ['@test throws if a value is decorated twice']() {
      expectAssertion(() => {
        var _class27;
        let Obj = (_class27 = class Obj {
          get foo() {
            return this._foo;
          }
        }, _applyDecoratedDescriptor(_class27.prototype, "foo", [_metal.computed, _metal.computed], Object.getOwnPropertyDescriptor(_class27.prototype, "foo"), _class27.prototype), _class27);
        new Obj();
      }, "Only one computed property decorator can be applied to a class field or accessor, but 'foo' was decorated twice. You may have added the decorator to both a getter and setter, which is unnecessary.");
    }
  });
});
define("@ember/-internals/metal/tests/computed_test", ["@ember/object", "@ember/-internals/meta", "@ember/-internals/metal", "@ember/runloop", "internal-test-helpers", "@glimmer/destroyable"], function (_object, _meta, _metal, _runloop, _internalTestHelpers, _destroyable) {
  "use strict";

  var _dec, _class;
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  let obj, objA, objB, count, func;
  class ComputedTestCase extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      let destroyables = [obj, objA, objB].filter(Boolean);
      obj = objA = objB = count = func = undefined;
      destroyables.forEach(_destroyable.destroy);
      return (0, _internalTestHelpers.runLoopSettled)();
    }
  }
  (0, _internalTestHelpers.moduleFor)('computed', class extends ComputedTestCase {
    ['@test isComputed is true for computed property on a factory'](assert) {
      let Obj = _object.default.extend({
        foo: (0, _metal.computed)(function () {})
      });
      Obj.proto(); // ensure the prototype is "collapsed" / merged

      assert.ok((0, _metal.isComputed)(Obj.prototype, 'foo'));
    }
    ['@test isComputed is true for computed property on an instance'](assert) {
      obj = _object.default.extend({
        foo: (0, _metal.computed)(function () {})
      }).create();
      assert.ok((0, _metal.isComputed)(obj, 'foo'));
    }
    ['@test computed property should be an instance of descriptor'](assert) {
      assert.ok((0, _metal.isClassicDecorator)((0, _metal.computed)(function () {})));
    }
    ['@test computed properties assert the presence of a getter or setter function']() {
      expectAssertion(function () {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('nogetternorsetter', {}));
      }, 'Computed properties must receive a getter or a setter, you passed none.');
    }
    ['@test computed properties check for the presence of a function or configuration object']() {
      expectAssertion(function () {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('nolastargument'));
      }, 'Attempted to use @computed on someProp, but it did not have a getter or a setter. You must either pass a get a function or getter/setter to @computed directly (e.g. `@computed({ get() { ... } })`) or apply @computed directly to a getter/setter');
    }

    // non valid properties are stripped away in the process of creating a computed property descriptor
    ['@test computed properties defined with an object only allow `get` and `set` keys']() {
      expectAssertion(function () {
        obj = _object.default.extend({
          someProp: (0, _metal.computed)({
            get() {},
            set() {},
            other() {}
          })
        });
        obj.create().someProp;
      }, 'Config object passed to computed can only contain `get` and `set` keys.');
    }
    ['@test computed property can be accessed without `get`'](assert) {
      obj = {};
      let count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function (key) {
        count++;
        return 'computed ' + key;
      }));
      assert.equal(obj.foo, 'computed foo', 'should return value');
      assert.equal(count, 1, 'should have invoked computed property');
    }
    ['@test defining computed property should invoke property on get'](assert) {
      obj = {};
      let count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function (key) {
        count++;
        return 'computed ' + key;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed foo', 'should return value');
      assert.equal(count, 1, 'should have invoked computed property');
    }
    ['@test computed property can be defined and accessed on a class constructor'](assert) {
      let count = 0;
      let Obj = _object.default.extend();
      Obj.reopenClass({
        bar: 123,
        foo: (0, _metal.computed)(function () {
          count++;
          return this.bar;
        })
      });
      assert.equal(Obj.foo, 123, 'should return value');
      Obj.foo;
      assert.equal(count, 1, 'should only call getter once');
    }
    ['@test defining computed property should invoke property on set'](assert) {
      obj = {};
      let count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
        get(key) {
          return this['__' + key];
        },
        set(key, value) {
          count++;
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value');
      assert.equal(count, 1, 'should have invoked computed property');
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed bar', 'should return new value');
    }

    // this should be a unit test elsewhere
    // computed is more integration-like, and this test asserts on implementation details.
    // ['@test defining a computed property with a dependent key ending with @each is expanded to []'](
    //   assert
    // ) {
    //   let cp = computed('blazo.@each', function() {});

    //   assert.deepEqual(cp._dependentKeys, ['blazo.[]']);

    //   cp = computed('qux', 'zoopa.@each', function() {});

    //   assert.deepEqual(cp._dependentKeys, ['qux', 'zoopa.[]']);
    // }

    ['@test defining a computed property with a dependent key more than one level deep beyond @each throws an assertion']() {
      expectNoWarning(() => {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos', () => {}));
      });
      expectNoWarning(() => {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos.@each.owner', () => {}));
      });
      let expected = /Dependent keys containing @each only work one level deep./;
      expectAssertion(() => {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos.@each.owner.name', () => {}));
      }, expected);
      expectAssertion(() => {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos.@each.owner.@each.name', () => {}));
      }, expected);
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed should inherit through prototype', class extends ComputedTestCase {
    beforeEach() {
      objA = {
        __foo: 'FOO'
      };
      (0, _metal.defineProperty)(objA, 'foo', (0, _metal.computed)({
        get(key) {
          return this['__' + key];
        },
        set(key, value) {
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));
      objB = Object.create(objA);
      objB.__foo = 'FOO'; // make a copy;
    }

    ['@test using get() and set()'](assert) {
      assert.equal((0, _metal.get)(objA, 'foo'), 'FOO', 'should get FOO from A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should get FOO from B');
      (0, _metal.set)(objA, 'foo', 'BIFF');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should NOT change B');
      (0, _metal.set)(objB, 'foo', 'bar');
      assert.equal((0, _metal.get)(objB, 'foo'), 'computed bar', 'should change B');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should NOT change A');
      (0, _metal.set)(objA, 'foo', 'BAZ');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BAZ', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'computed bar', 'should NOT change B');
    }
  });
  (0, _internalTestHelpers.moduleFor)('redefining computed property to normal', class extends ComputedTestCase {
    beforeEach() {
      objA = {
        __foo: 'FOO'
      };
      (0, _metal.defineProperty)(objA, 'foo', (0, _metal.computed)({
        get(key) {
          return this['__' + key];
        },
        set(key, value) {
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));
      objB = Object.create(objA);
      (0, _metal.defineProperty)(objB, 'foo'); // make this just a normal property.
    }

    ['@test using get() and set()'](assert) {
      assert.equal((0, _metal.get)(objA, 'foo'), 'FOO', 'should get FOO from A');
      assert.equal((0, _metal.get)(objB, 'foo'), undefined, 'should get undefined from B');
      (0, _metal.set)(objA, 'foo', 'BIFF');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), undefined, 'should NOT change B');
      (0, _metal.set)(objB, 'foo', 'bar');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar', 'should change B');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should NOT change A');
      (0, _metal.set)(objA, 'foo', 'BAZ');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BAZ', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar', 'should NOT change B');
    }
  });
  (0, _internalTestHelpers.moduleFor)('redefining computed property to another property', class extends ComputedTestCase {
    beforeEach() {
      objA = {
        __foo: 'FOO'
      };
      (0, _metal.defineProperty)(objA, 'foo', (0, _metal.computed)({
        get(key) {
          return this['__' + key];
        },
        set(key, value) {
          this['__' + key] = 'A ' + value;
          return this['__' + key];
        }
      }));
      objB = Object.create(objA);
      objB.__foo = 'FOO';
      (0, _metal.defineProperty)(objB, 'foo', (0, _metal.computed)({
        get(key) {
          return this['__' + key];
        },
        set(key, value) {
          this['__' + key] = 'B ' + value;
          return this['__' + key];
        }
      }));
    }
    ['@test using get() and set()'](assert) {
      assert.equal((0, _metal.get)(objA, 'foo'), 'FOO', 'should get FOO from A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should get FOO from B');
      (0, _metal.set)(objA, 'foo', 'BIFF');
      assert.equal((0, _metal.get)(objA, 'foo'), 'A BIFF', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should NOT change B');
      (0, _metal.set)(objB, 'foo', 'bar');
      assert.equal((0, _metal.get)(objB, 'foo'), 'B bar', 'should change B');
      assert.equal((0, _metal.get)(objA, 'foo'), 'A BIFF', 'should NOT change A');
      (0, _metal.set)(objA, 'foo', 'BAZ');
      assert.equal((0, _metal.get)(objA, 'foo'), 'A BAZ', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'B bar', 'should NOT change B');
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed - metadata', class extends _internalTestHelpers.AbstractTestCase {
    ['@test can set metadata on a computed property'](assert) {
      let computedProperty = (0, _metal.computed)(function () {});
      computedProperty.meta({
        key: 'keyValue'
      });
      assert.equal(computedProperty.meta().key, 'keyValue', 'saves passed meta hash to the _meta property');
    }
    ['@test meta should return an empty hash if no meta is set'](assert) {
      let computedProperty = (0, _metal.computed)(function () {});
      assert.deepEqual(computedProperty.meta(), {}, 'returned value is an empty hash');
    }
  });

  // ..........................................................
  // CACHEABLE
  //

  (0, _internalTestHelpers.moduleFor)('computed - cacheable', class extends ComputedTestCase {
    beforeEach() {
      obj = {};
      count = 0;
      let func = function () {
        count++;
        return 'bar ' + count;
      };
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
        get: func,
        set: func
      }));
    }
    ['@test cacheable should cache'](assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'first get');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'second get');
      assert.equal(count, 1, 'should only invoke once');
    }
    ['@test modifying a cacheable property should update cache'](assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'first get');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'second get');
      assert.equal((0, _metal.set)(obj, 'foo', 'baz'), 'baz', 'setting');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 2', 'third get');
      assert.equal(count, 2, 'should not invoke again');
    }
    ['@test inherited property should not pick up cache'](assert) {
      let objB = Object.create(obj);
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'obj first get');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar 2', 'objB first get');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'obj second get');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar 2', 'objB second get');
      (0, _metal.set)(obj, 'foo', 'baz'); // modify A
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 3', 'obj third get');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar 2', 'objB third get');
    }
    ['@test meta.valueFor should return the cached value'](assert) {
      assert.equal((0, _meta.meta)(obj).valueFor('foo'), undefined, 'should not yet be a cached value');
      (0, _metal.get)(obj, 'foo');
      assert.equal((0, _meta.meta)(obj).valueFor('foo'), 'bar 1', 'should retrieve cached value');
    }
    ['@test meta.valueFor should return falsy cached values'](assert) {
      (0, _metal.defineProperty)(obj, 'falsy', (0, _metal.computed)(function () {
        return false;
      }));
      assert.equal((0, _meta.meta)(obj).valueFor('falsy'), undefined, 'should not yet be a cached value');
      (0, _metal.get)(obj, 'falsy');
      assert.equal((0, _meta.meta)(obj).valueFor('falsy'), false, 'should retrieve cached value');
    }
    ['@test setting a cached computed property passes the old value as the third argument'](assert) {
      obj = {
        foo: 0
      };
      let receivedOldValue;
      (0, _metal.defineProperty)(obj, 'plusOne', (0, _metal.computed)('foo', {
        get() {},
        set(key, value, oldValue) {
          receivedOldValue = oldValue;
          return value;
        }
      }));
      (0, _metal.set)(obj, 'plusOne', 1);
      assert.strictEqual(receivedOldValue, undefined, 'oldValue should be undefined');
      (0, _metal.set)(obj, 'plusOne', 2);
      assert.strictEqual(receivedOldValue, 1, 'oldValue should be 1');
      (0, _metal.set)(obj, 'plusOne', 3);
      assert.strictEqual(receivedOldValue, 2, 'oldValue should be 2');
    }
  });

  // ..........................................................
  // DEPENDENT KEYS
  //

  (0, _internalTestHelpers.moduleFor)('computed - dependentkey', class extends ComputedTestCase {
    beforeEach() {
      obj = {
        bar: 'baz'
      };
      count = 0;
      let getterAndSetter = function () {
        count++;
        (0, _metal.get)(this, 'bar');
        return 'bar ' + count;
      };
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', {
        get: getterAndSetter,
        set: getterAndSetter
      }));
    }
    ['@test circular keys should not blow up'](assert) {
      let func = function () {
        count++;
        return 'bar ' + count;
      };
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)('foo', {
        get: func,
        set: func
      }));
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', function () {
        count++;
        return 'foo ' + count;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'get once');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'cached retrieve');
      (0, _metal.set)(obj, 'bar', 'BIFF'); // should invalidate bar -> foo -> bar

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'should recache');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'cached retrieve');
    }
    ['@test redefining a property should undo old dependent keys'](assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1');
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('baz', function () {
        count++;
        return 'baz ' + count;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz 2');
      (0, _metal.set)(obj, 'bar', 'BIFF'); // should not kill cache
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz 2');
      (0, _metal.set)(obj, 'baz', 'BOP');
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz 3');
    }
    ['@test can watch multiple dependent keys specified declaratively via brace expansion'](assert) {
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('qux.{bar,baz}', function () {
        count++;
        return 'foo ' + count;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'get once');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'cached retrieve');
      (0, _metal.set)(obj, 'qux', {});
      (0, _metal.set)(obj, 'qux.bar', 'bar'); // invalidate foo

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 2', 'foo invalidated from bar');
      (0, _metal.set)(obj, 'qux.baz', 'baz'); // invalidate foo

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'foo invalidated from baz');
      (0, _metal.set)(obj, 'qux.quux', 'quux'); // do not invalidate foo

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'foo not invalidated by quux');
    }
    ['@test throws assertion if brace expansion notation has spaces']() {
      expectAssertion(function () {
        (0, _metal.defineProperty)(obj, 'roo', (0, _metal.computed)('fee.{bar, baz,bop , }', function () {
          count++;
          return 'roo ' + count;
        }));
      }, /cannot contain spaces/);
    }
    ['@test throws an assertion if an uncached `get` is called after object is destroyed']() {
      (0, _runloop.run)(() => (0, _destroyable.destroy)(obj));
      obj.toString = () => '<custom-obj:here>';
      let message = 'Attempted to access the computed <custom-obj:here>.foo on a destroyed object, which is not allowed';
      expectAssertion(() => (0, _metal.get)(obj, 'foo'), message);
    }
    ['@test does not throw an assertion if an uncached `get` is called on computed without dependencies after object is destroyed'](assert) {
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {
        return 'baz';
      }));
      (0, _runloop.run)(() => (0, _destroyable.destroy)(obj));
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz', 'CP calculated successfully');
    }
  });

  // ..........................................................
  // CHAINED DEPENDENT KEYS
  //

  (0, _internalTestHelpers.moduleFor)('computed - dependentkey with chained properties', class extends ComputedTestCase {
    beforeEach() {
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        }
      };
      count = 0;
      func = function () {
        count++;
        return (0, _metal.get)(obj, 'foo.bar.baz.biff') + ' ' + count;
      };
    }
    ['@test depending on simple chain'](assert) {
      // assign computed property
      (0, _metal.defineProperty)(obj, 'prop', (0, _metal.computed)('foo.bar.baz.biff', func));
      assert.equal((0, _metal.get)(obj, 'prop'), 'BIFF 1');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 2');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 2');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar'), 'baz', {
        biff: 'BLOB'
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLOB 3');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLOB 3');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 4');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 4');
      (0, _metal.set)((0, _metal.get)(obj, 'foo'), 'bar', {
        baz: {
          biff: 'BOOM'
        }
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'BOOM 5');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BOOM 5');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 6');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 6');
      (0, _metal.set)(obj, 'foo', {
        bar: {
          baz: {
            biff: 'BLARG'
          }
        }
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLARG 7');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLARG 7');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 8');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 8');
      (0, _metal.defineProperty)(obj, 'prop');
      (0, _metal.set)(obj, 'prop', 'NONE');
      assert.equal((0, _metal.get)(obj, 'prop'), 'NONE');
      (0, _metal.set)(obj, 'foo', {
        bar: {
          baz: {
            biff: 'BLARG'
          }
        }
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'NONE'); // should do nothing
      assert.equal(count, 8, 'should be not have invoked computed again');
    }
    ['@test chained dependent keys should evaluate computed properties lazily'](assert) {
      (0, _metal.defineProperty)(obj.foo.bar, 'b', (0, _metal.computed)(func));
      (0, _metal.defineProperty)(obj.foo, 'c', (0, _metal.computed)('bar.b', function () {}));
      assert.equal(count, 0, 'b should not run');
    }
  });

  // ..........................................................
  // improved-cp-syntax
  //

  (0, _internalTestHelpers.moduleFor)('computed - improved cp syntax', class extends _internalTestHelpers.AbstractTestCase {
    ['@test setter and getters are passed using an object'](assert) {
      let testObj = _object.default.extend({
        a: '1',
        b: '2',
        aInt: (0, _metal.computed)('a', {
          get(keyName) {
            assert.equal(keyName, 'aInt', 'getter receives the keyName');
            return parseInt(this.get('a'));
          },
          set(keyName, value, oldValue) {
            assert.equal(keyName, 'aInt', 'setter receives the keyName');
            assert.equal(value, 123, 'setter receives the new value');
            assert.equal(oldValue, 1, 'setter receives the old value');
            this.set('a', String(value)); // side effect
            return parseInt(this.get('a'));
          }
        })
      }).create();
      assert.ok(testObj.get('aInt') === 1, 'getter works');
      testObj.set('aInt', 123);
      assert.ok(testObj.get('a') === '123', 'setter works');
      assert.ok(testObj.get('aInt') === 123, 'cp has been updated too');
    }
    ['@test an omitted setter cannot be set later'](assert) {
      let testObj = _object.default.extend({
        a: '1',
        b: '2',
        aInt: (0, _metal.computed)('a', {
          get(keyName) {
            assert.equal(keyName, 'aInt', 'getter receives the keyName');
            return parseInt(this.get('a'));
          }
        })
      }).create();
      assert.ok(testObj.get('aInt') === 1, 'getter works');
      assert.ok(testObj.get('a') === '1');
      expectAssertion(() => {
        testObj.set('aInt', '123');
      }, /Cannot override the computed property `aInt` on <\(unknown\):ember\d*>./);
    }
    ['@test getter can be omited'](assert) {
      let testObj = _object.default.extend({
        com: (0, _metal.computed)({
          set(key, value) {
            return value;
          }
        })
      }).create();
      assert.ok(testObj.get('com') === undefined);
      testObj.set('com', '123');
      assert.ok(testObj.get('com') === '123', 'cp has been updated');
    }
    ['@test the return value of the setter gets cached'](assert) {
      let testObj = _object.default.extend({
        a: '1',
        sampleCP: (0, _metal.computed)('a', {
          get() {
            assert.ok(false, 'The getter should not be invoked');
            return 'get-value';
          },
          set() {
            return 'set-value';
          }
        })
      }).create();
      testObj.set('sampleCP', 'abcd');
      assert.ok(testObj.get('sampleCP') === 'set-value', 'The return value of the CP was cached');
    }
  });

  // ..........................................................
  // BUGS
  //

  (0, _internalTestHelpers.moduleFor)('computed edge cases', class extends ComputedTestCase {
    ['@test adding a computed property should show up in key iteration'](assert) {
      obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {}));
      let found = [];
      for (let key in obj) {
        found.push(key);
      }
      assert.ok(found.indexOf('foo') >= 0, 'should find computed property in iteration found=' + found);
      assert.ok('foo' in obj, 'foo in obj should pass');
    }
    ["@test when setting a value after it had been retrieved empty don't pass function UNDEFINED as oldValue"](assert) {
      obj = {};
      let oldValueIsNoFunction = true;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
        get() {},
        set(key, value, oldValue) {
          if (typeof oldValue === 'function') {
            oldValueIsNoFunction = false;
          }
          return undefined;
        }
      }));
      (0, _metal.get)(obj, 'foo');
      (0, _metal.set)(obj, 'foo', undefined);
      assert.ok(oldValueIsNoFunction);
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed - setter', class extends ComputedTestCase {
    async ['@test setting a watched computed property'](assert) {
      obj = {
        firstName: 'Yehuda',
        lastName: 'Katz'
      };
      (0, _metal.defineProperty)(obj, 'fullName', (0, _metal.computed)('firstName', 'lastName', {
        get() {
          return (0, _metal.get)(this, 'firstName') + ' ' + (0, _metal.get)(this, 'lastName');
        },
        set(key, value) {
          let values = value.split(' ');
          (0, _metal.set)(this, 'firstName', values[0]);
          (0, _metal.set)(this, 'lastName', values[1]);
          return value;
        }
      }));
      let fullNameDidChange = 0;
      let firstNameDidChange = 0;
      let lastNameDidChange = 0;
      (0, _metal.addObserver)(obj, 'fullName', function () {
        fullNameDidChange++;
      });
      (0, _metal.addObserver)(obj, 'firstName', function () {
        firstNameDidChange++;
      });
      (0, _metal.addObserver)(obj, 'lastName', function () {
        lastNameDidChange++;
      });
      assert.equal((0, _metal.get)(obj, 'fullName'), 'Yehuda Katz');
      (0, _metal.set)(obj, 'fullName', 'Yehuda Katz');
      (0, _metal.set)(obj, 'fullName', 'Kris Selden');
      assert.equal((0, _metal.get)(obj, 'fullName'), 'Kris Selden');
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Kris');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Selden');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(fullNameDidChange, 1);
      assert.equal(firstNameDidChange, 1);
      assert.equal(lastNameDidChange, 1);
    }
    async ['@test setting a cached computed property that modifies the value you give it'](assert) {
      obj = {
        foo: 0
      };
      (0, _metal.defineProperty)(obj, 'plusOne', (0, _metal.computed)('foo', {
        get() {
          return (0, _metal.get)(this, 'foo') + 1;
        },
        set(key, value) {
          (0, _metal.set)(this, 'foo', value);
          return value + 1;
        }
      }));
      let plusOneDidChange = 0;
      (0, _metal.addObserver)(obj, 'plusOne', function () {
        plusOneDidChange++;
      });
      assert.equal((0, _metal.get)(obj, 'plusOne'), 1);
      (0, _metal.set)(obj, 'plusOne', 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _metal.get)(obj, 'plusOne'), 2);
      (0, _metal.set)(obj, 'plusOne', 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _metal.get)(obj, 'plusOne'), 2);
      assert.equal(plusOneDidChange, 1);
      (0, _metal.set)(obj, 'foo', 5);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _metal.get)(obj, 'plusOne'), 6);
      assert.equal(plusOneDidChange, 2);
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed - default setter', class extends ComputedTestCase {
    async ["@test raises assertion when setting a value on a computed property that doesn't handle sets"](assert) {
      obj = {};
      let observerFired = false;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {
        return 'foo';
      }));
      (0, _metal.addObserver)(obj, 'foo', null, () => observerFired = true);
      expectAssertion(() => {
        (0, _metal.set)(obj, 'foo', 'bar');
      }, /Cannot override the computed property `foo` on \[object Object\]./);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.notOk(observerFired, 'The observer was not notified');
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed - readOnly', class extends ComputedTestCase {
    ['@test is chainable'](assert) {
      let cp = (0, _metal.computed)(function () {});
      let readOnlyCp = cp.readOnly();
      assert.equal(cp, readOnlyCp);
    }
    ['@test throws assertion if called over a CP with a setter defined with the new syntax']() {
      expectAssertion(() => {
        obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)({
          get() {},
          set() {}
        }).readOnly());
      }, /Computed properties that define a setter using the new syntax cannot be read-only/);
    }
    ['@test protects against setting'](assert) {
      obj = {};
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)(function () {
        return 'barValue';
      }).readOnly());
      assert.equal((0, _metal.get)(obj, 'bar'), 'barValue');
      assert.throws(() => {
        (0, _metal.set)(obj, 'bar', 'newBar');
      }, /Cannot set read-only property "bar" on object:/);
      assert.equal((0, _metal.get)(obj, 'bar'), 'barValue');
    }
  });
  let LazyObject = (_dec = (0, _metal.computed)('_value'), (_class = class LazyObject {
    constructor() {
      this.value = 123;
    }
    // eslint-disable-next-line no-dupe-class-members
    get value() {
      return (0, _metal.get)(this, '_value');
    }

    // eslint-disable-next-line no-dupe-class-members
    set value(value) {
      (0, _metal.set)(this, '_value', value);
    }
    static create() {
      obj = new LazyObject();

      // ensure a tag exists for the value computed
      (0, _metal.get)(obj, 'value');
      return obj;
    }
  }, _applyDecoratedDescriptor(_class.prototype, "value", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "value"), _class.prototype), _class));
  (0, _internalTestHelpers.moduleFor)('computed - lazy dependencies', class extends ComputedTestCase {
    '@test computed properties with lazy dependencies work as expected'(assert) {
      var _dec2, _dec3, _class3;
      let calledCount = 0;
      let lazyObject = LazyObject.create();
      let ObjectWithLazyDep = (_dec2 = (0, _metal.computed)('lazyObject.value'), _dec3 = (0, _metal.computed)('otherProp'), (_class3 = class ObjectWithLazyDep {
        get someProp() {
          return ++calledCount;
        }
        get lazyObject() {
          return lazyObject;
        }
      }, (_applyDecoratedDescriptor(_class3.prototype, "someProp", [_dec2], Object.getOwnPropertyDescriptor(_class3.prototype, "someProp"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "lazyObject", [_dec3], Object.getOwnPropertyDescriptor(_class3.prototype, "lazyObject"), _class3.prototype)), _class3));
      obj = new ObjectWithLazyDep();

      // Get someProp and setup the lazy dependency
      assert.equal(obj.someProp, 1, 'called the first time');
      assert.equal(obj.someProp, 1, 'returned cached value the second time');

      // Finish the lazy dependency
      assert.equal(obj.lazyObject.value, 123, 'lazyObject returns expected value');
      assert.equal(obj.someProp, 1, 'someProp was not dirtied by propB being calculated for the first time');
      (0, _metal.set)(lazyObject, 'value', 456);
      assert.equal(obj.someProp, 2, 'someProp dirtied by lazyObject.value changing');
      (0, _metal.set)(lazyObject, 'value', 789);
      assert.equal(obj.someProp, 3, 'someProp still dirtied by otherProp when lazyObject.value is dirty');
    }
    '@test computed properties with lazy dependencies do not dirty until dependencies have been read at least once'(assert) {
      var _dec4, _dec5, _class4;
      let calledCount = 0;
      let lazyObject = LazyObject.create();
      let ObjectWithLazyDep = (_dec4 = (0, _metal.computed)('lazyObject.value'), _dec5 = (0, _metal.computed)('otherProp'), (_class4 = class ObjectWithLazyDep {
        get someProp() {
          return ++calledCount;
        }
        get lazyObject() {
          return lazyObject;
        }
      }, (_applyDecoratedDescriptor(_class4.prototype, "someProp", [_dec4], Object.getOwnPropertyDescriptor(_class4.prototype, "someProp"), _class4.prototype), _applyDecoratedDescriptor(_class4.prototype, "lazyObject", [_dec5], Object.getOwnPropertyDescriptor(_class4.prototype, "lazyObject"), _class4.prototype)), _class4));
      obj = new ObjectWithLazyDep();
      assert.equal(obj.someProp, 1, 'called the first time');
      assert.equal(obj.someProp, 1, 'returned cached value the second time');

      // dirty the object value before the dependency has been finished
      (0, _metal.set)(lazyObject, 'value', 456);
      assert.equal(obj.lazyObject.value, 456, 'propB returns expected value');
      assert.equal(obj.someProp, 1, 'someProp was not dirtied by propB being dirtied before it has been calculated');
    }
    '@test computed properties with lazy dependencies work correctly if lazy dependency is more recent'(assert) {
      var _dec6, _dec7, _class5;
      let calledCount = 0;
      let lazyObject = LazyObject.create();
      let ObjectWithLazyDep = (_dec6 = (0, _metal.computed)('lazyObject.value'), _dec7 = (0, _metal.computed)('otherProp'), (_class5 = class ObjectWithLazyDep {
        get someProp() {
          return ++calledCount;
        }
        get lazyObject() {
          return lazyObject;
        }
      }, (_applyDecoratedDescriptor(_class5.prototype, "someProp", [_dec6], Object.getOwnPropertyDescriptor(_class5.prototype, "someProp"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "lazyObject", [_dec7], Object.getOwnPropertyDescriptor(_class5.prototype, "lazyObject"), _class5.prototype)), _class5));
      obj = new ObjectWithLazyDep();
      (0, _metal.set)(lazyObject, 'value', 456);
      assert.equal(obj.someProp, 1, 'called the first time');
      assert.equal(obj.someProp, 1, 'returned cached value the second time');
      assert.equal(obj.lazyObject.value, 456, 'lazyObject returns expected value');
      assert.equal(obj.someProp, 1, 'someProp was not dirtied by lazyObject being dirtied before it has been calculated');
    }
  });
  (0, _internalTestHelpers.moduleFor)('computed - observer interop', class extends ComputedTestCase {
    async '@test observers that do not consume computed properties still work'(assert) {
      var _dec8, _class6;
      assert.expect(2);
      let Foo = (_dec8 = (0, _metal.computed)('otherProp'), (_class6 = class Foo {
        constructor() {
          this.otherProp = 123;
        }
        get someProp() {
          return this.otherProp;
        }
      }, _applyDecoratedDescriptor(_class6.prototype, "someProp", [_dec8], Object.getOwnPropertyDescriptor(_class6.prototype, "someProp"), _class6.prototype), _class6));
      obj = new Foo();
      (0, _metal.addObserver)(obj, 'otherProp', obj, () => assert.ok(true, 'otherProp observer called when it was changed'), false);
      (0, _metal.addObserver)(obj, 'someProp', obj, () => assert.ok(false, 'someProp observer called when it was not changed'), false);
      (0, _metal.set)(obj, 'otherProp', 456);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _metal.get)(obj, 'someProp'), 456, '');
      (0, _metal.addObserver)(obj, 'anotherProp', obj, () => {}, false);
      (0, _metal.set)(obj, 'anotherProp', 123);
      await (0, _internalTestHelpers.runLoopSettled)();
    }
  });
});
define("@ember/-internals/metal/tests/events_test", ["@ember/-internals/metal", "@ember/object/mixin", "internal-test-helpers"], function (_metal, _mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/props/events_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test listener should receive event - removing should remove'](assert) {
      let obj = {};
      let count = 0;
      function F() {
        count++;
      }
      (0, _metal.addListener)(obj, 'event!', F);
      assert.equal(count, 0, 'nothing yet');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 1, 'received event');
      (0, _metal.removeListener)(obj, 'event!', F);
      count = 0;
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 0, 'received event');
    }
    ['@test listeners should be inherited'](assert) {
      let count = 0;
      let obj = {
        func() {
          count++;
        }
      };
      (0, _metal.addListener)(obj, 'event!', null, 'func');
      let obj2 = Object.create(obj);
      assert.equal(count, 0, 'nothing yet');
      (0, _metal.sendEvent)(obj2, 'event!');
      assert.equal(count, 1, 'received event');
      (0, _metal.removeListener)(obj2, 'event!', null, 'func');
      count = 0;
      (0, _metal.sendEvent)(obj2, 'event!');
      assert.equal(count, 0, 'did not receive event');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 1, 'should still invoke on parent');
    }
    ['@test adding a listener more than once should only invoke once'](assert) {
      let count = 0;
      let obj = {
        func() {
          count++;
        }
      };
      (0, _metal.addListener)(obj, 'event!', null, 'func');
      (0, _metal.addListener)(obj, 'event!', null, 'func');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 1, 'should only invoke once');
    }
    ['@test adding a listener with a target should invoke with target'](assert) {
      let obj = {};
      let target;
      target = {
        count: 0,
        method() {
          this.count++;
        }
      };
      (0, _metal.addListener)(obj, 'event!', target, target.method);
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(target.count, 1, 'should invoke');
    }
    ['@test adding a listener with string method should lookup method on event delivery'](assert) {
      let obj = {};
      let target;
      target = {
        count: 0,
        method() {}
      };
      (0, _metal.addListener)(obj, 'event!', target, 'method');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(target.count, 0, 'should invoke but do nothing');
      target.method = function () {
        this.count++;
      };
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(target.count, 1, 'should invoke now');
    }
    ['@test calling sendEvent with extra params should be passed to listeners'](assert) {
      let obj = {};
      let params = null;
      (0, _metal.addListener)(obj, 'event!', function () {
        params = Array.prototype.slice.call(arguments);
      });
      (0, _metal.sendEvent)(obj, 'event!', ['foo', 'bar']);
      assert.deepEqual(params, ['foo', 'bar'], 'params should be saved');
    }
    ['@test hasListeners tells you if there are listeners for a given event'](assert) {
      let obj = {};
      function F() {}
      function F2() {}
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), false, 'no listeners at first');
      (0, _metal.addListener)(obj, 'event!', F);
      (0, _metal.addListener)(obj, 'event!', F2);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), true, 'has listeners');
      (0, _metal.removeListener)(obj, 'event!', F);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), true, 'has listeners');
      (0, _metal.removeListener)(obj, 'event!', F2);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), false, 'has no more listeners');
      (0, _metal.addListener)(obj, 'event!', F);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), true, 'has listeners');
    }
    ['@test a listener can be added as part of a mixin'](assert) {
      let triggered = 0;
      let MyMixin = _mixin.default.create({
        foo1: (0, _metal.on)('bar', function () {
          triggered++;
        }),
        foo2: (0, _metal.on)('bar', function () {
          triggered++;
        })
      });
      let obj = {};
      MyMixin.apply(obj);
      (0, _metal.sendEvent)(obj, 'bar');
      assert.equal(triggered, 2, 'should invoke listeners');
    }
    ["@test 'on' asserts for invalid arguments"]() {
      expectAssertion(() => {
        _mixin.default.create({
          foo1: (0, _metal.on)('bar')
        });
      }, 'on expects function as last argument');
      expectAssertion(() => {
        _mixin.default.create({
          foo1: (0, _metal.on)(function () {})
        });
      }, 'on called without valid event names');
    }
    ['@test a listener added as part of a mixin may be overridden'](assert) {
      let triggered = 0;
      let FirstMixin = _mixin.default.create({
        foo: (0, _metal.on)('bar', function () {
          triggered++;
        })
      });
      let SecondMixin = _mixin.default.create({
        foo: (0, _metal.on)('baz', function () {
          triggered++;
        })
      });
      let obj = {};
      FirstMixin.apply(obj);
      SecondMixin.apply(obj);
      (0, _metal.sendEvent)(obj, 'bar');
      assert.equal(triggered, 0, 'should not invoke from overridden property');
      (0, _metal.sendEvent)(obj, 'baz');
      assert.equal(triggered, 1, 'should invoke from subclass property');
    }
  });
});
define("@ember/-internals/metal/tests/expand_properties_test", ["@ember/-internals/metal", "internal-test-helpers"], function (_metal, _internalTestHelpers) {
  "use strict";

  let foundProperties = [];
  function addProperty(property) {
    foundProperties.push(property);
  }
  (0, _internalTestHelpers.moduleFor)('Property Brace Expansion Test', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      foundProperties = [];
    }
    ['@test Properties without expansions are unaffected'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a', addProperty);
      (0, _metal.expandProperties)('a.b', addProperty);
      (0, _metal.expandProperties)('a.b.[]', addProperty);
      (0, _metal.expandProperties)('a.b.@each.c', addProperty);
      assert.deepEqual(['a', 'a.b', 'a.b.[]', 'a.b.@each.c'].sort(), foundProperties.sort());
    }
    ['@test A single expansion at the end expands properly'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a.b.{c,d}', addProperty);
      assert.deepEqual(['a.b.c', 'a.b.d'].sort(), foundProperties.sort());
    }
    ['@test A property with only a brace expansion expands correctly'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('{a,b,c}', addProperty);
      let expected = ['a', 'b', 'c'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    }
    ['@test Expansions with single properties only expand once'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a.b.{c}.d.{e}', addProperty);
      assert.deepEqual(['a.b.c.d.e'], foundProperties);
    }
    ['@test A single brace expansion expands correctly'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a.{b,c,d}.e', addProperty);
      let expected = ['a.b.e', 'a.c.e', 'a.d.e'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    }
    ['@test Multiple brace expansions work correctly'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('{a,b,c}.d.{e,f}.g', addProperty);
      let expected = ['a.d.e.g', 'a.d.f.g', 'b.d.e.g', 'b.d.f.g', 'c.d.e.g', 'c.d.f.g'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    }
    ['@test A property with only brace expansions expands correctly'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('{a,b,c}.{d}.{e,f}', addProperty);
      let expected = ['a.d.e', 'a.d.f', 'b.d.e', 'b.d.f', 'c.d.e', 'c.d.f'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    }
    ['@test Nested brace expansions are not allowed']() {
      let nestedBraceProperties = ['a.{b.{c,d}}', 'a.{{b}.c}', 'a.{b,c}.{d.{e,f}.g', 'a.{b.{c}', 'a.{b,c}}', 'model.{bar,baz'];
      nestedBraceProperties.forEach(invalidProperties => {
        expectAssertion(() => (0, _metal.expandProperties)(invalidProperties, addProperty));
      }, /Brace expanded properties have to be balanced and cannot be nested/);
    }
    ['@test A property with no braces does not expand'](assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a,b,c.d.e,f', addProperty);
      assert.deepEqual(foundProperties, ['a,b,c.d.e,f']);
    }
    ['@test A pattern must be a string'](assert) {
      assert.expect(1);
      expectAssertion(() => {
        (0, _metal.expandProperties)([1, 2], addProperty);
      }, /A computed property key must be a string/);
    }
    ['@test A pattern must not contain a space'](assert) {
      assert.expect(1);
      expectAssertion(function () {
        (0, _metal.expandProperties)('{a, b}', addProperty);
      }, /Brace expanded properties cannot contain spaces, e.g. "user.{firstName, lastName}" should be "user.{firstName,lastName}"/);
    }
  });
});
define("@ember/-internals/metal/tests/injected_property_test", ["@ember/-internals/owner", "@ember/-internals/metal", "internal-test-helpers"], function (_owner, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('inject', class extends _internalTestHelpers.AbstractTestCase {
    ['@test injected properties should be descriptors'](assert) {
      assert.ok((0, _metal.isClassicDecorator)((0, _metal.inject)('type')));
    }
    ['@test injected properties should be overridable'](assert) {
      let obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type'));
      (0, _metal.set)(obj, 'foo', 'bar');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should return the overridden value');
    }
    ['@test getting on an object without an owner or container should fail assertion']() {
      let obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type', 'name'));
      expectAssertion(function () {
        (0, _metal.get)(obj, 'foo');
      }, /Attempting to lookup an injected property on an object without a container, ensure that the object was instantiated via a container./);
    }
    ['@test getting on an object without an owner but with a container should not fail'](assert) {
      let obj = {
        container: {
          lookup(key) {
            assert.ok(true, 'should call container.lookup');
            return key;
          }
        }
      };
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type', 'name'));
      assert.equal((0, _metal.get)(obj, 'foo'), 'type:name', 'should return the value of container.lookup');
    }
    ['@test getting should return a lookup on the container'](assert) {
      assert.expect(2);
      let obj = {};
      (0, _owner.setOwner)(obj, {
        lookup(key) {
          assert.ok(true, 'should call container.lookup');
          return key;
        }
      });
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type', 'name'));
      assert.equal((0, _metal.get)(obj, 'foo'), 'type:name', 'should return the value of container.lookup');
    }
    ['@test omitting the lookup name should default to the property name'](assert) {
      let obj = {};
      (0, _owner.setOwner)(obj, {
        lookup(key) {
          return key;
        }
      });
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type'));
      assert.equal((0, _metal.get)(obj, 'foo'), 'type:foo', 'should lookup the type using the property name');
    }
  });
});
define("@ember/-internals/metal/tests/libraries_test", ["@ember/debug", "@ember/-internals/metal", "internal-test-helpers"], function (_debug, _metal, _internalTestHelpers) {
  "use strict";

  let libs, registry;
  let originalWarn = (0, _debug.getDebugFunction)('warn');
  function noop() {}
  (0, _internalTestHelpers.moduleFor)('Libraries registry', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      libs = new _metal.Libraries();
      registry = libs._registry;
    }
    afterEach() {
      libs = null;
      registry = null;
      (0, _debug.setDebugFunction)('warn', originalWarn);
    }
    ['@test core libraries come before other libraries'](assert) {
      assert.expect(2);
      libs.register('my-lib', '2.0.0a');
      libs.registerCoreLibrary('DS', '1.0.0-beta.2');
      assert.equal(registry[0].name, 'DS');
      assert.equal(registry[1].name, 'my-lib');
    }
    ['@test only the first registration of a library is stored'](assert) {
      assert.expect(3);

      // overwrite warn to suppress the double registration warning (see https://github.com/emberjs/ember.js/issues/16391)
      (0, _debug.setDebugFunction)('warn', noop);
      libs.register('magic', 1.23);
      libs.register('magic', 2.23);
      assert.equal(registry[0].name, 'magic');
      assert.equal(registry[0].version, 1.23);
      assert.equal(registry.length, 1);
    }
    ['@test attempting to register a library that is already registered warns you'](assert) {
      if (!false /* DEBUG */) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }
      assert.expect(1);
      libs.register('magic', 1.23);
      (0, _debug.setDebugFunction)('warn', function (msg, test) {
        if (!test) {
          assert.equal(msg, 'Library "magic" is already registered with Ember.');
        }
      });

      // Should warn us
      libs.register('magic', 2.23);
    }
    ['@test libraries can be de-registered'](assert) {
      assert.expect(2);
      libs.register('lib1', '1.0.0b');
      libs.register('lib2', '1.0.0b');
      libs.register('lib3', '1.0.0b');
      libs.deRegister('lib1');
      libs.deRegister('lib3');
      assert.equal(registry[0].name, 'lib2');
      assert.equal(registry.length, 1);
    }
  });
});
define("@ember/-internals/metal/tests/main_test", ["ember/version", "internal-test-helpers"], function (_version, _internalTestHelpers) {
  "use strict";

  // From https://github.com/semver/semver.org/issues/59 & https://regex101.com/r/vW1jA8/6
  const SEMVER_REGEX = /^((?:0|(?:[1-9]\d*)))\.((?:0|(?:[1-9]\d*)))\.((?:0|(?:[1-9]\d*)))(?:-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$/;
  (0, _internalTestHelpers.moduleFor)('@ember/-internals/metal/core/main', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Ember.VERSION is in alignment with SemVer v2.0.0'](assert) {
      assert.ok(SEMVER_REGEX.test(_version.default), "Ember.VERSION (" + _version.default + ")is valid SemVer v2.0.0");
    }
    ['@test SEMVER_REGEX properly validates and invalidates version numbers'](assert) {
      function validateVersionString(versionString, expectedResult) {
        assert.equal(SEMVER_REGEX.test(versionString), expectedResult);
      }

      // Positive test cases
      validateVersionString('1.11.3', true);
      validateVersionString('1.0.0-beta.16.1', true);
      validateVersionString('1.12.1+canary.aba1412', true);
      validateVersionString('2.0.0-beta.1+canary.bb344775', true);
      validateVersionString('3.1.0-foobarBaz+30d70bd3', true);

      // Negative test cases
      validateVersionString('1.11.3.aba18a', false);
      validateVersionString('1.11', false);
    }
  });
});
define("@ember/-internals/metal/tests/mixin/apply_test", ["@ember/object", "@ember/object/mixin", "internal-test-helpers"], function (_object, _mixin, _internalTestHelpers) {
  "use strict";

  function K() {}
  (0, _internalTestHelpers.moduleFor)('Mixin.apply', class extends _internalTestHelpers.AbstractTestCase {
    ['@test using apply() should apply properties'](assert) {
      let MixinA = _mixin.default.create({
        foo: 'FOO',
        baz: K
      });
      let obj = {};
      (0, _mixin.mixin)(obj, MixinA);
      assert.equal((0, _object.get)(obj, 'foo'), 'FOO', 'should apply foo');
      assert.equal((0, _object.get)(obj, 'baz'), K, 'should apply foo');
    }
    ['@test applying anonymous properties'](assert) {
      let obj = {};
      (0, _mixin.mixin)(obj, {
        foo: 'FOO',
        baz: K
      });
      assert.equal((0, _object.get)(obj, 'foo'), 'FOO', 'should apply foo');
      assert.equal((0, _object.get)(obj, 'baz'), K, 'should apply foo');
    }
    ['@test applying null values']() {
      expectAssertion(() => (0, _mixin.mixin)({}, null));
    }
    ['@test applying a property with an undefined value'](assert) {
      let obj = {
        tagName: ''
      };
      (0, _mixin.mixin)(obj, {
        tagName: undefined
      });
      assert.strictEqual((0, _object.get)(obj, 'tagName'), '');
    }
  });
});
define("@ember/-internals/metal/tests/namespace_search_test", ["@ember/object/mixin", "internal-test-helpers"], function (_mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('NamespaceSearch', class extends _internalTestHelpers.AbstractTestCase {
    ['@test classToString: null as this inside class must not throw error'](assert) {
      let mixin = _mixin.default.create();
      assert.equal(mixin.toString(), '(unknown mixin)', 'this = null should be handled on Mixin.toString() call');
    }
  });
});
define("@ember/-internals/metal/tests/native_desc_decorator_test", ["@ember/object", "@ember/-internals/metal", "@ember/object/mixin", "internal-test-helpers"], function (_object, _metal, _mixin, _internalTestHelpers) {
  "use strict";

  let classes = [class {
    static module(title) {
      return title + ": using defineProperty on an object directly";
    }
    constructor() {
      this.object = {};
    }
    install(key, desc, assert) {
      let {
        object
      } = this;
      (0, _metal.defineProperty)(object, key, desc);
      assert.ok(Object.prototype.hasOwnProperty.call(object, key));
    }
    set(key, value) {
      this.object[key] = value;
    }
    finalize() {
      return this.object;
    }
    source() {
      return this.object;
    }
  }, class {
    static module(title) {
      return title + ": using defineProperty on a prototype";
    }
    constructor() {
      this.proto = {};
    }
    install(key, desc, assert) {
      let {
        proto
      } = this;
      (0, _metal.defineProperty)(proto, key, desc);
      assert.ok(Object.prototype.hasOwnProperty.call(proto, key));
    }
    set(key, value) {
      this.proto[key] = value;
    }
    finalize() {
      return Object.create(this.proto);
    }
    source() {
      return this.proto;
    }
  }, class {
    static module(title) {
      return title + ": in EmberObject.extend()";
    }
    constructor() {
      this.klass = null;
      this.props = {};
    }
    install(key, desc) {
      this.props[key] = desc;
    }
    set(key, value) {
      this.props[key] = value;
    }
    finalize() {
      this.klass = _object.default.extend(this.props);
      return this.klass.create();
    }
    source() {
      return this.klass.prototype;
    }
  }, class {
    static module(title) {
      return title + ": in EmberObject.extend() through a mixin";
    }
    constructor() {
      this.klass = null;
      this.props = {};
    }
    install(key, desc) {
      this.props[key] = desc;
    }
    set(key, value) {
      this.props[key] = value;
    }
    finalize() {
      this.klass = _object.default.extend(_mixin.default.create(this.props));
      return this.klass.create();
    }
    source() {
      return this.klass.prototype;
    }
  }, class {
    static module(title) {
      return title + ": inherited from another EmberObject super class";
    }
    constructor() {
      this.superklass = null;
      this.props = {};
    }
    install(key, desc) {
      this.props[key] = desc;
    }
    set(key, value) {
      this.props[key] = value;
    }
    finalize() {
      this.superklass = _object.default.extend(this.props);
      return this.superklass.extend().create();
    }
    source() {
      return this.superklass.prototype;
    }
  }];
  classes.forEach(TestClass => {
    (0, _internalTestHelpers.moduleFor)(TestClass.module('@ember/-internals/metal/nativeDescDecorator'), class extends _internalTestHelpers.AbstractTestCase {
      ['@test defining a configurable property'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          configurable: true,
          value: 'bar'
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        let source = factory.source();
        delete source.foo;
        assert.strictEqual(obj.foo, undefined);
        Object.defineProperty(source, 'foo', {
          configurable: true,
          value: 'baz'
        });
        assert.equal(obj.foo, 'baz');
      }
      ['@test defining a non-configurable property'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          configurable: false,
          value: 'bar'
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        let source = factory.source();
        assert.throws(() => delete source.foo, TypeError);
        assert.throws(() => Object.defineProperty(source, 'foo', {
          configurable: true,
          value: 'baz'
        }), TypeError);
        assert.equal(obj.foo, 'bar');
      }
      ['@test defining an enumerable property'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          enumerable: true,
          value: 'bar'
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        let source = factory.source();
        assert.ok(Object.keys(source).indexOf('foo') !== -1);
      }
      ['@test defining a non-enumerable property'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          enumerable: false,
          value: 'bar'
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        let source = factory.source();
        assert.ok(Object.keys(source).indexOf('foo') === -1);
      }
      ['@test defining a writable property'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          writable: true,
          value: 'bar'
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        let source = factory.source();
        source.foo = 'baz';
        assert.equal(obj.foo, 'baz');
        obj.foo = 'bat';
        assert.equal(obj.foo, 'bat');
      }
      ['@test defining a non-writable property'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          writable: false,
          value: 'bar'
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        let source = factory.source();
        assert.throws(() => source.foo = 'baz', TypeError);
        assert.throws(() => obj.foo = 'baz', TypeError);
        assert.equal(obj.foo, 'bar');
      }
      ['@test defining a getter'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.__foo__;
          }
        }), assert);
        factory.set('__foo__', 'bar');
        let obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        obj.__foo__ = 'baz';
        assert.equal(obj.foo, 'baz');
      }
      ['@test defining a setter'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          set: function (value) {
            this.__foo__ = value;
          }
        }), assert);
        factory.set('__foo__', 'bar');
        let obj = factory.finalize();
        assert.equal(obj.__foo__, 'bar');
        obj.foo = 'baz';
        assert.equal(obj.__foo__, 'baz');
      }
      ['@test combining multiple setter and getters'](assert) {
        let factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.__foo__;
          },
          set: function (value) {
            this.__foo__ = value;
          }
        }), assert);
        factory.set('__foo__', 'foo');
        factory.install('bar', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.__bar__;
          },
          set: function (value) {
            this.__bar__ = value;
          }
        }), assert);
        factory.set('__bar__', 'bar');
        factory.install('fooBar', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.foo + '-' + this.bar;
          }
        }), assert);
        let obj = factory.finalize();
        assert.equal(obj.fooBar, 'foo-bar');
        obj.foo = 'FOO';
        assert.equal(obj.fooBar, 'FOO-bar');
        obj.__bar__ = 'BAR';
        assert.equal(obj.fooBar, 'FOO-BAR');
        assert.throws(() => obj.fooBar = 'foobar', TypeError);
        assert.equal(obj.fooBar, 'FOO-BAR');
      }
    });
  });
});
define("@ember/-internals/metal/tests/observer_test", ["@ember/-internals/metal", "@ember/object", "@ember/object/mixin", "internal-test-helpers", "@glimmer/destroyable", "@ember/-internals/meta"], function (_metal, _object, _mixin, _internalTestHelpers, _destroyable, _meta) {
  "use strict";

  function K() {}
  let obj;

  // ..........................................................
  // ADD OBSERVER
  //

  (0, _internalTestHelpers.moduleFor)('addObserver', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
        return (0, _internalTestHelpers.runLoopSettled)();
      }
    }
    ['@test observer should assert to invalid input']() {
      expectAssertion(() => {
        (0, _object.observer)(() => {});
      }, 'observer called without valid path');
      expectAssertion(() => {
        (0, _object.observer)(null);
      }, 'observer must be provided a function or an observer definition');
      expectAssertion(() => {
        (0, _object.observer)({});
      }, 'observer called without a function');
      expectAssertion(() => {
        (0, _object.observer)({
          fn() {}
        });
      }, 'observer called without valid path');
      expectAssertion(() => {
        (0, _object.observer)({
          fn() {},
          dependentKeys: []
        });
      }, 'observer called without valid path');
      expectAssertion(() => {
        (0, _object.observer)({
          fn() {},
          dependentKeys: ['foo']
        });
      }, 'observer called without sync');
    }
    async ['@test observer should fire when property is modified'](assert) {
      obj = {};
      let count = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should invoke AFTER value changed');
        count++;
      });
      (0, _metal.set)(obj, 'foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should have invoked observer');
    }
    async ['@test observer supports keys with colons'](assert) {
      obj = {};
      let count = 0;
      (0, _metal.addObserver)(obj, 'foo:bar:baz', function () {
        assert.equal((0, _metal.get)(obj, 'foo:bar:baz'), 'bar', 'should invoke AFTER value changed');
        count++;
      });
      (0, _metal.set)(obj, 'foo:bar:baz', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should have invoked observer');
    }
    async ['@test observer should fire when dependent property is modified'](assert) {
      obj = {
        bar: 'bar'
      };
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', function () {
        return (0, _metal.get)(this, 'bar').toUpperCase();
      }));
      (0, _metal.get)(obj, 'foo');
      let count = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        assert.equal((0, _metal.get)(obj, 'foo'), 'BAZ', 'should have invoked after prop change');
        count++;
      });
      (0, _metal.set)(obj, 'bar', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should have invoked observer');
    }

    // https://github.com/emberjs/ember.js/issues/18246
    async ['@test observer should fire when computed property is modified'](assert) {
      obj = {
        bar: 'bar'
      };
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', {
        get() {
          return (0, _metal.get)(this, 'bar');
        },
        set(key, value) {
          return value;
        }
      }));
      (0, _metal.get)(obj, 'foo');
      let count = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        assert.equal((0, _metal.get)(obj, 'foo'), 'baz', 'should have invoked after prop change');
        count++;
      });
      (0, _metal.set)(obj, 'foo', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should have invoked observer');
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz', 'computed should have correct value');
    }
    async ['@test observer should continue to fire after dependent properties are accessed'](assert) {
      let observerCount = 0;
      obj = {};
      (0, _metal.defineProperty)(obj, 'prop', (0, _metal.computed)(function () {
        return Math.random();
      }));
      (0, _metal.defineProperty)(obj, 'anotherProp', (0, _metal.computed)('prop', function () {
        return (0, _metal.get)(this, 'prop') + Math.random();
      }));
      (0, _metal.addObserver)(obj, 'prop', function () {
        observerCount++;
      });
      (0, _metal.get)(obj, 'anotherProp');
      for (let i = 0; i < 10; i++) {
        (0, _metal.notifyPropertyChange)(obj, 'prop');
        await (0, _internalTestHelpers.runLoopSettled)();
      }
      assert.equal(observerCount, 10, 'should continue to fire indefinitely');
    }
    async ['@test observers watching multiple properties via brace expansion should fire when the properties change'](assert) {
      obj = {};
      let count = 0;
      (0, _mixin.mixin)(obj, {
        observeFooAndBar: (0, _object.observer)('{foo,bar}', function () {
          count++;
        })
      });
      (0, _metal.set)(obj, 'foo', 'foo');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'observer specified via brace expansion invoked on property change');
      (0, _metal.set)(obj, 'bar', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 2, 'observer specified via brace expansion invoked on property change');
      (0, _metal.set)(obj, 'baz', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 2, 'observer not invoked on unspecified property');
    }
    async ['@test observers watching multiple properties via brace expansion should fire when dependent properties change'](assert) {
      obj = {
        baz: 'Initial'
      };
      let count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', function () {
        return (0, _metal.get)(this, 'bar').toLowerCase();
      }));
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)('baz', function () {
        return (0, _metal.get)(this, 'baz').toUpperCase();
      }));
      (0, _mixin.mixin)(obj, {
        fooAndBarWatcher: (0, _object.observer)('{foo,bar}', function () {
          count++;
        })
      });
      (0, _metal.get)(obj, 'foo');
      (0, _metal.set)(obj, 'baz', 'Baz');
      await (0, _internalTestHelpers.runLoopSettled)();

      // fire once for foo, once for bar
      assert.equal(count, 2, 'observer specified via brace expansion invoked on dependent property change');
      (0, _metal.set)(obj, 'quux', 'Quux');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 2, 'observer not fired on unspecified property');
    }
    async ['@test removing an chain observer on change should not fail'](assert) {
      let foo = {
        bar: 'bar'
      };
      let obj1 = {
        foo: foo
      };
      let obj2 = {
        foo: foo
      };
      let obj3 = {
        foo: foo
      };
      let obj4 = {
        foo: foo
      };
      let count1 = 0;
      let count2 = 0;
      let count3 = 0;
      let count4 = 0;
      function observer1() {
        count1++;
      }
      function observer2() {
        count2++;
      }
      function observer3() {
        count3++;
        (0, _metal.removeObserver)(obj1, 'foo.bar', observer1);
        (0, _metal.removeObserver)(obj2, 'foo.bar', observer2);
        (0, _metal.removeObserver)(obj4, 'foo.bar', observer4);
      }
      function observer4() {
        count4++;
      }
      (0, _metal.addObserver)(obj1, 'foo.bar', observer1);
      (0, _metal.addObserver)(obj2, 'foo.bar', observer2);
      (0, _metal.addObserver)(obj3, 'foo.bar', observer3);
      (0, _metal.addObserver)(obj4, 'foo.bar', observer4);
      (0, _metal.set)(foo, 'bar', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count1, 1, 'observer1 fired');
      assert.equal(count2, 1, 'observer2 fired');
      assert.equal(count3, 1, 'observer3 fired');
      assert.equal(count4, 0, 'observer4 did not fire');
      (0, _destroyable.destroy)(obj1);
      (0, _destroyable.destroy)(obj2);
      (0, _destroyable.destroy)(obj3);
      (0, _destroyable.destroy)(obj4);
    }
    async ['@test deferring property change notifications'](assert) {
      obj = {
        foo: 'foo'
      };
      let fooCount = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        fooCount++;
      });
      (0, _metal.beginPropertyChanges)();
      (0, _metal.set)(obj, 'foo', 'BIFF');
      (0, _metal.set)(obj, 'foo', 'BAZ');
      (0, _metal.endPropertyChanges)();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(fooCount, 1, 'foo should have fired once');
    }
    async ['@test addObserver should respect targets with methods'](assert) {
      let observed = obj = {
        foo: 'foo'
      };
      let target1 = {
        count: 0,
        didChange(obj, keyName) {
          let value = (0, _metal.get)(obj, keyName);
          assert.equal(this, target1, 'should invoke with this');
          assert.equal(obj, observed, 'param1 should be observed object');
          assert.equal(keyName, 'foo', 'param2 should be keyName');
          assert.equal(value, 'BAZ', 'param3 should new value');
          this.count++;
        }
      };
      let target2 = {
        count: 0,
        didChange(obj, keyName) {
          let value = (0, _metal.get)(obj, keyName);
          assert.equal(this, target2, 'should invoke with this');
          assert.equal(obj, observed, 'param1 should be observed object');
          assert.equal(keyName, 'foo', 'param2 should be keyName');
          assert.equal(value, 'BAZ', 'param3 should new value');
          this.count++;
        }
      };
      (0, _metal.addObserver)(observed, 'foo', target1, 'didChange');
      (0, _metal.addObserver)(observed, 'foo', target2, target2.didChange);
      (0, _metal.set)(observed, 'foo', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(target1.count, 1, 'target1 observer should have fired');
      assert.equal(target2.count, 1, 'target2 observer should have fired');
    }
    async ['@test addObserver should allow multiple objects to observe a property'](assert) {
      let observed = obj = {
        foo: 'foo'
      };
      let target1 = {
        count: 0,
        didChange() {
          this.count++;
        }
      };
      let target2 = {
        count: 0,
        didChange() {
          this.count++;
        }
      };
      (0, _metal.addObserver)(observed, 'foo', target1, 'didChange');
      (0, _metal.addObserver)(observed, 'foo', target2, 'didChange');
      (0, _metal.set)(observed, 'foo', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(target1.count, 1, 'target1 observer should have fired');
      assert.equal(target2.count, 1, 'target2 observer should have fired');
    }
  });

  // ..........................................................
  // REMOVE OBSERVER
  //

  (0, _internalTestHelpers.moduleFor)('removeObserver', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
        return (0, _internalTestHelpers.runLoopSettled)();
      }
    }
    async ['@test removing observer should stop firing'](assert) {
      obj = {};
      let count = 0;
      function F() {
        count++;
      }
      (0, _metal.addObserver)(obj, 'foo', F);
      (0, _metal.set)(obj, 'foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should have invoked observer');
      (0, _metal.removeObserver)(obj, 'foo', F);
      (0, _metal.set)(obj, 'foo', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, "removed observer shouldn't fire");
    }
    async ['@test local observers can be removed'](assert) {
      let barObserved = 0;
      let MyMixin = _mixin.default.create({
        foo1: (0, _object.observer)('bar', function () {
          barObserved++;
        }),
        foo2: (0, _object.observer)('bar', function () {
          barObserved++;
        })
      });
      obj = {};
      MyMixin.apply(obj);
      (0, _metal.set)(obj, 'bar', 'HI!');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(barObserved, 2, 'precond - observers should be fired');
      (0, _metal.removeObserver)(obj, 'bar', null, 'foo1');
      barObserved = 0;
      (0, _metal.set)(obj, 'bar', 'HI AGAIN!');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(barObserved, 1, 'removed observers should not be called');
    }
    async ['@test removeObserver should respect targets with methods'](assert) {
      let observed = {
        foo: 'foo'
      };
      let target1 = {
        count: 0,
        didChange() {
          this.count++;
        }
      };
      let target2 = {
        count: 0,
        didChange() {
          this.count++;
        }
      };
      (0, _metal.addObserver)(observed, 'foo', target1, 'didChange');
      (0, _metal.addObserver)(observed, 'foo', target2, target2.didChange);
      (0, _metal.set)(observed, 'foo', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(target1.count, 1, 'target1 observer should have fired');
      assert.equal(target2.count, 1, 'target2 observer should have fired');
      (0, _metal.removeObserver)(observed, 'foo', target1, 'didChange');
      (0, _metal.removeObserver)(observed, 'foo', target2, target2.didChange);
      target1.count = target2.count = 0;
      (0, _metal.set)(observed, 'foo', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(target1.count, 0, 'target1 observer should not fire again');
      assert.equal(target2.count, 0, 'target2 observer should not fire again');
    }
  });

  // ..........................................................
  // CHAINED OBSERVERS
  //

  let count;
  (0, _internalTestHelpers.moduleFor)('addObserver - dependentkey with chained properties', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
      }
      obj = undefined;
      count = 0;
      return (0, _internalTestHelpers.runLoopSettled)();
    }
    beforeEach() {
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        Capital: {
          foo: {
            bar: {
              baz: {
                biff: 'BIFF'
              }
            }
          }
        }
      };
      count = 0;
    }
    async ['@test depending on a chain with a computed property'](assert) {
      (0, _metal.defineProperty)(obj, 'computed', (0, _metal.computed)(function () {
        return {
          foo: 'bar'
        };
      }));
      let changed = 0;
      (0, _metal.addObserver)(obj, 'computed.foo', function () {
        changed++;
      });
      assert.equal((0, _meta.meta)(obj).valueFor('computed'), undefined, 'addObserver should not compute CP');
      (0, _metal.set)(obj, 'computed.foo', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(changed, 1, 'should fire observer');
    }
    async ['@test depending on a simple chain'](assert) {
      let val;
      (0, _metal.addObserver)(obj, 'foo.bar.baz.biff', function (target, key) {
        val = (0, _metal.get)(target, key);
        count++;
      });
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BUZZ');
      assert.equal(count, 1);
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar'), 'baz', {
        biff: 'BLARG'
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BLARG');
      assert.equal(count, 2);
      (0, _metal.set)((0, _metal.get)(obj, 'foo'), 'bar', {
        baz: {
          biff: 'BOOM'
        }
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BOOM');
      assert.equal(count, 3);
      (0, _metal.set)(obj, 'foo', {
        bar: {
          baz: {
            biff: 'BLARG'
          }
        }
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BLARG');
      assert.equal(count, 4);
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BUZZ');
      assert.equal(count, 5);
      let foo = (0, _metal.get)(obj, 'foo');
      (0, _metal.set)(obj, 'foo', 'BOO');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, undefined);
      assert.equal(count, 6);
      (0, _metal.set)(foo.bar.baz, 'biff', 'BOOM');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 6, 'should be not have invoked observer');
    }
    async ['@test depending on a chain with a capitalized first key'](assert) {
      let val;
      (0, _metal.addObserver)(obj, 'Capital.foo.bar.baz.biff', function (target, key) {
        val = (0, _metal.get)(obj, key);
        count++;
      });
      (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo.bar.baz'), 'biff', 'BUZZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BUZZ');
      assert.equal(count, 1);
      (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo.bar'), 'baz', {
        biff: 'BLARG'
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BLARG');
      assert.equal(count, 2);
      (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo'), 'bar', {
        baz: {
          biff: 'BOOM'
        }
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BOOM');
      assert.equal(count, 3);
      (0, _metal.set)(obj, 'Capital.foo', {
        bar: {
          baz: {
            biff: 'BLARG'
          }
        }
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BLARG');
      assert.equal(count, 4);
      (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo.bar.baz'), 'biff', 'BUZZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, 'BUZZ');
      assert.equal(count, 5);
      let foo = (0, _metal.get)(obj, 'foo');
      (0, _metal.set)(obj, 'Capital.foo', 'BOO');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(val, undefined);
      assert.equal(count, 6);
      (0, _metal.set)(foo.bar.baz, 'biff', 'BOOM');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 6, 'should be not have invoked observer');
    }
  });

  // ..........................................................
  // SETTING IDENTICAL VALUES
  //

  (0, _internalTestHelpers.moduleFor)('props/observer_test - setting identical values', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
      }
      obj = undefined;
      count = 0;
      return (0, _internalTestHelpers.runLoopSettled)();
    }
    async ['@test setting simple prop should not trigger'](assert) {
      obj = {
        foo: 'bar'
      };
      let count = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        count++;
      });
      (0, _metal.set)(obj, 'foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 0, 'should not trigger observer');
      (0, _metal.set)(obj, 'foo', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should trigger observer');
      (0, _metal.set)(obj, 'foo', 'baz');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'should not trigger observer again');
    }

    // The issue here is when a computed property is directly set with a value, then has a
    // dependent key change (which triggers a cache expiration and recomputation), observers will
    // not be fired if the CP setter is called with the last set value.
    async ['@test setting a cached computed property whose value has changed should trigger'](assert) {
      obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('baz', {
        get: function () {
          return (0, _metal.get)(this, 'baz');
        },
        set: function (key, value) {
          return value;
        }
      }));
      let count = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        count++;
      });
      (0, _metal.set)(obj, 'foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar');
      (0, _metal.set)(obj, 'baz', 'qux');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 2);
      assert.equal((0, _metal.get)(obj, 'foo'), 'qux');
      (0, _metal.set)(obj, 'foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 3);
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Keys behavior with observers', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
        return (0, _internalTestHelpers.runLoopSettled)();
      }
    }
    ['@test should not leak properties on the prototype'](assert) {
      function Beer() {}
      Beer.prototype.type = 'ipa';
      obj = new Beer();
      (0, _metal.addObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(obj), []);
      (0, _metal.removeObserver)(obj, 'type', K);
    }
    ['@test observing a non existent property'](assert) {
      function Beer() {}
      Beer.prototype.type = 'ipa';
      obj = new Beer();
      (0, _metal.addObserver)(obj, 'brand', K);
      assert.deepEqual(Object.keys(obj), []);
      (0, _metal.set)(obj, 'brand', 'Corona');
      assert.deepEqual(Object.keys(obj), ['brand']);
      (0, _metal.removeObserver)(obj, 'brand', K);
    }
    ['@test with observers switched on and off'](assert) {
      function Beer() {}
      Beer.prototype.type = 'ipa';
      obj = new Beer();
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.removeObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(obj), []);
    }
    ['@test observers switched on and off with setter in between'](assert) {
      function Beer() {}
      Beer.prototype.type = 'ipa';
      obj = new Beer();
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.set)(obj, 'type', 'ale');
      (0, _metal.removeObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(obj), ['type']);
    }
    ['@test observer switched on and off and then setter'](assert) {
      function Beer() {}
      Beer.prototype.type = 'ipa';
      obj = new Beer();
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.removeObserver)(obj, 'type', K);
      (0, _metal.set)(obj, 'type', 'ale');
      assert.deepEqual(Object.keys(obj), ['type']);
    }
    ['@test observers switched on and off with setter in between (observed property is not shadowing)'](assert) {
      function Beer() {}
      obj = new Beer();
      (0, _metal.set)(obj, 'type', 'ale');
      assert.deepEqual(Object.keys(obj), ['type'], 'only set');
      let otherBeer = new Beer();
      (0, _metal.addObserver)(otherBeer, 'type', K);
      (0, _metal.set)(otherBeer, 'type', 'ale');
      assert.deepEqual(Object.keys(otherBeer), ['type'], 'addObserver -> set');
      let yetAnotherBeer = new Beer();
      (0, _metal.addObserver)(yetAnotherBeer, 'type', K);
      (0, _metal.set)(yetAnotherBeer, 'type', 'ale');
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.removeObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(yetAnotherBeer), ['type'], 'addObserver -> set -> removeObserver');
      let itsMyLastBeer = new Beer();
      (0, _metal.set)(itsMyLastBeer, 'type', 'ale');
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.removeObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(itsMyLastBeer), ['type'], 'set -> removeObserver');
      (0, _destroyable.destroy)(otherBeer);
      (0, _destroyable.destroy)(yetAnotherBeer);
      (0, _destroyable.destroy)(itsMyLastBeer);
    }
    ['@test observers switched on and off with setter in between (observed property is shadowing one on the prototype)'](assert) {
      function Beer() {}
      Beer.prototype.type = 'ipa';
      obj = new Beer();
      (0, _metal.set)(obj, 'type', 'ale');
      assert.deepEqual(Object.keys(obj), ['type'], 'after set');
      let otherBeer = new Beer();
      (0, _metal.addObserver)(otherBeer, 'type', K);
      (0, _metal.set)(otherBeer, 'type', 'ale');
      assert.deepEqual(Object.keys(otherBeer), ['type'], 'addObserver -> set');
      let yetAnotherBeer = new Beer();
      (0, _metal.addObserver)(yetAnotherBeer, 'type', K);
      (0, _metal.set)(yetAnotherBeer, 'type', 'ale');
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.removeObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(yetAnotherBeer), ['type'], 'addObserver -> set -> removeObserver');
      let itsMyLastBeer = new Beer();
      (0, _metal.set)(itsMyLastBeer, 'type', 'ale');
      (0, _metal.addObserver)(obj, 'type', K);
      (0, _metal.removeObserver)(obj, 'type', K);
      assert.deepEqual(Object.keys(itsMyLastBeer), ['type'], 'set -> removeObserver');
      (0, _destroyable.destroy)(otherBeer);
      (0, _destroyable.destroy)(yetAnotherBeer);
      (0, _destroyable.destroy)(itsMyLastBeer);
    }
  });
  (0, _internalTestHelpers.moduleFor)('changeProperties - sync observers', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
        return (0, _internalTestHelpers.runLoopSettled)();
      }
    }
    '@test observers added/removed during changeProperties should do the right thing.'(assert) {
      obj = {
        foo: 0
      };
      function Observer() {
        this.didChangeCount = 0;
      }
      Observer.prototype = {
        add() {
          (0, _metal.addObserver)(obj, 'foo', this, 'didChange', true);
        },
        remove() {
          (0, _metal.removeObserver)(obj, 'foo', this, 'didChange', true);
        },
        didChange() {
          this.didChangeCount++;
        }
      };
      let addedBeforeFirstChangeObserver = new Observer();
      let addedAfterFirstChangeObserver = new Observer();
      let addedAfterLastChangeObserver = new Observer();
      let removedBeforeFirstChangeObserver = new Observer();
      let removedBeforeLastChangeObserver = new Observer();
      let removedAfterLastChangeObserver = new Observer();
      removedBeforeFirstChangeObserver.add();
      removedBeforeLastChangeObserver.add();
      removedAfterLastChangeObserver.add();
      (0, _metal.changeProperties)(function () {
        removedBeforeFirstChangeObserver.remove();
        addedBeforeFirstChangeObserver.add();
        (0, _metal.set)(obj, 'foo', 1);
        assert.equal(addedBeforeFirstChangeObserver.didChangeCount, 0, 'addObserver called before the first change is deferred');
        addedAfterFirstChangeObserver.add();
        removedBeforeLastChangeObserver.remove();
        (0, _metal.set)(obj, 'foo', 2);
        assert.equal(addedAfterFirstChangeObserver.didChangeCount, 0, 'addObserver called after the first change is deferred');
        addedAfterLastChangeObserver.add();
        removedAfterLastChangeObserver.remove();
      });
      assert.equal(removedBeforeFirstChangeObserver.didChangeCount, 0, 'removeObserver called before the first change sees none');
      assert.equal(addedBeforeFirstChangeObserver.didChangeCount, 1, 'addObserver called before the first change sees only 1');
      assert.equal(addedAfterFirstChangeObserver.didChangeCount, 1, 'addObserver called after the first change sees 1');
      assert.equal(addedAfterLastChangeObserver.didChangeCount, 1, 'addObserver called after the last change sees 1');
      assert.equal(removedBeforeLastChangeObserver.didChangeCount, 0, 'removeObserver called before the last change sees none');
      assert.equal(removedAfterLastChangeObserver.didChangeCount, 0, 'removeObserver called after the last change sees none');
    }
    '@test calling changeProperties while executing deferred observers works correctly'(assert) {
      obj = {
        foo: 0
      };
      let fooDidChange = 0;
      (0, _metal.addObserver)(obj, 'foo', () => {
        fooDidChange++;
        (0, _metal.changeProperties)(() => {});
      }, undefined, true);
      (0, _metal.changeProperties)(() => {
        (0, _metal.set)(obj, 'foo', 1);
      });
      assert.equal(fooDidChange, 1);
    }
  });
});
define("@ember/-internals/metal/tests/performance_test", ["@ember/-internals/metal", "internal-test-helpers", "@glimmer/destroyable"], function (_metal, _internalTestHelpers, _destroyable) {
  "use strict";

  let obj;

  /*
    This test file is designed to capture performance regressions related to
    deferred computation. Things like run loops, computed properties, and bindings
    should run the minimum amount of times to achieve best performance, so any
    bugs that cause them to get evaluated more than necessary should be put here.
  */

  (0, _internalTestHelpers.moduleFor)('Computed Properties - Number of times evaluated', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
      }
      return (0, _internalTestHelpers.runLoopSettled)();
    }
    async ['@test computed properties that depend on multiple properties should run only once per run loop'](assert) {
      obj = {
        a: 'a',
        b: 'b',
        c: 'c'
      };
      let cpCount = 0;
      let obsCount = 0;
      (0, _metal.defineProperty)(obj, 'abc', (0, _metal.computed)('a', 'b', 'c', function (key) {
        cpCount++;
        return 'computed ' + key;
      }));
      (0, _metal.get)(obj, 'abc');
      cpCount = 0;
      (0, _metal.addObserver)(obj, 'abc', function () {
        obsCount++;
      });
      (0, _metal.beginPropertyChanges)();
      (0, _metal.set)(obj, 'a', 'aa');
      (0, _metal.set)(obj, 'b', 'bb');
      (0, _metal.set)(obj, 'c', 'cc');
      (0, _metal.endPropertyChanges)();
      (0, _metal.get)(obj, 'abc');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(cpCount, 1, 'The computed property is only invoked once');
      assert.equal(obsCount, 1, 'The observer is only invoked once');
    }
    ['@test computed properties are not executed if they are the last segment of an observer chain pain'](assert) {
      obj = {
        bar: {
          baz: {}
        }
      };
      let count = 0;
      (0, _metal.defineProperty)(obj.bar.baz, 'bam', (0, _metal.computed)(function () {
        count++;
      }));
      (0, _metal.addObserver)(obj, 'bar.baz.bam', function () {});
      (0, _metal.notifyPropertyChange)((0, _metal.get)(obj, 'bar.baz'), 'bam');
      assert.equal(count, 0, 'should not have recomputed property');
    }
  });
});
define("@ember/-internals/metal/tests/properties_test", ["@ember/-internals/metal", "internal-test-helpers"], function (_metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('defineProperty', class extends _internalTestHelpers.AbstractTestCase {
    ['@test toString'](assert) {
      let obj = {};
      (0, _metal.defineProperty)(obj, 'toString', undefined, function () {
        return 'FOO';
      });
      assert.equal(obj.toString(), 'FOO', 'should replace toString');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Ember.deprecateProperty', class extends _internalTestHelpers.AbstractTestCase {
    ['@test enables access to deprecated property and returns the value of the new property'](assert) {
      assert.expect(3);
      let obj = {
        foo: 'bar'
      };
      (0, _metal.deprecateProperty)(obj, 'baz', 'foo', {
        id: 'baz-deprecation',
        until: 'some.version'
      });
      expectDeprecation();
      assert.equal(obj.baz, obj.foo, 'baz and foo are equal');
      obj.foo = 'blammo';
      assert.equal(obj.baz, obj.foo, 'baz and foo are equal');
    }
    ['@test deprecatedKey is not enumerable'](assert) {
      assert.expect(2);
      let obj = {
        foo: 'bar',
        blammo: 'whammy'
      };
      (0, _metal.deprecateProperty)(obj, 'baz', 'foo', {
        id: 'baz-deprecation',
        until: 'some.version'
      });
      for (let prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
          assert.notEqual(prop, 'baz');
        }
      }
    }
    ['@test enables setter to deprecated property and updates the value of the new property'](assert) {
      assert.expect(3);
      let obj = {
        foo: 'bar'
      };
      (0, _metal.deprecateProperty)(obj, 'baz', 'foo', {
        id: 'baz-deprecation',
        until: 'some.version'
      });
      expectDeprecation();
      obj.baz = 'bloop';
      assert.equal(obj.foo, 'bloop', 'updating baz updates foo');
      assert.equal(obj.baz, obj.foo, 'baz and foo are equal');
    }
  });
});
define("@ember/-internals/metal/tests/property_events_test", ["@ember/-internals/meta", "@ember/-internals/metal", "internal-test-helpers"], function (_meta, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('notifyPropertyChange', class extends _internalTestHelpers.AbstractTestCase {
    ['@test notifies property changes on instances'](assert) {
      class Foo {
        [_metal.PROPERTY_DID_CHANGE](prop) {
          assert.equal(prop, 'bar', 'property change notified');
        }
      }
      let foo = new Foo();
      (0, _metal.notifyPropertyChange)(foo, 'bar');
    }
    ['@test notifies property changes on instances with meta'](assert) {
      class Foo {
        [_metal.PROPERTY_DID_CHANGE](prop) {
          assert.equal(prop, 'bar', 'property change notified');
        }
      }
      let foo = new Foo();
      (0, _meta.meta)(foo); // setup meta

      (0, _metal.notifyPropertyChange)(foo, 'bar');
    }
    ['@test does not notify on class prototypes with meta'](assert) {
      assert.expect(0);
      class Foo {
        [_metal.PROPERTY_DID_CHANGE](prop) {
          assert.equal(prop, 'bar', 'property change notified');
        }
      }
      let foo = new Foo();
      (0, _meta.meta)(foo.constructor.prototype); // setup meta for prototype

      (0, _metal.notifyPropertyChange)(foo.constructor.prototype, 'bar');
    }
    ['@test does not notify on non-class prototypes with meta'](assert) {
      assert.expect(0);
      let foo = {
        [_metal.PROPERTY_DID_CHANGE](prop) {
          assert.equal(prop, 'baz', 'property change notified');
        }
      };
      let bar = Object.create(foo);
      (0, _meta.meta)(foo); // setup meta for prototype
      (0, _meta.meta)(bar); // setup meta for instance, switch prototype

      (0, _metal.notifyPropertyChange)(foo, 'baz');
    }
  });
});
define("@ember/-internals/metal/tests/set_properties_test", ["@ember/-internals/metal", "internal-test-helpers"], function (_metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('setProperties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test supports setting multiple attributes at once'](assert) {
      assert.deepEqual((0, _metal.setProperties)(null, null), null, 'noop for null properties and null object');
      assert.deepEqual((0, _metal.setProperties)(undefined, undefined), undefined, 'noop for undefined properties and undefined object');
      assert.deepEqual((0, _metal.setProperties)({}), undefined, 'noop for no properties');
      assert.deepEqual((0, _metal.setProperties)({}, undefined), undefined, 'noop for undefined');
      assert.deepEqual((0, _metal.setProperties)({}, null), null, 'noop for null');
      assert.deepEqual((0, _metal.setProperties)({}, NaN), NaN, 'noop for NaN');
      assert.deepEqual((0, _metal.setProperties)({}, {}), {}, 'meh');
      let props = (0, _metal.setProperties)({}, {
        foo: undefined
      });
      assert.deepEqual(props, {
        foo: undefined
      }, 'Setting undefined value');
      assert.ok('foo' in props, 'Setting undefined value');
      assert.deepEqual(Object.keys(props), ['foo'], 'Setting undefined value');
      assert.deepEqual((0, _metal.setProperties)({}, {
        foo: 1
      }), {
        foo: 1
      }, 'Set a single property');
      assert.deepEqual((0, _metal.setProperties)({}, {
        foo: 1,
        bar: 1
      }), {
        foo: 1,
        bar: 1
      }, 'Set multiple properties');
      assert.deepEqual((0, _metal.setProperties)({
        foo: 2,
        baz: 2
      }, {
        foo: 1
      }), {
        foo: 1
      }, 'Set one of multiple properties');
      assert.deepEqual((0, _metal.setProperties)({
        foo: 2,
        baz: 2
      }, {
        bar: 2
      }), {
        bar: 2
      }, 'Set an additional, previously unset property');
    }
    ['@test cannot traverse through dangerous built-in Object properties'](assert) {
      class Inner {}
      class Example {
        constructor() {
          this.inner = new Inner();
        }
      }
      let example = new Example();
      assert.throws(() => {
        (0, _metal.setProperties)(example, {
          '__proto__.ohNo': 'polluted'
        });
      }, /Property set failed: object in path "__proto__" could not be found./);
      assert.equal(Example.prototype.ohNo, undefined, 'check for prototype pollution');
      assert.throws(() => {
        (0, _metal.setProperties)(example, {
          'constructor.ohNo': 'polluted'
        });
      }, /Property set failed: object in path "constructor" could not be found./);
      assert.equal(Example.ohNo, undefined, 'check for prototype pollution');
      assert.throws(() => {
        (0, _metal.setProperties)(example, {
          'inner.__proto__.ohNo': 'polluted'
        });
      }, /Property set failed: object in path "inner.__proto__" could not be found./);
      assert.equal(Inner.prototype.ohNo, undefined, 'check for prototype pollution');
      assert.throws(() => {
        (0, _metal.setProperties)(example, {
          'inner.constructor.ohNo': 'polluted'
        });
      }, /Property set failed: object in path "inner.constructor" could not be found./);
      assert.equal(Inner.ohNo, undefined, 'check for prototype pollution');
    }
  });
});
define("@ember/-internals/metal/tests/tracked/classic_classes_test", ["internal-test-helpers", "@ember/-internals/metal", "@glimmer/validator"], function (_internalTestHelpers, _metal, _validator) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('@tracked decorator - classic classes', class extends _internalTestHelpers.AbstractTestCase {
    ["@test validators for tracked getters with dependencies should invalidate when the dependencies invalidate"](assert) {
      let obj = {};
      (0, _metal.defineProperty)(obj, 'first', (0, _metal.tracked)());
      (0, _metal.defineProperty)(obj, 'last', (0, _metal.tracked)());
      (0, _metal.defineProperty)(obj, 'full', (0, _metal.nativeDescDecorator)({
        get() {
          return this.first + " " + this.last;
        },
        set(value) {
          let [first, last] = value.split(' ');
          this.first = first;
          this.last = last;
        }
      }));
      obj.first = 'Tom';
      obj.last = 'Dale';
      let tag = (0, _validator.track)(() => obj.full);
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal(obj.full, 'Tom Dale', 'The full name starts correct');
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      obj.full = 'Melanie Sumner';
      assert.equal((0, _validator.validateTag)(tag, snapshot), false);
      assert.equal(obj.full, 'Melanie Sumner');
      assert.equal(obj.first, 'Melanie');
      assert.equal(obj.last, 'Sumner');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ["@test can pass a default value to the tracked decorator"](assert) {
      class Tracked {
        get full() {
          return this.first + " " + this.last;
        }
      }
      (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)({
        value: 'Tom'
      }));
      (0, _metal.defineProperty)(Tracked.prototype, 'last', (0, _metal.tracked)({
        value: 'Dale'
      }));
      let obj = new Tracked();
      assert.equal(obj.full, 'Tom Dale', 'Default values are correctly assign');
    }
    ["@test errors if used directly on a classic class"]() {
      expectAssertion(() => {
        class Tracked {
          get full() {
            return this.first + " " + this.last;
          }
        }
        (0, _metal.defineProperty)(Tracked.prototype, 'first', _metal.tracked);
      }, "@tracked can only be used directly as a native decorator. If you're using tracked in classic classes, add parenthesis to call it like a function: tracked()");
    }
    ["@test errors on any keys besides 'value', 'get', or 'set' being passed"]() {
      expectAssertion(() => {
        class Tracked {
          get full() {
            return this.first + " " + this.last;
          }
        }
        (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)({
          foo() {}
        }));
      }, "The options object passed to tracked() may only contain a 'value' or 'initializer' property, not both. Received: [foo]");
    }
    ["@test errors if 'value' and 'get'/'set' are passed together"]() {
      expectAssertion(() => {
        class Tracked {
          get full() {
            return this.first + " " + this.last;
          }
        }
        (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)({
          value: 123,
          initializer: () => 123
        }));
      }, "The options object passed to tracked() may only contain a 'value' or 'initializer' property, not both. Received: [value,initializer]");
    }
    ["@test errors on anything besides an options object being passed"]() {
      expectAssertion(() => {
        class Tracked {
          get full() {
            return this.first + " " + this.last;
          }
        }
        (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)(null));
      }, "tracked() may only receive an options object containing 'value' or 'initializer', received null");
    }
  });
  (0, _internalTestHelpers.moduleFor)('@tracked decorator - native decorator behavior', class extends _internalTestHelpers.AbstractTestCase {
    ["@test errors if options are passed to native decorator"]() {
      expectAssertion(() => {
        var _dec, _class, _descriptor;
        let Tracked = (_dec = (0, _metal.tracked)(), (_class = class Tracked {
          constructor() {
            _initializerDefineProperty(this, "first", _descriptor, this);
          }
          get full() {
            return this.first + " " + this.last;
          }
        }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "first", [_dec], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class));
        new Tracked();
      }, "You attempted to set a default value for first with the @tracked({ value: 'default' }) syntax. You can only use this syntax with classic classes. For native classes, you can use class initializers: @tracked field = 'default';");
    }
    ["@test errors if options are passed to native decorator (GH#17764)"](assert) {
      var _class3, _descriptor2;
      let Tracked = (_class3 = class Tracked {
        constructor() {
          _initializerDefineProperty(this, "value", _descriptor2, this);
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "value", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class3);
      let obj = new Tracked();
      assert.strictEqual(obj.value, undefined, 'uninitilized value defaults to undefined');
    }
  });
});
define("@ember/-internals/metal/tests/tracked/get_test", ["internal-test-helpers", "@ember/-internals/metal"], function (_internalTestHelpers, _metal) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  let createObj = function () {
    var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
    let Obj = (_class = class Obj {
      constructor() {
        _initializerDefineProperty(this, "string", _descriptor, this);
        _initializerDefineProperty(this, "number", _descriptor2, this);
        _initializerDefineProperty(this, "boolTrue", _descriptor3, this);
        _initializerDefineProperty(this, "boolFalse", _descriptor4, this);
        _initializerDefineProperty(this, "nullValue", _descriptor5, this);
      }
    }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "string", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 'string';
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "number", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 23;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "boolTrue", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return true;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "boolFalse", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "nullValue", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      }
    })), _class);
    return new Obj();
  };
  (0, _internalTestHelpers.moduleFor)('@tracked decorator: get', class extends _internalTestHelpers.AbstractTestCase {
    '@test should get arbitrary properties on an object'() {
      let obj = createObj();
      for (let key in obj) {
        this.assert.equal((0, _metal.get)(obj, key), obj[key], key);
      }
    }
    '@test should get a @tracked path'() {
      var _class3, _descriptor6, _class5, _descriptor7, _class7, _descriptor8;
      let Key = (_class3 = class Key {
        constructor() {
          this.key = 'some-key';
          _initializerDefineProperty(this, "value", _descriptor6, this);
        }
      }, _descriptor6 = _applyDecoratedDescriptor(_class3.prototype, "value", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return "value for " + this.key;
        }
      }), _class3);
      let Path = (_class5 = class Path {
        constructor() {
          _initializerDefineProperty(this, "key", _descriptor7, this);
        }
      }, _descriptor7 = _applyDecoratedDescriptor(_class5.prototype, "key", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new Key();
        }
      }), _class5);
      let Obj = (_class7 = class Obj {
        constructor() {
          _initializerDefineProperty(this, "path", _descriptor8, this);
        }
      }, _descriptor8 = _applyDecoratedDescriptor(_class7.prototype, "path", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new Path();
        }
      }), _class7);
      let obj = new Obj();
      this.assert.equal((0, _metal.get)(obj, 'path.key.value'), 'value for some-key');
    }
  });
});
define("@ember/-internals/metal/tests/tracked/set_test", ["internal-test-helpers", "@ember/-internals/metal"], function (_internalTestHelpers, _metal) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  let createObj = () => {
    var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
    let Obj = (_class = class Obj {
      constructor() {
        _initializerDefineProperty(this, "string", _descriptor, this);
        _initializerDefineProperty(this, "number", _descriptor2, this);
        _initializerDefineProperty(this, "boolTrue", _descriptor3, this);
        _initializerDefineProperty(this, "boolFalse", _descriptor4, this);
        _initializerDefineProperty(this, "nullValue", _descriptor5, this);
        _initializerDefineProperty(this, "undefinedValue", _descriptor6, this);
      }
    }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "string", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 'string';
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "number", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 23;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "boolTrue", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return true;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "boolFalse", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "nullValue", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "undefinedValue", [_metal.tracked], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return undefined;
      }
    })), _class);
    return new Obj();
  };
  (0, _internalTestHelpers.moduleFor)('@tracked set', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should set arbitrary properties on an object'](assert) {
      var _class3, _descriptor7;
      let obj = createObj();
      let Obj = (_class3 = class Obj {
        constructor() {
          _initializerDefineProperty(this, "undefinedValue", _descriptor7, this);
        }
      }, _descriptor7 = _applyDecoratedDescriptor(_class3.prototype, "undefinedValue", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'emberjs';
        }
      }), _class3);
      let newObj = new Obj();
      for (let key in obj) {
        assert.equal((0, _metal.set)(newObj, key, obj[key]), obj[key], 'should return value');
        assert.equal((0, _metal.get)(newObj, key), obj[key], 'should set value');
      }
    }
    ['@test set should not throw an error when setting on shadowed properties'](assert) {
      var _class5, _descriptor8;
      let Obj = (_class5 = class Obj {
        constructor() {
          _initializerDefineProperty(this, "value", _descriptor8, this);
          Object.defineProperty(this, 'value', {
            writable: true,
            value: 'emberjs'
          });
        }
      }, _descriptor8 = _applyDecoratedDescriptor(_class5.prototype, "value", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'emberjs';
        }
      }), _class5);
      let newObj = new Obj();
      (0, _metal.set)(newObj, 'value', 123);
      assert.equal(newObj.value, 123, 'it worked');
    }
  });
});
define("@ember/-internals/metal/tests/tracked/validation_test", ["@ember/-internals/metal", "internal-test-helpers", "@glimmer/validator"], function (_metal, _internalTestHelpers, _validator) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('@tracked get validation', class extends _internalTestHelpers.AbstractTestCase {
    ["@test autotracking should work with tracked fields"](assert) {
      var _class, _descriptor;
      let Tracked = (_class = class Tracked {
        constructor(first) {
          _initializerDefineProperty(this, "first", _descriptor, this);
          this.first = first;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return undefined;
        }
      }), _class);
      let obj = new Tracked('Tom', 'Dale');
      let tag = (0, _validator.track)(() => obj.first);
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal(obj.first, 'Tom', 'The full name starts correct');
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      obj.first = 'Thomas';
      assert.equal((0, _validator.validateTag)(tag, snapshot), false);
      assert.equal(obj.first, 'Thomas');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ["@test autotracking should work with initializers"](assert) {
      var _class3, _descriptor2, _descriptor3;
      let Tracked = (_class3 = class Tracked {
        constructor() {
          _initializerDefineProperty(this, "first", _descriptor2, this);
          _initializerDefineProperty(this, "second", _descriptor3, this);
        }
      }, (_descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return "first: " + this.second;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class3.prototype, "second", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'second';
        }
      })), _class3);
      let obj = new Tracked();
      let tag = (0, _validator.track)(() => obj.first);
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal(obj.first, 'first: second', 'The value initializes correctly');
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      obj.second = '2nd';

      // See: https://github.com/glimmerjs/glimmer-vm/pull/1018
      // assert.equal(validate(tag, snapshot), true);

      assert.equal(obj.first, 'first: second', 'The value stays the same once initialized');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      obj.first = 'FIRST!!!';
      assert.equal((0, _validator.validateTag)(tag, snapshot), false);
      assert.equal(obj.first, 'FIRST!!!');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ["@test autotracking should work with native getters"](assert) {
      var _class5, _descriptor4, _descriptor5;
      let Tracked = (_class5 = class Tracked {
        constructor(first, last) {
          _initializerDefineProperty(this, "first", _descriptor4, this);
          _initializerDefineProperty(this, "last", _descriptor5, this);
          this.first = first;
          this.last = last;
        }
        get full() {
          return this.first + " " + this.last;
        }
      }, (_descriptor4 = _applyDecoratedDescriptor(_class5.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return undefined;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "last", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return undefined;
        }
      })), _class5);
      let obj = new Tracked('Tom', 'Dale');
      let tag = (0, _validator.track)(() => obj.full);
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal(obj.full, 'Tom Dale', 'The full name starts correct');
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      obj.first = 'Thomas';
      assert.equal((0, _validator.validateTag)(tag, snapshot), false);
      assert.equal(obj.full, 'Thomas Dale');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ["@test autotracking should work with native setters"](assert) {
      var _class7, _descriptor6, _descriptor7;
      let Tracked = (_class7 = class Tracked {
        constructor(first, last) {
          _initializerDefineProperty(this, "first", _descriptor6, this);
          _initializerDefineProperty(this, "last", _descriptor7, this);
          this.first = first;
          this.last = last;
        }
        get full() {
          return this.first + " " + this.last;
        }
        set full(value) {
          let [first, last] = value.split(' ');
          this.first = first;
          this.last = last;
        }
      }, (_descriptor6 = _applyDecoratedDescriptor(_class7.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return undefined;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class7.prototype, "last", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return undefined;
        }
      })), _class7);
      let obj = new Tracked('Tom', 'Dale');
      let tag = (0, _validator.track)(() => obj.full);
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal(obj.full, 'Tom Dale', 'The full name starts correct');
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      obj.full = 'Melanie Sumner';
      assert.equal((0, _validator.validateTag)(tag, snapshot), false);
      assert.equal(obj.full, 'Melanie Sumner');
      assert.equal(obj.first, 'Melanie');
      assert.equal(obj.last, 'Sumner');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ["@test interaction with Ember object model (tracked property depending on Ember property)"](assert) {
      class Tracked {
        constructor(name) {
          this.name = name;
        }
        get full() {
          return (0, _metal.get)(this, 'name.first') + " " + (0, _metal.get)(this, 'name.last');
        }
      }
      let tom = {
        first: 'Tom',
        last: 'Dale'
      };
      let obj = new Tracked(tom);
      let tag = (0, _validator.track)(() => obj.full);
      assert.equal(obj.full, 'Tom Dale');
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      (0, _metal.set)(tom, 'first', 'Thomas');
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after setting with Ember set');
      assert.equal(obj.full, 'Thomas Dale');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      (0, _metal.set)(obj, 'name', {
        first: 'Ricardo',
        last: 'Mendes'
      });
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after setting with Ember set');
      assert.equal(obj.full, 'Ricardo Mendes');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ["@test interaction with Ember object model (Ember computed property depending on tracked property)"](assert) {
      var _class9, _descriptor8, _descriptor9;
      class EmberObject {
        constructor(name) {
          this.name = name;
        }
      }
      (0, _metal.defineProperty)(EmberObject.prototype, 'full', (0, _metal.computed)('name.first', 'name.last', function () {
        let name = (0, _metal.get)(this, 'name');
        return name.first + " " + name.last;
      }));
      let Name = (_class9 = class Name {
        constructor(first, last) {
          _initializerDefineProperty(this, "first", _descriptor8, this);
          _initializerDefineProperty(this, "last", _descriptor9, this);
          this.first = first;
          this.last = last;
        }
      }, (_descriptor8 = _applyDecoratedDescriptor(_class9.prototype, "first", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor9 = _applyDecoratedDescriptor(_class9.prototype, "last", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class9);
      let tom = new Name('Tom', 'Dale');
      let obj = new EmberObject(tom);
      let tag = (0, _metal.tagForProperty)(obj, 'full');
      let full = (0, _metal.get)(obj, 'full');
      assert.equal(full, 'Tom Dale');
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      tom.first = 'Thomas';
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after setting with tracked properties');
      assert.equal((0, _metal.get)(obj, 'full'), 'Thomas Dale');
      snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
    }
    ['@test interaction with the Ember object model (paths going through tracked properties)'](assert) {
      var _class12, _descriptor10;
      let self;
      class EmberObject {
        constructor(contact) {
          this.contact = void 0;
          this.contact = contact;
          self = this;
        }
      }
      (0, _metal.defineProperty)(EmberObject.prototype, 'full', (0, _metal.computed)('contact.name.first', 'contact.name.last', function () {
        let contact = (0, _metal.get)(self, 'contact');
        return (0, _metal.get)(contact.name, 'first') + " " + (0, _metal.get)(contact.name, 'last');
      }));
      let Contact = (_class12 = class Contact {
        constructor(name) {
          _initializerDefineProperty(this, "name", _descriptor10, this);
          this.name = name;
        }
      }, _descriptor10 = _applyDecoratedDescriptor(_class12.prototype, "name", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return undefined;
        }
      }), _class12);
      class EmberName {
        constructor(first, last) {
          this.first = void 0;
          this.last = void 0;
          this.first = first;
          this.last = last;
        }
      }
      let tom = new EmberName('Tom', 'Dale');
      let contact = new Contact(tom);
      let obj = new EmberObject(contact);
      let tag = (0, _metal.tagForProperty)(obj, 'full');
      let full = (0, _metal.get)(obj, 'full');
      assert.equal(full, 'Tom Dale');
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      (0, _metal.set)(tom, 'first', 'Thomas');
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after setting with Ember.set');
      assert.equal((0, _metal.get)(obj, 'full'), 'Thomas Dale');
      snapshot = (0, _validator.valueForTag)(tag);
      tom = contact.name = new EmberName('T', 'Dale');
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after setting with Ember.set');
      assert.equal((0, _metal.get)(obj, 'full'), 'T Dale');
      snapshot = (0, _validator.valueForTag)(tag);
      (0, _metal.set)(tom, 'first', 'Tizzle');
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after setting with Ember.set');
      assert.equal((0, _metal.get)(obj, 'full'), 'Tizzle Dale');
    }
    ['@test ember get interaction with arrays'](assert) {
      class EmberObject {
        constructor() {
          this.array = [];
        }
      }
      let obj = new EmberObject();
      let array;
      let tag = (0, _validator.track)(() => array = (0, _metal.get)(obj, 'array'));
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.deepEqual(array, []);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      array.push(1);
      (0, _metal.notifyPropertyChange)(array, '[]');
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after pushing an object and notifying on the array');
    }
    ['@test native get interaction with arrays'](assert) {
      var _class16, _descriptor11;
      let EmberObject = (_class16 = class EmberObject {
        constructor() {
          _initializerDefineProperty(this, "array", _descriptor11, this);
        }
      }, _descriptor11 = _applyDecoratedDescriptor(_class16.prototype, "array", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _class16);
      let obj = new EmberObject();
      let array;
      let tag = (0, _validator.track)(() => array = obj.array);
      let snapshot = (0, _validator.valueForTag)(tag);
      assert.deepEqual(array, []);
      assert.equal((0, _validator.validateTag)(tag, snapshot), true);
      array.push(1);
      (0, _metal.notifyPropertyChange)(array, '[]');
      assert.equal((0, _validator.validateTag)(tag, snapshot), false, 'invalid after pushing an object and notifying on the array');
    }
    ['@test gives helpful assertion when a tracked property is mutated after access in with an autotracking transaction']() {
      var _class18, _descriptor12;
      let EmberObject = (_class18 = class EmberObject {
        constructor() {
          _initializerDefineProperty(this, "value", _descriptor12, this);
        }
      }, _descriptor12 = _applyDecoratedDescriptor(_class18.prototype, "value", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class18);
      let obj = new EmberObject();
      expectAssertion(() => {
        (0, _validator.track)(() => {
          obj.value;
          obj.value = 123;
        });
      }, /You attempted to update `value` on `EmberObject`, but it had already been used previously in the same computation/);
    }
    ['@test get() does not entangle in the autotracking stack until after retrieving the value'](assert) {
      assert.expect(0);
      class EmberObject {
        get foo() {
          (0, _metal.notifyPropertyChange)(this, 'foo');
          return 123;
        }
      }
      let obj = new EmberObject();
      (0, _validator.track)(() => {
        (0, _metal.get)(obj, 'foo');
      });
    }
  });
});
define("@ember/-internals/runtime/tests/array/any-test", ["@ember/array", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_array, _internalTestHelpers, _array2) {
  "use strict";

  class AnyTests extends _internalTestHelpers.AbstractTestCase {
    '@test any should should invoke callback on each item as long as you return false'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let found = [];
      let result;
      result = obj.any(function (i) {
        found.push(i);
        return false;
      });
      this.assert.equal(result, false, 'return value of obj.any');
      this.assert.deepEqual(found, ary, 'items passed during any() should match');
    }
    '@test any should stop invoking when you return true'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let cnt = ary.length - 2;
      let exp = cnt;
      let found = [];
      let result;
      result = obj.any(function (i) {
        found.push(i);
        return --cnt <= 0;
      });
      this.assert.equal(result, true, 'return value of obj.any');
      this.assert.equal(found.length, exp, 'should invoke proper number of times');
      this.assert.deepEqual(found, ary.slice(0, -2), 'items passed during any() should match');
    }
    '@test any should return true if any object matches the callback'() {
      let obj = (0, _array.A)([0, 1, 2]);
      let result;
      result = obj.any(i => Boolean(i));
      this.assert.equal(result, true, 'return value of obj.any');
    }
    '@test any should produce correct results even if the matching element is undefined'(assert) {
      let obj = (0, _array.A)([undefined]);
      let result;
      result = obj.any(() => true);
      assert.equal(result, true, 'return value of obj.any');
    }
  }
  (0, _array2.runArrayTests)('any', AnyTests);
});
define("@ember/-internals/runtime/tests/array/apply-test", ["@ember/array", "internal-test-helpers"], function (_array, _internalTestHelpers) {
  "use strict";

  class ArrayPrototypeExtensionSelfReferenceTests extends _internalTestHelpers.AbstractTestCase {
    '@test should not create non-Symbol, enumerable properties that refer to itself'() {
      // Don't want to pollute Array.prototype so we make a fake / simple prototype
      function ThrowAwayArray() {}

      // Extend our throw-away prototype (like EXTEND_PROTOTYPES.Array would)
      _array.NativeArray.apply(ThrowAwayArray.prototype);

      // Create an instance to test
      let obj = new ThrowAwayArray();

      // Make sure that no enumerable properties refer back to the object (creating a cyclic structure)
      for (let p in obj) {
        this.assert.notStrictEqual(obj[p], obj, ("Property \"" + p + "\" is an enumerable part of the prototype\n        so must not refer back to the original array.\n        Otherwise code that explores all properties,\n        such as jQuery.extend and other \"deep cloning\" functions,\n        will get stuck in an infinite loop.\n        ").replace(/\s+/g, ' '));
      }
    }
  }
  (0, _internalTestHelpers.moduleFor)("NativeArray: apply", ArrayPrototypeExtensionSelfReferenceTests);
});
define("@ember/-internals/runtime/tests/array/compact-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class CompactTests extends _internalTestHelpers.AbstractTestCase {
    '@test removes null and undefined values from enumerable'() {
      let obj = this.newObject([null, 1, false, '', undefined, 0, null]);
      let ary = obj.compact();
      this.assert.deepEqual(ary, [1, false, '', 0]);
    }
  }
  (0, _array.runArrayTests)('compact', CompactTests);
});
define("@ember/-internals/runtime/tests/array/every-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_internalTestHelpers, _array, _object) {
  "use strict";

  class EveryTest extends _internalTestHelpers.AbstractTestCase {
    '@test every should should invoke callback on each item as long as you return true'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let found = [];
      let result;
      result = obj.every(function (i) {
        found.push(i);
        return true;
      });
      this.assert.equal(result, true, 'return value of obj.every');
      this.assert.deepEqual(found, ary, 'items passed during every() should match');
    }
    '@test every should stop invoking when you return false'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let cnt = ary.length - 2;
      let exp = cnt;
      let found = [];
      let result;
      result = obj.every(function (i) {
        found.push(i);
        return --cnt > 0;
      });
      this.assert.equal(result, false, 'return value of obj.every');
      this.assert.equal(found.length, exp, 'should invoke proper number of times');
      this.assert.deepEqual(found, ary.slice(0, -2), 'items passed during every() should match');
    }
  }
  class IsEveryTest extends _internalTestHelpers.AbstractTestCase {
    '@test should return true of every property matches'() {
      let obj = this.newObject([{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })]);
      this.assert.equal(obj.isEvery('foo', 'foo'), true, 'isEvery(foo)');
      this.assert.equal(obj.isEvery('bar', 'bar'), false, 'isEvery(bar)');
    }
    '@test should return true of every property is true'() {
      let obj = this.newObject([{
        foo: 'foo',
        bar: true
      }, _object.default.create({
        foo: 'bar',
        bar: false
      })]);

      // different values - all eval to true
      this.assert.equal(obj.isEvery('foo'), true, 'isEvery(foo)');
      this.assert.equal(obj.isEvery('bar'), false, 'isEvery(bar)');
    }
    '@test should return true if every property matches null'() {
      let obj = this.newObject([{
        foo: null,
        bar: 'BAZ'
      }, _object.default.create({
        foo: null,
        bar: null
      })]);
      this.assert.equal(obj.isEvery('foo', null), true, "isEvery('foo', null)");
      this.assert.equal(obj.isEvery('bar', null), false, "isEvery('bar', null)");
    }
    '@test should return true if every property is undefined'() {
      let obj = this.newObject([{
        foo: undefined,
        bar: 'BAZ'
      }, _object.default.create({
        bar: undefined
      })]);
      this.assert.equal(obj.isEvery('foo', undefined), true, "isEvery('foo', undefined)");
      this.assert.equal(obj.isEvery('bar', undefined), false, "isEvery('bar', undefined)");
    }
  }
  (0, _array.runArrayTests)('every', EveryTest);
  (0, _array.runArrayTests)('isEvery', IsEveryTest);
});
define("@ember/-internals/runtime/tests/array/filter-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class FilterTest extends _internalTestHelpers.AbstractTestCase {
    '@test filter should invoke on each item'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let cnt = ary.length - 2;
      let found = [];
      let result;

      // return true on all but the last two
      result = obj.filter(function (i) {
        found.push(i);
        return --cnt >= 0;
      });
      this.assert.deepEqual(found, ary, 'should have invoked on each item');
      this.assert.deepEqual(result, ary.slice(0, -2), 'filtered array should exclude items');
    }
  }
  class FilterByTest extends _internalTestHelpers.AbstractTestCase {
    '@test should include in result if property is true'() {
      let obj, ary;
      ary = [{
        foo: 'foo',
        bar: true
      }, _object.default.create({
        foo: 'bar',
        bar: false
      })];
      obj = this.newObject(ary);

      // different values - all eval to true
      this.assert.deepEqual(obj.filterBy('foo'), ary, 'filterBy(foo)');
      this.assert.deepEqual(obj.filterBy('bar'), [ary[0]], 'filterBy(bar)');
    }
    '@test should filter on second argument if provided'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      }), {
        name: 'obj3',
        foo: 2
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', 3), [ary[0], ary[3]], "filterBy('foo', 3)')");
    }
    '@test should correctly filter null second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: null
      }), {
        name: 'obj3',
        foo: null
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', null), [ary[1], ary[2]], "filterBy('foo', 3)')");
    }
    '@test should correctly filter explicit undefined second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', undefined), ary.slice(2), "filterBy('foo', 3)')");
    }
    '@test should not match undefined properties without second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo'), ary.slice(0, 2), "filterBy('foo', 3)')");
    }
  }
  (0, _array.runArrayTests)('filter', FilterTest);
  (0, _array.runArrayTests)('filter', FilterByTest);
});
define("@ember/-internals/runtime/tests/array/find-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class FindTests extends _internalTestHelpers.AbstractTestCase {
    '@test find should invoke callback on each item as long as you return false'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let found = [];
      let result;
      result = obj.find(function (i) {
        found.push(i);
        return false;
      });
      this.assert.equal(result, undefined, 'return value of obj.find');
      this.assert.deepEqual(found, ary, 'items passed during find() should match');
    }
    '@test every should stop invoking when you return true'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let cnt = ary.length - 2;
      let exp = cnt;
      let found = [];
      let result;
      result = obj.find(function (i) {
        found.push(i);
        return --cnt >= 0;
      });
      this.assert.equal(result, ary[exp - 1], 'return value of obj.find');
      this.assert.equal(found.length, exp, 'should invoke proper number of times');
      this.assert.deepEqual(found, ary.slice(0, -2), 'items passed during find() should match');
    }
  }
  class FindByTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return first object of property matches'() {
      let ary, obj;
      ary = [{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })];
      obj = this.newObject(ary);
      this.assert.equal(obj.findBy('foo', 'foo'), ary[0], 'findBy(foo)');
      this.assert.equal(obj.findBy('bar', 'bar'), ary[1], 'findBy(bar)');
    }
    '@test should return first object with truthy prop'() {
      let ary, obj;
      ary = [{
        foo: 'foo',
        bar: false
      }, _object.default.create({
        foo: 'bar',
        bar: true
      })];
      obj = this.newObject(ary);

      // different values - all eval to true
      this.assert.equal(obj.findBy('foo'), ary[0], 'findBy(foo)');
      this.assert.equal(obj.findBy('bar'), ary[1], 'findBy(bar)');
    }
    '@test should return first null property match'() {
      let ary, obj;
      ary = [{
        foo: null,
        bar: 'BAZ'
      }, _object.default.create({
        foo: null,
        bar: null
      })];
      obj = this.newObject(ary);
      this.assert.equal(obj.findBy('foo', null), ary[0], "findBy('foo', null)");
      this.assert.equal(obj.findBy('bar', null), ary[1], "findBy('bar', null)");
    }
    '@test should return first undefined property match'() {
      let ary, obj;
      ary = [{
        foo: undefined,
        bar: 'BAZ'
      }, _object.default.create({})];
      obj = this.newObject(ary);
      this.assert.equal(obj.findBy('foo', undefined), ary[0], "findBy('foo', undefined)");
      this.assert.equal(obj.findBy('bar', undefined), ary[1], "findBy('bar', undefined)");
    }
  }
  (0, _array.runArrayTests)('find', FindTests);
  (0, _array.runArrayTests)('findBy', FindByTests);
});
define("@ember/-internals/runtime/tests/array/firstObject-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class FirstObjectTests extends _internalTestHelpers.AbstractTestCase {
    '@test returns first item in enumerable'() {
      let obj = this.newObject();
      this.assert.equal((0, _object.get)(obj, 'firstObject'), this.toArray(obj)[0]);
    }
    '@test returns undefined if enumerable is empty'() {
      let obj = this.newObject([]);
      this.assert.equal((0, _object.get)(obj, 'firstObject'), undefined);
    }
    '@test can not be set'() {
      let obj = this.newObject([]);
      this.assert.equal((0, _object.get)(obj, 'firstObject'), this.toArray(obj)[0]);
      this.assert.throws(() => {
        (0, _object.set)(obj, 'firstObject', 'foo!');
      }, /Cannot set read-only property "firstObject" on object/);
    }
  }
  (0, _array.runArrayTests)('firstObject', FirstObjectTests);
});
define("@ember/-internals/runtime/tests/array/forEach-test", ["@ember/-internals/utils", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_utils, _metal, _internalTestHelpers, _array) {
  "use strict";

  class ForEachTests extends _internalTestHelpers.AbstractTestCase {
    '@test forEach should iterate over list'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let found = [];
      obj.forEach(i => found.push(i));
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
    }
    '@test forEach should iterate over list after mutation'() {
      if ((0, _metal.get)(this, 'canTestMutation')) {
        this.assert.expect(0);
        return;
      }
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let found = [];
      obj.forEach(i => found.push(i));
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
      this.mutate(obj);
      ary = this.toArray(obj);
      found = [];
      obj.forEach(i => found.push(i));
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
    }
    '@test 2nd target parameter'() {
      let obj = this.newObject();
      let target = this;
      obj.forEach(() => {
        // ES6TODO: When transpiled we will end up with "use strict" which disables automatically binding to the global context.
        // Therefore, the following test can never pass in strict mode unless we modify the `map` function implementation to
        // use `Ember.lookup` if target is not specified.
        //
        // equal(guidFor(this), guidFor(global), 'should pass the global object as this if no context');
      });
      obj.forEach(() => {
        this.assert.equal((0, _utils.guidFor)(this), (0, _utils.guidFor)(target), 'should pass target as this if context');
      }, target);
    }
    '@test callback params'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let loc = 0;
      obj.forEach((item, idx, enumerable) => {
        this.assert.equal(item, ary[loc], 'item param');
        this.assert.equal(idx, loc, 'idx param');
        this.assert.equal((0, _utils.guidFor)(enumerable), (0, _utils.guidFor)(obj), 'enumerable param');
        loc++;
      });
    }
  }
  (0, _array.runArrayTests)('forEach', ForEachTests);
});
define("@ember/-internals/runtime/tests/array/includes-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class IncludesTests extends _internalTestHelpers.AbstractTestCase {
    '@test includes returns correct value if startAt is positive'() {
      let data = (0, _array.newFixture)(3);
      let obj = this.newObject(data);
      this.assert.equal(obj.includes(data[1], 1), true, 'should return true if included');
      this.assert.equal(obj.includes(data[0], 1), false, 'should return false if not included');
    }
    '@test includes returns correct value if startAt is negative'() {
      let data = (0, _array.newFixture)(3);
      let obj = this.newObject(data);
      this.assert.equal(obj.includes(data[1], -2), true, 'should return true if included');
      this.assert.equal(obj.includes(data[0], -2), false, 'should return false if not included');
    }
    '@test includes returns true if startAt + length is still negative'() {
      let data = (0, _array.newFixture)(1);
      let obj = this.newObject(data);
      this.assert.equal(obj.includes(data[0], -2), true, 'should return true if included');
      this.assert.equal(obj.includes((0, _array.newFixture)(1), -2), false, 'should return false if not included');
    }
    '@test includes returns false if startAt out of bounds'() {
      let data = (0, _array.newFixture)(1);
      let obj = this.newObject(data);
      this.assert.equal(obj.includes(data[0], 2), false, 'should return false if startAt >= length');
      this.assert.equal(obj.includes((0, _array.newFixture)(1), 2), false, 'should return false if startAt >= length');
    }
  }
  (0, _array.runArrayTests)('includes', IncludesTests);
});
define("@ember/-internals/runtime/tests/array/indexOf-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class IndexOfTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return index of object'() {
      let expected = (0, _array.newFixture)(3);
      let obj = this.newObject(expected);
      let len = 3;
      for (let idx = 0; idx < len; idx++) {
        this.assert.equal(obj.indexOf(expected[idx]), idx, "obj.indexOf(" + expected[idx] + ") should match idx");
      }
    }
    '@test should return -1 when requesting object not in index'() {
      let obj = this.newObject((0, _array.newFixture)(3));
      let foo = {};
      this.assert.equal(obj.indexOf(foo), -1, 'obj.indexOf(foo) should be < 0');
    }
  }
  (0, _array.runArrayTests)('indexOf', IndexOfTests);
});
define("@ember/-internals/runtime/tests/array/invoke-test", ["@ember/object", "@ember/array", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _array, _internalTestHelpers, _array2) {
  "use strict";

  class InvokeTests extends _internalTestHelpers.AbstractTestCase {
    '@test invoke should call on each object that implements'() {
      let cnt, ary, obj;
      function F(amt) {
        cnt += amt === undefined ? 1 : amt;
      }
      cnt = 0;
      ary = [{
        foo: F
      }, _object.default.create({
        foo: F
      }),
      // NOTE: does not impl foo - invoke should just skip
      _object.default.create({
        bar: F
      }), {
        foo: F
      }];
      obj = this.newObject(ary);
      obj.invoke('foo');
      this.assert.equal(cnt, 3, 'should have invoked 3 times');
      cnt = 0;
      obj.invoke('foo', 2);
      this.assert.equal(cnt, 6, 'should have invoked 3 times, passing param');
    }
    '@test invoke should return an array containing the results of each invoked method'(assert) {
      let obj = this.newObject([{
        foo() {
          return 'one';
        }
      }, {},
      // intentionally not including `foo` method
      {
        foo() {
          return 'two';
        }
      }]);
      let result = obj.invoke('foo');
      assert.deepEqual(result, ['one', undefined, 'two']);
    }
    '@test invoke should return an extended array (aka Ember.A)'(assert) {
      let obj = this.newObject([{
        foo() {}
      }, {
        foo() {}
      }]);
      let result = obj.invoke('foo');
      assert.ok(_array.NativeArray.detect(result), 'NativeArray has been applied');
    }
  }
  (0, _array2.runArrayTests)('invoke', InvokeTests);
});
define("@ember/-internals/runtime/tests/array/isAny-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class IsAnyTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return true of any property matches'() {
      let obj = this.newObject([{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })]);
      this.assert.equal(obj.isAny('foo', 'foo'), true, 'isAny(foo)');
      this.assert.equal(obj.isAny('bar', 'bar'), true, 'isAny(bar)');
      this.assert.equal(obj.isAny('bar', 'BIFF'), false, 'isAny(BIFF)');
    }
    '@test should return true of any property is true'() {
      let obj = this.newObject([{
        foo: 'foo',
        bar: true
      }, _object.default.create({
        foo: 'bar',
        bar: false
      })]);

      // different values - all eval to true
      this.assert.equal(obj.isAny('foo'), true, 'isAny(foo)');
      this.assert.equal(obj.isAny('bar'), true, 'isAny(bar)');
      this.assert.equal(obj.isAny('BIFF'), false, 'isAny(biff)');
    }
    '@test should return true if any property matches null'() {
      let obj = this.newObject([{
        foo: null,
        bar: 'bar'
      }, _object.default.create({
        foo: 'foo',
        bar: null
      })]);
      this.assert.equal(obj.isAny('foo', null), true, "isAny('foo', null)");
      this.assert.equal(obj.isAny('bar', null), true, "isAny('bar', null)");
    }
    '@test should return true if any property is undefined'() {
      let obj = this.newObject([{
        foo: undefined,
        bar: 'bar'
      }, _object.default.create({
        foo: 'foo'
      })]);
      this.assert.equal(obj.isAny('foo', undefined), true, "isAny('foo', undefined)");
      this.assert.equal(obj.isAny('bar', undefined), true, "isAny('bar', undefined)");
    }
    '@test should not match undefined properties without second argument'() {
      let obj = this.newObject([{
        foo: undefined
      }, _object.default.create({})]);
      this.assert.equal(obj.isAny('foo'), false, "isAny('foo', undefined)");
    }
  }
  (0, _array.runArrayTests)('isAny', IsAnyTests);
});
define("@ember/-internals/runtime/tests/array/lastIndexOf-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class LastIndexOfTests extends _internalTestHelpers.AbstractTestCase {
    "@test should return index of object's last occurrence"() {
      let expected = (0, _array.newFixture)(3);
      let obj = this.newObject(expected);
      let len = 3;
      for (let idx = 0; idx < len; idx++) {
        this.assert.equal(obj.lastIndexOf(expected[idx]), idx, "obj.lastIndexOf(" + expected[idx] + ") should match idx");
      }
    }
    "@test should return index of object's last occurrence even startAt search location is equal to length"() {
      let expected = (0, _array.newFixture)(3);
      let obj = this.newObject(expected);
      let len = 3;
      for (let idx = 0; idx < len; idx++) {
        this.assert.equal(obj.lastIndexOf(expected[idx], len), idx, "obj.lastIndexOfs(" + expected[idx] + ") should match idx");
      }
    }
    "@test should return index of object's last occurrence even startAt search location is greater than length"() {
      let expected = (0, _array.newFixture)(3);
      let obj = this.newObject(expected);
      let len = 3;
      for (let idx = 0; idx < len; idx++) {
        this.assert.equal(obj.lastIndexOf(expected[idx], len + 1), idx, "obj.lastIndexOf(" + expected[idx] + ") should match idx");
      }
    }
    '@test should return -1 when no match is found'() {
      let obj = this.newObject((0, _array.newFixture)(3));
      let foo = {};
      this.assert.equal(obj.lastIndexOf(foo), -1, 'obj.lastIndexOf(foo) should be -1');
    }
    '@test should return -1 when no match is found even startAt search location is equal to length'() {
      let obj = this.newObject((0, _array.newFixture)(3));
      let foo = {};
      this.assert.equal(obj.lastIndexOf(foo, (0, _object.get)(obj, 'length')), -1, 'obj.lastIndexOf(foo) should be -1');
    }
    '@test should return -1 when no match is found even startAt search location is greater than length'() {
      let obj = this.newObject((0, _array.newFixture)(3));
      let foo = {};
      this.assert.equal(obj.lastIndexOf(foo, (0, _object.get)(obj, 'length') + 1), -1, 'obj.lastIndexOf(foo) should be -1');
    }
  }
  (0, _array.runArrayTests)('lastIndexOf', LastIndexOfTests);
});
define("@ember/-internals/runtime/tests/array/lastObject-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_internalTestHelpers, _array, _object) {
  "use strict";

  class LastObjectTests extends _internalTestHelpers.AbstractTestCase {
    '@test returns last item in enumerable'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      this.assert.equal((0, _object.get)(obj, 'lastObject'), ary[ary.length - 1]);
    }
    '@test returns undefined if enumerable is empty'() {
      let obj = this.newObject([]);
      this.assert.equal((0, _object.get)(obj, 'lastObject'), undefined);
    }
    '@test can not be set'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      this.assert.equal((0, _object.get)(obj, 'lastObject'), ary[ary.length - 1]);
      this.assert.throws(function () {
        (0, _object.set)(obj, 'lastObject', 'foo!');
      }, /Cannot set read-only property "lastObject" on object/);
    }
  }
  (0, _array.runArrayTests)('lastObject', LastObjectTests);
});
define("@ember/-internals/runtime/tests/array/map-test", ["@ember/-internals/utils", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_utils, _internalTestHelpers, _array, _object) {
  "use strict";

  const mapFunc = item => item ? item.toString() : null;
  class MapTests extends _internalTestHelpers.AbstractTestCase {
    '@test map should iterate over list'() {
      let obj = this.newObject();
      let ary = this.toArray(obj).map(mapFunc);
      let found = [];
      found = obj.map(mapFunc);
      this.assert.deepEqual(found, ary, 'mapped arrays should match');
    }
    '@test map should iterate over list after mutation'() {
      if ((0, _object.get)(this, 'canTestMutation')) {
        this.assert.expect(0);
        return;
      }
      let obj = this.newObject();
      let ary = this.toArray(obj).map(mapFunc);
      let found;
      found = obj.map(mapFunc);
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
      this.mutate(obj);
      ary = this.toArray(obj).map(mapFunc);
      found = obj.map(mapFunc);
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
    }
    '@test 2nd target parameter'() {
      let obj = this.newObject();
      let target = this;
      obj.map(() => {
        // ES6TODO: When transpiled we will end up with "use strict" which disables automatically binding to the global context.
        // Therefore, the following test can never pass in strict mode unless we modify the `map` function implementation to
        // use `Ember.lookup` if target is not specified.
        //
        // equal(guidFor(this), guidFor(global), 'should pass the global object as this if no context');
      });
      obj.map(() => {
        this.assert.equal((0, _utils.guidFor)(this), (0, _utils.guidFor)(target), 'should pass target as this if context');
      }, target);
    }
    '@test callback params'() {
      let obj = this.newObject();
      let ary = this.toArray(obj);
      let loc = 0;
      obj.map((item, idx, enumerable) => {
        this.assert.equal(item, ary[loc], 'item param');
        this.assert.equal(idx, loc, 'idx param');
        this.assert.equal((0, _utils.guidFor)(enumerable), (0, _utils.guidFor)(obj), 'enumerable param');
        loc++;
      });
    }
  }
  (0, _array.runArrayTests)('map', MapTests);
});
define("@ember/-internals/runtime/tests/array/mapBy-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class MapByTests extends _internalTestHelpers.AbstractTestCase {
    '@test get value of each property'() {
      let obj = this.newObject([{
        a: 1
      }, {
        a: 2
      }]);
      this.assert.equal(obj.mapBy('a').join(''), '12');
    }
    '@test should work also through getEach alias'() {
      let obj = this.newObject([{
        a: 1
      }, {
        a: 2
      }]);
      this.assert.equal(obj.getEach('a').join(''), '12');
    }
  }
  (0, _array.runArrayTests)('mapBy', MapByTests);
});
define("@ember/-internals/runtime/tests/array/objectAt-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class ObjectAtTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return object at specified index'() {
      let expected = (0, _array.newFixture)(3);
      let obj = this.newObject(expected);
      let len = expected.length;
      for (let idx = 0; idx < len; idx++) {
        this.assert.equal(obj.objectAt(idx), expected[idx], "obj.objectAt(" + idx + ") should match");
      }
    }
    '@test should return undefined when requesting objects beyond index'() {
      let obj;
      obj = this.newObject((0, _array.newFixture)(3));
      this.assert.equal(obj.objectAt(obj, 5), undefined, 'should return undefined for obj.objectAt(5) when len = 3');
      obj = this.newObject([]);
      this.assert.equal(obj.objectAt(obj, 0), undefined, 'should return undefined for obj.objectAt(0) when len = 0');
    }
  }
  (0, _array.runArrayTests)('objectAt', ObjectAtTests);
});
define("@ember/-internals/runtime/tests/array/reduce-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class ReduceTests extends _internalTestHelpers.AbstractTestCase {
    '@test collects a summary value from an enumeration'() {
      let obj = this.newObject([1, 2, 3]);
      let res = obj.reduce((previousValue, item) => previousValue + item, 0);
      this.assert.equal(res, 6);
    }
    '@test passes index of item to callback'() {
      let obj = this.newObject([1, 2, 3]);
      let res = obj.reduce((previousValue, item, index) => previousValue + index, 0);
      this.assert.equal(res, 3);
    }
    '@test passes enumerable object to callback'() {
      let obj = this.newObject([1, 2, 3]);
      let res = obj.reduce((previousValue, item, index, enumerable) => enumerable, 0);
      this.assert.equal(res, obj);
    }
  }
  (0, _array.runArrayTests)('reduce', ReduceTests);
});
define("@ember/-internals/runtime/tests/array/reject-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_internalTestHelpers, _array, _object) {
  "use strict";

  class RejectTest extends _internalTestHelpers.AbstractTestCase {
    '@test should reject any item that does not meet the condition'() {
      let obj = this.newObject([1, 2, 3, 4]);
      let result;
      result = obj.reject(i => i < 3);
      this.assert.deepEqual(result, [3, 4], 'reject the correct items');
    }
    '@test should be the inverse of filter'() {
      let obj = this.newObject([1, 2, 3, 4]);
      let isEven = i => i % 2 === 0;
      let filtered, rejected;
      filtered = obj.filter(isEven);
      rejected = obj.reject(isEven);
      this.assert.deepEqual(filtered, [2, 4], 'filtered evens');
      this.assert.deepEqual(rejected, [1, 3], 'rejected evens');
    }
  }
  class RejectByTest extends _internalTestHelpers.AbstractTestCase {
    '@test should reject based on object'() {
      let obj, ary;
      ary = [{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', 'foo'), [], 'rejectBy(foo)');
      this.assert.deepEqual(obj.rejectBy('bar', 'bar'), [ary[0]], 'rejectBy(bar)');
    }
    '@test should include in result if property is false'() {
      let obj, ary;
      ary = [{
        foo: false,
        bar: true
      }, _object.default.create({
        foo: false,
        bar: false
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo'), ary, 'rejectBy(foo)');
      this.assert.deepEqual(obj.rejectBy('bar'), [ary[1]], 'rejectBy(bar)');
    }
    '@test should reject on second argument if provided'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      }), {
        name: 'obj3',
        foo: 2
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', 3), [ary[1], ary[2]], "rejectBy('foo', 3)')");
    }
    '@test should correctly reject null second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: null
      }), {
        name: 'obj3',
        foo: null
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', null), [ary[0], ary[3]], "rejectBy('foo', null)')");
    }
    '@test should correctly reject undefined second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('bar', undefined), [], "rejectBy('bar', undefined)')");
    }
    '@test should correctly reject explicit undefined second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', undefined), ary.slice(0, 2), "rejectBy('foo', undefined)')");
    }
    '@test should match undefined, null, or false properties without second argument'() {
      let obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      }), {
        name: 'obj7',
        foo: null
      }, _object.default.create({
        name: 'obj8',
        foo: null
      }), {
        name: 'obj9',
        foo: false
      }, _object.default.create({
        name: 'obj10',
        foo: false
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo'), ary.slice(2), "rejectBy('foo')')");
    }
  }
  (0, _array.runArrayTests)('reject', RejectTest);
  (0, _array.runArrayTests)('rejectBy', RejectByTest);
});
define("@ember/-internals/runtime/tests/array/sortBy-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class SortByTests extends _internalTestHelpers.AbstractTestCase {
    '@test sort by value of property'() {
      let obj = this.newObject([{
        a: 2
      }, {
        a: 1
      }]);
      let sorted = obj.sortBy('a');
      this.assert.equal((0, _object.get)(sorted[0], 'a'), 1);
      this.assert.equal((0, _object.get)(sorted[1], 'a'), 2);
    }
    '@test supports multiple propertyNames'() {
      let obj = this.newObject([{
        a: 1,
        b: 2
      }, {
        a: 1,
        b: 1
      }]);
      let sorted = obj.sortBy('a', 'b');
      this.assert.equal((0, _object.get)(sorted[0], 'b'), 1);
      this.assert.equal((0, _object.get)(sorted[1], 'b'), 2);
    }
  }
  (0, _array.runArrayTests)('sortBy', SortByTests);
});
define("@ember/-internals/runtime/tests/array/toArray-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class ToArrayTests extends _internalTestHelpers.AbstractTestCase {
    '@test toArray should convert to an array'() {
      let obj = this.newObject();
      this.assert.deepEqual(obj.toArray(), this.toArray(obj));
    }
  }
  (0, _array.runArrayTests)('toArray', ToArrayTests);
});
define("@ember/-internals/runtime/tests/array/uniq-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class UniqTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return new instance with duplicates removed'() {
      let before, after, obj, ret;
      after = (0, _array.newFixture)(3);
      before = [after[0], after[1], after[2], after[1], after[0]];
      obj = this.newObject(before);
      before = obj.toArray(); // in case of set before will be different...

      ret = obj.uniq();
      this.assert.deepEqual(this.toArray(ret), after, 'should have removed item');
      this.assert.deepEqual(this.toArray(obj), before, 'should not have changed original');
    }
    '@test should return duplicate of same content if no duplicates found'() {
      let item, obj, ret;
      obj = this.newObject((0, _array.newFixture)(3));
      ret = obj.uniq(item);
      this.assert.ok(ret !== obj, 'should not be same object');
      this.assert.deepEqual(this.toArray(ret), this.toArray(obj), 'should be the same content');
    }
  }
  (0, _array.runArrayTests)('uniq', UniqTests);
});
define("@ember/-internals/runtime/tests/array/uniqBy-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class UniqByTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return new instance with duplicates removed'() {
      let numbers = this.newObject([{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 1,
        value: 'one'
      }]);
      this.assert.deepEqual(numbers.uniqBy('id'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }]);
    }
    '@test supports function as key'() {
      let numbers = this.newObject([{
        id: 1,
        value: 'boom'
      }, {
        id: 2,
        value: 'boom'
      }, {
        id: 1,
        value: 'doom'
      }]);
      let keyFunction = val => {
        this.assert.equal(arguments.length, 1);
        return val.value;
      };
      this.assert.deepEqual(numbers.uniqBy(keyFunction), [{
        id: 1,
        value: 'boom'
      }, {
        id: 1,
        value: 'doom'
      }]);
    }
  }
  (0, _array.runArrayTests)('uniqBy', UniqByTests);
});
define("@ember/-internals/runtime/tests/array/without-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class WithoutTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return new instance with item removed'() {
      let before, after, obj, ret;
      before = (0, _array.newFixture)(3);
      after = [before[0], before[2]];
      obj = this.newObject(before);
      ret = obj.without(before[1]);
      this.assert.deepEqual(this.toArray(ret), after, 'should have removed item');
      this.assert.deepEqual(this.toArray(obj), before, 'should not have changed original');
    }
    '@test should remove NaN value'() {
      let before, after, obj, ret;
      before = [...(0, _array.newFixture)(2), NaN];
      after = [before[0], before[1]];
      obj = this.newObject(before);
      ret = obj.without(NaN);
      this.assert.deepEqual(this.toArray(ret), after, 'should have removed item');
    }
    '@test should return same instance if object not found'() {
      let item, obj, ret;
      item = (0, _array.newFixture)(1)[0];
      obj = this.newObject((0, _array.newFixture)(3));
      ret = obj.without(item);
      this.assert.equal(ret, obj, 'should be same instance');
    }
  }
  (0, _array.runArrayTests)('without', WithoutTests);
});
define("@ember/-internals/runtime/tests/core/isEqual_test", ["@ember/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isEqual', class extends _internalTestHelpers.AbstractTestCase {
    ['@test undefined and null'](assert) {
      assert.ok((0, _utils.isEqual)(undefined, undefined), 'undefined is equal to undefined');
      assert.ok(!(0, _utils.isEqual)(undefined, null), 'undefined is not equal to null');
      assert.ok((0, _utils.isEqual)(null, null), 'null is equal to null');
      assert.ok(!(0, _utils.isEqual)(null, undefined), 'null is not equal to undefined');
    }
    ['@test strings should be equal'](assert) {
      assert.ok(!(0, _utils.isEqual)('Hello', 'Hi'), 'different Strings are unequal');
      assert.ok((0, _utils.isEqual)('Hello', 'Hello'), 'same Strings are equal');
    }
    ['@test numericals should be equal'](assert) {
      assert.ok((0, _utils.isEqual)(24, 24), 'same numbers are equal');
      assert.ok(!(0, _utils.isEqual)(24, 21), 'different numbers are inequal');
    }
    ['@test dates should be equal'](assert) {
      assert.ok((0, _utils.isEqual)(new Date(1985, 7, 22), new Date(1985, 7, 22)), 'same dates are equal');
      assert.ok(!(0, _utils.isEqual)(new Date(2014, 7, 22), new Date(1985, 7, 22)), 'different dates are not equal');
    }
    ['@test array should be equal'](assert) {
      // NOTE: We don't test for array contents -- that would be too expensive.
      assert.ok(!(0, _utils.isEqual)([1, 2], [1, 2]), 'two array instances with the same values should not be equal');
      assert.ok(!(0, _utils.isEqual)([1, 2], [1]), 'two array instances with different values should not be equal');
    }
    ['@test first object implements isEqual should use it'](assert) {
      assert.ok((0, _utils.isEqual)({
        isEqual() {
          return true;
        }
      }, null), 'should return true always');
      let obj = {
        isEqual() {
          return false;
        }
      };
      assert.equal((0, _utils.isEqual)(obj, obj), false, 'should return false because isEqual returns false');
    }
  });
});
define("@ember/-internals/runtime/tests/core/is_array_test", ["@ember/array", "@ember/array/proxy", "@ember/object", "@ember/-internals/browser-environment", "internal-test-helpers"], function (_array, _proxy, _object, _browserEnvironment, _internalTestHelpers) {
  "use strict";

  const global = void 0;
  (0, _internalTestHelpers.moduleFor)('Ember Type Checking', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Ember.isArray'](assert) {
      let numarray = [1, 2, 3];
      let number = 23;
      let strarray = ['Hello', 'Hi'];
      let string = 'Hello';
      let object = {};
      let length = {
        length: 12
      };
      let strangeLength = {
        length: 'yes'
      };
      let fn = function () {};
      let asyncFn = async function () {};
      let arrayProxy = _proxy.default.create({
        content: (0, _array.A)()
      });
      assert.equal((0, _array.isArray)(numarray), true, '[1,2,3]');
      assert.equal((0, _array.isArray)(number), false, '23');
      assert.equal((0, _array.isArray)(strarray), true, '["Hello", "Hi"]');
      assert.equal((0, _array.isArray)(string), false, '"Hello"');
      assert.equal((0, _array.isArray)(object), false, '{}');
      assert.equal((0, _array.isArray)(length), true, '{ length: 12 }');
      assert.equal((0, _array.isArray)(strangeLength), false, '{ length: "yes" }');
      assert.equal((0, _array.isArray)(global), false, 'global');
      assert.equal((0, _array.isArray)(fn), false, 'function() {}');
      assert.equal((0, _array.isArray)(asyncFn), false, 'async function() {}');
      assert.equal((0, _array.isArray)(arrayProxy), true, '[]');
    }
    '@test Ember.isArray does not trigger proxy assertion when probing for length GH#16495'(assert) {
      let instance = _object.default.extend({
        // intentionally returning non-null / non-undefined
        unknownProperty() {
          return false;
        }
      }).create();
      assert.equal((0, _array.isArray)(instance), false);
    }
    ['@test Ember.isArray(fileList)'](assert) {
      if (_browserEnvironment.window && typeof _browserEnvironment.window.FileList === 'function') {
        let fileListElement = document.createElement('input');
        fileListElement.type = 'file';
        let fileList = fileListElement.files;
        assert.equal((0, _array.isArray)(fileList), false, 'fileList');
      } else {
        assert.ok(true, 'FileList is not present on window');
      }
    }
  });
});
define("@ember/-internals/runtime/tests/core/is_empty_test", ["@ember/utils", "@ember/array/proxy", "@ember/object/proxy", "@ember/array", "internal-test-helpers"], function (_utils, _proxy, _proxy2, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.isEmpty', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Ember.isEmpty ArrayProxy'](assert) {
      let arrayProxy = _proxy.default.create({
        content: (0, _array.A)()
      });
      assert.equal(true, (0, _utils.isEmpty)(arrayProxy), 'for an ArrayProxy that has empty content');
    }
    ['@test Ember.isEmpty ObjectProxy ArrayProxy'](assert) {
      let arrayProxy = _proxy.default.create({
        content: (0, _array.A)([])
      });
      let objectProxy = _proxy2.default.create({
        content: arrayProxy
      });
      assert.equal(true, (0, _utils.isEmpty)(objectProxy), 'for an ArrayProxy inside ObjectProxy that has empty content');
    }
  });
});
define("@ember/-internals/runtime/tests/ext/rsvp_test", ["@ember/runloop", "@ember/-internals/error-handling", "@ember/-internals/runtime/lib/ext/rsvp", "@ember/debug", "internal-test-helpers"], function (_runloop, _errorHandling, _rsvp, _debug, _internalTestHelpers) {
  "use strict";

  const ORIGINAL_ONERROR = (0, _errorHandling.getOnerror)();
  (0, _internalTestHelpers.moduleFor)('Ember.RSVP', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      (0, _errorHandling.setOnerror)(ORIGINAL_ONERROR);
    }
    ['@test Ensure that errors thrown from within a promise are sent to the console'](assert) {
      let error = new Error('Error thrown in a promise for testing purposes.');
      try {
        (0, _runloop.run)(function () {
          new _rsvp.default.Promise(function () {
            throw error;
          });
        });
        assert.ok(false, 'expected assertion to be thrown');
      } catch (e) {
        assert.equal(e, error, 'error was re-thrown');
      }
    }
    ['@test TransitionAborted errors are not re-thrown'](assert) {
      assert.expect(1);
      let fakeTransitionAbort = {
        name: 'TransitionAborted'
      };
      (0, _runloop.run)(_rsvp.default, 'reject', fakeTransitionAbort);
      assert.ok(true, 'did not throw an error when dealing with TransitionAborted');
    }
    ['@test Can reject with non-Error object'](assert) {
      let wasEmberTesting = (0, _debug.isTesting)();
      (0, _debug.setTesting)(false);
      assert.expect(1);
      try {
        (0, _runloop.run)(_rsvp.default, 'reject', 'foo');
      } catch (e) {
        assert.equal(e, 'foo', 'should throw with rejection message');
      } finally {
        (0, _debug.setTesting)(wasEmberTesting);
      }
    }
    ['@test Can reject with no arguments'](assert) {
      let wasEmberTesting = (0, _debug.isTesting)();
      (0, _debug.setTesting)(false);
      assert.expect(1);
      try {
        (0, _runloop.run)(_rsvp.default, 'reject');
      } catch (e) {
        assert.ok(false, 'should not throw');
      } finally {
        (0, _debug.setTesting)(wasEmberTesting);
      }
      assert.ok(true);
    }
    ['@test rejections like jqXHR which have errorThrown property work'](assert) {
      assert.expect(2);
      let wasEmberTesting = (0, _debug.isTesting)();
      let wasOnError = (0, _errorHandling.getOnerror)();
      try {
        (0, _debug.setTesting)(false);
        (0, _errorHandling.setOnerror)(error => {
          assert.equal(error, actualError, 'expected the real error on the jqXHR');
          assert.equal(error.__reason_with_error_thrown__, jqXHR, 'also retains a helpful reference to the rejection reason');
        });
        let actualError = new Error('OMG what really happened');
        let jqXHR = {
          errorThrown: actualError
        };
        (0, _runloop.run)(_rsvp.default, 'reject', jqXHR);
      } finally {
        (0, _errorHandling.setOnerror)(wasOnError);
        (0, _debug.setTesting)(wasEmberTesting);
      }
    }
    ['@test rejections where the errorThrown is a string should wrap the sting in an error object'](assert) {
      assert.expect(2);
      let wasEmberTesting = (0, _debug.isTesting)();
      let wasOnError = (0, _errorHandling.getOnerror)();
      try {
        (0, _debug.setTesting)(false);
        (0, _errorHandling.setOnerror)(error => {
          assert.equal(error.message, actualError, 'expected the real error on the jqXHR');
          assert.equal(error.__reason_with_error_thrown__, jqXHR, 'also retains a helpful reference to the rejection reason');
        });
        let actualError = 'OMG what really happened';
        let jqXHR = {
          errorThrown: actualError
        };
        (0, _runloop.run)(_rsvp.default, 'reject', jqXHR);
      } finally {
        (0, _errorHandling.setOnerror)(wasOnError);
        (0, _debug.setTesting)(wasEmberTesting);
      }
    }
    ['@test rejections can be serialized to JSON'](assert) {
      assert.expect(2);
      let wasEmberTesting = (0, _debug.isTesting)();
      let wasOnError = (0, _errorHandling.getOnerror)();
      try {
        (0, _debug.setTesting)(false);
        (0, _errorHandling.setOnerror)(error => {
          assert.equal(error.message, 'a fail');
          assert.ok(JSON.stringify(error), 'Error can be serialized');
        });
        let jqXHR = {
          errorThrown: new Error('a fail')
        };
        (0, _runloop.run)(_rsvp.default, 'reject', jqXHR);
      } finally {
        (0, _errorHandling.setOnerror)(wasOnError);
        (0, _debug.setTesting)(wasEmberTesting);
      }
    }
  });
  const reason = 'i failed';
  function ajax() {
    return new _rsvp.default.Promise(function (resolve) {
      setTimeout(resolve, 0); // fake true / foreign async
    });
  }

  (0, _internalTestHelpers.moduleFor)('Ember.test: rejection assertions', class extends _internalTestHelpers.AbstractTestCase {
    ['@test unambigiously unhandled rejection'](assert) {
      assert.throws(function () {
        (0, _runloop.run)(function () {
          _rsvp.default.Promise.reject(reason);
        }); // something is funky, we should likely assert
      }, reason);
    }
    ['@test sync handled'](assert) {
      (0, _runloop.run)(function () {
        _rsvp.default.Promise.reject(reason).catch(function () {});
      }); // handled, we shouldn't need to assert.
      assert.ok(true, 'reached end of test');
    }
    ['@test handled within the same micro-task (via Ember.RVP.Promise)'](assert) {
      (0, _runloop.run)(function () {
        let rejection = _rsvp.default.Promise.reject(reason);
        _rsvp.default.Promise.resolve(1).then(() => rejection.catch(function () {}));
      }); // handled, we shouldn't need to assert.
      assert.ok(true, 'reached end of test');
    }
    ['@test handled within the same micro-task (via direct run-loop)'](assert) {
      (0, _runloop.run)(function () {
        let rejection = _rsvp.default.Promise.reject(reason);
        (0, _runloop.schedule)('afterRender', () => rejection.catch(function () {}));
      }); // handled, we shouldn't need to assert.
      assert.ok(true, 'reached end of test');
    }
    ['@test handled in the next microTask queue flush (next)'](assert) {
      assert.expect(2);
      let done = assert.async();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          let rejection = _rsvp.default.Promise.reject(reason);
          (0, _runloop.next)(() => {
            rejection.catch(function () {});
            assert.ok(true, 'reached end of test');
            done();
          });
        });
      }, reason);

      // a promise rejection survived a full flush of the run-loop without being handled
      // this is very likely an issue.
    }

    ['@test handled in the same microTask Queue flush do to data locality'](assert) {
      // an ambiguous scenario, this may or may not assert
      // it depends on the locality of `user#1`
      let store = {
        find() {
          return _rsvp.default.Promise.resolve(1);
        }
      };
      (0, _runloop.run)(function () {
        let rejection = _rsvp.default.Promise.reject(reason);
        store.find('user', 1).then(() => rejection.catch(function () {}));
      });
      assert.ok(true, 'reached end of test');
    }
    ['@test handled in a different microTask Queue flush do to data locality'](assert) {
      let done = assert.async();
      // an ambiguous scenario, this may or may not assert
      // it depends on the locality of `user#1`
      let store = {
        find() {
          return ajax();
        }
      };
      assert.throws(function () {
        (0, _runloop.run)(function () {
          let rejection = _rsvp.default.Promise.reject(reason);
          store.find('user', 1).then(() => {
            rejection.catch(function () {});
            assert.ok(true, 'reached end of test');
            done();
          });
        });
      }, reason);
    }
    ['@test handled in the next microTask queue flush (ajax example)'](assert) {
      let done = assert.async();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          let rejection = _rsvp.default.Promise.reject(reason);
          ajax().then(() => {
            rejection.catch(function () {});
            assert.ok(true, 'reached end of test');
            done();
          });
        });
      }, reason);
    }
  });
});
define("@ember/-internals/runtime/tests/helpers/array", ["exports", "@ember/array/proxy", "@ember/array", "@ember/array/mutable", "@ember/-internals/utils", "@ember/-internals/metal", "@ember/object", "internal-test-helpers"], function (_exports, _proxy, _array, _mutable, _utils, _metal, _object, _internalTestHelpers) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.newFixture = newFixture;
  _exports.newObjectsFixture = newObjectsFixture;
  _exports.runArrayTests = runArrayTests;
  function newFixture(cnt) {
    let ret = [];
    while (--cnt >= 0) {
      ret.push((0, _utils.generateGuid)());
    }
    return ret;
  }
  function newObjectsFixture(cnt) {
    let ret = [];
    let item;
    while (--cnt >= 0) {
      item = {};
      (0, _utils.guidFor)(item);
      ret.push(item);
    }
    return ret;
  }
  const ArrayTestsObserverClass = _object.default.extend({
    init() {
      this._super(...arguments);
      this.isEnabled = true;
      this.reset();
    },
    reset() {
      this._keys = {};
      this._values = {};
      this._before = null;
      this._after = null;
      return this;
    },
    observe(obj) {
      if (obj.addObserver) {
        for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          keys[_key - 1] = arguments[_key];
        }
        let loc = keys.length;
        while (--loc >= 0) {
          obj.addObserver(keys[loc], this, 'propertyDidChange');
        }
      } else {
        this.isEnabled = false;
      }
      return this;
    },
    observeArray(obj) {
      (0, _metal.addArrayObserver)(obj, this, {
        willChange: 'arrayWillChange',
        didChange: 'arrayDidChange'
      });
      return this;
    },
    stopObserveArray(obj) {
      (0, _metal.removeArrayObserver)(obj, this, {
        willChange: 'arrayWillChange',
        didChange: 'arrayDidChange'
      });
      return this;
    },
    propertyDidChange(target, key, value) {
      if (this._keys[key] === undefined) {
        this._keys[key] = 0;
      }
      this._keys[key]++;
      this._values[key] = value;
    },
    arrayWillChange() {
      this.assert.equal(this._before, null, 'should only call once');
      this._before = Array.prototype.slice.call(arguments);
    },
    arrayDidChange() {
      this.assert.equal(this._after, null, 'should only call once');
      this._after = Array.prototype.slice.call(arguments);
    },
    validate(key, value) {
      if (!this.isEnabled) {
        return true;
      }
      if (!this._keys[key]) {
        return false;
      }
      if (arguments.length > 1) {
        return this._values[key] === value;
      } else {
        return true;
      }
    },
    timesCalled(key) {
      return this._keys[key] || 0;
    }
  });
  class AbstractArrayHelper {
    beforeEach(assert) {
      this.assert = assert;
    }
    newObject(ary) {
      return ary ? ary.slice() : newFixture(3);
    }
    toArray(obj) {
      return obj.slice();
    }
    newObserver() {
      let ret = ArrayTestsObserverClass.create({
        assert: this.assert
      });
      if (arguments.length > 0) {
        ret.observe.apply(ret, arguments);
      }
      return ret;
    }
  }
  class NativeArrayHelpers extends AbstractArrayHelper {
    newObject(ary) {
      return (0, _array.A)(super.newObject(ary));
    }
    mutate(obj) {
      obj.pushObject(obj.length + 1);
    }
  }
  class ArrayProxyHelpers extends AbstractArrayHelper {
    newObject(ary) {
      return _proxy.default.create({
        content: (0, _array.A)(super.newObject(ary))
      });
    }
    mutate(obj) {
      obj.pushObject((0, _object.get)(obj, 'length') + 1);
    }
    toArray(obj) {
      return obj.toArray ? obj.toArray() : obj.slice();
    }
  }

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  const TestArray = _object.default.extend(_array.default, {
    _content: null,
    init() {
      this._content = this._content || [];
    },
    // some methods to modify the array so we can test changes.  Note that
    // arrays can be modified even if they don't implement MutableArray.  The
    // MutableArray is just a standard API for mutation but not required.
    addObject(obj) {
      let idx = this._content.length;
      (0, _metal.arrayContentWillChange)(this, idx, 0, 1);
      this._content.push(obj);
      (0, _metal.arrayContentDidChange)(this, idx, 0, 1);
    },
    removeFirst() {
      (0, _metal.arrayContentWillChange)(this, 0, 1, 0);
      this._content.shift();
      (0, _metal.arrayContentDidChange)(this, 0, 1, 0);
    },
    objectAt(idx) {
      return this._content[idx];
    },
    length: (0, _object.computed)(function () {
      return this._content.length;
    })
  });

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  const TestMutableArray = _object.default.extend(_mutable.default, {
    _content: null,
    init(ary) {
      if (ary === void 0) {
        ary = [];
      }
      this._content = (0, _array.A)(ary);
    },
    replace(idx, amt, objects) {
      let args = objects ? objects.slice() : [];
      let removeAmt = amt;
      let addAmt = args.length;
      (0, _metal.arrayContentWillChange)(this, idx, removeAmt, addAmt);
      args.unshift(amt);
      args.unshift(idx);
      this._content.splice.apply(this._content, args);
      (0, _metal.arrayContentDidChange)(this, idx, removeAmt, addAmt);
      return this;
    },
    objectAt(idx) {
      return this._content[idx];
    },
    length: (0, _object.computed)(function () {
      return this._content.length;
    }),
    slice() {
      return this._content.slice();
    }
  });
  class MutableArrayHelpers extends NativeArrayHelpers {
    newObject(ary) {
      return TestMutableArray.create(super.newObject(ary));
    }

    // allows for testing of the basic enumerable after an internal mutation
    mutate(obj) {
      obj.addObject(this.getFixture(1)[0]);
    }
  }
  class EmberArrayHelpers extends MutableArrayHelpers {
    newObject(ary) {
      return TestArray.create(super.newObject(ary));
    }
  }
  function runArrayTests(name, Tests) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      types[_key2 - 2] = arguments[_key2];
    }
    if (types.length > 0) {
      types.forEach(type => {
        switch (type) {
          case 'ArrayProxy':
            (0, _internalTestHelpers.moduleFor)("ArrayProxy: " + name, Tests, ArrayProxyHelpers);
            break;
          case 'EmberArray':
            (0, _internalTestHelpers.moduleFor)("EmberArray: " + name, Tests, EmberArrayHelpers);
            break;
          case 'MutableArray':
            (0, _internalTestHelpers.moduleFor)("MutableArray: " + name, Tests, MutableArrayHelpers);
            break;
          case 'NativeArray':
            (0, _internalTestHelpers.moduleFor)("NativeArray: " + name, Tests, NativeArrayHelpers);
            break;
          default:
            throw new Error("runArrayTests passed unexpected type " + type);
        }
      });
    } else {
      (0, _internalTestHelpers.moduleFor)("ArrayProxy: " + name, Tests, ArrayProxyHelpers);
      (0, _internalTestHelpers.moduleFor)("EmberArray: " + name, Tests, EmberArrayHelpers);
      (0, _internalTestHelpers.moduleFor)("MutableArray: " + name, Tests, MutableArrayHelpers);
      (0, _internalTestHelpers.moduleFor)("NativeArray: " + name, Tests, NativeArrayHelpers);
    }
  }
});
define("@ember/-internals/runtime/tests/inject_test", ["@ember/-internals/metal", "@ember/object", "internal-test-helpers"], function (_metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('inject', class extends _internalTestHelpers.AbstractTestCase {
    ['@test attempting to inject a nonexistent container key should error']() {
      let owner = (0, _internalTestHelpers.buildOwner)();
      let AnObject = _object.default.extend({
        foo: (0, _metal.inject)('bar', 'baz')
      });
      owner.register('foo:main', AnObject);
      expectAssertion(() => {
        owner.lookup('foo:main');
      }, /Attempting to inject an unknown injection: 'bar:baz'/);
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test factories should return a list of lazy injection full names'](assert) {
      if (false /* DEBUG */) {
        let AnObject = _object.default.extend({
          foo: (0, _metal.inject)('foo', 'bar'),
          bar: (0, _metal.inject)('quux')
        });
        assert.deepEqual(AnObject._lazyInjections(), {
          foo: {
            specifier: 'foo:bar',
            source: undefined,
            namespace: undefined
          },
          bar: {
            specifier: 'quux:bar',
            source: undefined,
            namespace: undefined
          }
        }, 'should return injected container keys');
      } else {
        assert.expect(0);
      }
    }
  });
});
define("@ember/-internals/runtime/tests/legacy_1x/mixins/observable/chained_test", ["@ember/-internals/metal", "@ember/object", "@ember/array", "internal-test-helpers"], function (_metal, _object, _array, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed obj.set() and obj.get() to Ember.set() and Ember.get()
    * changed obj.addObserver() to addObserver()
  */

  (0, _internalTestHelpers.moduleFor)('Ember.Observable - Observing with @each', class extends _internalTestHelpers.AbstractTestCase {
    async ['@test chained observers on enumerable properties are triggered when the observed property of any item changes'](assert) {
      let family = _object.default.create({
        momma: null
      });
      let momma = _object.default.create({
        children: []
      });
      let child1 = _object.default.create({
        name: 'Bartholomew'
      });
      let child2 = _object.default.create({
        name: 'Agnes'
      });
      let child3 = _object.default.create({
        name: 'Dan'
      });
      let child4 = _object.default.create({
        name: 'Nancy'
      });
      (0, _object.set)(family, 'momma', momma);
      (0, _object.set)(momma, 'children', (0, _array.A)([child1, child2, child3]));
      let observerFiredCount = 0;
      (0, _metal.addObserver)(family, 'momma.children.@each.name', this, function () {
        observerFiredCount++;
      });
      observerFiredCount = 0;
      for (let i = 0; i < momma.children.length; i++) {
        momma.children[i].set('name', 'Juan');
        await (0, _internalTestHelpers.runLoopSettled)();
      }
      assert.equal(observerFiredCount, 3, 'observer fired after changing child names');
      observerFiredCount = 0;
      (0, _object.get)(momma, 'children').pushObject(child4);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(observerFiredCount, 1, 'observer fired after adding a new item');
      observerFiredCount = 0;
      (0, _object.set)(child4, 'name', 'Herbert');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(observerFiredCount, 1, 'observer fired after changing property on new object');
      (0, _object.set)(momma, 'children', []);
      await (0, _internalTestHelpers.runLoopSettled)();
      observerFiredCount = 0;
      (0, _object.set)(child1, 'name', 'Hanna');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(observerFiredCount, 0, 'observer did not fire after removing changing property on a removed object');
      family.destroy();
      momma.destroy();
      child1.destroy();
      child2.destroy();
      child3.destroy();
      child4.destroy();
    }
  });
});
define("@ember/-internals/runtime/tests/legacy_1x/system/object/base_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()
    * Removed obj.instanceOf() and obj.kindOf() tests.  use obj instanceof Foo
      instead
    * Removed respondsTo() and tryToPerform() tests.  Can be brought back in a
      utils package.
    * Removed destroy() test.  You can impl yourself but not built in
    * Changed Class.subclassOf() test to Class.detect()
    * Remove broken test for 'superclass' property.
    * Removed obj.didChangeFor()
  */

  // ========================================================================
  // EmberObject Base Tests
  // ========================================================================
  let obj, obj1; // global variables

  (0, _internalTestHelpers.moduleFor)('A new EmberObject instance', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.create({
        foo: 'bar',
        total: 12345,
        aMethodThatExists() {},
        aMethodThatReturnsTrue() {
          return true;
        },
        aMethodThatReturnsFoobar() {
          return 'Foobar';
        },
        aMethodThatReturnsFalse() {
          return false;
        }
      });
    }
    afterEach() {
      obj = undefined;
    }
    ['@test Should return its properties when requested using EmberObject#get'](assert) {
      assert.equal((0, _object.get)(obj, 'foo'), 'bar');
      assert.equal((0, _object.get)(obj, 'total'), 12345);
    }
    ['@test Should allow changing of those properties by calling EmberObject#set'](assert) {
      assert.equal((0, _object.get)(obj, 'foo'), 'bar');
      assert.equal((0, _object.get)(obj, 'total'), 12345);
      (0, _object.set)(obj, 'foo', 'Chunky Bacon');
      (0, _object.set)(obj, 'total', 12);
      assert.equal((0, _object.get)(obj, 'foo'), 'Chunky Bacon');
      assert.equal((0, _object.get)(obj, 'total'), 12);
    }
  });
  (0, _internalTestHelpers.moduleFor)('EmberObject superclass and subclasses', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        method1() {
          return 'hello';
        }
      });
      obj1 = obj.extend();
    }
    afterEach() {
      obj = undefined;
      obj1 = undefined;
    }
    ['@test Checking the detect() function on an object and its subclass'](assert) {
      assert.equal(obj.detect(obj1), true);
      assert.equal(obj1.detect(obj), false);
    }
    ['@test Checking the detectInstance() function on an object and its subclass'](assert) {
      assert.ok(_object.default.detectInstance(obj.create()));
      assert.ok(obj.detectInstance(obj.create()));
    }
  });
});
define("@ember/-internals/runtime/tests/legacy_1x/system/object/concatenated_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()
    * converted uses of obj.isEqual() to use deepEqual() test since isEqual is not
      always defined
  */

  function K() {
    return this;
  }
  let klass;
  (0, _internalTestHelpers.moduleFor)('EmberObject Concatenated Properties', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      klass = _object.default.extend({
        concatenatedProperties: ['values', 'functions'],
        values: ['a', 'b', 'c'],
        functions: [K]
      });
    }
    ['@test concatenates instances'](assert) {
      let obj = klass.create({
        values: ['d', 'e', 'f']
      });
      let values = (0, _object.get)(obj, 'values');
      let expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    }
    ['@test concatenates subclasses'](assert) {
      let subKlass = klass.extend({
        values: ['d', 'e', 'f']
      });
      let obj = subKlass.create();
      let values = (0, _object.get)(obj, 'values');
      let expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    }
    ['@test concatenates reopen'](assert) {
      klass.reopen({
        values: ['d', 'e', 'f']
      });
      let obj = klass.create();
      let values = (0, _object.get)(obj, 'values');
      let expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    }
    ['@test concatenates mixin'](assert) {
      let mixin = {
        values: ['d', 'e']
      };
      let subKlass = klass.extend(mixin, {
        values: ['f']
      });
      let obj = subKlass.create();
      let values = (0, _object.get)(obj, 'values');
      let expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    }
    ['@test concatenates reopen, subclass, and instance'](assert) {
      klass.reopen({
        values: ['d']
      });
      let subKlass = klass.extend({
        values: ['e']
      });
      let obj = subKlass.create({
        values: ['f']
      });
      let values = (0, _object.get)(obj, 'values');
      let expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    }
    ['@test concatenates subclasses when the values are functions'](assert) {
      let subKlass = klass.extend({
        functions: K
      });
      let obj = subKlass.create();
      let values = (0, _object.get)(obj, 'functions');
      let expected = [K, K];
      assert.deepEqual(values, expected, "should concatenate functions property (expected: " + expected + ", got: " + values + ")");
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/accessor_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('runtime: Mixin Accessors', class extends _internalTestHelpers.RenderingTestCase {
    ['@test works with getters'](assert) {
      let value = 'building';
      let Base = _object.default.extend({
        get foo() {
          if (value === 'building') {
            throw Error('base should not be called yet');
          }
          return "base's foo";
        }
      });

      // force Base to be finalized so its properties will contain `foo`
      Base.proto();
      class Child extends Base {
        get foo() {
          if (value === 'building') {
            throw Error('child should not be called yet');
          }
          return "child's foo";
        }
      }
      Child.proto();
      let Grandchild = Child.extend({
        get foo() {
          if (value === 'building') {
            throw Error('grandchild should not be called yet');
          }
          return value;
        }
      });
      let instance = Grandchild.create();
      value = 'done building';
      assert.equal(instance.foo, 'done building', 'getter defined correctly');
      value = 'changed value';
      assert.equal(instance.foo, 'changed value', 'the value is a real getter, not a snapshot');
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/array_test", ["@ember/-internals/metal", "@ember/object", "@ember/array", "internal-test-helpers"], function (_metal, _object, _array, _internalTestHelpers) {
  "use strict";

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  const TestArray = _object.default.extend(_array.default, {
    _content: null,
    init() {
      this._content = this._content || [];
    },
    // some methods to modify the array so we can test changes.  Note that
    // arrays can be modified even if they don't implement MutableArray.  The
    // MutableArray is just a standard API for mutation but not required.
    addObject(obj) {
      let idx = this._content.length;
      (0, _metal.arrayContentWillChange)(this, idx, 0, 1);
      this._content.push(obj);
      (0, _metal.arrayContentDidChange)(this, idx, 0, 1);
    },
    removeFirst() {
      (0, _metal.arrayContentWillChange)(this, 0, 1, 0);
      this._content.shift();
      (0, _metal.arrayContentDidChange)(this, 0, 1, 0);
    },
    objectAt(idx) {
      return this._content[idx];
    },
    length: (0, _object.computed)(function () {
      return this._content.length;
    })
  });
  (0, _internalTestHelpers.moduleFor)('Ember.Array', class extends _internalTestHelpers.AbstractTestCase {
    ['@test the return value of slice has Ember.Array applied'](assert) {
      let x = _object.default.extend(_array.default).create({
        length: 0
      });
      let y = x.slice(1);
      assert.equal(_array.default.detect(y), true, 'mixin should be applied');
    }
    ['@test slice supports negative index arguments'](assert) {
      let testArray = TestArray.create({
        _content: [1, 2, 3, 4]
      });
      assert.deepEqual(testArray.slice(-2), [3, 4], 'slice(-2)');
      assert.deepEqual(testArray.slice(-2, -1), [3], 'slice(-2, -1');
      assert.deepEqual(testArray.slice(-2, -2), [], 'slice(-2, -2)');
      assert.deepEqual(testArray.slice(-1, -2), [], 'slice(-1, -2)');
      assert.deepEqual(testArray.slice(-4, 1), [1], 'slice(-4, 1)');
      assert.deepEqual(testArray.slice(-4, 5), [1, 2, 3, 4], 'slice(-4, 5)');
      assert.deepEqual(testArray.slice(-4), [1, 2, 3, 4], 'slice(-4)');
      assert.deepEqual(testArray.slice(0, -1), [1, 2, 3], 'slice(0, -1)');
      assert.deepEqual(testArray.slice(0, -4), [], 'slice(0, -4)');
      assert.deepEqual(testArray.slice(0, -3), [1], 'slice(0, -3)');
    }
  });

  // ..........................................................
  // CONTENT DID CHANGE
  //

  const DummyArray = _object.default.extend(_array.default, {
    length: 0,
    objectAt(idx) {
      return 'ITEM-' + idx;
    }
  });
  let obj, observer;

  // ..........................................................
  // NOTIFY ARRAY OBSERVERS
  //

  (0, _internalTestHelpers.moduleFor)('mixins/array/arrayContent[Will|Did]Change', class extends _internalTestHelpers.AbstractTestCase {
    async ['@test should notify observers of []'](assert) {
      obj = DummyArray.extend({
        enumerablePropertyDidChange: (0, _object.observer)('[]', function () {
          this._count++;
        })
      }).create({
        _count: 0
      });
      assert.equal(obj._count, 0, 'should not have invoked yet');
      (0, _metal.arrayContentWillChange)(obj, 0, 1, 1);
      (0, _metal.arrayContentDidChange)(obj, 0, 1, 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._count, 1, 'should have invoked');
    }
    afterEach() {
      obj.destroy();
      obj = undefined;
    }
  });

  // ..........................................................
  // NOTIFY CHANGES TO LENGTH
  //

  (0, _internalTestHelpers.moduleFor)('notify observers of length', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach(assert) {
      obj = DummyArray.extend({
        lengthDidChange: (0, _object.observer)('length', function () {
          this._after++;
        })
      }).create({
        _after: 0
      });
      assert.equal(obj._after, 0, 'should not have fired yet');
    }
    afterEach() {
      obj.destroy();
      obj = undefined;
    }
    async ['@test should notify observers when call with no params'](assert) {
      (0, _metal.arrayContentWillChange)(obj);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._after, 0);
      (0, _metal.arrayContentDidChange)(obj);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._after, 1);
    }

    // API variation that included items only
    async ['@test should not notify when passed lengths are same'](assert) {
      (0, _metal.arrayContentWillChange)(obj, 0, 1, 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._after, 0);
      (0, _metal.arrayContentDidChange)(obj, 0, 1, 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._after, 0);
    }
    async ['@test should notify when passed lengths are different'](assert) {
      (0, _metal.arrayContentWillChange)(obj, 0, 1, 2);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._after, 0);
      (0, _metal.arrayContentDidChange)(obj, 0, 1, 2);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj._after, 1);
    }
  });

  // ..........................................................
  // NOTIFY ARRAY OBSERVER
  //

  (0, _internalTestHelpers.moduleFor)('notify array observers (internal)', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach(assert) {
      obj = DummyArray.create();
      observer = _object.default.extend({
        arrayWillChange() {
          assert.equal(this._before, null); // should only call once
          this._before = Array.prototype.slice.call(arguments);
        },
        arrayDidChange() {
          assert.equal(this._after, null); // should only call once
          this._after = Array.prototype.slice.call(arguments);
        }
      }).create({
        _before: null,
        _after: null
      });
      (0, _metal.addArrayObserver)(obj, observer, {
        willChange: 'arrayWillChange',
        didChange: 'arrayDidChange'
      });
    }
    afterEach() {
      obj = observer = null;
    }
    ['@test should notify array observers when called with no params'](assert) {
      (0, _metal.arrayContentWillChange)(obj);
      assert.deepEqual(observer._before, [obj, 0, -1, -1]);
      (0, _metal.arrayContentDidChange)(obj);
      assert.deepEqual(observer._after, [obj, 0, -1, -1]);
    }

    // API variation that included items only
    ['@test should notify when called with same length items'](assert) {
      (0, _metal.arrayContentWillChange)(obj, 0, 1, 1);
      assert.deepEqual(observer._before, [obj, 0, 1, 1]);
      (0, _metal.arrayContentDidChange)(obj, 0, 1, 1);
      assert.deepEqual(observer._after, [obj, 0, 1, 1]);
    }
    ['@test should notify when called with diff length items'](assert) {
      (0, _metal.arrayContentWillChange)(obj, 0, 2, 1);
      assert.deepEqual(observer._before, [obj, 0, 2, 1]);
      (0, _metal.arrayContentDidChange)(obj, 0, 2, 1);
      assert.deepEqual(observer._after, [obj, 0, 2, 1]);
    }
    ['@test removing array observer should disable'](assert) {
      (0, _metal.removeArrayObserver)(obj, observer, {
        willChange: 'arrayWillChange',
        didChange: 'arrayDidChange'
      });
      (0, _metal.arrayContentWillChange)(obj);
      assert.deepEqual(observer._before, null);
      (0, _metal.arrayContentDidChange)(obj);
      assert.deepEqual(observer._after, null);
    }
  });

  // ..........................................................
  // @each
  //

  let ary;
  (0, _internalTestHelpers.moduleFor)('EmberArray.@each support', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      ary = TestArray.create({
        _content: [{
          isDone: true,
          desc: 'Todo 1'
        }, {
          isDone: false,
          desc: 'Todo 2'
        }, {
          isDone: true,
          desc: 'Todo 3'
        }, {
          isDone: false,
          desc: 'Todo 4'
        }]
      });
    }
    afterEach() {
      ary.destroy();
      ary = null;
    }
    async ['@test adding an object should notify (@each.isDone)'](assert) {
      let called = 0;
      let observerObject = _object.default.create({
        wasCalled() {
          called++;
        }
      });
      (0, _metal.addObserver)(ary, '@each.isDone', observerObject, 'wasCalled');
      ary.addObject(_object.default.create({
        desc: 'foo',
        isDone: false
      }));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(called, 1, 'calls observer when object is pushed');
    }
    async ['@test using @each to observe arrays that does not return objects raise error'](assert) {
      let called = 0;
      let observerObject = _object.default.create({
        wasCalled() {
          called++;
        }
      });
      ary = TestArray.create({
        objectAt(idx) {
          return (0, _object.get)(this._content[idx], 'desc');
        }
      });
      ary.addObject({
        desc: 'foo',
        isDone: false
      });
      assert.throwsAssertion(() => {
        (0, _metal.addObserver)(ary, '@each.isDone', observerObject, 'wasCalled');
      }, /When using @each to observe the array/);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(called, 0, 'not calls observer when object is pushed');
    }
    ['@test `objectAt` returns correct object'](assert) {
      let arr = ['first', 'second', 'third', 'fourth'];
      assert.equal((0, _metal.objectAt)(arr, 2), 'third');
      assert.equal((0, _metal.objectAt)(arr, 4), undefined);
    }
    ['@test should be clear caches for computed properties that have dependent keys on arrays that are changed after object initialization'](assert) {
      let obj = _object.default.extend({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'resources', (0, _array.A)());
        },
        common: (0, _object.computed)('resources.@each.common', function () {
          return (0, _object.get)((0, _metal.objectAt)((0, _object.get)(this, 'resources'), 0), 'common');
        })
      }).create();
      (0, _object.get)(obj, 'resources').pushObject(_object.default.create({
        common: 'HI!'
      }));
      assert.equal('HI!', (0, _object.get)(obj, 'common'));
      (0, _object.set)((0, _metal.objectAt)((0, _object.get)(obj, 'resources'), 0), 'common', 'BYE!');
      assert.equal('BYE!', (0, _object.get)(obj, 'common'));
    }
    async ['@test observers that contain @each in the path should fire only once the first time they are accessed'](assert) {
      let count = 0;
      let obj = _object.default.extend({
        init() {
          this._super(...arguments);
          // Observer does not fire on init
          (0, _object.set)(this, 'resources', (0, _array.A)());
        },
        commonDidChange: (0, _object.observer)('resources.@each.common', () => count++)
      }).create();

      // Observer fires first time when new object is added
      (0, _object.get)(obj, 'resources').pushObject(_object.default.create({
        common: 'HI!'
      }));
      await (0, _internalTestHelpers.runLoopSettled)();

      // Observer fires second time when property on an object is changed
      (0, _object.set)((0, _metal.objectAt)((0, _object.get)(obj, 'resources'), 0), 'common', 'BYE!');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 2, 'observers should be called twice');
      obj.destroy();
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/comparable_test", ["@ember/object", "@ember/utils", "@ember/-internals/runtime/lib/mixins/comparable", "internal-test-helpers"], function (_object, _utils, _comparable, _internalTestHelpers) {
  "use strict";

  const Rectangle = _object.default.extend(_comparable.default, {
    length: 0,
    width: 0,
    area() {
      return (0, _object.get)(this, 'length') * (0, _object.get)(this, 'width');
    },
    compare(a, b) {
      return (0, _utils.compare)(a.area(), b.area());
    }
  });
  let r1, r2;
  (0, _internalTestHelpers.moduleFor)('Comparable', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      r1 = Rectangle.create({
        length: 6,
        width: 12
      });
      r2 = Rectangle.create({
        length: 6,
        width: 13
      });
    }
    ['@test should be comparable and return the correct result'](assert) {
      assert.equal(_comparable.default.detect(r1), true);
      assert.equal((0, _utils.compare)(r1, r1), 0);
      assert.equal((0, _utils.compare)(r1, r2), -1);
      assert.equal((0, _utils.compare)(r2, r1), 1);
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/container_proxy_test", ["@ember/-internals/owner", "@ember/-internals/container", "@ember/-internals/runtime/lib/mixins/container_proxy", "@ember/object", "@ember/runloop", "internal-test-helpers", "@glimmer/destroyable"], function (_owner, _container, _container_proxy, _object, _runloop, _internalTestHelpers, _destroyable) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/runtime/mixins/container_proxy', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      this.Owner = _object.default.extend(_container_proxy.default);
      this.instance = this.Owner.create();
      this.registry = new _container.Registry();
      this.instance.__container__ = new _container.Container(this.registry, {
        owner: this.instance
      });
    }
    ['@test provides ownerInjection helper method'](assert) {
      let result = this.instance.ownerInjection();
      assert.equal((0, _owner.getOwner)(result), this.instance, 'returns an object with an associated owner');
    }
    ['@test actions queue completes before destruction'](assert) {
      assert.expect(1);
      this.registry.register('service:auth', _object.default.extend({
        willDestroy() {
          assert.ok((0, _owner.getOwner)(this).lookup('service:auth'), 'can still lookup');
        }
      }));
      let service = this.instance.lookup('service:auth');
      (0, _runloop.run)(() => {
        (0, _runloop.schedule)('actions', service, 'destroy');
        this.instance.destroy();
      });
    }
    '@test being destroyed by @ember/destroyable properly destroys the container and created instances'(assert) {
      assert.expect(1);
      this.registry.register('service:foo', class FooService extends _object.default {
        willDestroy() {
          assert.ok(true, 'is properly destroyed');
        }
      });
      this.instance.lookup('service:foo');
      (0, _runloop.run)(() => {
        (0, _destroyable.destroy)(this.instance);
      });
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/mutable_enumerable_test", ["@ember/enumerable/mutable", "@ember/array/proxy", "@ember/array", "internal-test-helpers"], function (_mutable, _proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('MutableEnumerable', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should be mixed into A()'](assert) {
      assert.ok(_mutable.default.detect((0, _array.A)()));
    }
    ['@test should be mixed into ArrayProxy'](assert) {
      assert.ok(_mutable.default.detect(_proxy.default.create()));
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/observable_test", ["@ember/-internals/metal", "@ember/object", "internal-test-helpers"], function (_metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('mixins/observable', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should be able to use getProperties to get a POJO of provided keys'](assert) {
      let obj = _object.default.create({
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      });
      let pojo = obj.getProperties('firstName', 'lastName');
      assert.equal('Steve', pojo.firstName);
      assert.equal('Jobs', pojo.lastName);
    }
    ['@test should be able to use getProperties with array parameter to get a POJO of provided keys'](assert) {
      let obj = _object.default.create({
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      });
      let pojo = obj.getProperties(['firstName', 'lastName']);
      assert.equal('Steve', pojo.firstName);
      assert.equal('Jobs', pojo.lastName);
    }
    ['@test should be able to use setProperties to set multiple properties at once'](assert) {
      let obj = _object.default.create({
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      });
      obj.setProperties({
        firstName: 'Tim',
        lastName: 'Cook'
      });
      assert.equal('Tim', obj.get('firstName'));
      assert.equal('Cook', obj.get('lastName'));
    }
    async ['@test calling setProperties completes safely despite exceptions'](assert) {
      let exc = new Error('Something unexpected happened!');
      let obj = _object.default.extend({
        companyName: (0, _object.computed)({
          get() {
            return 'Apple, Inc.';
          },
          set() {
            throw exc;
          }
        })
      }).create({
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      let firstNameChangedCount = 0;
      (0, _metal.addObserver)(obj, 'firstName', () => firstNameChangedCount++);
      try {
        obj.setProperties({
          firstName: 'Tim',
          lastName: 'Cook',
          companyName: 'Fruit Co., Inc.'
        });
      } catch (err) {
        if (err !== exc) {
          throw err;
        }
      }
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(firstNameChangedCount, 1, 'firstName should have fired once');
      obj.destroy();
    }
    ['@test should be able to retrieve cached values of computed properties without invoking the computed property'](assert) {
      let obj = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'foo';
        })
      }).create({
        bar: 'bar'
      });
      assert.equal(obj.cacheFor('foo'), undefined, 'should return undefined if no value has been cached');
      (0, _object.get)(obj, 'foo');
      assert.equal((0, _object.get)(obj, 'foo'), 'foo', 'precond - should cache the value');
      assert.equal(obj.cacheFor('foo'), 'foo', 'should return the cached value after it is invoked');
      assert.equal(obj.cacheFor('bar'), undefined, 'returns undefined if the value is not a computed property');
    }
    ['@test incrementProperty should work even if value is number in string'](assert) {
      let obj = _object.default.create({
        age: '24'
      });
      obj.incrementProperty('age');
      assert.equal(25, obj.get('age'));
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/promise_proxy_test", ["@ember/runloop", "@ember/object", "@ember/object/proxy", "@ember/object/promise-proxy-mixin", "@ember/-internals/runtime/lib/ext/rsvp", "rsvp", "internal-test-helpers"], function (_runloop, _object, _proxy, _promiseProxyMixin, _rsvp, RSVP, _internalTestHelpers) {
  "use strict";

  let ObjectPromiseProxy, proxy;
  (0, _internalTestHelpers.moduleFor)('Ember.PromiseProxy - ObjectProxy', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      ObjectPromiseProxy = _proxy.default.extend(_promiseProxyMixin.default);
    }
    afterEach() {
      RSVP.on('error', _rsvp.onerrorDefault);
      if (proxy) proxy.destroy();
      proxy = undefined;
    }
    ['@test present on ember namespace'](assert) {
      assert.ok(_promiseProxyMixin.default, 'expected PromiseProxyMixin to exist');
    }
    ['@test no promise, invoking then should raise'](assert) {
      proxy = ObjectPromiseProxy.create();
      assert.throws(function () {
        proxy.then(function () {
          return this;
        }, function () {
          return this;
        });
      }, new RegExp("PromiseProxy's promise must be set"));
    }
    ['@test fulfillment'](assert) {
      let value = {
        firstName: 'stef',
        lastName: 'penner'
      };
      let deferred = RSVP.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      let didFulfillCount = 0;
      let didRejectCount = 0;
      proxy.then(() => didFulfillCount++, () => didRejectCount++);
      assert.equal((0, _object.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _object.get)(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not yet have been rejected');
      (0, _runloop.run)(deferred, 'resolve', value);
      assert.equal(didFulfillCount, 1, 'should have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not have been rejected');
      assert.equal((0, _object.get)(proxy, 'content'), value, 'expects the proxy to have content');
      assert.equal((0, _object.get)(proxy, 'reason'), undefined, 'expects the proxy to still have no reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');
      (0, _runloop.run)(deferred, 'resolve', value);
      assert.equal(didFulfillCount, 1, 'should still have been only fulfilled once');
      assert.equal(didRejectCount, 0, 'should still not have been rejected');
      (0, _runloop.run)(deferred, 'reject', value);
      assert.equal(didFulfillCount, 1, 'should still have been only fulfilled once');
      assert.equal(didRejectCount, 0, 'should still not have been rejected');
      assert.equal((0, _object.get)(proxy, 'content'), value, 'expects the proxy to have still have same content');
      assert.equal((0, _object.get)(proxy, 'reason'), undefined, 'expects the proxy still to have no reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');

      // rest of the promise semantics are tested in directly in RSVP
    }

    ['@test rejection'](assert) {
      let reason = new Error('failure');
      let deferred = RSVP.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      let didFulfillCount = 0;
      let didRejectCount = 0;
      proxy.then(() => didFulfillCount++, () => didRejectCount++);
      assert.equal((0, _object.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _object.get)(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not yet have been rejected');
      (0, _runloop.run)(deferred, 'reject', reason);
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should have been rejected');
      assert.equal((0, _object.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _object.get)(proxy, 'reason'), reason, 'expects the proxy to have a reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      (0, _runloop.run)(deferred, 'reject', reason);
      assert.equal(didFulfillCount, 0, 'should stll not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should still remain rejected');
      (0, _runloop.run)(deferred, 'resolve', 1);
      assert.equal(didFulfillCount, 0, 'should stll not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should still remain rejected');
      assert.equal((0, _object.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _object.get)(proxy, 'reason'), reason, 'expects the proxy to have a reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
    }

    // https://github.com/emberjs/ember.js/issues/15694
    ['@test rejection without specifying reason'](assert) {
      let deferred = RSVP.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      let didFulfillCount = 0;
      let didRejectCount = 0;
      proxy.then(() => didFulfillCount++, () => didRejectCount++);
      assert.equal((0, _object.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _object.get)(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not yet have been rejected');
      (0, _runloop.run)(deferred, 'reject');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should have been rejected');
      assert.equal((0, _object.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _object.get)(proxy, 'reason'), undefined, 'expects the proxy to have a reason');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
    }
    ["@test unhandled rejects still propagate to RSVP.on('error', ...) "](assert) {
      assert.expect(1);
      RSVP.on('error', onerror);
      RSVP.off('error', _rsvp.onerrorDefault);
      let expectedReason = new Error('failure');
      let deferred = RSVP.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.get('promise');
      function onerror(reason) {
        assert.equal(reason, expectedReason, 'expected reason');
      }
      RSVP.on('error', onerror);
      RSVP.off('error', _rsvp.onerrorDefault);
      (0, _runloop.run)(deferred, 'reject', expectedReason);
      RSVP.on('error', _rsvp.onerrorDefault);
      RSVP.off('error', onerror);
      (0, _runloop.run)(deferred, 'reject', expectedReason);
      RSVP.on('error', _rsvp.onerrorDefault);
      RSVP.off('error', onerror);
    }
    ['@test should work with promise inheritance'](assert) {
      class PromiseSubclass extends RSVP.Promise {}
      proxy = ObjectPromiseProxy.create({
        promise: new PromiseSubclass(() => {})
      });
      assert.ok(proxy.then() instanceof PromiseSubclass, 'promise proxy respected inheritance');
    }
    ['@test should reset isFulfilled and isRejected when promise is reset'](assert) {
      let deferred = _rsvp.default.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      assert.equal((0, _object.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      (0, _runloop.run)(deferred, 'resolve');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');
      let anotherDeferred = _rsvp.default.defer();
      proxy.set('promise', anotherDeferred.promise);
      assert.equal((0, _object.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      (0, _runloop.run)(anotherDeferred, 'reject');
      assert.equal((0, _object.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _object.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _object.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _object.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
    }
    ['@test should have content when isFulfilled is set'](assert) {
      let deferred = _rsvp.default.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.addObserver('isFulfilled', () => assert.equal((0, _object.get)(proxy, 'content'), true));
      (0, _runloop.run)(deferred, 'resolve', true);
    }
    ['@test should have reason when isRejected is set'](assert) {
      let error = new Error('Y U REJECT?!?');
      let deferred = _rsvp.default.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.addObserver('isRejected', () => assert.equal((0, _object.get)(proxy, 'reason'), error));
      try {
        (0, _runloop.run)(deferred, 'reject', error);
      } catch (e) {
        assert.equal(e, error);
      }
    }
    ['@test should not error if promise is resolved after proxy has been destroyed'](assert) {
      let deferred = _rsvp.default.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(() => {}, () => {});
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'resolve', true);
      assert.ok(true, 'resolving the promise after the proxy has been destroyed does not raise an error');
    }
    ['@test should not error if promise is rejected after proxy has been destroyed'](assert) {
      let deferred = _rsvp.default.defer();
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(() => {}, () => {});
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'reject', 'some reason');
      assert.ok(true, 'rejecting the promise after the proxy has been destroyed does not raise an error');
    }
    ['@test promise chain is not broken if promised is resolved after proxy has been destroyed'](assert) {
      let deferred = _rsvp.default.defer();
      let expectedValue = {};
      let receivedValue;
      let didResolveCount = 0;
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(value => {
        receivedValue = value;
        didResolveCount++;
      }, () => {});
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'resolve', expectedValue);
      assert.equal(didResolveCount, 1, 'callback called');
      assert.equal(receivedValue, expectedValue, 'passed value is the value the promise was resolved with');
    }
    ['@test promise chain is not broken if promised is rejected after proxy has been destroyed'](assert) {
      let deferred = _rsvp.default.defer();
      let expectedReason = 'some reason';
      let receivedReason;
      let didRejectCount = 0;
      proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(() => {}, reason => {
        receivedReason = reason;
        didRejectCount++;
      });
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'reject', expectedReason);
      assert.equal(didRejectCount, 1, 'callback called');
      assert.equal(receivedReason, expectedReason, 'passed reason is the reason the promise was rejected for');
    }
  });
});
define("@ember/-internals/runtime/tests/mixins/target_action_support_test", ["@ember/-internals/environment", "@ember/object", "@ember/-internals/runtime/lib/mixins/target_action_support", "internal-test-helpers"], function (_environment, _object, _target_action_support, _internalTestHelpers) {
  "use strict";

  let originalLookup = _environment.context.lookup;
  let lookup;
  (0, _internalTestHelpers.moduleFor)('TargetActionSupport', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      _environment.context.lookup = lookup = {};
    }
    afterEach() {
      _environment.context.lookup = originalLookup;
    }
    ['@test it should return false if no target or action are specified'](assert) {
      assert.expect(1);
      let obj = _object.default.extend(_target_action_support.default).create();
      assert.ok(false === obj.triggerAction(), 'no target or action was specified');
    }
    ['@test it should support actions specified as strings'](assert) {
      assert.expect(2);
      let obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent() {
            assert.ok(true, 'anEvent method was called');
          }
        }),
        action: 'anEvent'
      });
      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    }
    ['@test it should invoke the send() method on objects that implement it'](assert) {
      assert.expect(3);
      let obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          send(evt, context) {
            assert.equal(evt, 'anEvent', 'send() method was invoked with correct event name');
            assert.equal(context, obj, 'send() method was invoked with correct context');
          }
        }),
        action: 'anEvent'
      });
      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    }
    ['@test it should find targets specified using a property path'](assert) {
      assert.expect(2);
      let Test = {};
      lookup.Test = Test;
      Test.targetObj = _object.default.create({
        anEvent() {
          assert.ok(true, 'anEvent method was called on global object');
        }
      });
      let myObj = _object.default.extend(_target_action_support.default).create({
        target: 'Test.targetObj',
        action: 'anEvent'
      });
      assert.ok(true === myObj.triggerAction(), 'a valid target and action were specified');
    }
    ['@test it should use an actionContext object specified as a property on the object'](assert) {
      assert.expect(2);
      let obj = _object.default.extend(_target_action_support.default).create({
        action: 'anEvent',
        actionContext: {},
        target: _object.default.create({
          anEvent(ctx) {
            assert.ok(obj.actionContext === ctx, 'anEvent method was called with the expected context');
          }
        })
      });
      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    }
    ['@test it should find an actionContext specified as a property path'](assert) {
      assert.expect(2);
      let Test = {};
      lookup.Test = Test;
      Test.aContext = {};
      let obj = _object.default.extend(_target_action_support.default).create({
        action: 'anEvent',
        actionContext: 'Test.aContext',
        target: _object.default.create({
          anEvent(ctx) {
            assert.ok(Test.aContext === ctx, 'anEvent method was called with the expected context');
          }
        })
      });
      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    }
    ['@test it should use the target specified in the argument'](assert) {
      assert.expect(2);
      let targetObj = _object.default.create({
        anEvent() {
          assert.ok(true, 'anEvent method was called');
        }
      });
      let obj = _object.default.extend(_target_action_support.default).create({
        action: 'anEvent'
      });
      assert.ok(true === obj.triggerAction({
        target: targetObj
      }), 'a valid target and action were specified');
    }
    ['@test it should use the action specified in the argument'](assert) {
      assert.expect(2);
      let obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent() {
            assert.ok(true, 'anEvent method was called');
          }
        })
      });
      assert.ok(true === obj.triggerAction({
        action: 'anEvent'
      }), 'a valid target and action were specified');
    }
    ['@test it should use the actionContext specified in the argument'](assert) {
      assert.expect(2);
      let context = {};
      let obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent(ctx) {
            assert.ok(context === ctx, 'anEvent method was called with the expected context');
          }
        }),
        action: 'anEvent'
      });
      assert.ok(true === obj.triggerAction({
        actionContext: context
      }), 'a valid target and action were specified');
    }
    ['@test it should allow multiple arguments from actionContext'](assert) {
      assert.expect(3);
      let param1 = 'someParam';
      let param2 = 'someOtherParam';
      let obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent(first, second) {
            assert.ok(first === param1, 'anEvent method was called with the expected first argument');
            assert.ok(second === param2, 'anEvent method was called with the expected second argument');
          }
        }),
        action: 'anEvent'
      });
      assert.ok(true === obj.triggerAction({
        actionContext: [param1, param2]
      }), 'a valid target and action were specified');
    }
    ['@test it should use a null value specified in the actionContext argument'](assert) {
      assert.expect(2);
      let obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent(ctx) {
            assert.ok(null === ctx, 'anEvent method was called with the expected context (null)');
          }
        }),
        action: 'anEvent'
      });
      assert.ok(true === obj.triggerAction({
        actionContext: null
      }), 'a valid target and action were specified');
    }
  });
});
define("@ember/-internals/runtime/tests/mutable-array/addObject-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class AddObjectTest extends _internalTestHelpers.AbstractTestCase {
    '@test should return receiver'() {
      let before = (0, _array.newFixture)(3);
      let obj = this.newObject(before);
      this.assert.equal(obj.addObject(before[1]), obj, 'should return receiver');
    }
    async '@test [A,B].addObject(C) => [A,B,C] + notify'() {
      let before = (0, _array.newFixture)(2);
      let item = (0, _array.newFixture)(1)[0];
      let after = [before[0], before[1], item];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.addObject(item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      }
      obj.destroy();
    }
    async '@test [A,B,C].addObject(A) => [A,B,C] + NO notify'() {
      let before = (0, _array.newFixture)(3);
      let after = before;
      let item = before[0];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.addObject(item); // note: item in set

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
        this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each');
        this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      }
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('addObject', AddObjectTest, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/clear-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class ClearTests extends _internalTestHelpers.AbstractTestCase {
    async '@test [].clear() => [] + notify'() {
      let before = [];
      let after = [];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.clear(), obj, 'return self');
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.validate('[]'), false, 'should NOT have notified [] once');
      this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each once');
      this.assert.equal(observer.validate('length'), false, 'should NOT have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test [X].clear() => [] + notify'() {
      let obj, before, after, observer;
      before = (0, _array.newFixture)(1);
      after = [];
      obj = this.newObject(before);
      observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.clear(), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('clear', ClearTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/insertAt-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class InsertAtTests extends _internalTestHelpers.AbstractTestCase {
    async '@test [].insertAt(0, X) => [X] + notify'() {
      let after = (0, _array.newFixture)(1);
      let obj = this.newObject([]);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.insertAt(0, after[0]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] did change once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each did change once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length did change once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject did change once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject did change once');
      obj.destroy();
    }
    '@test [].insertAt(200,X) => OUT_OF_RANGE_EXCEPTION exception'() {
      let obj = this.newObject([]);
      let item = (0, _array.newFixture)(1)[0];
      expectAssertion(() => obj.insertAt(200, item), /`insertAt` index provided is out of range/);
    }
    async '@test [A].insertAt(0, X) => [X,A] + notify'() {
      let item = (0, _array.newFixture)(1)[0];
      let before = (0, _array.newFixture)(1);
      let after = [item, before[0]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.insertAt(0, item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test [A].insertAt(1, X) => [A,X] + notify'() {
      let item = (0, _array.newFixture)(1)[0];
      let before = (0, _array.newFixture)(1);
      let after = [before[0], item];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.insertAt(1, item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      obj.destroy();
    }
    '@test [A].insertAt(200,X) => OUT_OF_RANGE exception'() {
      let obj = this.newObject((0, _array.newFixture)(1));
      let that = this;
      this.assert.throws(() => obj.insertAt(200, that.newFixture(1)[0]), Error);
    }
    async '@test [A,B,C].insertAt(0,X) => [X,A,B,C] + notify'() {
      let item = (0, _array.newFixture)(1)[0];
      let before = (0, _array.newFixture)(3);
      let after = [item, before[0], before[1], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.insertAt(0, item);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test [A,B,C].insertAt(1,X) => [A,X,B,C] + notify'() {
      let item = (0, _array.newFixture)(1)[0];
      let before = (0, _array.newFixture)(3);
      let after = [before[0], item, before[1], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      let objectAtCalls = [];
      let objectAt = obj.objectAt;
      obj.objectAt = ix => {
        objectAtCalls.push(ix);
        return objectAt.call(obj, ix);
      };
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      objectAtCalls.splice(0, objectAtCalls.length);
      obj.insertAt(1, item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(objectAtCalls, [], 'objectAt is not called when only inserting items');
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test [A,B,C].insertAt(3,X) => [A,B,C,X] + notify'() {
      let item = (0, _array.newFixture)(1)[0];
      let before = (0, _array.newFixture)(3);
      let after = [before[0], before[1], before[2], item];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.insertAt(3, item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('instertAt', InsertAtTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/popObject-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class PopObjectTests extends _internalTestHelpers.AbstractTestCase {
    async '@test [].popObject() => [] + returns undefined + NO notify'() {
      let obj = this.newObject([]);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.popObject(), undefined, 'popObject results');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), [], 'post item results');
      this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
      this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each');
      this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test [X].popObject() => [] + notify'() {
      let before = (0, _array.newFixture)(1);
      let after = [];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      let ret = obj.popObject();

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.equal(ret, before[0], 'return object');
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C].popObject() => [A,B] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = [before[0], before[1]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      let ret = obj.popObject();

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.equal(ret, before[2], 'return object');
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('popObject', PopObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/pushObject-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class PushObjectTests extends _internalTestHelpers.AbstractTestCase {
    '@test returns pushed object'() {
      let exp = (0, _array.newFixture)(1)[0];
      let obj = this.newObject([]);
      this.assert.equal(obj.pushObject(exp), exp, 'should return pushed object');
    }
    async '@test [].pushObject(X) => [X] + notify'() {
      let before = [];
      let after = (0, _array.newFixture)(1);
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.pushObject(after[0]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C].pushObject(X) => [A,B,C,X] + notify'() {
      let before = (0, _array.newFixture)(3);
      let item = (0, _array.newFixture)(1)[0];
      let after = [before[0], before[1], before[2], item];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.pushObject(item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      obj.destroy();
    }
    async '@test [A,B,C,C].pushObject(A) => [A,B,C,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let item = before[2]; // note same object as current tail. should end up twice
      let after = [before[0], before[1], before[2], item];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.pushObject(item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      this.assert.equal(observer.validate('lastObject'), true, 'should have notified lastObject');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('pushObject', PushObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/pushObjects-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class PushObjectsTests extends _internalTestHelpers.AbstractTestCase {
    '@test should raise exception if not Ember.Enumerable is passed to pushObjects'() {
      let obj = this.newObject([]);
      expectAssertion(() => obj.pushObjects('string'));
    }
  }
  (0, _array.runArrayTests)('pushObjects', PushObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/removeAt-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/array", "@ember/object"], function (_internalTestHelpers, _array, _array2, _object) {
  "use strict";

  class RemoveAtTests extends _internalTestHelpers.AbstractTestCase {
    async '@test removeAt([X], 0) => [] + notify'() {
      let before = (0, _array.newFixture)(1);
      let after = [];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal((0, _array2.removeAt)(obj, 0), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    '@test removeAt([], 200) => OUT_OF_RANGE_EXCEPTION exception'() {
      let obj = this.newObject([]);
      expectAssertion(() => (0, _array2.removeAt)(obj, 200), /`removeAt` index provided is out of range/);
    }
    async '@test removeAt([A,B], 0) => [B] + notify'() {
      let before = (0, _array.newFixture)(2);
      let after = [before[1]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal((0, _array2.removeAt)(obj, 0), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test removeAt([A,B], 1) => [A] + notify'() {
      let before = (0, _array.newFixture)(2);
      let after = [before[0]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal((0, _array2.removeAt)(obj, 1), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      obj.destroy();
    }
    async '@test removeAt([A,B,C], 1) => [A,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = [before[0], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal((0, _array2.removeAt)(obj, 1), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test removeAt([A,B,C,D], 1,2) => [A,D] + notify'() {
      let before = (0, _array.newFixture)(4);
      let after = [before[0], before[3]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal((0, _array2.removeAt)(obj, 1, 2), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C,D].removeAt(1,2) => [A,D] + notify'() {
      let obj, before, after, observer;
      before = (0, _array.newFixture)(4);
      after = [before[0], before[3]];
      obj = this.newObject(before);
      observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.removeAt(1, 2), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('removeAt', RemoveAtTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/removeObject-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_object, _internalTestHelpers, _array) {
  "use strict";

  class RemoveObjectTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return receiver'() {
      let before = (0, _array.newFixture)(3);
      let obj = this.newObject(before);
      this.assert.equal(obj.removeObject(before[1]), obj, 'should return receiver');
      obj.destroy();
    }
    async '@test [A,B,C].removeObject(B) => [A,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = [before[0], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.removeObject(before[1]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      }
      obj.destroy();
    }
    async '@test [A,B,C].removeObject(D) => [A,B,C]'() {
      let before = (0, _array.newFixture)(3);
      let after = before;
      let item = (0, _array.newFixture)(1)[0];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.removeObject(item); // note: item not in set

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
        this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each');
        this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      }
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('removeObject', RemoveObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/removeObjects-test", ["@ember/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/array", "@glimmer/destroyable"], function (_object, _internalTestHelpers, _array, _array2, _destroyable) {
  "use strict";

  class RemoveObjectsTests extends _internalTestHelpers.AbstractTestCase {
    '@test should return receiver'() {
      let before = (0, _array2.A)((0, _array.newFixture)(3));
      let obj = before;
      this.assert.equal(obj.removeObjects(before[1]), obj, 'should return receiver');
    }
    async '@test [A,B,C].removeObjects([B]) => [A,C] + notify'() {
      let before = (0, _array2.A)((0, _array.newFixture)(3));
      let after = [before[0], before[2]];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects([before[1]]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
    async '@test [{A},{B},{C}].removeObjects([{B}]) => [{A},{C}] + notify'() {
      let before = (0, _array2.A)((0, _array.newObjectsFixture)(3));
      let after = [before[0], before[2]];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects([before[1]]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
    async '@test [A,B,C].removeObjects([A,B]) => [C] + notify'() {
      let before = (0, _array2.A)((0, _array.newFixture)(3));
      let after = [before[2]];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects([before[0], before[1]]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
    async '@test [{A},{B},{C}].removeObjects([{A},{B}]) => [{C}] + notify'() {
      let before = (0, _array2.A)((0, _array.newObjectsFixture)(3));
      let after = [before[2]];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects([before[0], before[1]]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
    async '@test [A,B,C].removeObjects([A,B,C]) => [] + notify'() {
      let before = (0, _array2.A)((0, _array.newFixture)(3));
      let after = [];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects([before[0], before[1], before[2]]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
        this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
    async '@test [{A},{B},{C}].removeObjects([{A},{B},{C}]) => [] + notify'() {
      let before = (0, _array2.A)((0, _array.newObjectsFixture)(3));
      let after = [];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects(before);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
        this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
        this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
        this.assert.equal(observer.validate('lastObject'), 1, 'should have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
    async '@test [A,B,C].removeObjects([D]) => [A,B,C]'() {
      let before = (0, _array2.A)((0, _array.newFixture)(3));
      let after = before;
      let item = (0, _array.newFixture)(1)[0];
      let obj = before;
      let observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); // Prime the cache

      obj.removeObjects([item]); // Note: item not in set

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      if (observer.isEnabled) {
        this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
        this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
        this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
        this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      }
      (0, _destroyable.destroy)(obj);
    }
  }
  (0, _array.runArrayTests)('removeObjects', RemoveObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/replace-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _array) {
  "use strict";

  class ReplaceTests extends _internalTestHelpers.AbstractTestCase {
    async "@test [].replace(0,0,'X') => ['X'] + notify"() {
      let exp = (0, _array.newFixture)(1);
      let obj = this.newObject([]);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.replace(0, 0, exp);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), exp, 'post item results');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [].replace(0,0,"X") => ["X"] + avoid calling objectAt and notifying fistObject/lastObject when not in cache'() {
      let obj, exp, observer;
      let called = 0;
      exp = (0, _array.newFixture)(1);
      obj = this.newObject([]);
      obj.objectAt = function () {
        called++;
      };
      observer = this.newObserver(obj, 'firstObject', 'lastObject');
      obj.replace(0, 0, exp);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.equal(called, 0, 'should NOT have called objectAt upon replace when firstObject/lastObject are not cached');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject since not cached');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject since not cached');
      obj.destroy();
    }
    async '@test [A,B,C,D].replace(1,2,X) => [A,X,D] + notify'() {
      let before = (0, _array.newFixture)(4);
      let replace = (0, _array.newFixture)(1);
      let after = [before[0], replace[0], before[3]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.replace(1, 2, replace);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C,D].replace(1,2,[X,Y]) => [A,X,Y,D] + notify'() {
      let before = (0, _array.newFixture)(4);
      let replace = (0, _array.newFixture)(2);
      let after = [before[0], replace[0], replace[1], before[3]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.replace(1, 2, replace);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B].replace(1,0,[X,Y]) => [A,X,Y,B] + notify'() {
      let before = (0, _array.newFixture)(2);
      let replace = (0, _array.newFixture)(2);
      let after = [before[0], replace[0], replace[1], before[1]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.replace(1, 0, replace);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C,D].replace(2,2) => [A,B] + notify'() {
      let before = (0, _array.newFixture)(4);
      let after = [before[0], before[1]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.replace(2, 2);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      obj.destroy();
    }
    async '@test [A,B,C,D].replace(-1,1) => [A,B,C] + notify'() {
      let before = (0, _array.newFixture)(4);
      let after = [before[0], before[1], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.replace(-1, 1);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      obj.destroy();
    }
    async '@test Adding object should notify array observer (internal)'() {
      let fixtures = (0, _array.newFixture)(4);
      let obj = this.newObject(fixtures);
      let observer = this.newObserver(obj).observeArray(obj);
      let item = (0, _array.newFixture)(1)[0];
      obj.replace(2, 2, [item]);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(observer._before, [obj, 2, 2, 1], 'before');
      this.assert.deepEqual(observer._after, [obj, 2, 2, 1], 'after');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('replace', ReplaceTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/reverseObjects-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_internalTestHelpers, _array, _object) {
  "use strict";

  class ReverseObjectsTests extends _internalTestHelpers.AbstractTestCase {
    async '@test [A,B,C].reverseObjects() => [] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = [before[2], before[1], before[0]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.reverseObjects(), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 0, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('reverseObjects', ReverseObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/setObjects-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_internalTestHelpers, _array, _object) {
  "use strict";

  class SetObjectsTests extends _internalTestHelpers.AbstractTestCase {
    async '@test [A,B,C].setObjects([]) = > [] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = [];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.setObjects(after), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C].setObjects([D, E, F, G]) = > [D, E, F, G] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = (0, _array.newFixture)(4);
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.setObjects(after), obj, 'return self');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('setObjects', SetObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/shiftObject-test", ["internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/object"], function (_internalTestHelpers, _array, _object) {
  "use strict";

  class ShiftObjectTests extends _internalTestHelpers.AbstractTestCase {
    async '@test [].shiftObject() => [] + returns undefined + NO notify'() {
      let before = [];
      let after = [];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.shiftObject(), undefined);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.validate('[]', undefined, 1), false, 'should NOT have notified [] once');
      this.assert.equal(observer.validate('@each', undefined, 1), false, 'should NOT have notified @each once');
      this.assert.equal(observer.validate('length', undefined, 1), false, 'should NOT have notified length once');
      this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
    async '@test [X].shiftObject() => [] + notify'() {
      let before = (0, _array.newFixture)(1);
      let after = [];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.shiftObject(), before[0], 'should return object');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C].shiftObject() => [B,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let after = [before[1], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      this.assert.equal(obj.shiftObject(), before[0], 'should return object');

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('shiftObject', ShiftObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/unshiftObject-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _object, _array) {
  "use strict";

  class UnshiftObjectTests extends _internalTestHelpers.AbstractTestCase {
    '@test returns unshifted object'() {
      let obj = this.newObject([]);
      let item = (0, _array.newFixture)(1)[0];
      this.assert.equal(obj.unshiftObject(item), item, 'should return unshifted object');
    }
    async '@test [].unshiftObject(X) => [X] + notify'() {
      let before = [];
      let item = (0, _array.newFixture)(1)[0];
      let after = [item];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.unshiftObject(item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C].unshiftObject(X) => [X,A,B,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let item = (0, _array.newFixture)(1)[0];
      let after = [item, before[0], before[1], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.unshiftObject(item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test [A,B,C].unshiftObject(A) => [A,A,B,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let item = before[0]; // note same object as current head. should end up twice
      let after = [item, before[0], before[1], before[2]];
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.unshiftObject(item);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), true, 'should have notified firstObject');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('unshiftObject', UnshiftObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/mutable-array/unshiftObjects-test", ["internal-test-helpers", "@ember/object", "@ember/-internals/runtime/tests/helpers/array"], function (_internalTestHelpers, _object, _array) {
  "use strict";

  class UnshiftObjectsTests extends _internalTestHelpers.AbstractTestCase {
    '@test returns receiver'() {
      let obj = this.newObject([]);
      let items = (0, _array.newFixture)(3);
      this.assert.equal(obj.unshiftObjects(items), obj, 'should return receiver');
    }
    async '@test [].unshiftObjects([A,B,C]) => [A,B,C] + notify'() {
      let before = [];
      let items = (0, _array.newFixture)(3);
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.unshiftObjects(items);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), items, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), items.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      obj.destroy();
    }
    async '@test [A,B,C].unshiftObjects([X,Y]) => [X,Y,A,B,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let items = (0, _array.newFixture)(2);
      let after = items.concat(before);
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.unshiftObjects(items);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
    async '@test [A,B,C].unshiftObjects([A,B]) => [A,B,A,B,C] + notify'() {
      let before = (0, _array.newFixture)(3);
      let items = [before[0], before[1]]; // note same object as current head. should end up twice
      let after = items.concat(before);
      let obj = this.newObject(before);
      let observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
      obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

      obj.unshiftObjects(items);

      // flush observers
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assert.deepEqual(this.toArray(obj), after, 'post item results');
      this.assert.equal((0, _object.get)(obj, 'length'), after.length, 'length');
      this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
      this.assert.equal(observer.validate('firstObject'), true, 'should NOT have notified firstObject');
      this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
      obj.destroy();
    }
  }
  (0, _array.runArrayTests)('unshiftObjects', UnshiftObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
define("@ember/-internals/runtime/tests/system/array_proxy/arranged_content_test", ["@ember/runloop", "@ember/-internals/metal", "@ember/object", "@ember/array/proxy", "@ember/array", "internal-test-helpers"], function (_runloop, _metal, _object, _proxy, _array, _internalTestHelpers) {
  "use strict";

  let array;
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - arrangedContent', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      (0, _runloop.run)(() => {
        array = _proxy.default.extend({
          arrangedContent: (0, _object.computed)('content.[]', function () {
            let content = this.get('content');
            return content && (0, _array.A)(content.slice().sort((a, b) => {
              if (a == null) {
                a = -1;
              }
              if (b == null) {
                b = -1;
              }
              return b - a;
            }));
          })
        }).create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    }
    afterEach() {
      (0, _runloop.run)(() => array.destroy());
    }
    ['@test compact - returns arrangedContent without nulls and undefined'](assert) {
      (0, _runloop.run)(() => array.set('content', (0, _array.A)([1, 3, null, 2, undefined])));
      assert.deepEqual(array.compact(), [3, 2, 1]);
    }
    ['@test indexOf - returns index of object in arrangedContent'](assert) {
      assert.equal(array.indexOf(4), 1, 'returns arranged index');
    }
    ['@test lastIndexOf - returns last index of object in arrangedContent'](assert) {
      array.get('content').pushObject(4);
      assert.equal(array.lastIndexOf(4), 2, 'returns last arranged index');
    }
    ['@test objectAt - returns object at index in arrangedContent'](assert) {
      assert.equal((0, _metal.objectAt)(array, 1), 4, 'returns object at index');
    }

    // Not sure if we need a specific test for it, since it's internal
    ['@test objectAtContent - returns object at index in arrangedContent'](assert) {
      assert.equal(array.objectAtContent(1), 4, 'returns object at index');
    }
    ['@test objectsAt - returns objects at indices in arrangedContent'](assert) {
      assert.deepEqual(array.objectsAt([0, 2, 4]), [5, 2, undefined], 'returns objects at indices');
    }
    ['@test replace - mutating an arranged ArrayProxy is not allowed']() {
      expectAssertion(() => {
        array.replace(0, 0, [3]);
      }, /Mutating an arranged ArrayProxy is not allowed/);
    }
    ['@test replaceContent - does a standard array replace on content'](assert) {
      (0, _runloop.run)(() => array.replaceContent(1, 2, [3]));
      assert.deepEqual(array.get('content'), [1, 3, 5]);
    }
    ['@test slice - returns a slice of the arrangedContent'](assert) {
      assert.deepEqual(array.slice(1, 3), [4, 2], 'returns sliced arrangedContent');
    }
    ['@test toArray - returns copy of arrangedContent'](assert) {
      assert.deepEqual(array.toArray(), [5, 4, 2, 1]);
    }
    ['@test without - returns arrangedContent without object'](assert) {
      assert.deepEqual(array.without(2), [5, 4, 1], 'returns arranged without object');
    }
    ['@test lastObject - returns last arranged object'](assert) {
      assert.equal(array.get('lastObject'), 1, 'returns last arranged object');
    }
    ['@test firstObject - returns first arranged object'](assert) {
      assert.equal(array.get('firstObject'), 5, 'returns first arranged object');
    }
  });
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - arrangedContent matching content', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      (0, _runloop.run)(function () {
        array = _proxy.default.create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    }
    afterEach() {
      (0, _runloop.run)(function () {
        array.destroy();
      });
    }
    ['@test insertAt - inserts object at specified index'](assert) {
      (0, _runloop.run)(function () {
        array.insertAt(2, 3);
      });
      assert.deepEqual(array.get('content'), [1, 2, 3, 4, 5]);
    }
    ['@test replace - does a standard array replace'](assert) {
      (0, _runloop.run)(function () {
        array.replace(1, 2, [3]);
      });
      assert.deepEqual(array.get('content'), [1, 3, 5]);
    }
    ['@test reverseObjects - reverses content'](assert) {
      (0, _runloop.run)(function () {
        array.reverseObjects();
      });
      assert.deepEqual(array.get('content'), [5, 4, 2, 1]);
    }
  });
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - arrangedContent with transforms', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      (0, _runloop.run)(function () {
        array = _proxy.default.extend({
          arrangedContent: (0, _object.computed)('content.[]', function () {
            let content = this.get('content');
            return content && (0, _array.A)(content.slice().sort(function (a, b) {
              if (a == null) {
                a = -1;
              }
              if (b == null) {
                b = -1;
              }
              return b - a;
            }));
          }),
          objectAtContent(idx) {
            let obj = (0, _metal.objectAt)(this.get('arrangedContent'), idx);
            return obj && obj.toString();
          }
        }).create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    }
    afterEach() {
      (0, _runloop.run)(function () {
        array.destroy();
      });
    }
    ['@test indexOf - returns index of object in arrangedContent'](assert) {
      assert.equal(array.indexOf('4'), 1, 'returns arranged index');
    }
    ['@test lastIndexOf - returns last index of object in arrangedContent'](assert) {
      array.get('content').pushObject(4);
      assert.equal(array.lastIndexOf('4'), 2, 'returns last arranged index');
    }
    ['@test objectAt - returns object at index in arrangedContent'](assert) {
      assert.equal((0, _metal.objectAt)(array, 1), '4', 'returns object at index');
    }

    // Not sure if we need a specific test for it, since it's internal
    ['@test objectAtContent - returns object at index in arrangedContent'](assert) {
      assert.equal(array.objectAtContent(1), '4', 'returns object at index');
    }
    ['@test objectsAt - returns objects at indices in arrangedContent'](assert) {
      assert.deepEqual(array.objectsAt([0, 2, 4]), ['5', '2', undefined], 'returns objects at indices');
    }
    ['@test slice - returns a slice of the arrangedContent'](assert) {
      assert.deepEqual(array.slice(1, 3), ['4', '2'], 'returns sliced arrangedContent');
    }
    ['@test toArray - returns copy of arrangedContent'](assert) {
      assert.deepEqual(array.toArray(), ['5', '4', '2', '1']);
    }
    ['@test without - returns arrangedContent without object'](assert) {
      assert.deepEqual(array.without('2'), ['5', '4', '1'], 'returns arranged without object');
    }
    ['@test lastObject - returns last arranged object'](assert) {
      assert.equal(array.get('lastObject'), '1', 'returns last arranged object');
    }
    ['@test firstObject - returns first arranged object'](assert) {
      assert.equal(array.get('firstObject'), '5', 'returns first arranged object');
    }
  });
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - with transforms', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      (0, _runloop.run)(function () {
        array = _proxy.default.extend({
          objectAtContent(idx) {
            let obj = (0, _metal.objectAt)(this.get('arrangedContent'), idx);
            return obj && obj.toString();
          }
        }).create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    }
    afterEach() {
      (0, _runloop.run)(function () {
        array.destroy();
      });
    }
    ['@test popObject - removes last object in arrangedContent'](assert) {
      let popped = array.popObject();
      assert.equal(popped, '5', 'returns last object');
      assert.deepEqual(array.toArray(), ['1', '2', '4'], 'removes from content');
    }
    ['@test removeObject - removes object from content'](assert) {
      array.removeObject('2');
      assert.deepEqual(array.toArray(), ['1', '4', '5']);
    }
    ['@test removeObjects - removes objects from content'](assert) {
      array.removeObjects(['2', '4', '6']);
      assert.deepEqual(array.toArray(), ['1', '5']);
    }
    ['@test shiftObject - removes from start of arrangedContent'](assert) {
      let shifted = array.shiftObject();
      assert.equal(shifted, '1', 'returns first object');
      assert.deepEqual(array.toArray(), ['2', '4', '5'], 'removes object from content');
    }
  });
});
define("@ember/-internals/runtime/tests/system/array_proxy/content_change_test", ["@ember/runloop", "@ember/-internals/metal", "@ember/object", "@ember/array/proxy", "@ember/array", "internal-test-helpers"], function (_runloop, _metal, _object, _proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ArrayProxy - content change', class extends _internalTestHelpers.AbstractTestCase {
    ["@test The ArrayProxy doesn't explode when assigned a destroyed object"](assert) {
      let proxy1 = _proxy.default.create();
      let proxy2 = _proxy.default.create();
      (0, _runloop.run)(() => proxy1.destroy());
      (0, _object.set)(proxy2, 'content', proxy1);
      assert.ok(true, 'No exception was raised');
    }
    ['@test should update if content changes while change events are deferred'](assert) {
      let proxy = _proxy.default.create();
      assert.deepEqual(proxy.toArray(), []);
      (0, _metal.changeProperties)(() => {
        proxy.set('content', (0, _array.A)([1, 2, 3]));
        assert.deepEqual(proxy.toArray(), [1, 2, 3]);
      });
    }
    ['@test objectAt recomputes the object cache correctly'](assert) {
      let indexes = [];
      let proxy = _proxy.default.extend({
        objectAtContent(index) {
          indexes.push(index);
          return this.content[index];
        }
      }).create({
        content: (0, _array.A)([1, 2, 3, 4, 5])
      });
      assert.deepEqual(indexes, []);
      assert.deepEqual(proxy.objectAt(0), 1);
      assert.deepEqual(indexes, [0, 1, 2, 3, 4]);
      indexes.length = 0;
      proxy.set('content', (0, _array.A)([1, 2, 3]));
      assert.deepEqual(proxy.objectAt(0), 1);
      assert.deepEqual(indexes, [0, 1, 2]);
      indexes.length = 0;
      proxy.content.replace(2, 0, [4, 5]);
      assert.deepEqual(proxy.objectAt(0), 1);
      assert.deepEqual(proxy.objectAt(1), 2);
      assert.deepEqual(indexes, []);
      assert.deepEqual(proxy.objectAt(2), 4);
      assert.deepEqual(indexes, [2, 3, 4]);
    }
    ['@test negative indexes are handled correctly'](assert) {
      let indexes = [];
      let proxy = _proxy.default.extend({
        objectAtContent(index) {
          indexes.push(index);
          return this.content[index];
        }
      }).create({
        content: (0, _array.A)([1, 2, 3, 4, 5])
      });
      assert.deepEqual(proxy.toArray(), [1, 2, 3, 4, 5]);
      indexes.length = 0;
      proxy.content.replace(-1, 0, [7]);
      proxy.content.replace(-2, 0, [6]);
      assert.deepEqual(proxy.toArray(), [1, 2, 3, 4, 6, 7, 5]);
      assert.deepEqual(indexes, [4, 5, 6]);
    }
  });
});
define("@ember/-internals/runtime/tests/system/array_proxy/length_test", ["@ember/array/proxy", "@ember/object", "@ember/object/computed", "@ember/array", "internal-test-helpers", "@glimmer/validator"], function (_proxy, _object, _computed, _array, _internalTestHelpers, _validator) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.ArrayProxy - content change (length)', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should update length for null content'](assert) {
      let proxy = _proxy.default.create({
        content: (0, _array.A)([1, 2, 3])
      });
      assert.equal(proxy.get('length'), 3, 'precond - length is 3');
      proxy.set('content', null);
      assert.equal(proxy.get('length'), 0, 'length updates');
    }
    ['@test should update length for null content when there is a computed property watching length'](assert) {
      let proxy = _proxy.default.extend({
        isEmpty: (0, _computed.not)('length')
      }).create({
        content: (0, _array.A)([1, 2, 3])
      });
      assert.equal(proxy.get('length'), 3, 'precond - length is 3');

      // Consume computed property that depends on length
      proxy.get('isEmpty');

      // update content
      proxy.set('content', null);
      assert.equal(proxy.get('length'), 0, 'length updates');
    }
    ['@test getting length does not recompute the object cache'](assert) {
      let indexes = [];
      let proxy = _proxy.default.extend({
        objectAtContent(index) {
          indexes.push(index);
          return this.content[index];
        }
      }).create({
        content: (0, _array.A)([1, 2, 3, 4, 5])
      });
      assert.equal((0, _object.get)(proxy, 'length'), 5);
      assert.deepEqual(indexes, []);
      indexes.length = 0;
      proxy.set('content', (0, _array.A)([6, 7, 8]));
      assert.equal((0, _object.get)(proxy, 'length'), 3);
      assert.deepEqual(indexes, []);
      indexes.length = 0;
      proxy.content.replace(1, 0, [1, 2, 3]);
      assert.equal((0, _object.get)(proxy, 'length'), 6);
      assert.deepEqual(indexes, []);
    }
    '@test accessing length after content set to null'(assert) {
      let obj = _proxy.default.create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _object.set)(obj, 'content', null);
      assert.equal(obj.length, 0, 'length is 0 without content');
      assert.deepEqual(obj.content, null, 'content was updated');
    }
    '@test accessing length after content set to null in willDestroy'(assert) {
      let obj = _proxy.default.extend({
        willDestroy() {
          this.set('content', null);
          this._super(...arguments);
        }
      }).create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _internalTestHelpers.runTask)(() => obj.destroy());
      assert.equal(obj.length, 0, 'length is 0 without content');
      assert.deepEqual(obj.content, null, 'content was updated');
    }
    '@test setting length to 0'(assert) {
      let obj = _proxy.default.create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _object.set)(obj, 'length', 0);
      assert.equal(obj.length, 0, 'length was updated');
      assert.deepEqual(obj.content, [], 'content length was truncated');
    }
    '@test setting length to smaller value'(assert) {
      let obj = _proxy.default.create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _object.set)(obj, 'length', 1);
      assert.equal(obj.length, 1, 'length was updated');
      assert.deepEqual(obj.content, ['foo'], 'content length was truncated');
    }
    '@test setting length to larger value'(assert) {
      let obj = _proxy.default.create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _object.set)(obj, 'length', 3);
      assert.equal(obj.length, 3, 'length was updated');
      assert.deepEqual(obj.content, ['foo', 'bar', undefined], 'content length was updated');
    }
    '@test setting length after content set to null'(assert) {
      let obj = _proxy.default.create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _object.set)(obj, 'content', null);
      assert.equal(obj.length, 0, 'length was updated');
      (0, _object.set)(obj, 'length', 0);
      assert.equal(obj.length, 0, 'length is still updated');
    }
    '@test setting length to greater than zero'(assert) {
      let obj = _proxy.default.create({
        content: ['foo', 'bar']
      });
      assert.equal(obj.length, 2, 'precond');
      (0, _object.set)(obj, 'length', 1);
      assert.equal(obj.length, 1, 'length was updated');
      assert.deepEqual(obj.content, ['foo'], 'content length was truncated');
    }
    async ['@test array proxy + aliasedProperty complex test'](assert) {
      let aCalled, bCalled, cCalled, dCalled, eCalled;
      aCalled = bCalled = cCalled = dCalled = eCalled = 0;
      let obj = _object.default.extend({
        colors: (0, _computed.oneWay)('model'),
        length: (0, _computed.oneWay)('colors.length'),
        a: (0, _object.observer)('length', () => aCalled++),
        b: (0, _object.observer)('colors.length', () => bCalled++),
        c: (0, _object.observer)('colors.content.length', () => cCalled++),
        d: (0, _object.observer)('colors.[]', () => dCalled++),
        e: (0, _object.observer)('colors.content.[]', () => eCalled++)
      }).create();

      // bootstrap aliases
      obj.length;
      obj.set('model', _proxy.default.create({
        content: (0, _array.A)(['red', 'yellow', 'blue'])
      }));
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj.get('colors.content.length'), 3);
      assert.equal(obj.get('colors.length'), 3);
      assert.equal(obj.get('length'), 3);
      assert.equal(aCalled, 1, 'expected observer `length` to be called ONCE');
      assert.equal(bCalled, 1, 'expected observer `colors.length` to be called ONCE');
      assert.equal(cCalled, 1, 'expected observer `colors.content.length` to be called ONCE');
      assert.equal(dCalled, 1, 'expected observer `colors.[]` to be called ONCE');
      assert.equal(eCalled, 1, 'expected observer `colors.content.[]` to be called ONCE');
      obj.get('colors').pushObjects(['green', 'red']);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj.get('colors.content.length'), 5);
      assert.equal(obj.get('colors.length'), 5);
      assert.equal(obj.get('length'), 5);
      assert.equal(aCalled, 2, 'expected observer `length` to be called TWICE');
      assert.equal(bCalled, 2, 'expected observer `colors.length` to be called TWICE');
      assert.equal(cCalled, 2, 'expected observer `colors.content.length` to be called TWICE');
      assert.equal(dCalled, 2, 'expected observer `colors.[]` to be called TWICE');
      assert.equal(eCalled, 2, 'expected observer `colors.content.[]` to be called TWICE');
      obj.destroy();
    }
    async ['@test array proxy length is reactive when accessed normally'](assert) {
      let proxy = _proxy.default.create({
        content: (0, _array.A)([1, 2, 3])
      });
      let lengthCache = (0, _validator.createCache)(() => proxy.length);
      assert.equal((0, _validator.getValue)(lengthCache), 3, 'length is correct');
      proxy.pushObject(4);
      assert.equal((0, _validator.getValue)(lengthCache), 4, 'length is correct');
      proxy.removeObject(1);
      assert.equal((0, _validator.getValue)(lengthCache), 3, 'length is correct');
      proxy.set('content', []);
      assert.equal((0, _validator.getValue)(lengthCache), 0, 'length is correct');
    }
    async ['@test array proxy length is reactive when accessed using get'](assert) {
      let proxy = _proxy.default.create({
        content: (0, _array.A)([1, 2, 3])
      });
      let lengthCache = (0, _validator.createCache)(() => (0, _object.get)(proxy, 'length'));
      assert.equal((0, _validator.getValue)(lengthCache), 3, 'length is correct');
      proxy.pushObject(4);
      assert.equal((0, _validator.getValue)(lengthCache), 4, 'length is correct');
      proxy.removeObject(1);
      assert.equal((0, _validator.getValue)(lengthCache), 3, 'length is correct');
      proxy.set('content', []);
      assert.equal((0, _validator.getValue)(lengthCache), 0, 'length is correct');
    }
  });
});
define("@ember/-internals/runtime/tests/system/array_proxy/watching_and_listening_test", ["@ember/-internals/meta", "@ember/array/proxy", "@ember/array", "internal-test-helpers"], function (_meta, _proxy, _array, _internalTestHelpers) {
  "use strict";

  function sortedListenersFor(obj, eventName) {
    let listeners = (0, _meta.peekMeta)(obj).matchingListeners(eventName) || [];
    let keys = [];
    for (let i = 0; i < listeners.length; i += 3) {
      keys.push(listeners[i + 1]);
    }
    return keys.sort();
  }
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - watching and listening', class extends _internalTestHelpers.AbstractTestCase {
    ["@test setting 'content' adds listeners correctly"](assert) {
      let content = (0, _array.A)();
      let proxy = _proxy.default.create();
      assert.deepEqual(sortedListenersFor(content, '@array:before'), []);
      assert.deepEqual(sortedListenersFor(content, '@array:change'), []);
      proxy.set('content', content);
      assert.deepEqual(sortedListenersFor(content, '@array:before'), ['_arrangedContentArrayWillChange']);
      assert.deepEqual(sortedListenersFor(content, '@array:change'), ['_arrangedContentArrayDidChange']);
    }
    ["@test changing 'content' adds and removes listeners correctly"](assert) {
      let content1 = (0, _array.A)();
      let content2 = (0, _array.A)();
      let proxy = _proxy.default.create({
        content: content1
      });
      assert.deepEqual(sortedListenersFor(content1, '@array:before'), []);
      assert.deepEqual(sortedListenersFor(content1, '@array:change'), []);

      // setup proxy
      proxy.length;
      assert.deepEqual(sortedListenersFor(content1, '@array:before'), ['_arrangedContentArrayWillChange']);
      assert.deepEqual(sortedListenersFor(content1, '@array:change'), ['_arrangedContentArrayDidChange']);
      proxy.set('content', content2);
      assert.deepEqual(sortedListenersFor(content1, '@array:before'), []);
      assert.deepEqual(sortedListenersFor(content1, '@array:change'), []);
      assert.deepEqual(sortedListenersFor(content2, '@array:before'), ['_arrangedContentArrayWillChange']);
      assert.deepEqual(sortedListenersFor(content2, '@array:change'), ['_arrangedContentArrayDidChange']);
    }
  });
});
define("@ember/-internals/runtime/tests/system/core_object_test", ["@ember/-internals/owner", "@ember/object", "@ember/object/core", "internal-test-helpers", "@glimmer/validator", "@glimmer/destroyable", "@ember/runloop"], function (_owner, _object, _core, _internalTestHelpers, _validator, _destroyable, _runloop) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.CoreObject', class extends _internalTestHelpers.AbstractTestCase {
    ['@test toString should be not be added as a property when calling toString()'](assert) {
      let obj = _core.default.create({
        firstName: 'Foo',
        lastName: 'Bar'
      });
      obj.toString();
      assert.notOk(Object.prototype.hasOwnProperty.call(obj, 'toString'), 'Calling toString() should not create a toString class property');
    }
    ['@test should not trigger proxy assertion when retrieving a proxy with (GH#16263)'](assert) {
      let someProxyishThing = _core.default.extend({
        unknownProperty() {
          return true;
        }
      }).create();
      let obj = _core.default.create({
        someProxyishThing
      });
      let proxy = (0, _object.get)(obj, 'someProxyishThing');
      assert.equal((0, _object.get)(proxy, 'lolol'), true, 'should be able to get data from a proxy');
    }
    ['@test should not trigger proxy assertion when retrieving a re-registered proxy (GH#16610)'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      let someProxyishThing = _core.default.extend({
        unknownProperty() {
          return true;
        }
      }).create();

      // emulates ember-engines's process of registering services provided
      // by the host app down to the engine
      owner.register('thing:one', someProxyishThing, {
        instantiate: false
      });
      assert.equal(owner.lookup('thing:one'), someProxyishThing);
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test should not trigger proxy assertion when probing for a "symbol"'](assert) {
      let proxy = _core.default.extend({
        unknownProperty() {
          return true;
        }
      }).create();
      assert.equal((0, _object.get)(proxy, 'lolol'), true, 'should be able to get data from a proxy');

      // should not trigger an assertion
      (0, _owner.getOwner)(proxy);
    }
    ['@test can use getOwner in a proxy init GH#16484'](assert) {
      let owner = {};
      let options = {};
      (0, _owner.setOwner)(options, owner);
      _core.default.extend({
        init() {
          this._super(...arguments);
          let localOwner = (0, _owner.getOwner)(this);
          assert.equal(localOwner, owner, 'should be able to `getOwner` in init');
        },
        unknownProperty() {
          return undefined;
        }
      }).create(options);
    }
    async ['@test observed properties are enumerable when set GH#14594'](assert) {
      let callCount = 0;
      let Test = _core.default.extend({
        myProp: null,
        anotherProp: undefined,
        didChangeMyProp: (0, _object.observer)('myProp', function () {
          callCount++;
        })
      });
      let test = Test.create();
      (0, _object.set)(test, 'id', '3');
      (0, _object.set)(test, 'myProp', {
        id: 1
      });
      assert.deepEqual(Object.keys(test).sort(), ['id', 'myProp']);
      (0, _object.set)(test, 'anotherProp', 'nice');
      assert.deepEqual(Object.keys(test).sort(), ['anotherProp', 'id', 'myProp']);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(callCount, 1);
      test.destroy();
    }
    ['@test native getters/setters do not cause rendering invalidation during init'](assert) {
      let objectMeta = Object.create(null);
      class TestObject extends _core.default {
        get hiddenValue() {
          let v = (0, _object.get)(objectMeta, 'hiddenValue');
          return v !== undefined ? v : false;
        }
        set hiddenValue(v) {
          (0, _object.set)(objectMeta, 'hiddenValue', v);
        }
      }
      (0, _validator.track)(() => {
        TestObject.create({
          hiddenValue: true
        });
        assert.ok(true, 'We did not error');
      });
    }
    '@test destroy method is called when being destroyed by @ember/destroyable'(assert) {
      assert.expect(1);
      class TestObject extends _core.default {
        destroy() {
          assert.ok(true, 'destroy was invoked');
        }
      }
      let instance = TestObject.create();
      (0, _runloop.run)(() => {
        (0, _destroyable.destroy)(instance);
      });
    }
  });
});
define("@ember/-internals/runtime/tests/system/namespace/base_test", ["@ember/-internals/environment", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/utils", "@ember/object", "@ember/application/namespace", "internal-test-helpers"], function (_environment, _runloop, _metal, _utils, _object, _namespace, _internalTestHelpers) {
  "use strict";

  const originalLookup = _environment.context.lookup;
  let lookup;
  (0, _internalTestHelpers.moduleFor)('Namespace', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      (0, _metal.setNamespaceSearchDisabled)(false);
      lookup = _environment.context.lookup = {};
    }
    afterEach() {
      (0, _metal.setNamespaceSearchDisabled)(false);
      for (let prop in lookup) {
        if (lookup[prop]) {
          (0, _runloop.run)(lookup[prop], 'destroy');
        }
      }
      _environment.context.lookup = originalLookup;
    }
    ['@test Namespace should be a subclass of EmberObject'](assert) {
      assert.ok(_object.default.detect(_namespace.default));
    }
    ['@test Namespace should be duck typed'](assert) {
      let namespace = _namespace.default.create();
      try {
        assert.ok((0, _metal.get)(namespace, 'isNamespace'), 'isNamespace property is true');
      } finally {
        (0, _runloop.run)(namespace, 'destroy');
      }
    }
    ['@test Namespace is found and named'](assert) {
      let nsA = lookup.NamespaceA = _namespace.default.create();
      assert.equal(nsA.toString(), 'NamespaceA', 'namespaces should have a name if they are on lookup');
      let nsB = lookup.NamespaceB = _namespace.default.create();
      assert.equal(nsB.toString(), 'NamespaceB', 'namespaces work if created after the first namespace processing pass');
    }
    ['@test Classes under an Namespace are properly named'](assert) {
      let nsA = lookup.NamespaceA = _namespace.default.create();
      nsA.Foo = _object.default.extend();
      _namespace.default.processAll();
      assert.equal((0, _utils.getName)(nsA.Foo), 'NamespaceA.Foo', 'Classes pick up their parent namespace');
      nsA.Bar = _object.default.extend();
      _namespace.default.processAll();
      assert.equal((0, _utils.getName)(nsA.Bar), 'NamespaceA.Bar', 'New Classes get the naming treatment too');
      let nsB = lookup.NamespaceB = _namespace.default.create();
      nsB.Foo = _object.default.extend();
      _namespace.default.processAll();
      assert.equal((0, _utils.getName)(nsB.Foo), 'NamespaceB.Foo', 'Classes in new namespaces get the naming treatment');
    }

    //test("Classes under Ember are properly named", function() {
    //  // ES6TODO: This test does not work reliably when running independent package build with Broccoli config.
    //  Ember.TestObject = EmberObject.extend({});
    //  equal(Ember.TestObject.toString(), "Ember.TestObject", "class under Ember is given a string representation");
    //});

    ['@test Lowercase namespaces are no longer supported'](assert) {
      let nsC = lookup.namespaceC = _namespace.default.create();
      _namespace.default.processAll();
      assert.equal((0, _utils.getName)(nsC), (0, _utils.guidFor)(nsC));
    }
    ['@test A namespace can be assigned a custom name'](assert) {
      let nsA = _namespace.default.create({
        name: 'NamespaceA'
      });
      try {
        let nsB = lookup.NamespaceB = _namespace.default.create({
          name: 'CustomNamespaceB'
        });
        nsA.Foo = _object.default.extend();
        nsB.Foo = _object.default.extend();
        _namespace.default.processAll();
        assert.equal((0, _utils.getName)(nsA.Foo), 'NamespaceA.Foo', "The namespace's name is used when the namespace is not in the lookup object");
        assert.equal((0, _utils.getName)(nsB.Foo), 'CustomNamespaceB.Foo', "The namespace's name is used when the namespace is in the lookup object");
      } finally {
        (0, _runloop.run)(nsA, 'destroy');
      }
    }
    ['@test Calling namespace.nameClasses() eagerly names all classes'](assert) {
      (0, _metal.setNamespaceSearchDisabled)(true);
      let namespace = lookup.NS = _namespace.default.create();
      namespace.ClassA = _object.default.extend();
      namespace.ClassB = _object.default.extend();
      _namespace.default.processAll();
      assert.equal((0, _utils.getName)(namespace.ClassA), 'NS.ClassA');
      assert.equal((0, _utils.getName)(namespace.ClassB), 'NS.ClassB');
    }
    ['@test A namespace can be looked up by its name'](assert) {
      let NS = lookup.NS = _namespace.default.create();
      let UI = lookup.UI = _namespace.default.create();
      let CF = lookup.CF = _namespace.default.create();
      assert.equal(_namespace.default.byName('NS'), NS);
      assert.equal(_namespace.default.byName('UI'), UI);
      assert.equal(_namespace.default.byName('CF'), CF);
    }
    ['@test A nested namespace can be looked up by its name'](assert) {
      let UI = lookup.UI = _namespace.default.create();
      UI.Nav = _namespace.default.create();
      assert.equal(_namespace.default.byName('UI.Nav'), UI.Nav);
      (0, _runloop.run)(UI.Nav, 'destroy');
    }
    ['@test Destroying a namespace before caching lookup removes it from the list of namespaces'](assert) {
      let CF = lookup.CF = _namespace.default.create();
      (0, _runloop.run)(CF, 'destroy');
      assert.equal(_namespace.default.byName('CF'), undefined, 'namespace can not be found after destroyed');
    }
    ['@test Destroying a namespace after looking up removes it from the list of namespaces'](assert) {
      let CF = lookup.CF = _namespace.default.create();
      assert.equal(_namespace.default.byName('CF'), CF, 'precondition - namespace can be looked up by name');
      (0, _runloop.run)(CF, 'destroy');
      assert.equal(_namespace.default.byName('CF'), undefined, 'namespace can not be found after destroyed');
    }
  });
});
define("@ember/-internals/runtime/tests/system/native_array/a_test", ["@ember/array", "internal-test-helpers"], function (_array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.A', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Ember.A'](assert) {
      assert.deepEqual((0, _array.A)([1, 2]), [1, 2], 'array values were not be modified');
      assert.deepEqual((0, _array.A)(), [], 'returned an array with no arguments');
      assert.deepEqual((0, _array.A)(null), [], 'returned an array with a null argument');
      assert.ok(_array.default.detect((0, _array.A)()), 'returned an ember array');
      assert.ok(_array.default.detect((0, _array.A)([1, 2])), 'returned an ember array');
    }
    ['@test new Ember.A'](assert) {
      expectAssertion(() => {
        assert.deepEqual(new _array.A([1, 2]), [1, 2], 'array values were not be modified');
        assert.deepEqual(new _array.A(), [], 'returned an array with no arguments');
        assert.deepEqual(new _array.A(null), [], 'returned an array with a null argument');
        assert.ok(_array.default.detect(new _array.A()), 'returned an ember array');
        assert.ok(_array.default.detect(new _array.A([1, 2])), 'returned an ember array');
      });
    }
  });
});
define("@ember/-internals/runtime/tests/system/native_array/replace_test", ["@ember/array", "internal-test-helpers"], function (_array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('NativeArray.replace', class extends _internalTestHelpers.AbstractTestCase {
    ['@test raises assertion if third argument is not an array']() {
      expectAssertion(function () {
        (0, _array.A)([1, 2, 3]).replace(1, 1, '');
      }, 'The third argument to replace needs to be an array.');
    }
    ['@test it does not raise an assertion if third parameter is not passed'](assert) {
      assert.deepEqual((0, _array.A)([1, 2, 3]).replace(1, 2), (0, _array.A)([1]), 'no assertion raised');
    }
  });
});
define("@ember/-internals/runtime/tests/system/object_proxy_test", ["@ember/-internals/metal", "@ember/object", "@ember/object/proxy", "internal-test-helpers"], function (_metal, _object, _proxy, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ObjectProxy', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should not proxy properties passed to create'](assert) {
      let Proxy = _proxy.default.extend({
        cp: (0, _object.computed)({
          get() {
            return this._cp;
          },
          set(key, value) {
            this._cp = value;
            return this._cp;
          }
        })
      });
      let proxy = Proxy.create({
        prop: 'Foo',
        cp: 'Bar'
      });
      assert.equal((0, _object.get)(proxy, 'prop'), 'Foo', 'should not have tried to proxy set');
      assert.equal(proxy._cp, 'Bar', 'should use CP setter');
    }
    ['@test should proxy properties to content'](assert) {
      let content = {
        firstName: 'Tom',
        lastName: 'Dale',
        unknownProperty(key) {
          return key + ' unknown';
        }
      };
      let proxy = _proxy.default.create();
      assert.equal((0, _object.get)(proxy, 'firstName'), undefined, 'get on proxy without content should return undefined');
      expectAssertion(() => {
        (0, _object.set)(proxy, 'firstName', 'Foo');
      }, /Cannot delegate set\('firstName', Foo\) to the 'content'/i);
      (0, _object.set)(proxy, 'content', content);
      assert.equal((0, _object.get)(proxy, 'firstName'), 'Tom', 'get on proxy with content should forward to content');
      assert.equal((0, _object.get)(proxy, 'lastName'), 'Dale', 'get on proxy with content should forward to content');
      assert.equal((0, _object.get)(proxy, 'foo'), 'foo unknown', 'get on proxy with content should forward to content');
      (0, _object.set)(proxy, 'lastName', 'Huda');
      assert.equal((0, _object.get)(content, 'lastName'), 'Huda', 'content should have new value from set on proxy');
      assert.equal((0, _object.get)(proxy, 'lastName'), 'Huda', 'proxy should have new value from set on proxy');
      (0, _object.set)(proxy, 'content', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      assert.equal((0, _object.get)(proxy, 'firstName'), 'Yehuda', 'proxy should reflect updated content');
      assert.equal((0, _object.get)(proxy, 'lastName'), 'Katz', 'proxy should reflect updated content');
    }
    ['@test getting proxied properties with Ember.get should work'](assert) {
      let proxy = _proxy.default.create({
        content: {
          foo: 'FOO'
        }
      });
      assert.equal((0, _object.get)(proxy, 'foo'), 'FOO');
    }
    ["@test JSON.stringify doens't assert"](assert) {
      let proxy = _proxy.default.create({
        content: {
          foo: 'FOO'
        }
      });
      assert.equal(JSON.stringify(proxy), JSON.stringify({
        content: {
          foo: 'FOO'
        }
      }));
    }
    ['@test calling a function on the proxy avoids the assertion'](assert) {
      if (false /* DEBUG */) {
        let proxy = _proxy.default.extend({
          init() {
            this._super();
            if (!this.foobar) {
              this.foobar = function () {
                let content = (0, _object.get)(this, 'content');
                return content.foobar.apply(content, []);
              };
            }
          }
        }).create({
          content: {
            foobar() {
              return 'xoxo';
            }
          }
        });
        assert.equal(proxy.foobar(), 'xoxo', 'should be able to use a function from a proxy');
      } else {
        assert.expect(0);
      }
    }
    ["@test setting a property on the proxy avoids the assertion"](assert) {
      let proxy = _proxy.default.create({
        toJSON: undefined,
        content: {
          toJSON() {
            return 'hello';
          }
        }
      });
      assert.equal(JSON.stringify(proxy), JSON.stringify({
        content: 'hello'
      }));
    }
    ["@test setting a property on the proxy's prototype avoids the assertion"](assert) {
      let proxy = _proxy.default.extend({
        toJSON: null
      }).create({
        content: {
          toJSON() {
            return 'hello';
          }
        }
      });
      assert.equal(JSON.stringify(proxy), JSON.stringify({
        content: 'hello'
      }));
    }
    ['@test getting proxied properties with [] should be an error'](assert) {
      if (false /* DEBUG */) {
        let proxy = _proxy.default.create({
          content: {
            foo: 'FOO'
          }
        });
        expectAssertion(() => proxy.foo, /\.get\('foo'\)/);
      } else {
        assert.expect(0);
      }
    }
    async ['@test should work with watched properties'](assert) {
      let content1 = {
        firstName: 'Tom',
        lastName: 'Dale'
      };
      let content2 = {
        firstName: 'Yehuda',
        lastName: 'Katz'
      };
      let count = 0;
      let last;
      let Proxy = _proxy.default.extend({
        fullName: (0, _object.computed)('firstName', 'lastName', function () {
          let firstName = this.get('firstName');
          let lastName = this.get('lastName');
          if (firstName && lastName) {
            return firstName + ' ' + lastName;
          }
          return firstName || lastName;
        })
      });
      let proxy = Proxy.create();
      (0, _metal.addObserver)(proxy, 'fullName', () => {
        last = (0, _object.get)(proxy, 'fullName');
      });

      // We need separate observers for each property for async observers
      (0, _metal.addObserver)(proxy, 'firstName', function () {
        count++;
      });
      (0, _metal.addObserver)(proxy, 'lastName', function () {
        count++;
      });

      // proxy without content returns undefined
      assert.equal((0, _object.get)(proxy, 'fullName'), undefined);

      // setting content causes all watched properties to change
      (0, _object.set)(proxy, 'content', content1);
      await (0, _internalTestHelpers.runLoopSettled)();

      // both dependent keys changed
      assert.equal(count, 2);
      assert.equal(last, 'Tom Dale');

      // setting property in content causes proxy property to change
      (0, _object.set)(content1, 'lastName', 'Huda');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 3);
      assert.equal(last, 'Tom Huda');

      // replacing content causes all watched properties to change
      (0, _object.set)(proxy, 'content', content2);
      await (0, _internalTestHelpers.runLoopSettled)();

      // both dependent keys changed
      assert.equal(count, 5);
      assert.equal(last, 'Yehuda Katz');

      // setting property in new content
      (0, _object.set)(content2, 'firstName', 'Tomhuda');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(last, 'Tomhuda Katz');
      assert.equal(count, 6);

      // setting property in proxy syncs with new content
      (0, _object.set)(proxy, 'lastName', 'Katzdale');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 7);
      assert.equal(last, 'Tomhuda Katzdale');
      assert.equal((0, _object.get)(content2, 'firstName'), 'Tomhuda');
      assert.equal((0, _object.get)(content2, 'lastName'), 'Katzdale');
      proxy.destroy();
    }
    async ['@test set and get should work with paths'](assert) {
      let content = {
        foo: {
          bar: 'baz'
        }
      };
      let proxy = _proxy.default.create({
        content
      });
      let count = 0;
      proxy.set('foo.bar', 'hello');
      assert.equal(proxy.get('foo.bar'), 'hello');
      assert.equal(proxy.get('content.foo.bar'), 'hello');
      proxy.addObserver('foo.bar', function () {
        count++;
      });
      proxy.set('foo.bar', 'bye');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      assert.equal(proxy.get('foo.bar'), 'bye');
      assert.equal(proxy.get('content.foo.bar'), 'bye');
      proxy.destroy();
    }
    async ['@test should transition between watched and unwatched strategies'](assert) {
      let content = {
        foo: 'foo'
      };
      let proxy = _proxy.default.create({
        content: content
      });
      let count = 0;
      function observer() {
        count++;
      }
      assert.equal((0, _object.get)(proxy, 'foo'), 'foo');
      (0, _object.set)(content, 'foo', 'bar');
      assert.equal((0, _object.get)(proxy, 'foo'), 'bar');
      (0, _object.set)(proxy, 'foo', 'foo');
      assert.equal((0, _object.get)(content, 'foo'), 'foo');
      assert.equal((0, _object.get)(proxy, 'foo'), 'foo');
      (0, _metal.addObserver)(proxy, 'foo', observer);
      assert.equal(count, 0);
      assert.equal((0, _object.get)(proxy, 'foo'), 'foo');
      (0, _object.set)(content, 'foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      assert.equal((0, _object.get)(proxy, 'foo'), 'bar');
      (0, _object.set)(proxy, 'foo', 'foo');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 2);
      assert.equal((0, _object.get)(content, 'foo'), 'foo');
      assert.equal((0, _object.get)(proxy, 'foo'), 'foo');
      (0, _metal.removeObserver)(proxy, 'foo', observer);
      (0, _object.set)(content, 'foo', 'bar');
      assert.equal((0, _object.get)(proxy, 'foo'), 'bar');
      (0, _object.set)(proxy, 'foo', 'foo');
      assert.equal((0, _object.get)(content, 'foo'), 'foo');
      assert.equal((0, _object.get)(proxy, 'foo'), 'foo');
    }
    ['@test setting `undefined` to a proxied content property should override its existing value'](assert) {
      let proxyObject = _proxy.default.create({
        content: {
          prop: 'emberjs'
        }
      });
      (0, _object.set)(proxyObject, 'prop', undefined);
      assert.equal((0, _object.get)(proxyObject, 'prop'), undefined, 'sets the `undefined` value to the proxied content');
    }
    ['@test should not throw or deprecate when adding an observer to an ObjectProxy based class'](assert) {
      assert.expect(0);
      let obj = _proxy.default.extend({
        observe: (0, _object.observer)('foo', function () {})
      }).create();
      obj.destroy();
    }
    async '@test custom proxies should be able to notify property changes manually'(assert) {
      let proxy = _proxy.default.extend({
        locals: {
          foo: 123
        },
        unknownProperty(key) {
          return this.locals[key];
        },
        setUnknownProperty(key, value) {
          this.locals[key] = value;
          this.notifyPropertyChange(key);
        }
      }).create();
      let count = 0;
      proxy.addObserver('foo', function () {
        count++;
      });
      proxy.set('foo', 456);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      assert.equal(proxy.get('foo'), 456);
      assert.equal(proxy.get('locals.foo'), 456);
      proxy.destroy();
    }
  });
});
define("@ember/-internals/string/tests/classify_test", ["@ember/-internals/string", "internal-test-helpers"], function (_string, _internalTestHelpers) {
  "use strict";

  /* eslint-disable qunit/no-test-expect-argument */

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.classify)(given), expected, description);
  }
  (0, _internalTestHelpers.moduleFor)('EmberInternalsString.classify', class extends _internalTestHelpers.AbstractTestCase {
    ['@test String classify tests'](assert) {
      test(assert, 'my favorite items', 'MyFavoriteItems', 'classify normal string');
      test(assert, 'css-class-name', 'CssClassName', 'classify dasherized string');
      test(assert, 'action_name', 'ActionName', 'classify underscored string');
      test(assert, 'privateDocs/ownerInvoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced dasherized string');
      test(assert, '-view-registry', '_ViewRegistry', 'classify prefixed dasherized string');
      test(assert, 'components/-text-field', 'Components/_TextField', 'classify namespaced prefixed dasherized string');
      test(assert, '_Foo_Bar', '_FooBar', 'classify underscore-prefixed underscored string');
      test(assert, '_Foo-Bar', '_FooBar', 'classify underscore-prefixed dasherized string');
      test(assert, '_foo/_bar', '_Foo/_Bar', 'classify underscore-prefixed-namespaced underscore-prefixed string');
      test(assert, '-foo/_bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced underscore-prefixed string');
      test(assert, '-foo/-bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced dash-prefixed string');
      test(assert, 'InnerHTML', 'InnerHTML', 'does nothing with classified string');
      test(assert, '_FooBar', '_FooBar', 'does nothing with classified prefixed string');
    }
  });
});
define("@ember/-internals/string/tests/dasherize_test", ["@ember/-internals/string", "internal-test-helpers"], function (_string, _internalTestHelpers) {
  "use strict";

  /* eslint-disable qunit/no-test-expect-argument */

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.dasherize)(given), expected, description);
  }
  (0, _internalTestHelpers.moduleFor)('EmberInternalsString.dasherize', class extends _internalTestHelpers.AbstractTestCase {
    ['@test String dasherize tests'](assert) {
      test(assert, 'my favorite items', 'my-favorite-items', 'dasherize normal string');
      test(assert, 'css-class-name', 'css-class-name', 'does nothing with dasherized string');
      test(assert, 'action_name', 'action-name', 'dasherize underscored string');
      test(assert, 'innerHTML', 'inner-html', 'dasherize camelcased string');
      test(assert, 'toString', 'to-string', 'dasherize string that is the property name of Object.prototype');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private-docs/owner-invoice', 'dasherize namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private-docs/owner-invoice', 'dasherize namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'private-docs/owner-invoice', 'dasherize namespaced underscored string');
    }
  });
});
define("@ember/-internals/utils/tests/cache_test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Cache', class extends _internalTestHelpers.AbstractTestCase {
    ['@test basic'](assert) {
      let cache = new _utils.Cache(100, key => key.toUpperCase());
      assert.equal(cache.get('foo'), 'FOO');
      assert.equal(cache.get('bar'), 'BAR');
      assert.equal(cache.get('foo'), 'FOO');
    }
    ['@test explicit sets'](assert) {
      let cache = new _utils.Cache(100, key => key.toUpperCase());
      assert.equal(cache.get('foo'), 'FOO');
      assert.equal(cache.set('foo', 'FOO!!!'), 'FOO!!!');
      assert.equal(cache.get('foo'), 'FOO!!!');
      assert.strictEqual(cache.set('foo', undefined), undefined);
      assert.strictEqual(cache.get('foo'), undefined);
    }
    ['@test caches computation correctly'](assert) {
      let count = 0;
      let cache = new _utils.Cache(100, key => {
        count++;
        return key.toUpperCase();
      });
      assert.equal(count, 0);
      cache.get('foo');
      assert.equal(count, 1);
      cache.get('bar');
      assert.equal(count, 2);
      cache.get('bar');
      assert.equal(count, 2);
      cache.get('foo');
      assert.equal(count, 2);
    }
    ['@test handles undefined value correctly'](assert) {
      let count = 0;
      let cache = new _utils.Cache(100, () => {
        count++;
      });
      assert.equal(count, 0);
      assert.strictEqual(cache.get('foo'), undefined);
      assert.equal(count, 1);
      assert.strictEqual(cache.get('bar'), undefined);
      assert.equal(count, 2);
      assert.strictEqual(cache.get('bar'), undefined);
      assert.equal(count, 2);
      assert.strictEqual(cache.get('foo'), undefined);
      assert.equal(count, 2);
    }
    ['@test continues working after reaching cache limit'](assert) {
      let cache = new _utils.Cache(3, key => key.toUpperCase());
      cache.get('a');
      cache.get('b');
      cache.get('c');
      assert.equal(cache.get('d'), 'D');
      assert.equal(cache.get('a'), 'A');
      assert.equal(cache.get('b'), 'B');
      assert.equal(cache.get('c'), 'C');
    }
  });
});
define("@ember/-internals/utils/tests/can_invoke_test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  let obj;
  (0, _internalTestHelpers.moduleFor)('Ember.canInvoke', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      obj = {
        foobar: 'foobar',
        aMethodThatExists() {}
      };
    }
    teardown() {
      obj = undefined;
    }
    ["@test should return false if the object doesn't exist"](assert) {
      assert.equal((0, _utils.canInvoke)(undefined, 'aMethodThatDoesNotExist'), false);
    }
    ['@test should return true for falsy values that have methods'](assert) {
      assert.equal((0, _utils.canInvoke)(false, 'valueOf'), true);
      assert.equal((0, _utils.canInvoke)('', 'charAt'), true);
      assert.equal((0, _utils.canInvoke)(0, 'toFixed'), true);
    }
    ['@test should return true if the method exists on the object'](assert) {
      assert.equal((0, _utils.canInvoke)(obj, 'aMethodThatExists'), true);
    }
    ["@test should return false if the method doesn't exist on the object"](assert) {
      assert.equal((0, _utils.canInvoke)(obj, 'aMethodThatDoesNotExist'), false);
    }
    ['@test should return false if the property exists on the object but is a non-function'](assert) {
      assert.equal((0, _utils.canInvoke)(obj, 'foobar'), false);
    }
  });
});
define("@ember/-internals/utils/tests/checkHasSuper_test", ["@ember/-internals/browser-environment", "@ember/-internals/utils", "internal-test-helpers"], function (_browserEnvironment, _utils, _internalTestHelpers) {
  "use strict";

  // Only run this test on browsers that we are certain should have function
  // source available.  This allows the test suite to continue to pass on other
  // platforms that correctly (for them) fall back to the "always wrap" code.
  if (_browserEnvironment.isChrome || _browserEnvironment.isFirefox) {
    (0, _internalTestHelpers.moduleFor)('checkHasSuper', class extends _internalTestHelpers.AbstractTestCase {
      ['@test does not super wrap needlessly [GH #12462]'](assert) {
        assert.notOk((0, _utils.checkHasSuper)(function () {}), 'empty function does not have super');
      }
    });
  }
});
define("@ember/-internals/utils/tests/generate_guid_test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.generateGuid', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Prefix'](assert) {
      let a = {};
      assert.ok((0, _utils.generateGuid)(a, 'tyrell').indexOf('tyrell') > -1, 'guid can be prefixed');
    }
  });
});
define("@ember/-internals/utils/tests/get-debug-name-test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  if (false /* DEBUG */) {
    (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils getDebugName', class extends _internalTestHelpers.AbstractTestCase {
      '@test basic'(assert) {
        class Person {}
        assert.equal((0, _utils.getDebugName)({}), '(unknown object)');
        assert.equal((0, _utils.getDebugName)(() => {}), '(unknown function)');
        assert.equal((0, _utils.getDebugName)(Person), 'Person');
        assert.equal((0, _utils.getDebugName)(new Person()), 'Person');
        assert.equal((0, _utils.getDebugName)(function foo() {}), 'foo');
        assert.equal((0, _utils.getDebugName)({
          toString() {
            return 'bar';
          }
        }), 'bar');
        class ClassWithToString {
          toString() {
            return 'baz';
          }
        }
        assert.equal((0, _utils.getDebugName)(ClassWithToString), 'ClassWithToString');
        assert.equal((0, _utils.getDebugName)(new ClassWithToString()), 'baz');
        class ClassWithEmberLikeToString {
          toString() {
            return '<some-desc:ember1234>';
          }
        }
        assert.equal((0, _utils.getDebugName)(ClassWithEmberLikeToString), 'ClassWithEmberLikeToString');
        assert.equal((0, _utils.getDebugName)(new ClassWithEmberLikeToString()), '<ClassWithEmberLikeToString:ember1234>');
        assert.equal((0, _utils.getDebugName)(true), 'true');
        assert.equal((0, _utils.getDebugName)(123), '123');
        assert.equal((0, _utils.getDebugName)('string'), 'string');
      }
    });
  }
});
define("@ember/-internals/utils/tests/guid_for_test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  function sameGuid(assert, a, b, message) {
    assert.equal((0, _utils.guidFor)(a), (0, _utils.guidFor)(b), message);
  }
  function diffGuid(assert, a, b, message) {
    assert.ok((0, _utils.guidFor)(a) !== (0, _utils.guidFor)(b), message);
  }
  function nanGuid(assert, obj) {
    let type = typeof obj;
    assert.ok(isNaN(parseInt((0, _utils.guidFor)(obj), 0)), 'guids for ' + type + "don't parse to numbers");
  }
  (0, _internalTestHelpers.moduleFor)('guidFor', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Object'](assert) {
      let a = {};
      let b = {};
      sameGuid(assert, a, a, 'same object always yields same guid');
      diffGuid(assert, a, b, 'different objects yield different guids');
      nanGuid(assert, a);
    }
    ['@test strings'](assert) {
      let a = 'string A';
      let aprime = 'string A';
      let b = 'String B';
      sameGuid(assert, a, a, 'same string always yields same guid');
      sameGuid(assert, a, aprime, 'identical strings always yield the same guid');
      diffGuid(assert, a, b, 'different strings yield different guids');
      nanGuid(assert, a);
    }
    ['@test numbers'](assert) {
      let a = 23;
      let aprime = 23;
      let b = 34;
      sameGuid(assert, a, a, 'same numbers always yields same guid');
      sameGuid(assert, a, aprime, 'identical numbers always yield the same guid');
      diffGuid(assert, a, b, 'different numbers yield different guids');
      nanGuid(assert, a);
    }
    ['@test symbols'](assert) {
      let a = Symbol('a');
      let b = Symbol('b');
      sameGuid(assert, a, a, 'same symbols always yields same guid');
      diffGuid(assert, a, b, 'different symbols yield different guids');
      nanGuid(assert, a);
    }
    ['@test booleans'](assert) {
      let a = true;
      let aprime = true;
      let b = false;
      sameGuid(assert, a, a, 'same booleans always yields same guid');
      sameGuid(assert, a, aprime, 'identical booleans always yield the same guid');
      diffGuid(assert, a, b, 'different boolean yield different guids');
      nanGuid(assert, a);
      nanGuid(assert, b);
    }
    ['@test null and undefined'](assert) {
      let a = null;
      let aprime = null;
      let b;
      sameGuid(assert, a, a, 'null always returns the same guid');
      sameGuid(assert, b, b, 'undefined always returns the same guid');
      sameGuid(assert, a, aprime, 'different nulls return the same guid');
      diffGuid(assert, a, b, 'null and undefined return different guids');
      nanGuid(assert, a);
      nanGuid(assert, b);
    }
    ['@test arrays'](assert) {
      let a = ['a', 'b', 'c'];
      let aprime = ['a', 'b', 'c'];
      let b = ['1', '2', '3'];
      sameGuid(assert, a, a, 'same instance always yields same guid');
      diffGuid(assert, a, aprime, 'identical arrays always yield the same guid');
      diffGuid(assert, a, b, 'different arrays yield different guids');
      nanGuid(assert, a);
    }
  });
});
define("@ember/-internals/utils/tests/is_proxy_test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils isProxy', class extends _internalTestHelpers.AbstractTestCase {
    ['@test basic'](assert) {
      let proxy = {};
      (0, _utils.setProxy)(proxy);
      assert.equal((0, _utils.isProxy)(proxy), true);
      assert.equal((0, _utils.isProxy)({}), false);
      assert.equal((0, _utils.isProxy)(undefined), false);
      assert.equal((0, _utils.isProxy)(null), false);
    }
  });
});
define("@ember/-internals/utils/tests/to-string-test", ["@ember/-internals/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils toString', class extends _internalTestHelpers.AbstractTestCase {
    ["@test toString uses an object's toString method when available"](assert) {
      let obj = {
        toString() {
          return 'bob';
        }
      };
      assert.strictEqual((0, _utils.toString)(obj), 'bob');
    }
    ['@test toString falls back to Object.prototype.toString'](assert) {
      let obj = Object.create(null);
      assert.strictEqual((0, _utils.toString)(obj), {}.toString());
    }
    ['@test toString does not fail when called on Arrays with objects without toString method'](assert) {
      let obj = Object.create(null);
      let arr = [obj, 2];
      assert.strictEqual((0, _utils.toString)(arr), {}.toString() + ",2");
    }
  });
});
define("@ember/application/tests/application_instance_test", ["ember-babel", "@ember/engine", "@ember/application", "@ember/application/instance", "@ember/runloop", "@ember/-internals/container", "internal-test-helpers", "@ember/object", "@ember/debug"], function (_emberBabel, _engine, _application, _instance, _runloop, _container, _internalTestHelpers, _object, _debug) {
  "use strict";

  var _templateObject;
  const originalDebug = (0, _debug.getDebugFunction)('debug');
  const noop = function () {};
  let application, appInstance;
  (0, _internalTestHelpers.moduleFor)('ApplicationInstance', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      (0, _debug.setDebugFunction)('debug', noop);
      super();
      document.getElementById('qunit-fixture').innerHTML = "\n      <div id='one'><div id='one-child'>HI</div></div><div id='two'>HI</div>\n    ";
      application = (0, _runloop.run)(() => _application.default.create({
        rootElement: '#one',
        router: null,
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      }));
    }
    teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
      if (appInstance) {
        (0, _runloop.run)(appInstance, 'destroy');
        appInstance = null;
      }
      if (application) {
        (0, _runloop.run)(application, 'destroy');
        application = null;
      }
      document.getElementById('qunit-fixture').innerHTML = '';
    }
    ['@test an application instance can be created based upon an application'](assert) {
      appInstance = (0, _runloop.run)(() => _instance.default.create({
        application
      }));
      assert.ok(appInstance, 'instance should be created');
      assert.equal(appInstance.application, application, 'application should be set to parent');
    }
    ['@test customEvents added to the application before setupEventDispatcher'](assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(() => _instance.default.create({
        application
      }));
      appInstance.setupRegistry();
      application.customEvents = {
        awesome: 'sauce'
      };
      let eventDispatcher = appInstance.lookup('event_dispatcher:main');
      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };
      appInstance.setupEventDispatcher();
    }
    ['@test customEvents added to the application instance before setupEventDispatcher'](assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(() => _instance.default.create({
        application
      }));
      appInstance.setupRegistry();
      appInstance.customEvents = {
        awesome: 'sauce'
      };
      let eventDispatcher = appInstance.lookup('event_dispatcher:main');
      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };
      appInstance.setupEventDispatcher();
    }
    ['@test unregistering a factory clears all cached instances of that factory'](assert) {
      assert.expect(5);
      appInstance = (0, _runloop.run)(() => _instance.default.create({
        application
      }));
      let PostController1 = (0, _internalTestHelpers.factory)();
      let PostController2 = (0, _internalTestHelpers.factory)();
      appInstance.register('controller:post', PostController1);
      let postController1 = appInstance.lookup('controller:post');
      let postController1Factory = appInstance.factoryFor('controller:post');
      assert.ok(postController1 instanceof PostController1, 'precond - lookup creates instance');
      assert.equal(PostController1, postController1Factory.class, 'precond - factoryFor().class matches');
      appInstance.unregister('controller:post');
      appInstance.register('controller:post', PostController2);
      let postController2 = appInstance.lookup('controller:post');
      let postController2Factory = appInstance.factoryFor('controller:post');
      assert.ok(postController2 instanceof PostController2, 'lookup creates instance');
      assert.equal(PostController2, postController2Factory.class, 'factoryFor().class matches');
      assert.notStrictEqual(postController1, postController2, 'lookup creates a brand new instance, because the previous one was reset');
    }
    ['@skip unregistering a factory clears caches with source of that factory'](assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(() => _instance.default.create({
        application
      }));
      let PostController1 = (0, _internalTestHelpers.factory)();
      let PostController2 = (0, _internalTestHelpers.factory)();
      appInstance.register('controller:post', PostController1);
      appInstance.lookup('controller:post');
      let postControllerLookupWithSource = appInstance.lookup('controller:post', {
        source: 'doesnt-even-matter'
      });
      appInstance.unregister('controller:post');
      appInstance.register('controller:post', PostController2);

      // The cache that is source-specific is not cleared
      assert.ok(postControllerLookupWithSource !== appInstance.lookup('controller:post', {
        source: 'doesnt-even-matter'
      }), 'lookup with source creates a new instance');
    }
    ['@test can build and boot a registered engine'](assert) {
      assert.expect(10);
      let ChatEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      let chatEngineInstance;
      application.register('engine:chat', ChatEngine);
      (0, _runloop.run)(() => {
        appInstance = _instance.default.create({
          application
        });
        appInstance.setupRegistry();
        chatEngineInstance = appInstance.buildChildEngineInstance('chat');
      });
      return chatEngineInstance.boot().then(() => {
        assert.ok(true, 'boot successful');
        let registrations = ['route:basic', 'service:-routing'];
        registrations.forEach(key => {
          assert.strictEqual(chatEngineInstance.resolveRegistration(key), appInstance.resolveRegistration(key), "Engine and parent app share registrations for '" + key + "'");
        });
        let singletons = ['router:main', (0, _container.privatize)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]))), '-view-registry:main', '-environment:main', 'service:-document', 'event_dispatcher:main'];
        singletons.push('renderer:-dom');
        singletons.forEach(key => {
          assert.strictEqual(chatEngineInstance.lookup(key), appInstance.lookup(key), "Engine and parent app share singleton '" + key + "'");
        });
      });
    }
    ['@test can build a registry via ApplicationInstance.setupRegistry() -- simulates ember-test-helpers'](assert) {
      let namespace = _object.default.create({
        Resolver: {
          create: function () {}
        }
      });
      let registry = _application.default.buildRegistry(namespace);
      _instance.default.setupRegistry(registry);
      assert.equal(registry.resolve('service:-document'), document);
    }
  });
});
define("@ember/application/tests/application_test", ["ember/version", "@ember/-internals/environment", "@ember/-internals/metal", "@ember/debug", "@ember/routing/route", "@ember/routing/router", "@ember/routing/none-location", "@ember/application", "@ember/controller", "@ember/object", "internal-test-helpers", "@ember/runloop"], function (_version, _environment, _metal, _debug, _route, _router, _noneLocation, _application, _controller, _object, _internalTestHelpers, _runloop) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application, autobooting multiple apps', class extends _internalTestHelpers.ApplicationTestCase {
    get fixture() {
      return "\n      <div id=\"one\">\n        <div id=\"one-child\">HI</div>\n      </div>\n      <div id=\"two\">HI</div>\n    ";
    }
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        rootElement: '#one',
        router: null,
        autoboot: true
      });
    }
    createSecondApplication(options) {
      let myOptions = Object.assign(this.applicationOptions, options);
      return this.secondApp = _application.default.create(myOptions);
    }
    teardown() {
      super.teardown();
      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(() => this.secondApp.destroy());
      }
    }
    ["@test you can make a new application in a non-overlapping element"](assert) {
      let app = (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({
        rootElement: '#two'
      }));
      (0, _internalTestHelpers.runTask)(() => app.destroy());
      assert.ok(true, 'should not raise');
    }
    ["@test you cannot make a new application that is a parent of an existing application"]() {
      expectAssertion(() => {
        (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({
          rootElement: this.applicationOptions.rootElement
        }));
      });
    }
    ["@test you cannot make a new application that is a descendant of an existing application"]() {
      expectAssertion(() => {
        (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({
          rootElement: '#one-child'
        }));
      });
    }
    ["@test you cannot make a new application that is a duplicate of an existing application"]() {
      expectAssertion(() => {
        (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({
          rootElement: '#one'
        }));
      });
    }
    ["@test you cannot make two default applications without a rootElement error"]() {
      expectAssertion(() => {
        (0, _internalTestHelpers.runTask)(() => this.createSecondApplication());
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application', class extends _internalTestHelpers.ApplicationTestCase {
    ["@test builds a registry"](assert) {
      let {
        application
      } = this;
      assert.strictEqual(application.resolveRegistration('application:main'), application, "application:main is registered");
      assert.deepEqual(application.registeredOptionsForType('component'), {
        singleton: false
      }, "optionsForType 'component'");
      assert.deepEqual(application.registeredOptionsForType('view'), {
        singleton: false
      }, "optionsForType 'view'");
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'controller:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, '-view-registry:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'route:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'event_dispatcher:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:hash');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:history');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:none');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:link-to');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:textarea');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-routing');

      // DEBUGGING
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component-lookup:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'view:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'renderer:-dom');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'template:-outlet');
      assert.deepEqual(application.registeredOptionsForType('helper'), {
        instantiate: false
      }, "optionsForType 'helper'");
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application, autobooting', class extends _internalTestHelpers.AutobootApplicationTestCase {
    constructor() {
      super(...arguments);
      this.originalLogVersion = _environment.ENV.LOG_VERSION;
      this.originalDebug = (0, _debug.getDebugFunction)('debug');
      this.originalWarn = (0, _debug.getDebugFunction)('warn');
    }
    teardown() {
      (0, _debug.setDebugFunction)('warn', this.originalWarn);
      (0, _debug.setDebugFunction)('debug', this.originalDebug);
      _environment.ENV.LOG_VERSION = this.originalLogVersion;
      super.teardown();
    }
    ["@test initialized application goes to initial route"]() {
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication();
        this.addTemplate('application', '{{outlet}}');
        this.addTemplate('index', '<h1>Hi from index</h1>');
      });
      this.assertText('Hi from index');
    }
    ["@test ready hook is called before routing begins"](assert) {
      assert.expect(2);
      (0, _internalTestHelpers.runTask)(() => {
        function registerRoute(application, name, callback) {
          let route = _route.default.extend({
            activate: callback
          });
          application.register('route:' + name, route);
        }
        let MyApplication = _application.default.extend({
          ready() {
            registerRoute(this, 'index', () => {
              assert.ok(true, 'last-minute route is activated');
            });
          }
        });
        let app = this.createApplication({}, MyApplication);
        registerRoute(app, 'application', () => assert.ok(true, 'normal route is activated'));
      });
    }
    ["@test initialize application via initialize call"](assert) {
      (0, _internalTestHelpers.runTask)(() => this.createApplication());
      // This is not a public way to access the container; we just
      // need to make some assertions about the created router
      let router = this.applicationInstance.lookup('router:main');
      assert.equal(router instanceof _router.default, true, 'Router was set from initialize call');
      assert.equal(router.location instanceof _noneLocation.default, true, 'Location was set from location implementation name');
    }
    ["@test initialize application with stateManager via initialize call from Router class"](assert) {
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication();
        this.addTemplate('application', '<h1>Hello!</h1>');
      });
      // This is not a public way to access the container; we just
      // need to make some assertions about the created router
      let router = this.application.__deprecatedInstance__.lookup('router:main');
      assert.equal(router instanceof _router.default, true, 'Router was set from initialize call');
      this.assertText('Hello!');
    }
    ["@test Application Controller backs the appplication template"]() {
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication();
        this.addTemplate('application', '<h1>{{this.greeting}}</h1>');
        this.add('controller:application', _controller.default.extend({
          greeting: 'Hello!'
        }));
      });
      this.assertText('Hello!');
    }
    ["@test enable log of libraries with an ENV var"](assert) {
      if (!false /* DEBUG */) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }
      let messages = [];
      _environment.ENV.LOG_VERSION = true;
      (0, _debug.setDebugFunction)('debug', message => messages.push(message));
      _metal.libraries.register('my-lib', '2.0.0a');
      (0, _internalTestHelpers.runTask)(() => this.createApplication());
      assert.equal(messages[1], 'Ember  : ' + _version.default);
      assert.equal(messages[2], 'my-lib : ' + '2.0.0a');
      _metal.libraries.deRegister('my-lib');
    }
    ["@test disable log of version of libraries with an ENV var"](assert) {
      let logged = false;
      _environment.ENV.LOG_VERSION = false;
      (0, _debug.setDebugFunction)('debug', () => logged = true);
      (0, _internalTestHelpers.runTask)(() => this.createApplication());
      assert.ok(!logged, 'library version logging skipped');
    }
    ["@test can resolve custom router"](assert) {
      let CustomRouter = _router.default.extend();
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication();
        this.add('router:main', CustomRouter);
      });
      assert.ok(this.application.__deprecatedInstance__.lookup('router:main') instanceof CustomRouter, 'application resolved the correct router');
    }
    ["@test does not leak itself in onLoad._loaded"](assert) {
      assert.equal(_application._loaded.application, undefined);
      (0, _internalTestHelpers.runTask)(() => this.createApplication());
      assert.equal(_application._loaded.application, this.application);
      (0, _internalTestHelpers.runTask)(() => this.application.destroy());
      assert.equal(_application._loaded.application, undefined);
    }
    ["@test can build a registry via Application.buildRegistry() --- simulates ember-test-helpers"](assert) {
      let namespace = _object.default.create({
        Resolver: {
          create: function () {}
        }
      });
      let registry = _application.default.buildRegistry(namespace);
      assert.equal(registry.resolve('application:main'), namespace);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application#buildRegistry', class extends _internalTestHelpers.AbstractTestCase {
    ["@test can build a registry via Application.buildRegistry() --- simulates ember-test-helpers"](assert) {
      let namespace = _object.default.create({
        Resolver: {
          create() {}
        }
      });
      let registry = _application.default.buildRegistry(namespace);
      assert.equal(registry.resolve('application:main'), namespace);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application - instance tracking', class extends _internalTestHelpers.ApplicationTestCase {
    ['@test tracks built instance'](assert) {
      let instance = this.application.buildInstance();
      (0, _runloop.run)(() => {
        this.application.destroy();
      });
      assert.ok(instance.isDestroyed, 'instance was destroyed');
    }
    ['@test tracks built instances'](assert) {
      let instanceA = this.application.buildInstance();
      let instanceB = this.application.buildInstance();
      (0, _runloop.run)(() => {
        this.application.destroy();
      });
      assert.ok(instanceA.isDestroyed, 'instanceA was destroyed');
      assert.ok(instanceB.isDestroyed, 'instanceB was destroyed');
    }
  });
});
define("@ember/application/tests/dependency_injection_test", ["@ember/-internals/environment", "@ember/runloop", "@ember/object", "@ember/application", "internal-test-helpers"], function (_environment, _runloop, _object, _application, _internalTestHelpers) {
  "use strict";

  let originalLookup = _environment.context.lookup;
  let registry, locator, application;
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      application = (0, _runloop.run)(_application.default, 'create', {
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      application.Person = _object.default.extend({});
      application.Orange = _object.default.extend({});
      application.Email = _object.default.extend({});
      application.User = _object.default.extend({});
      application.PostIndexController = _object.default.extend({});
      application.register('model:person', application.Person, {
        singleton: false
      });
      application.register('model:user', application.User, {
        singleton: false
      });
      application.register('fruit:favorite', application.Orange);
      application.register('communication:main', application.Email, {
        singleton: false
      });
      application.register('controller:postIndex', application.PostIndexController, {
        singleton: true
      });
      registry = application.__registry__;
      locator = application.__container__;
      _environment.context.lookup = {};
    }
    teardown() {
      super.teardown();
      (0, _runloop.run)(application, 'destroy');
      registry = application = locator = null;
      _environment.context.lookup = originalLookup;
    }
    ['@test registered entities can be looked up later'](assert) {
      assert.equal(registry.resolve('model:person'), application.Person);
      assert.equal(registry.resolve('model:user'), application.User);
      assert.equal(registry.resolve('fruit:favorite'), application.Orange);
      assert.equal(registry.resolve('communication:main'), application.Email);
      assert.equal(registry.resolve('controller:postIndex'), application.PostIndexController);
      assert.equal(locator.lookup('fruit:favorite'), locator.lookup('fruit:favorite'), 'singleton lookup worked');
      assert.ok(locator.lookup('model:user') !== locator.lookup('model:user'), 'non-singleton lookup worked');
    }
  });
});
define("@ember/application/tests/initializers_test", ["internal-test-helpers", "@ember/application"], function (_internalTestHelpers, _application) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application initializers', class extends _internalTestHelpers.AutobootApplicationTestCase {
    get fixture() {
      return "<div id=\"one\">ONE</div>\n      <div id=\"two\">TWO</div>\n    ";
    }
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        rootElement: '#one'
      });
    }
    createSecondApplication(options, MyApplication) {
      if (MyApplication === void 0) {
        MyApplication = _application.default;
      }
      let myOptions = Object.assign(this.applicationOptions, {
        rootElement: '#two'
      }, options);
      let secondApp = this.secondApp = MyApplication.create(myOptions);
      return secondApp;
    }
    teardown() {
      super.teardown();
      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(() => this.secondApp.destroy());
      }
    }
    ["@test initializers require proper 'name' and 'initialize' properties"]() {
      let MyApplication = _application.default.extend();
      expectAssertion(() => {
        MyApplication.initializer({
          name: 'initializer'
        });
      });
      expectAssertion(() => {
        MyApplication.initializer({
          initialize() {}
        });
      });
    }
    ["@test initializers that throw errors cause the boot promise to reject with the error"](assert) {
      assert.expect(2);
      let MyApplication = _application.default.extend();
      MyApplication.initializer({
        name: 'initializer',
        initialize() {
          throw new Error('boot failure');
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication({
          autoboot: false
        }, MyApplication);
      });
      let app = this.application;
      try {
        (0, _internalTestHelpers.runTask)(() => {
          app.boot().then(() => {
            assert.ok(false, 'The boot promise should not resolve when there is a boot error');
          }, error => {
            assert.ok(error instanceof Error, 'The boot promise should reject with an error');
            assert.equal(error.message, 'boot failure');
          });
        });
      } catch (error) {
        assert.ok(false, 'The boot method should not throw');
        throw error;
      }
    }
    ["@test initializers are passed an App"](assert) {
      let MyApplication = _application.default.extend();
      MyApplication.initializer({
        name: 'initializer',
        initialize(App) {
          assert.ok(App instanceof _application.default, 'initialize is passed an Application');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
    }
    ["@test initializers can be registered in a specified order"](assert) {
      let order = [];
      let MyApplication = _application.default.extend();
      MyApplication.initializer({
        name: 'fourth',
        after: 'third',
        initialize() {
          order.push('fourth');
        }
      });
      MyApplication.initializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize() {
          order.push('second');
        }
      });
      MyApplication.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyApplication.initializer({
        name: 'first',
        before: 'second',
        initialize() {
          order.push('first');
        }
      });
      MyApplication.initializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyApplication.initializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    }
    ["@test initializers can be registered in a specified order as an array"](assert) {
      let order = [];
      let MyApplication = _application.default.extend();
      MyApplication.initializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyApplication.initializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize() {
          order.push('second');
        }
      });
      MyApplication.initializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize() {
          order.push('fourth');
        }
      });
      MyApplication.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyApplication.initializer({
        name: 'first',
        before: ['second'],
        initialize() {
          order.push('first');
        }
      });
      MyApplication.initializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    }
    ["@test initializers can have multiple dependencies"](assert) {
      let order = [];
      let MyApplication = _application.default.extend();
      let a = {
        name: 'a',
        before: 'b',
        initialize() {
          order.push('a');
        }
      };
      let b = {
        name: 'b',
        initialize() {
          order.push('b');
        }
      };
      let c = {
        name: 'c',
        after: 'b',
        initialize() {
          order.push('c');
        }
      };
      let afterB = {
        name: 'after b',
        after: 'b',
        initialize() {
          order.push('after b');
        }
      };
      let afterC = {
        name: 'after c',
        after: 'c',
        initialize() {
          order.push('after c');
        }
      };
      MyApplication.initializer(b);
      MyApplication.initializer(a);
      MyApplication.initializer(afterC);
      MyApplication.initializer(afterB);
      MyApplication.initializer(c);
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    }
    ["@test initializers set on Application subclasses are not shared between apps"](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstApp = _application.default.extend();
      FirstApp.initializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondApp = _application.default.extend();
      SecondApp.initializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, FirstApp));
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({}, SecondApp));
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
    }
    ["@test initializers are concatenated"](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstApp = _application.default.extend();
      FirstApp.initializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondApp = FirstApp.extend();
      SecondApp.initializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, FirstApp));
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
      firstInitializerRunCount = 0;
      (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({}, SecondApp));
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    }
    ["@test initializers are per-app"](assert) {
      assert.expect(2);
      let FirstApp = _application.default.extend();
      FirstApp.initializer({
        name: 'abc',
        initialize() {}
      });
      expectAssertion(() => {
        FirstApp.initializer({
          name: 'abc',
          initialize() {}
        });
      });
      let SecondApp = _application.default.extend();
      SecondApp.instanceInitializer({
        name: 'abc',
        initialize() {}
      });
      assert.ok(true, 'Two apps can have initializers named the same.');
    }
    ["@test initializers are executed in their own context"](assert) {
      assert.expect(1);
      let MyApplication = _application.default.extend();
      MyApplication.initializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize() {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
    }
  });
});
define("@ember/application/tests/instance_initializers_test", ["internal-test-helpers", "@ember/application/instance", "@ember/application"], function (_internalTestHelpers, _instance, _application) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application instance initializers', class extends _internalTestHelpers.AutobootApplicationTestCase {
    get fixture() {
      return "<div id=\"one\">ONE</div>\n      <div id=\"two\">TWO</div>\n    ";
    }
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        rootElement: '#one'
      });
    }
    createSecondApplication(options, MyApplication) {
      if (MyApplication === void 0) {
        MyApplication = _application.default;
      }
      let myOptions = Object.assign(this.applicationOptions, {
        rootElement: '#two'
      }, options);
      let secondApp = this.secondApp = MyApplication.create(myOptions);
      return secondApp;
    }
    teardown() {
      super.teardown();
      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(() => this.secondApp.destroy());
      }
    }
    ["@test initializers require proper 'name' and 'initialize' properties"]() {
      let MyApplication = _application.default.extend();
      expectAssertion(() => {
        MyApplication.instanceInitializer({
          name: 'initializer'
        });
      });
      expectAssertion(() => {
        MyApplication.instanceInitializer({
          initialize() {}
        });
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
    }
    ["@test initializers are passed an app instance"](assert) {
      let MyApplication = _application.default.extend();
      MyApplication.instanceInitializer({
        name: 'initializer',
        initialize(instance) {
          assert.ok(instance instanceof _instance.default, 'initialize is passed an application instance');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
    }
    ["@test initializers can be registered in a specified order"](assert) {
      let order = [];
      let MyApplication = _application.default.extend();
      MyApplication.instanceInitializer({
        name: 'fourth',
        after: 'third',
        initialize() {
          order.push('fourth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize() {
          order.push('second');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'first',
        before: 'second',
        initialize() {
          order.push('first');
        }
      });
      MyApplication.instanceInitializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyApplication.instanceInitializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    }
    ["@test initializers can be registered in a specified order as an array"](assert) {
      let order = [];
      let MyApplication = _application.default.extend();
      MyApplication.instanceInitializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyApplication.instanceInitializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize() {
          order.push('second');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize() {
          order.push('fourth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'first',
        before: ['second'],
        initialize() {
          order.push('first');
        }
      });
      MyApplication.instanceInitializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    }
    ["@test initializers can have multiple dependencies"](assert) {
      let order = [];
      let MyApplication = _application.default.extend();
      let a = {
        name: 'a',
        before: 'b',
        initialize() {
          order.push('a');
        }
      };
      let b = {
        name: 'b',
        initialize() {
          order.push('b');
        }
      };
      let c = {
        name: 'c',
        after: 'b',
        initialize() {
          order.push('c');
        }
      };
      let afterB = {
        name: 'after b',
        after: 'b',
        initialize() {
          order.push('after b');
        }
      };
      let afterC = {
        name: 'after c',
        after: 'c',
        initialize() {
          order.push('after c');
        }
      };
      MyApplication.instanceInitializer(b);
      MyApplication.instanceInitializer(a);
      MyApplication.instanceInitializer(afterC);
      MyApplication.instanceInitializer(afterB);
      MyApplication.instanceInitializer(c);
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    }
    ["@test initializers set on Application subclasses should not be shared between apps"](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstApp = _application.default.extend();
      FirstApp.instanceInitializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondApp = _application.default.extend();
      SecondApp.instanceInitializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, FirstApp));
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({}, SecondApp));
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
    }
    ["@test initializers are concatenated"](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstApp = _application.default.extend();
      FirstApp.instanceInitializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondApp = FirstApp.extend();
      SecondApp.instanceInitializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, FirstApp));
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
      firstInitializerRunCount = 0;
      (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({}, SecondApp));
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    }
    ["@test initializers are per-app"](assert) {
      assert.expect(2);
      let FirstApp = _application.default.extend();
      FirstApp.instanceInitializer({
        name: 'abc',
        initialize() {}
      });
      expectAssertion(function () {
        FirstApp.instanceInitializer({
          name: 'abc',
          initialize() {}
        });
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, FirstApp));
      let SecondApp = _application.default.extend();
      SecondApp.instanceInitializer({
        name: 'abc',
        initialize() {}
      });
      (0, _internalTestHelpers.runTask)(() => this.createSecondApplication({}, SecondApp));
      assert.ok(true, 'Two apps can have initializers named the same.');
    }
    ["@test initializers are run before ready hook"](assert) {
      assert.expect(2);
      let MyApplication = _application.default.extend({
        ready() {
          assert.ok(true, 'ready is called');
          readyWasCalled = false;
        }
      });
      let readyWasCalled = false;
      MyApplication.instanceInitializer({
        name: 'initializer',
        initialize() {
          assert.ok(!readyWasCalled, 'ready is not yet called');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
    }
    ["@test initializers are executed in their own context"](assert) {
      assert.expect(1);
      let MyApplication = _application.default.extend();
      MyApplication.instanceInitializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize() {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
    }
    ["@test initializers get an instance on app reset"](assert) {
      assert.expect(2);
      let MyApplication = _application.default.extend();
      MyApplication.instanceInitializer({
        name: 'giveMeAnInstance',
        initialize(instance) {
          assert.ok(Boolean(instance), 'Initializer got an instance');
        }
      });
      (0, _internalTestHelpers.runTask)(() => this.createApplication({}, MyApplication));
      (0, _internalTestHelpers.runTask)(() => this.application.reset());
    }
  });
});
define("@ember/application/tests/lazy_load_test", ["@ember/runloop", "@ember/application", "internal-test-helpers"], function (_runloop, _application, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Lazy Loading', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      let keys = Object.keys(_application._loaded);
      for (let i = 0; i < keys.length; i++) {
        delete _application._loaded[keys[i]];
      }
    }
    ['@test if a load hook is registered, it is executed when runLoadHooks are exected'](assert) {
      let count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          count += object;
        });
      });
      (0, _runloop.run)(function () {
        (0, _application.runLoadHooks)('__test_hook__', 1);
      });
      assert.equal(count, 1, 'the object was passed into the load hook');
    }
    ['@test if runLoadHooks was already run, it executes newly added hooks immediately'](assert) {
      let count = 0;
      (0, _runloop.run)(() => {
        (0, _application.onLoad)('__test_hook__', object => count += object);
      });
      (0, _runloop.run)(() => (0, _application.runLoadHooks)('__test_hook__', 1));
      count = 0;
      (0, _runloop.run)(() => {
        (0, _application.onLoad)('__test_hook__', object => count += object);
      });
      assert.equal(count, 1, 'the original object was passed into the load hook');
    }
    ["@test hooks in EmberENV.EMBER_LOAD_HOOKS['hookName'] get executed"](assert) {
      // Note that the necessary code to perform this test is run before
      // the Ember lib is loaded in tests/index.html

      (0, _runloop.run)(() => {
        (0, _application.runLoadHooks)('__before_ember_test_hook__', 1);
      });
      assert.equal(window.EmberENV.__test_hook_count__, 1, 'the object was passed into the load hook');
    }
    ['@test load hooks trigger a custom event'](assert) {
      if (typeof window === 'object' && typeof window.dispatchEvent === 'function' && typeof CustomEvent === 'function') {
        let eventObject = 'super duper awesome events';
        window.addEventListener('__test_hook_for_events__', function (e) {
          assert.ok(true, 'custom event was fired');
          assert.equal(e.detail, eventObject, 'event details are provided properly');
        });
        (0, _runloop.run)(() => {
          (0, _application.runLoadHooks)('__test_hook_for_events__', eventObject);
        });
      } else {
        assert.expect(0);
      }
    }
  });
});
define("@ember/application/tests/logging_test", ["internal-test-helpers", "@ember/controller", "@ember/routing/route"], function (_internalTestHelpers, _controller, _route) {
  "use strict";

  class LoggingApplicationTestCase extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      this.logs = {};

      /* eslint-disable no-console */
      this._originalLogger = console.info;
      console.info = (_, _ref) => {
        let {
          fullName
        } = _ref;
        if (!Object.prototype.hasOwnProperty.call(this.logs, fullName)) {
          this.logs[fullName] = 0;
        }
        /* eslint-ensable no-console */
        this.logs[fullName]++;
      };
      this.router.map(function () {
        this.route('posts', {
          resetNamespace: true
        });
      });
    }
    teardown() {
      /* eslint-disable no-console */
      console.info = this._originalLogger;
      /* eslint-enable no-console */
      super.teardown();
    }
  }
  (0, _internalTestHelpers.moduleFor)('Application with LOG_ACTIVE_GENERATION=true', class extends LoggingApplicationTestCase {
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        LOG_ACTIVE_GENERATION: true
      });
    }
    ['@test log class generation if logging enabled'](assert) {
      if (!false /* DEBUG */) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }
      return this.visit('/posts').then(() => {
        assert.equal(Object.keys(this.logs).length, 4, 'expected logs');
      });
    }
    ['@test actively generated classes get logged'](assert) {
      if (!false /* DEBUG */) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }
      return this.visit('/posts').then(() => {
        assert.equal(this.logs['controller:application'], 1, 'expected: ApplicationController was generated');
        assert.equal(this.logs['controller:posts'], 1, 'expected: PostsController was generated');
        assert.equal(this.logs['route:application'], 1, 'expected: ApplicationRoute was generated');
        assert.equal(this.logs['route:posts'], 1, 'expected: PostsRoute was generated');
      });
    }
    ['@test predefined classes do not get logged'](assert) {
      this.add('controller:application', _controller.default.extend());
      this.add('controller:posts', _controller.default.extend());
      this.add('route:application', _route.default.extend());
      this.add('route:posts', _route.default.extend());
      return this.visit('/posts').then(() => {
        assert.ok(!this.logs['controller:application'], 'did not expect: ApplicationController was generated');
        assert.ok(!this.logs['controller:posts'], 'did not expect: PostsController was generated');
        assert.ok(!this.logs['route:application'], 'did not expect: ApplicationRoute was generated');
        assert.ok(!this.logs['route:posts'], 'did not expect: PostsRoute was generated');
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application when LOG_ACTIVE_GENERATION=false', class extends LoggingApplicationTestCase {
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        LOG_ACTIVE_GENERATION: false
      });
    }
    ["@test do NOT log class generation if logging disabled"](assert) {
      return this.visit('/posts').then(() => {
        assert.equal(Object.keys(this.logs).length, 0, 'expected logs');
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application with LOG_VIEW_LOOKUPS=true', class extends LoggingApplicationTestCase {
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        LOG_VIEW_LOOKUPS: true
      });
    }
    ["@test log when template and view are missing when flag is active"](assert) {
      if (!false /* DEBUG */) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }
      this.addTemplate('application', '{{outlet}}');
      return this.visit('/').then(() => this.visit('/posts')).then(() => {
        assert.equal(this.logs['template:application'], undefined, 'expected: Should not log template:application since it exists.');
        assert.equal(this.logs['template:index'], 1, 'expected: Could not find "index" template or view.');
        assert.equal(this.logs['template:posts'], 1, 'expected: Could not find "posts" template or view.');
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application with LOG_VIEW_LOOKUPS=false', class extends LoggingApplicationTestCase {
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        LOG_VIEW_LOOKUPS: false
      });
    }
    ["@test do not log when template and view are missing when flag is not true"](assert) {
      return this.visit('/posts').then(() => {
        assert.equal(Object.keys(this.logs).length, 0, 'expected no logs');
      });
    }
    ["@test do not log which views are used with templates when flag is not true"](assert) {
      return this.visit('/posts').then(() => {
        assert.equal(Object.keys(this.logs).length, 0, 'expected no logs');
      });
    }
  });
});
define("@ember/application/tests/readiness_test", ["internal-test-helpers", "@ember/runloop", "@ember/application"], function (_internalTestHelpers, _runloop, _application) {
  "use strict";

  let application, Application, _document, callbacks;
  let readyWasCalled = 0;
  const dispatchEvent = eventName => {
    callbacks[eventName].forEach(callback => callback());
  };
  const removeEventListener = (eventName, callbackToRemove) => {
    callbacks[eventName] = callbacks[eventName].filter(callback => callback !== callbackToRemove);
  };
  const addEventListener = (eventName, callback) => {
    callbacks[eventName] ? callbacks[eventName].push(callback) : callbacks[eventName] = [callback];
  };
  (0, _internalTestHelpers.moduleFor)('Application readiness', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      callbacks = [];
      _document = {
        removeEventListener,
        addEventListener
      };
      Application = _application.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        _document,
        ready() {
          this._super();
          readyWasCalled++;
        }
      });
    }
    teardown() {
      if (application) {
        (0, _runloop.run)(() => application.destroy());
        Application = application = _document = callbacks = undefined;
        readyWasCalled = 0;
      }
    }
    ["@test Application's ready event is called right away if DOM is already ready"](assert) {
      _document.readyState = 'interactive';
      (0, _runloop.run)(() => {
        application = Application.create({
          router: false
        });
        assert.equal(readyWasCalled, 0, 'ready is not called until later');
      });
      assert.equal(readyWasCalled, 1, 'ready was called');
      application.domReady();
      assert.equal(callbacks['DOMContentLoaded'], undefined);
      assert.equal(readyWasCalled, 1, "application's ready was not called again");
    }
    ["@test Application's ready event is called after the document becomes ready"](assert) {
      _document.readyState = 'loading';
      (0, _runloop.run)(() => {
        application = Application.create({
          router: false
        });
        assert.equal(callbacks['DOMContentLoaded'].length, 1);
      });
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      dispatchEvent('DOMContentLoaded');
      assert.equal(callbacks['DOMContentLoaded'].length, 0);
      assert.equal(readyWasCalled, 1, 'ready was called now that DOM is ready');
    }
    ["@test Application's ready event can be deferred by other components"](assert) {
      _document.readyState = 'loading';
      (0, _runloop.run)(() => {
        application = Application.create({
          router: false
        });
        application.deferReadiness();
        assert.equal(readyWasCalled, 0, "ready wasn't called yet");
        assert.equal(callbacks['DOMContentLoaded'].length, 1);
      });
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      application.domReady();
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      (0, _runloop.run)(() => {
        application.advanceReadiness();
        assert.equal(readyWasCalled, 0);
      });
      assert.equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');
      dispatchEvent('DOMContentLoaded');
      assert.equal(callbacks['DOMContentLoaded'].length, 0);
      expectAssertion(() => {
        application.deferReadiness();
      });
    }
  });
});
define("@ember/application/tests/reset_test", ["@ember/runloop", "@ember/controller", "@ember/routing/router", "@ember/-internals/views", "internal-test-helpers"], function (_runloop, _controller, _router, _views, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application - resetting', class extends _internalTestHelpers.AutobootApplicationTestCase {
    ['@test Brings its own run-loop if not provided'](assert) {
      assert.expect(0);
      (0, _runloop.run)(() => this.createApplication());
      this.application.reset();
    }
    ['@test Does not bring its own run loop if one is already provided'](assert) {
      assert.expect(3);
      let didBecomeReady = false;
      (0, _runloop.run)(() => this.createApplication());
      (0, _runloop.run)(() => {
        this.application.ready = () => {
          didBecomeReady = true;
        };
        this.application.reset();
        this.application.deferReadiness();
        assert.ok(!didBecomeReady, 'app is not ready');
      });
      assert.ok(!didBecomeReady, 'app is not ready');
      (0, _runloop.run)(this.application, 'advanceReadiness');
      assert.ok(didBecomeReady, 'app is ready');
    }
    ['@test When an application is reset, new instances of controllers are generated'](assert) {
      (0, _runloop.run)(() => {
        this.createApplication();
        this.add('controller:academic', _controller.default.extend());
      });
      let firstController = this.applicationInstance.lookup('controller:academic');
      let secondController = this.applicationInstance.lookup('controller:academic');
      this.application.reset();
      let thirdController = this.applicationInstance.lookup('controller:academic');
      assert.strictEqual(firstController, secondController, 'controllers looked up in succession should be the same instance');
      assert.ok(firstController.isDestroying, 'controllers are destroyed when their application is reset');
      assert.notStrictEqual(firstController, thirdController, 'controllers looked up after the application is reset should not be the same instance');
    }
    ['@test When an application is reset, the eventDispatcher is destroyed and recreated'](assert) {
      let eventDispatcherWasSetup = 0;
      let eventDispatcherWasDestroyed = 0;
      class FakeEventDispatcher extends _views.EventDispatcher {
        setup() {
          eventDispatcherWasSetup++;
        }
        destroy() {
          if (this.isDestroying) {
            return;
          }
          super.destroy();
          eventDispatcherWasDestroyed++;
        }
      }
      (0, _runloop.run)(() => {
        this.createApplication();
        this.add('event_dispatcher:main', FakeEventDispatcher);
        assert.equal(eventDispatcherWasSetup, 0, 'not setup yet');
        assert.equal(eventDispatcherWasDestroyed, 0, 'not destroyed yet');
      });
      assert.equal(eventDispatcherWasSetup, 1, 'setup');
      assert.equal(eventDispatcherWasDestroyed, 0, 'still not destroyed');
      this.application.reset();
      assert.equal(eventDispatcherWasDestroyed, 1, 'destroyed');
      assert.equal(eventDispatcherWasSetup, 2, 'setup called after reset');
    }
    ['@test When an application is reset, the router URL is reset to `/`'](assert) {
      (0, _runloop.run)(() => {
        this.createApplication();
        this.add('router:main', _router.default.extend({
          location: 'none'
        }));
        this.router.map(function () {
          this.route('one');
          this.route('two');
        });
      });
      let initialRouter, initialApplicationController;
      return this.visit('/one').then(() => {
        initialApplicationController = this.applicationInstance.lookup('controller:application');
        initialRouter = this.applicationInstance.lookup('router:main');
        let location = initialRouter.get('location');
        assert.equal(location.getURL(), '/one');
        assert.equal(initialRouter.currentPath, 'one');
        this.application.reset();
        return this.application._bootPromise;
      }).then(() => {
        let applicationController = this.applicationInstance.lookup('controller:application');
        assert.strictEqual(applicationController, undefined, 'application controller no longer exists');
        return this.visit('/one');
      }).then(() => {
        let applicationController = this.applicationInstance.lookup('controller:application');
        let router = this.applicationInstance.lookup('router:main');
        let location = router.get('location');
        assert.notEqual(initialRouter, router, 'a different router instance was created');
        assert.notEqual(initialApplicationController, applicationController, 'a different application controller is created');
        assert.equal(location.getURL(), '/one');
        assert.equal(router.currentPath, 'one');
      });
    }
    ['@test When an application with advance/deferReadiness is reset, the app does correctly become ready after reset'](assert) {
      let readyCallCount = 0;
      (0, _runloop.run)(() => {
        this.createApplication({
          ready() {
            readyCallCount++;
          }
        });
        this.application.deferReadiness();
        assert.equal(readyCallCount, 0, 'ready has not yet been called');
      });
      (0, _runloop.run)(this.application, 'advanceReadiness');
      assert.equal(readyCallCount, 1, 'ready was called once');
      this.application.reset();
      assert.equal(readyCallCount, 2, 'ready was called twice');
    }
  });
});
define("@ember/application/tests/visit_test", ["internal-test-helpers", "@ember/service", "@ember/object", "@ember/-internals/runtime", "@ember/runloop", "@ember/application", "@ember/application/instance", "@ember/engine", "@ember/routing/route", "@ember/-internals/glimmer", "ember-template-compiler", "@ember/-internals/environment"], function (_internalTestHelpers, _service, _object, _runtime, _runloop, _application, _instance, _engine, _route, _glimmer, _emberTemplateCompiler, _environment) {
  "use strict";

  function expectAsyncError() {
    _runtime.RSVP.off('error');
  }
  (0, _internalTestHelpers.moduleFor)('Application - visit()', class extends _internalTestHelpers.ApplicationTestCase {
    teardown() {
      _runtime.RSVP.on('error', _runtime.onerrorDefault);
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      super.teardown();
    }
    createApplication(options) {
      return super.createApplication(options, _application.default.extend());
    }
    assertEmptyFixture(message) {
      this.assert.strictEqual(document.getElementById('qunit-fixture').children.length, 0, "there are no elements in the fixture element " + (message ? message : ''));
    }
    ["@test does not add serialize-mode markers by default"](assert) {
      let templateContent = '<div class="foo">Hi, Mom!</div>';
      this.addTemplate('index', templateContent);
      let rootElement = document.createElement('div');
      let bootOptions = {
        isBrowser: false,
        rootElement
      };
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      return this.visit('/', bootOptions).then(() => {
        assert.equal(rootElement.innerHTML, templateContent, 'without serialize flag renders as expected');
      });
    }
    ["@test _renderMode: rehydration"](assert) {
      assert.expect(2);
      let indexTemplate = '<div class="foo">Hi, Mom!</div>';
      this.addTemplate('index', indexTemplate);
      let rootElement = document.createElement('div');
      let bootOptions = {
        isBrowser: false,
        rootElement,
        _renderMode: 'serialize'
      };
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      return this.visit('/', bootOptions).then(instance => {
        assert.ok((0, _glimmer.isSerializationFirstNode)(instance.rootElement.firstChild), 'glimmer-vm comment node was not found');
      }).then(() => {
        return (0, _internalTestHelpers.runTask)(() => {
          this.applicationInstance.destroy();
          this.applicationInstance = null;
        });
      }).then(() => {
        bootOptions = {
          isBrowser: false,
          rootElement,
          _renderMode: 'rehydrate'
        };
        this.application.visit('/', bootOptions).then(instance => {
          assert.equal(instance.rootElement.innerHTML, indexTemplate, 'was not properly rehydrated');
        });
      });
    }

    // This tests whether the application is "autobooted" by registering an
    // instance initializer and asserting it never gets run. Since this is
    // inherently testing that async behavior *doesn't* happen, we set a
    // 500ms timeout to verify that when autoboot is set to false, the
    // instance initializer that would normally get called on DOM ready
    // does not fire.
    ["@test Applications with autoboot set to false do not autoboot"](assert) {
      function delay(time) {
        return new _runtime.RSVP.Promise(resolve => (0, _runloop.later)(resolve, time));
      }
      let appBooted = 0;
      let instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize() {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize() {
          instanceBooted++;
        }
      });
      assert.ok(!this.applicationInstance, 'precond - no instance');
      assert.ok(appBooted === 0, 'precond - not booted');
      assert.ok(instanceBooted === 0, 'precond - not booted');

      // Continue after 500ms
      return delay(500).then(() => {
        assert.ok(appBooted === 0, '500ms elapsed without app being booted');
        assert.ok(instanceBooted === 0, '500ms elapsed without instances being booted');
        return (0, _internalTestHelpers.runTask)(() => this.application.boot());
      }).then(() => {
        assert.ok(appBooted === 1, 'app should boot when manually calling `app.boot()`');
        assert.ok(instanceBooted === 0, 'no instances should be booted automatically when manually calling `app.boot()');
      });
    }
    ["@test calling visit() on an app without first calling boot() should boot the app"](assert) {
      let appBooted = 0;
      let instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize() {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize() {
          instanceBooted++;
        }
      });
      return this.visit('/').then(() => {
        assert.ok(appBooted === 1, 'the app should be booted`');
        assert.ok(instanceBooted === 1, 'an instances should be booted');
      });
    }
    ["@test calling visit() on an already booted app should not boot it again"](assert) {
      let appBooted = 0;
      let instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize() {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize() {
          instanceBooted++;
        }
      });
      return (0, _internalTestHelpers.runTask)(() => this.application.boot()).then(() => {
        assert.ok(appBooted === 1, 'the app should be booted');
        assert.ok(instanceBooted === 0, 'no instances should be booted');
        return this.visit('/');
      }).then(() => {
        assert.ok(appBooted === 1, 'the app should not be booted again');
        assert.ok(instanceBooted === 1, 'an instance should be booted');

        /*
         * Destroy the instance.
         */
        return (0, _internalTestHelpers.runTask)(() => {
          this.applicationInstance.destroy();
          this.applicationInstance = null;
        });
      }).then(() => {
        /*
         * Visit on the application a second time. The application should remain
         * booted, but a new instance will be created.
         */
        return this.application.visit('/').then(instance => {
          this.applicationInstance = instance;
        });
      }).then(() => {
        assert.ok(appBooted === 1, 'the app should not be booted again');
        assert.ok(instanceBooted === 2, 'another instance should be booted');
      });
    }
    ["@test visit() rejects on application boot failure"](assert) {
      this.application.initializer({
        name: 'error',
        initialize() {
          throw new Error('boot failure');
        }
      });
      expectAsyncError();
      return this.visit('/').then(() => {
        assert.ok(false, 'It should not resolve the promise');
      }, error => {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'boot failure');
      });
    }
    ["@test visit() rejects on instance boot failure"](assert) {
      this.application.instanceInitializer({
        name: 'error',
        initialize() {
          throw new Error('boot failure');
        }
      });
      expectAsyncError();
      return this.visit('/').then(() => {
        assert.ok(false, 'It should not resolve the promise');
      }, error => {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'boot failure');
      });
    }
    ["@test visit() follows redirects"](assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b', {
          path: '/b/:b'
        });
        this.route('c', {
          path: '/c/:c'
        });
      });
      this.add('route:a', _route.default.extend({
        router: (0, _service.service)(),
        afterModel() {
          this.router.replaceWith('b', 'zomg');
        }
      }));
      this.add('route:b', _route.default.extend({
        router: (0, _service.service)(),
        afterModel(params) {
          this.router.transitionTo('c', params.b);
        }
      }));

      /*
       * First call to `visit` is `this.application.visit` and returns the
       * applicationInstance.
       */
      return this.visit('/a').then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/c/zomg', 'It should follow all redirects');
      });
    }
    ["@test visit() rejects if an error occurred during a transition"](assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b', {
          path: '/b/:b'
        });
        this.route('c', {
          path: '/c/:c'
        });
      });
      this.add('route:a', _route.default.extend({
        router: (0, _service.service)(),
        afterModel() {
          this.router.replaceWith('b', 'zomg');
        }
      }));
      this.add('route:b', _route.default.extend({
        router: (0, _service.service)(),
        afterModel(params) {
          this.router.transitionTo('c', params.b);
        }
      }));
      this.add('route:c', _route.default.extend({
        afterModel() {
          throw new Error('transition failure');
        }
      }));
      expectAsyncError();
      return this.visit('/a').then(() => {
        assert.ok(false, 'It should not resolve the promise');
      }, error => {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'transition failure');
      });
    }
    ["@test visit() chain"](assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b');
        this.route('c');
      });
      return this.visit('/').then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/');
        return instance.visit('/a');
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/a');
        return instance.visit('/b');
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/b');
        return instance.visit('/c');
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/c');
      });
    }
    ["@test visit() returns a promise that resolves when the view has rendered"](assert) {
      this.addTemplate('application', "<h1>Hello world</h1>");
      this.assertEmptyFixture();
      return this.visit('/').then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(this.element.textContent, 'Hello world', 'the application was rendered once the promise resolves');
      });
    }
    ["@test visit() returns a promise that resolves without rendering when shouldRender is set to false"](assert) {
      assert.expect(3);
      this.addTemplate('application', '<h1>Hello world</h1>');
      this.assertEmptyFixture();
      return this.visit('/', {
        shouldRender: false
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        this.assertEmptyFixture('after visit');
      });
    }
    ["@test visit() renders a template when shouldRender is set to true"](assert) {
      assert.expect(3);
      this.addTemplate('application', '<h1>Hello world</h1>');
      this.assertEmptyFixture();
      return this.visit('/', {
        shouldRender: true
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.strictEqual(document.querySelector('#qunit-fixture').children.length, 1, 'there is 1 element in the fixture element after visit');
      });
    }
    ["@test visit() returns a promise that resolves without rendering when shouldRender is set to false with Engines"](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.mount('blog');
      });
      this.addTemplate('application', '<h1>Hello world</h1>');

      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      this.add('engine:blog', BlogEngine);

      // Register engine route map
      let BlogMap = function () {};
      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: false
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        this.assertEmptyFixture('after visit');
      });
    }
    ["@test visit() does not setup the event_dispatcher:main if isInteractive is false (with Engines) GH#15615"](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.mount('blog');
      });
      this.addTemplate('application', '<h1>Hello world</h1>{{outlet}}');
      this.add('event_dispatcher:main', {
        create() {
          throw new Error('should not happen!');
        }
      });

      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          this._super.apply(this, args);
          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{cache-money}}'));
          this.register('template:components/cache-money', (0, _emberTemplateCompiler.compile)("\n          <p>Dis cache money</p>\n        "));
          this.register('component:cache-money', _glimmer.Component.extend({}));
        }
      });
      this.add('engine:blog', BlogEngine);

      // Register engine route map
      let BlogMap = function () {};
      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        isInteractive: false
      }).then(instance => {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.strictEqual(this.element.querySelector('p').textContent, 'Dis cache money', 'Engine component is resolved');
      });
    }
    ["@test visit() on engine resolves engine component"](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.mount('blog');
      });

      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          this._super.apply(this, args);
          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{cache-money}}'));
          this.register('template:components/cache-money', (0, _emberTemplateCompiler.compile)("\n          <p>Dis cache money</p>\n        "));
          this.register('component:cache-money', _glimmer.Component.extend({}));
        }
      });
      this.add('engine:blog', BlogEngine);

      // Register engine route map
      let BlogMap = function () {};
      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: true
      }).then(() => {
        assert.strictEqual(this.element.querySelector('p').textContent, 'Dis cache money', 'Engine component is resolved');
      });
    }
    ["@test visit() on engine resolves engine helper"](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.mount('blog');
      });

      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver,
        init() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          this._super.apply(this, args);
          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{swag}}'));
          this.register('helper:swag', (0, _glimmer.helper)(function () {
            return 'turnt up';
          }));
        }
      });
      this.add('engine:blog', BlogEngine);

      // Register engine route map
      let BlogMap = function () {};
      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: true
      }).then(() => {
        assert.strictEqual(this.element.textContent, 'turnt up', 'Engine component is resolved');
      });
    }
    ["@test Ember Islands-style setup"](assert) {
      let xFooInitCalled = false;
      let xFooDidInsertElementCalled = false;
      let xBarInitCalled = false;
      let xBarDidInsertElementCalled = false;
      this.router.map(function () {
        this.route('show', {
          path: '/:component_name'
        });
      });
      this.add('route:show', _route.default.extend({
        queryParams: {
          data: {
            refreshModel: true
          }
        },
        model(params) {
          return {
            componentName: params.component_name,
            componentData: params.data ? JSON.parse(params.data) : undefined
          };
        }
      }));
      let Counter = _object.default.extend({
        value: 0,
        increment() {
          this.incrementProperty('value');
        }
      });
      this.add('service:isolatedCounter', Counter);
      this.add('service:sharedCounter', Counter.create());
      this.application.registerOptions('service:sharedCounter', {
        instantiate: false
      });
      this.addTemplate('show', '{{component @model.componentName model=@model.componentData}}');
      this.addTemplate('components/x-foo', "\n        <h1>X-Foo</h1>\n        <p>Hello {{@model.name}}, I have been clicked {{this.isolatedCounter.value}} times ({{this.sharedCounter.value}} times combined)!</p>\n        ");
      this.add('component:x-foo', _glimmer.Component.extend({
        tagName: 'x-foo',
        isolatedCounter: (0, _service.service)(),
        sharedCounter: (0, _service.service)(),
        init() {
          this._super();
          xFooInitCalled = true;
        },
        didInsertElement() {
          xFooDidInsertElementCalled = true;
        },
        click() {
          this.get('isolatedCounter').increment();
          this.get('sharedCounter').increment();
        }
      }));
      this.addTemplate('components/x-bar', "\n        <h1>X-Bar</h1>\n        <button {{action \"incrementCounter\"}}>Join {{this.counter.value}} others in clicking me!</button>\n        ");
      this.add('component:x-bar', _glimmer.Component.extend({
        counter: (0, _service.service)('sharedCounter'),
        actions: {
          incrementCounter() {
            this.get('counter').increment();
          }
        },
        init() {
          this._super();
          xBarInitCalled = true;
        },
        didInsertElement() {
          xBarDidInsertElementCalled = true;
        }
      }));
      let fixtureElement = document.querySelector('#qunit-fixture');
      let foo = document.createElement('div');
      let bar = document.createElement('div');
      fixtureElement.appendChild(foo);
      fixtureElement.appendChild(bar);
      let data = encodeURIComponent(JSON.stringify({
        name: 'Godfrey'
      }));
      let instances = [];
      return _runtime.RSVP.all([(0, _internalTestHelpers.runTask)(() => {
        return this.application.visit("/x-foo?data=" + data, {
          rootElement: foo
        });
      }), (0, _internalTestHelpers.runTask)(() => {
        return this.application.visit('/x-bar', {
          rootElement: bar
        });
      })]).then(_instances => {
        instances = _instances;
        assert.ok(xFooInitCalled);
        assert.ok(xFooDidInsertElementCalled);
        assert.ok(xBarInitCalled);
        assert.ok(xBarDidInsertElementCalled);
        assert.equal(foo.querySelector('h1').textContent, 'X-Foo');
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 0 times (0 times combined)!');
        assert.ok(foo.textContent.indexOf('X-Bar') === -1);
        assert.equal(bar.querySelector('h1').textContent, 'X-Bar');
        assert.equal(bar.querySelector('button').textContent, 'Join 0 others in clicking me!');
        assert.ok(bar.textContent.indexOf('X-Foo') === -1);
        (0, _internalTestHelpers.runTask)(() => {
          this.click(foo.querySelector('x-foo'));
        });
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 1 times (1 times combined)!');
        assert.equal(bar.querySelector('button').textContent, 'Join 1 others in clicking me!');
        (0, _internalTestHelpers.runTask)(() => {
          this.click(bar.querySelector('button'));
          this.click(bar.querySelector('button'));
        });
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 1 times (3 times combined)!');
        assert.equal(bar.querySelector('button').textContent, 'Join 3 others in clicking me!');
      }).finally(() => {
        (0, _internalTestHelpers.runTask)(() => {
          instances.forEach(instance => {
            instance.destroy();
          });
        });
      });
    }
  });
});
define("@ember/array/tests/is-ember-array-test", ["@ember/array/-internals", "internal-test-helpers"], function (_internals, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils Trackable Object', class extends _internalTestHelpers.AbstractTestCase {
    ['@test classes'](assert) {
      class Test {
        constructor() {
          (0, _internals.setEmberArray)(this);
        }
      }
      let instance = new Test();
      assert.equal((0, _internals.isEmberArray)(instance), true);
    }
  });
});
define("@ember/array/tests/make_array_test", ["@ember/array", "internal-test-helpers"], function (_array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.makeArray', class extends _internalTestHelpers.AbstractTestCase {
    ['@test undefined'](assert) {
      assert.deepEqual((0, _array.makeArray)(), []);
      assert.deepEqual((0, _array.makeArray)(undefined), []);
    }
    ['@test null'](assert) {
      assert.deepEqual((0, _array.makeArray)(null), []);
    }
    ['@test string'](assert) {
      assert.deepEqual((0, _array.makeArray)('lindsay'), ['lindsay']);
    }
    ['@test number'](assert) {
      assert.deepEqual((0, _array.makeArray)(0), [0]);
      assert.deepEqual((0, _array.makeArray)(1), [1]);
    }
    ['@test array'](assert) {
      assert.deepEqual((0, _array.makeArray)([1, 2, 42]), [1, 2, 42]);
    }
    ['@test true'](assert) {
      assert.deepEqual((0, _array.makeArray)(true), [true]);
    }
    ['@test false'](assert) {
      assert.deepEqual((0, _array.makeArray)(false), [false]);
    }
    ['@test object'](assert) {
      assert.deepEqual((0, _array.makeArray)({}), [{}]);
    }
  });
});
define("@ember/controller/tests/controller_test", ["@ember/controller", "@ember/service", "@ember/object", "@ember/object/mixin", "@ember/-internals/owner", "internal-test-helpers"], function (_controller, _service, _object, _mixin, _owner, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  (0, _internalTestHelpers.moduleFor)('Controller model', class extends _internalTestHelpers.ApplicationTestCase {
    async '@test model is tracked'() {
      var _class;
      this.add('controller:index', (_class = class extends _controller.default {
        constructor() {
          super(...arguments);
          this.model = 0;
        }
        get derived() {
          return this.model + 1;
        }
        update() {
          this.model++;
        }
      }, _applyDecoratedDescriptor(_class.prototype, "update", [_object.action], Object.getOwnPropertyDescriptor(_class.prototype, "update"), _class.prototype), _class));
      this.addTemplate('index', '<button {{on "click" this.update}}>{{this.derived}}</button>');
      await this.visit('/');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      this.assertText('2');
    }
    async '@test model can be observed with sync observers'(assert) {
      var _class2;
      let observerRunCount = 0;
      this.add('controller:index', (_class2 = class extends _controller.default {
        constructor() {
          super(...arguments);
          this.model = 0;
          this.addObserver('model', this, () => observerRunCount++, true);
        }
        update() {
          this.model++;
        }
      }, _applyDecoratedDescriptor(_class2.prototype, "update", [_object.action], Object.getOwnPropertyDescriptor(_class2.prototype, "update"), _class2.prototype), _class2));
      this.addTemplate('index', '<button {{on "click" this.update}}>{{this.model}}</button>');
      await this.visit('/');
      (0, _internalTestHelpers.runTask)(() => this.$('button').click());
      assert.equal(observerRunCount, 1, 'observer ran exactly once');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Controller event handling', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Action can be handled by a function on actions object'](assert) {
      assert.expect(1);
      let TestController = _controller.default.extend({
        actions: {
          poke() {
            assert.ok(true, 'poked');
          }
        }
      });
      let controller = TestController.create();
      controller.send('poke');
    }
    ['@test A handled action can be bubbled to the target for continued processing'](assert) {
      assert.expect(2);
      let owner = (0, _internalTestHelpers.buildOwner)();
      let TestController = _controller.default.extend({
        actions: {
          poke() {
            assert.ok(true, 'poked 1');
            return true;
          }
        }
      });
      owner.register('controller:index', TestController);
      let controller = TestController.create({
        target: _controller.default.extend({
          actions: {
            poke() {
              assert.ok(true, 'poked 2');
            }
          }
        }).create()
      });
      (0, _owner.setOwner)(controller, owner);
      controller.send('poke');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ["@test Action can be handled by a superclass' actions object"](assert) {
      assert.expect(4);
      let SuperController = _controller.default.extend({
        actions: {
          foo() {
            assert.ok(true, 'foo');
          },
          bar(msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });
      let BarControllerMixin = _mixin.default.create({
        actions: {
          bar(msg) {
            assert.equal(msg, 'HELLO');
            this._super(msg);
          }
        }
      });
      let IndexController = SuperController.extend(BarControllerMixin, {
        actions: {
          baz() {
            assert.ok(true, 'baz');
          }
        }
      });
      let controller = IndexController.create({});
      controller.send('foo');
      controller.send('bar', 'HELLO');
      controller.send('baz');
    }
    ['@test .send asserts if called on a destroyed controller']() {
      let owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:application', _controller.default.extend({
        toString() {
          return 'controller:rip-alley';
        }
      }));
      let controller = owner.lookup('controller:application');
      (0, _internalTestHelpers.runDestroy)(owner);
      expectAssertion(() => {
        controller.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed object 'controller:rip-alley'.");
    }
  });
  (0, _internalTestHelpers.moduleFor)('Controller deprecations -> Controller Content -> Model Alias', class extends _internalTestHelpers.AbstractTestCase {
    ['@test `content` is not moved to `model` when `model` is unset'](assert) {
      assert.expect(2);
      let controller;
      ignoreDeprecation(function () {
        controller = _controller.default.extend({
          content: 'foo-bar'
        }).create();
      });
      assert.notEqual(controller.get('model'), 'foo-bar', 'model is set properly');
      assert.equal(controller.get('content'), 'foo-bar', 'content is not set properly');
    }
    ['@test specifying `content` (without `model` specified) does not result in deprecation'](assert) {
      assert.expect(2);
      expectNoDeprecation();
      let controller = _controller.default.extend({
        content: 'foo-bar'
      }).create();
      assert.equal((0, _object.get)(controller, 'content'), 'foo-bar');
    }
    ['@test specifying `content` (with `model` specified) does not result in deprecation'](assert) {
      assert.expect(3);
      expectNoDeprecation();
      let controller = _controller.default.create({
        content: 'foo-bar',
        model: 'blammo'
      });
      assert.equal((0, _object.get)(controller, 'content'), 'foo-bar');
      assert.equal((0, _object.get)(controller, 'model'), 'blammo');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Controller deprecations -> Controller injected properties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test defining a controller on a non-controller should fail assertion']() {
      let owner = (0, _internalTestHelpers.buildOwner)();
      expectAssertion(function () {
        let AnObject = _object.default.extend({
          foo: (0, _controller.inject)('bar')
        });
        owner.register('controller:bar', _object.default.extend());
        owner.register('foo:main', AnObject);
        owner.lookup('foo:main');
      }, /Defining `foo` as an injected controller property on a non-controller \(`foo:main`\) is not allowed/);
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test controllers can be injected into controllers'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:post', _controller.default.extend({
        postsController: (0, _controller.inject)('posts')
      }));
      owner.register('controller:posts', _controller.default.extend());
      let postController = owner.lookup('controller:post');
      let postsController = owner.lookup('controller:posts');
      assert.equal(postsController, postController.get('postsController'), 'controller.posts is injected');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test services can be injected into controllers'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:application', _controller.default.extend({
        authService: (0, _service.service)('auth')
      }));
      owner.register('service:auth', _service.default.extend());
      let appController = owner.lookup('controller:application');
      let authService = owner.lookup('service:auth');
      assert.equal(authService, appController.get('authService'), 'service.auth is injected');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Controller Injections', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works with native decorators'](assert) {
      var _dec, _class3, _descriptor;
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainController extends _controller.default {}
      let IndexController = (_dec = (0, _controller.inject)('main'), (_class3 = class IndexController extends _controller.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "main", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class3.prototype, "main", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class3));
      owner.register('controller:main', MainController);
      owner.register('controller:index', IndexController);
      let index = owner.lookup('controller:index');
      assert.ok(index.main instanceof _controller.default, 'controller injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test uses the decorated property key if not provided'](assert) {
      var _class5, _descriptor2;
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainController extends _controller.default {}
      let IndexController = (_class5 = class IndexController extends _controller.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "main", _descriptor2, this);
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class5.prototype, "main", [_controller.inject], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class5);
      owner.register('controller:main', MainController);
      owner.register('controller:index', IndexController);
      let index = owner.lookup('controller:index');
      assert.ok(index.main instanceof _controller.default, 'controller injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
});
define("@ember/engine/tests/engine_initializers_test", ["@ember/runloop", "@ember/engine", "internal-test-helpers"], function (_runloop, _engine, _internalTestHelpers) {
  "use strict";

  let MyEngine, myEngine, myEngineInstance;
  (0, _internalTestHelpers.moduleFor)('Engine initializers', class extends _internalTestHelpers.AbstractTestCase {
    teardown() {
      (0, _runloop.run)(() => {
        if (myEngineInstance) {
          myEngineInstance.destroy();
          myEngineInstance = null;
        }
        if (myEngine) {
          myEngine.destroy();
          myEngine = null;
        }
      });
    }
    ["@test initializers require proper 'name' and 'initialize' properties"]() {
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      expectAssertion(() => {
        (0, _runloop.run)(() => {
          MyEngine.initializer({
            name: 'initializer'
          });
        });
      });
      expectAssertion(() => {
        (0, _runloop.run)(() => {
          MyEngine.initializer({
            initialize() {}
          });
        });
      });
    }
    ['@test initializers are passed an Engine'](assert) {
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.initializer({
        name: 'initializer',
        initialize(engine) {
          assert.ok(engine instanceof _engine.default, 'initialize is passed an Engine');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
    }
    ['@test initializers can be registered in a specified order'](assert) {
      let order = [];
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.initializer({
        name: 'fourth',
        after: 'third',
        initialize() {
          order.push('fourth');
        }
      });
      MyEngine.initializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize() {
          order.push('second');
        }
      });
      MyEngine.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyEngine.initializer({
        name: 'first',
        before: 'second',
        initialize() {
          order.push('first');
        }
      });
      MyEngine.initializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyEngine.initializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    }
    ['@test initializers can be registered in a specified order as an array'](assert) {
      let order = [];
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.initializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyEngine.initializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize() {
          order.push('second');
        }
      });
      MyEngine.initializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize() {
          order.push('fourth');
        }
      });
      MyEngine.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyEngine.initializer({
        name: 'first',
        before: ['second'],
        initialize() {
          order.push('first');
        }
      });
      MyEngine.initializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    }
    ['@test initializers can have multiple dependencies'](assert) {
      let order = [];
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      let a = {
        name: 'a',
        before: 'b',
        initialize() {
          order.push('a');
        }
      };
      let b = {
        name: 'b',
        initialize() {
          order.push('b');
        }
      };
      let c = {
        name: 'c',
        after: 'b',
        initialize() {
          order.push('c');
        }
      };
      let afterB = {
        name: 'after b',
        after: 'b',
        initialize() {
          order.push('after b');
        }
      };
      let afterC = {
        name: 'after c',
        after: 'c',
        initialize() {
          order.push('after c');
        }
      };
      MyEngine.initializer(b);
      MyEngine.initializer(a);
      MyEngine.initializer(afterC);
      MyEngine.initializer(afterB);
      MyEngine.initializer(c);
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    }
    ['@test initializers set on Engine subclasses are not shared between engines'](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      FirstEngine.initializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      SecondEngine.initializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      let firstEngine = FirstEngine.create();
      let firstEngineInstance = firstEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      let secondEngine = SecondEngine.create();
      let secondEngineInstance = secondEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
      (0, _runloop.run)(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();
        firstEngine.destroy();
        secondEngine.destroy();
      });
    }
    ['@test initializers are concatenated'](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      FirstEngine.initializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondEngine = FirstEngine.extend();
      SecondEngine.initializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      let firstEngine = FirstEngine.create();
      let firstEngineInstance = firstEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
      firstInitializerRunCount = 0;
      let secondEngine = SecondEngine.create();
      let secondEngineInstance = secondEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
      (0, _runloop.run)(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();
        firstEngine.destroy();
        secondEngine.destroy();
      });
    }
    ['@test initializers are per-engine'](assert) {
      assert.expect(2);
      let FirstEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      FirstEngine.initializer({
        name: 'abc',
        initialize() {}
      });
      expectAssertion(function () {
        FirstEngine.initializer({
          name: 'abc',
          initialize() {}
        });
      });
      let SecondEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      SecondEngine.instanceInitializer({
        name: 'abc',
        initialize() {}
      });
      assert.ok(true, 'Two engines can have initializers named the same.');
    }
    ['@test initializers are executed in their own context'](assert) {
      assert.expect(1);
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.initializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize() {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
    }
  });
});
define("@ember/engine/tests/engine_instance_initializers_test", ["@ember/runloop", "@ember/engine", "@ember/engine/instance", "internal-test-helpers"], function (_runloop, _engine, _instance, _internalTestHelpers) {
  "use strict";

  let MyEngine, myEngine, myEngineInstance;
  function buildEngineInstance(EngineClass) {
    let engineInstance = EngineClass.buildInstance();
    (0, _engine.setEngineParent)(engineInstance, {
      lookup() {
        return {};
      },
      resolveRegistration() {
        // Implement Factory
        return {
          isFake: true,
          create: () => {}
        };
      }
    });
    return engineInstance;
  }
  (0, _internalTestHelpers.moduleFor)('Engine instance initializers', class extends _internalTestHelpers.AbstractTestCase {
    teardown() {
      super.teardown();
      (0, _runloop.run)(() => {
        if (myEngineInstance) {
          myEngineInstance.destroy();
        }
        if (myEngine) {
          myEngine.destroy();
        }
      });
      MyEngine = myEngine = myEngineInstance = undefined;
    }
    ["@test initializers require proper 'name' and 'initialize' properties"]() {
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      expectAssertion(() => {
        (0, _runloop.run)(() => {
          MyEngine.instanceInitializer({
            name: 'initializer'
          });
        });
      });
      expectAssertion(() => {
        (0, _runloop.run)(() => {
          MyEngine.instanceInitializer({
            initialize() {}
          });
        });
      });
    }
    ['@test initializers are passed an engine instance'](assert) {
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.instanceInitializer({
        name: 'initializer',
        initialize(instance) {
          assert.ok(instance instanceof _instance.default, 'initialize is passed an engine instance');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot();
    }
    ['@test initializers can be registered in a specified order'](assert) {
      let order = [];
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.instanceInitializer({
        name: 'fourth',
        after: 'third',
        initialize() {
          order.push('fourth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize() {
          order.push('second');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'first',
        before: 'second',
        initialize() {
          order.push('first');
        }
      });
      MyEngine.instanceInitializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyEngine.instanceInitializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(() => {
        assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
      });
    }
    ['@test initializers can be registered in a specified order as an array'](assert) {
      let order = [];
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.instanceInitializer({
        name: 'third',
        initialize() {
          order.push('third');
        }
      });
      MyEngine.instanceInitializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize() {
          order.push('second');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize() {
          order.push('fourth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize() {
          order.push('fifth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'first',
        before: ['second'],
        initialize() {
          order.push('first');
        }
      });
      MyEngine.instanceInitializer({
        name: 'sixth',
        initialize() {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(() => {
        assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
      });
    }
    ['@test initializers can have multiple dependencies'](assert) {
      let order = [];
      MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      let a = {
        name: 'a',
        before: 'b',
        initialize() {
          order.push('a');
        }
      };
      let b = {
        name: 'b',
        initialize() {
          order.push('b');
        }
      };
      let c = {
        name: 'c',
        after: 'b',
        initialize() {
          order.push('c');
        }
      };
      let afterB = {
        name: 'after b',
        after: 'b',
        initialize() {
          order.push('after b');
        }
      };
      let afterC = {
        name: 'after c',
        after: 'c',
        initialize() {
          order.push('after c');
        }
      };
      MyEngine.instanceInitializer(b);
      MyEngine.instanceInitializer(a);
      MyEngine.instanceInitializer(afterC);
      MyEngine.instanceInitializer(afterB);
      MyEngine.instanceInitializer(c);
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(() => {
        assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
        assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
        assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
        assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
      });
    }
    ['@test initializers set on Engine subclasses should not be shared between engines'](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      let firstEngine, firstEngineInstance;
      FirstEngine.instanceInitializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      let secondEngine, secondEngineInstance;
      SecondEngine.instanceInitializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      firstEngine = FirstEngine.create();
      firstEngineInstance = buildEngineInstance(firstEngine);
      return firstEngineInstance.boot().then(() => {
        assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
        assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
        secondEngine = SecondEngine.create();
        secondEngineInstance = buildEngineInstance(secondEngine);
        return secondEngineInstance.boot();
      }).then(() => {
        assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
        assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
        (0, _runloop.run)(() => {
          firstEngineInstance.destroy();
          secondEngineInstance.destroy();
          firstEngine.destroy();
          secondEngine.destroy();
        });
      });
    }
    ['@test initializers are concatenated'](assert) {
      let firstInitializerRunCount = 0;
      let secondInitializerRunCount = 0;
      let FirstEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      FirstEngine.instanceInitializer({
        name: 'first',
        initialize() {
          firstInitializerRunCount++;
        }
      });
      let SecondEngine = FirstEngine.extend();
      SecondEngine.instanceInitializer({
        name: 'second',
        initialize() {
          secondInitializerRunCount++;
        }
      });
      let firstEngine = FirstEngine.create();
      let firstEngineInstance = buildEngineInstance(firstEngine);
      let secondEngine, secondEngineInstance;
      return firstEngineInstance.boot().then(() => {
        assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
        assert.equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
        firstInitializerRunCount = 0;
        secondEngine = SecondEngine.create();
        secondEngineInstance = buildEngineInstance(secondEngine);
        return secondEngineInstance.boot();
      }).then(() => {
        assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
        assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
        (0, _runloop.run)(() => {
          firstEngineInstance.destroy();
          secondEngineInstance.destroy();
          firstEngine.destroy();
          secondEngine.destroy();
        });
      });
    }
    ['@test initializers are per-engine'](assert) {
      assert.expect(2);
      let FirstEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      FirstEngine.instanceInitializer({
        name: 'abc',
        initialize() {}
      });
      expectAssertion(() => {
        FirstEngine.instanceInitializer({
          name: 'abc',
          initialize() {}
        });
      });
      let SecondEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      SecondEngine.instanceInitializer({
        name: 'abc',
        initialize() {}
      });
      assert.ok(true, 'Two engines can have initializers named the same.');
    }
    ['@test initializers are executed in their own context'](assert) {
      assert.expect(1);
      let MyEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      MyEngine.instanceInitializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize() {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot();
    }
  });
});
define("@ember/engine/tests/engine_instance_test", ["@ember/engine", "@ember/engine/instance", "@ember/runloop", "internal-test-helpers"], function (_engine, _instance, _runloop, _internalTestHelpers) {
  "use strict";

  let engine, engineInstance;
  (0, _internalTestHelpers.moduleFor)('EngineInstance', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      (0, _runloop.run)(() => {
        engine = _engine.default.create({
          router: null,
          Resolver: _internalTestHelpers.ModuleBasedTestResolver
        });
      });
    }
    teardown() {
      if (engineInstance) {
        (0, _runloop.run)(engineInstance, 'destroy');
        engineInstance = undefined;
      }
      if (engine) {
        (0, _runloop.run)(engine, 'destroy');
        engine = undefined;
      }
    }
    ['@test an engine instance can be created based upon a base engine'](assert) {
      (0, _runloop.run)(() => {
        engineInstance = _instance.default.create({
          base: engine
        });
      });
      assert.ok(engineInstance, 'instance should be created');
      assert.equal(engineInstance.base, engine, 'base should be set to engine');
    }
    ['@test unregistering a factory clears all cached instances of that factory'](assert) {
      assert.expect(3);
      engineInstance = (0, _runloop.run)(() => _instance.default.create({
        base: engine
      }));
      let PostComponent = (0, _internalTestHelpers.factory)();
      engineInstance.register('component:post', PostComponent);
      let postComponent1 = engineInstance.lookup('component:post');
      assert.ok(postComponent1, 'lookup creates instance');
      engineInstance.unregister('component:post');
      engineInstance.register('component:post', PostComponent);
      let postComponent2 = engineInstance.lookup('component:post');
      assert.ok(postComponent2, 'lookup creates instance');
      assert.notStrictEqual(postComponent1, postComponent2, 'lookup creates a brand new instance because previous one was reset');
    }
    ['@test can be booted when its parent has been set'](assert) {
      assert.expect(3);
      engineInstance = (0, _runloop.run)(() => _instance.default.create({
        base: engine
      }));
      expectAssertion(() => {
        engineInstance._bootSync();
      }, "An engine instance's parent must be set via `setEngineParent(engine, parent)` prior to calling `engine.boot()`.");
      (0, _engine.setEngineParent)(engineInstance, {});

      // Stub `cloneParentDependencies`, the internals of which are tested along
      // with application instances.
      engineInstance.cloneParentDependencies = function () {
        assert.ok(true, 'parent dependencies are cloned');
      };
      return engineInstance.boot().then(() => {
        assert.ok(true, 'boot successful');
      });
    }
    ['@test can build a child instance of a registered engine'](assert) {
      let ChatEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      let chatEngineInstance;
      engine.register('engine:chat', ChatEngine);
      (0, _runloop.run)(() => {
        engineInstance = _instance.default.create({
          base: engine
        });

        // Try to build an unregistered engine.
        assert.throws(() => {
          engineInstance.buildChildEngineInstance('fake');
        }, "You attempted to mount the engine 'fake', but it is not registered with its parent.");

        // Build the `chat` engine, registered above.
        chatEngineInstance = engineInstance.buildChildEngineInstance('chat');
      });
      assert.ok(chatEngineInstance, 'child engine instance successfully created');
      assert.strictEqual((0, _engine.getEngineParent)(chatEngineInstance), engineInstance, 'child engine instance is assigned the correct parent');
    }
  });
});
define("@ember/engine/tests/engine_parent_test", ["@ember/engine", "internal-test-helpers"], function (_engine, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EngineParent', class extends _internalTestHelpers.AbstractTestCase {
    ["@test An engine's parent can be set with `setEngineParent` and retrieved with `getEngineParent`"](assert) {
      let engine = {};
      let parent = {};
      assert.strictEqual((0, _engine.getEngineParent)(engine), undefined, 'parent has not been set');
      (0, _engine.setEngineParent)(engine, parent);
      assert.strictEqual((0, _engine.getEngineParent)(engine), parent, 'parent has been set');
    }
  });
});
define("@ember/engine/tests/engine_test", ["@ember/-internals/environment", "@ember/runloop", "@ember/engine", "@ember/object", "@ember/-internals/metal", "@ember/-internals/utils", "internal-test-helpers"], function (_environment, _runloop, _engine, _object, _metal, _utils, _internalTestHelpers) {
  "use strict";

  let engine;
  let originalLookup = _environment.context.lookup;
  (0, _internalTestHelpers.moduleFor)('Engine', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      (0, _runloop.run)(() => {
        engine = _engine.default.create({
          Resolver: _internalTestHelpers.ModuleBasedTestResolver
        });
        _environment.context.lookup = {
          TestEngine: engine
        };
      });
    }
    teardown() {
      _environment.context.lookup = originalLookup;
      if (engine) {
        (0, _runloop.run)(engine, 'destroy');
        engine = null;
      }
    }
    ['@test acts like a namespace'](assert) {
      engine.Foo = _object.default.extend();
      (0, _metal.processAllNamespaces)();
      assert.equal((0, _utils.getName)(engine.Foo), 'TestEngine.Foo', 'Classes pick up their parent namespace');
    }
    ['@test builds a registry'](assert) {
      assert.strictEqual(engine.resolveRegistration('application:main'), engine, "application:main is registered");
      assert.deepEqual(engine.registeredOptionsForType('component'), {
        singleton: false
      }, "optionsForType 'component'");
      assert.deepEqual(engine.registeredOptionsForType('view'), {
        singleton: false
      }, "optionsForType 'view'");
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'controller:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:link-to');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:textarea');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'service:-routing');

      // DEBUGGING
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component-lookup:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'view:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'template:-outlet');
      assert.deepEqual(engine.registeredOptionsForType('helper'), {
        instantiate: false
      }, "optionsForType 'helper'");
    }
  });
});
define("@ember/enumerable/tests/enumerable_test", ["@ember/enumerable", "@ember/array/proxy", "@ember/array", "internal-test-helpers"], function (_enumerable, _proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Enumerable', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should be mixed into A()'](assert) {
      assert.ok(_enumerable.default.detect((0, _array.A)()));
    }
    ['@test should be mixed into ArrayProxy'](assert) {
      assert.ok(_enumerable.default.detect(_proxy.default.create()));
    }
  });
});
define("@ember/instrumentation/tests/index-test", ["@ember/instrumentation", "internal-test-helpers"], function (_instrumentation, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Instrumentation', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      (0, _instrumentation.reset)();
    }
    ['@test execute block even if no listeners'](assert) {
      let result = (0, _instrumentation.instrument)('render', {}, function () {
        return 'hello';
      });
      assert.equal(result, 'hello', 'called block');
    }
    ['@test subscribing to a simple path receives the listener'](assert) {
      assert.expect(12);
      let sentPayload = {};
      let count = 0;
      (0, _instrumentation.subscribe)('render', {
        before(name, timestamp, payload) {
          if (count === 0) {
            assert.strictEqual(name, 'render');
          } else {
            assert.strictEqual(name, 'render.handlebars');
          }
          assert.ok(typeof timestamp === 'number');
          assert.strictEqual(payload, sentPayload);
        },
        after(name, timestamp, payload) {
          if (count === 0) {
            assert.strictEqual(name, 'render');
          } else {
            assert.strictEqual(name, 'render.handlebars');
          }
          assert.ok(typeof timestamp === 'number');
          assert.strictEqual(payload, sentPayload);
          count++;
        }
      });
      (0, _instrumentation.instrument)('render', sentPayload, function () {});
      (0, _instrumentation.instrument)('render.handlebars', sentPayload, function () {});
    }
    ['@test returning a value from the before callback passes it to the after callback'](assert) {
      assert.expect(2);
      let passthru1 = {};
      let passthru2 = {};
      (0, _instrumentation.subscribe)('render', {
        before() {
          return passthru1;
        },
        after(name, timestamp, payload, beforeValue) {
          assert.strictEqual(beforeValue, passthru1);
        }
      });
      (0, _instrumentation.subscribe)('render', {
        before() {
          return passthru2;
        },
        after(name, timestamp, payload, beforeValue) {
          assert.strictEqual(beforeValue, passthru2);
        }
      });
      (0, _instrumentation.instrument)('render', null, function () {});
    }
    ['@test instrument with 2 args (name, callback) no payload'](assert) {
      assert.expect(1);
      (0, _instrumentation.subscribe)('render', {
        before(name, timestamp, payload) {
          assert.deepEqual(payload, {});
        },
        after() {}
      });
      (0, _instrumentation.instrument)('render', function () {});
    }
    ['@test instrument with 3 args (name, callback, binding) no payload'](assert) {
      assert.expect(2);
      let binding = {};
      (0, _instrumentation.subscribe)('render', {
        before(name, timestamp, payload) {
          assert.deepEqual(payload, {});
        },
        after() {}
      });
      (0, _instrumentation.instrument)('render', function () {
        assert.deepEqual(this, binding);
      }, binding);
    }
    ['@test instrument with 3 args (name, payload, callback) with payload'](assert) {
      assert.expect(1);
      let expectedPayload = {
        hi: 1
      };
      (0, _instrumentation.subscribe)('render', {
        before(name, timestamp, payload) {
          assert.deepEqual(payload, expectedPayload);
        },
        after() {}
      });
      (0, _instrumentation.instrument)('render', expectedPayload, function () {});
    }
    ['@test instrument with 4 args (name, payload, callback, binding) with payload'](assert) {
      assert.expect(2);
      let expectedPayload = {
        hi: 1
      };
      let binding = {};
      (0, _instrumentation.subscribe)('render', {
        before(name, timestamp, payload) {
          assert.deepEqual(payload, expectedPayload);
        },
        after() {}
      });
      (0, _instrumentation.instrument)('render', expectedPayload, function () {
        assert.deepEqual(this, binding);
      }, binding);
    }
    ['@test raising an exception in the instrumentation attaches it to the payload'](assert) {
      assert.expect(3);
      let error = new Error('Instrumentation');
      (0, _instrumentation.subscribe)('render', {
        before() {},
        after(name, timestamp, payload) {
          assert.strictEqual(payload.exception, error);
        }
      });
      (0, _instrumentation.subscribe)('render', {
        before() {},
        after(name, timestamp, payload) {
          assert.strictEqual(payload.exception, error);
        }
      });
      assert.throws(() => (0, _instrumentation.instrument)('render.handlebars', null, () => {
        throw error;
      }), /Instrumentation/);
    }
    ['@test it is possible to add a new subscriber after the first instrument'](assert) {
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
      (0, _instrumentation.subscribe)('render', {
        before() {
          assert.ok(true, 'Before callback was called');
        },
        after() {
          assert.ok(true, 'After callback was called');
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
    }
    ['@test it is possible to remove a subscriber'](assert) {
      assert.expect(4);
      let count = 0;
      let subscriber = (0, _instrumentation.subscribe)('render', {
        before() {
          assert.equal(count, 0);
          assert.ok(true, 'Before callback was called');
        },
        after() {
          assert.equal(count, 0);
          assert.ok(true, 'After callback was called');
          count++;
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
      (0, _instrumentation.unsubscribe)(subscriber);
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
    }
  });
});
define("@ember/object/tests/action_test", ["ember-babel", "@ember/-internals/glimmer", "@ember/object", "internal-test-helpers"], function (_emberBabel, _glimmer, _object, _internalTestHelpers) {
  "use strict";

  var _templateObject;
  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  (0, _internalTestHelpers.moduleFor)('@action decorator', class extends _internalTestHelpers.RenderingTestCase {
    '@test action decorator works with ES6 class'(assert) {
      var _class;
      let FooComponent = (_class = class FooComponent extends _glimmer.Component {
        foo() {
          assert.ok(true, 'called!');
        }
      }, _applyDecoratedDescriptor(_class.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class.prototype, "foo"), _class.prototype), _class);
      this.registerComponent('foo-bar', {
        ComponentClass: FooComponent,
        template: "<button {{action 'foo'}}>Click Me!</button>"
      });
      this.render('{{foo-bar}}');
      this.$('button').click();
    }
    '@test action decorator does not add actions to superclass'(assert) {
      var _class2, _class3;
      let Foo = (_class2 = class Foo extends _object.default {
        foo() {
          // Do nothing
        }
      }, _applyDecoratedDescriptor(_class2.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class2.prototype, "foo"), _class2.prototype), _class2);
      let Bar = (_class3 = class Bar extends Foo {
        bar() {
          assert.ok(false, 'called');
        }
      }, _applyDecoratedDescriptor(_class3.prototype, "bar", [_object.action], Object.getOwnPropertyDescriptor(_class3.prototype, "bar"), _class3.prototype), _class3);
      let foo = Foo.create();
      let bar = Bar.create();
      assert.equal(typeof foo.actions.foo, 'function', 'foo has foo action');
      assert.equal(typeof foo.actions.bar, 'undefined', 'foo does not have bar action');
      assert.equal(typeof bar.actions.foo, 'function', 'bar has foo action');
      assert.equal(typeof bar.actions.bar, 'function', 'bar has bar action');
    }
    '@test actions are properly merged through traditional and ES6 prototype hierarchy'(assert) {
      var _class4, _class5;
      assert.expect(4);
      let FooComponent = _glimmer.Component.extend({
        actions: {
          foo() {
            assert.ok(true, 'foo called!');
          }
        }
      });
      let BarComponent = (_class4 = class BarComponent extends FooComponent {
        bar() {
          assert.ok(true, 'bar called!');
        }
      }, _applyDecoratedDescriptor(_class4.prototype, "bar", [_object.action], Object.getOwnPropertyDescriptor(_class4.prototype, "bar"), _class4.prototype), _class4);
      let BazComponent = BarComponent.extend({
        actions: {
          baz() {
            assert.ok(true, 'baz called!');
          }
        }
      });
      let QuxComponent = (_class5 = class QuxComponent extends BazComponent {
        qux() {
          assert.ok(true, 'qux called!');
        }
      }, _applyDecoratedDescriptor(_class5.prototype, "qux", [_object.action], Object.getOwnPropertyDescriptor(_class5.prototype, "qux"), _class5.prototype), _class5);
      this.registerComponent('qux-component', {
        ComponentClass: QuxComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject || (_templateObject = (0, _emberBabel.taggedTemplateLiteralLoose)(["\n          <button {{action 'foo'}}>Click Foo!</button>\n          <button {{action 'bar'}}>Click Bar!</button>\n          <button {{action 'baz'}}>Click Baz!</button>\n          <button {{action 'qux'}}>Click Qux!</button>\n        "])))
      });
      this.render('{{qux-component}}');
      this.$('button').click();
    }
    '@test action decorator super works with native class methods'(assert) {
      var _class6;
      class FooComponent extends _glimmer.Component {
        foo() {
          assert.ok(true, 'called!');
        }
      }
      let BarComponent = (_class6 = class BarComponent extends FooComponent {
        foo() {
          super.foo();
        }
      }, _applyDecoratedDescriptor(_class6.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class6.prototype, "foo"), _class6.prototype), _class6);
      this.registerComponent('bar-bar', {
        ComponentClass: BarComponent,
        template: "<button {{action 'foo'}}>Click Me!</button>"
      });
      this.render('{{bar-bar}}');
      this.$('button').click();
    }
    '@test action decorator super works with traditional class methods'(assert) {
      var _class7;
      let FooComponent = _glimmer.Component.extend({
        foo() {
          assert.ok(true, 'called!');
        }
      });
      let BarComponent = (_class7 = class BarComponent extends FooComponent {
        foo() {
          super.foo();
        }
      }, _applyDecoratedDescriptor(_class7.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class7.prototype, "foo"), _class7.prototype), _class7);
      this.registerComponent('bar-bar', {
        ComponentClass: BarComponent,
        template: "<button {{action 'foo'}}>Click Me!</button>"
      });
      this.render('{{bar-bar}}');
      this.$('button').click();
    }

    // This test fails with _classes_ compiled in loose mode
    '@skip action decorator works with parent native class actions'(assert) {
      var _class8, _class9;
      let FooComponent = (_class8 = class FooComponent extends _glimmer.Component {
        foo() {
          assert.ok(true, 'called!');
        }
      }, _applyDecoratedDescriptor(_class8.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class8.prototype, "foo"), _class8.prototype), _class8);
      let BarComponent = (_class9 = class BarComponent extends FooComponent {
        foo() {
          super.foo();
        }
      }, _applyDecoratedDescriptor(_class9.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class9.prototype, "foo"), _class9.prototype), _class9);
      this.registerComponent('bar-bar', {
        ComponentClass: BarComponent,
        template: "<button {{action 'foo'}}>Click Me!</button>"
      });
      this.render('{{bar-bar}}');
      this.$('button').click();
    }
    '@test action decorator binds functions'(assert) {
      var _class10;
      let FooComponent = (_class10 = class FooComponent extends _glimmer.Component {
        constructor() {
          super(...arguments);
          this.bar = 'some value';
        }
        foo() {
          assert.equal(this.bar, 'some value', 'context bound correctly');
        }
      }, _applyDecoratedDescriptor(_class10.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class10.prototype, "foo"), _class10.prototype), _class10);
      this.registerComponent('foo-bar', {
        ComponentClass: FooComponent,
        template: '<button onclick={{this.foo}}>Click Me!</button>'
      });
      this.render('{{foo-bar}}');
      this.$('button').click();
    }

    // This test fails with _classes_ compiled in loose mode
    '@skip action decorator super works correctly when bound'(assert) {
      var _class12, _class14;
      let FooComponent = (_class12 = class FooComponent extends _glimmer.Component {
        constructor() {
          super(...arguments);
          this.bar = 'some value';
        }
        foo() {
          assert.equal(this.bar, 'some value', 'context bound correctly');
        }
      }, _applyDecoratedDescriptor(_class12.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class12.prototype, "foo"), _class12.prototype), _class12);
      let BarComponent = (_class14 = class BarComponent extends FooComponent {
        foo() {
          super.foo();
        }
      }, _applyDecoratedDescriptor(_class14.prototype, "foo", [_object.action], Object.getOwnPropertyDescriptor(_class14.prototype, "foo"), _class14.prototype), _class14);
      this.registerComponent('bar-bar', {
        ComponentClass: BarComponent,
        template: '<button onclick={{this.foo}}>Click Me!</button>'
      });
      this.render('{{bar-bar}}');
      this.$('button').click();
    }
    '@test action decorator throws an error if applied to non-methods'() {
      expectAssertion(() => {
        var _class15, _descriptor;
        let TestObject = (_class15 = class TestObject extends _object.default {
          constructor() {
            super(...arguments);
            _initializerDefineProperty(this, "foo", _descriptor, this);
          }
        }, _descriptor = _applyDecoratedDescriptor(_class15.prototype, "foo", [_object.action], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 'bar';
          }
        }), _class15);
        new TestObject();
      }, /The @action decorator must be applied to methods/);
    }
    '@test action decorator throws an error if passed a function in native classes'() {
      expectAssertion(() => {
        var _dec, _class17, _descriptor2;
        let TestObject = (_dec = (0, _object.action)(function () {}), (_class17 = class TestObject extends _object.default {
          constructor() {
            super(...arguments);
            _initializerDefineProperty(this, "foo", _descriptor2, this);
          }
        }, _descriptor2 = _applyDecoratedDescriptor(_class17.prototype, "foo", [_dec], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 'bar';
          }
        }), _class17));
        new TestObject();
      }, /The @action decorator may only be passed a method when used in classic classes/);
    }
    '@test action decorator can be used as a classic decorator with strings'(assert) {
      let FooComponent = _glimmer.Component.extend({
        foo: (0, _object.action)(function () {
          assert.ok(true, 'called!');
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooComponent,
        template: "<button {{action 'foo'}}>Click Me!</button>"
      });
      this.render('{{foo-bar}}');
      this.$('button').click();
    }
    '@test action decorator can be used as a classic decorator directly'(assert) {
      let FooComponent = _glimmer.Component.extend({
        foo: (0, _object.action)(function () {
          assert.ok(true, 'called!');
        })
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooComponent,
        template: '<button onclick={{this.foo}}>Click Me!</button>'
      });
      this.render('{{foo-bar}}');
      this.$('button').click();
    }
  });
});
define("@ember/object/tests/computed/computed_macros_test", ["@ember/object/computed", "@ember/object", "@ember/array", "internal-test-helpers"], function (_computed, _object, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('CP macros', class extends _internalTestHelpers.AbstractTestCase {
    ['@test empty part 1/2'](assert) {
      let obj = _object.default.extend({
        bestLannister: null,
        lannisters: null,
        bestLannisterUnspecified: (0, _computed.empty)('bestLannister'),
        noLannistersKnown: (0, _computed.empty)('lannisters')
      }).create({
        lannisters: (0, _array.A)()
      });
      assert.equal((0, _object.get)(obj, 'bestLannisterUnspecified'), true, 'bestLannister initially empty');
      assert.equal((0, _object.get)(obj, 'noLannistersKnown'), true, 'lannisters initially empty');
      (0, _object.get)(obj, 'lannisters').pushObject('Tyrion');
      (0, _object.set)(obj, 'bestLannister', 'Tyrion');
      assert.equal((0, _object.get)(obj, 'bestLannisterUnspecified'), false, 'empty respects strings');
      assert.equal((0, _object.get)(obj, 'noLannistersKnown'), false, 'empty respects array mutations');
    }
    ['@test notEmpty part 1/2'](assert) {
      let obj = _object.default.extend({
        bestLannister: null,
        lannisters: null,
        bestLannisterSpecified: (0, _computed.notEmpty)('bestLannister'),
        LannistersKnown: (0, _computed.notEmpty)('lannisters')
      }).create({
        lannisters: (0, _array.A)()
      });
      assert.equal((0, _object.get)(obj, 'bestLannisterSpecified'), false, 'bestLannister initially empty');
      assert.equal((0, _object.get)(obj, 'LannistersKnown'), false, 'lannisters initially empty');
      (0, _object.get)(obj, 'lannisters').pushObject('Tyrion');
      (0, _object.set)(obj, 'bestLannister', 'Tyrion');
      assert.equal((0, _object.get)(obj, 'bestLannisterSpecified'), true, 'empty respects strings');
      assert.equal((0, _object.get)(obj, 'LannistersKnown'), true, 'empty respects array mutations');
    }
    ['@test not'](assert) {
      let obj = {
        foo: true
      };
      (0, _object.defineProperty)(obj, 'notFoo', (0, _computed.not)('foo'));
      assert.equal((0, _object.get)(obj, 'notFoo'), false);
      obj = {
        foo: {
          bar: true
        }
      };
      (0, _object.defineProperty)(obj, 'notFoo', (0, _computed.not)('foo.bar'));
      assert.equal((0, _object.get)(obj, 'notFoo'), false);
    }
    ['@test empty part 2/2'](assert) {
      let obj = {
        foo: [],
        bar: undefined,
        baz: null,
        quz: ''
      };
      (0, _object.defineProperty)(obj, 'fooEmpty', (0, _computed.empty)('foo'));
      (0, _object.defineProperty)(obj, 'barEmpty', (0, _computed.empty)('bar'));
      (0, _object.defineProperty)(obj, 'bazEmpty', (0, _computed.empty)('baz'));
      (0, _object.defineProperty)(obj, 'quzEmpty', (0, _computed.empty)('quz'));
      assert.equal((0, _object.get)(obj, 'fooEmpty'), true);
      (0, _object.set)(obj, 'foo', [1]);
      assert.equal((0, _object.get)(obj, 'fooEmpty'), false);
      assert.equal((0, _object.get)(obj, 'barEmpty'), true);
      assert.equal((0, _object.get)(obj, 'bazEmpty'), true);
      assert.equal((0, _object.get)(obj, 'quzEmpty'), true);
      (0, _object.set)(obj, 'quz', 'asdf');
      assert.equal((0, _object.get)(obj, 'quzEmpty'), false);
    }
    ['@test bool'](assert) {
      let obj = {
        foo() {},
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _object.defineProperty)(obj, 'fooBool', (0, _computed.bool)('foo'));
      (0, _object.defineProperty)(obj, 'barBool', (0, _computed.bool)('bar'));
      (0, _object.defineProperty)(obj, 'bazBool', (0, _computed.bool)('baz'));
      (0, _object.defineProperty)(obj, 'quzBool', (0, _computed.bool)('quz'));
      assert.equal((0, _object.get)(obj, 'fooBool'), true);
      assert.equal((0, _object.get)(obj, 'barBool'), true);
      assert.equal((0, _object.get)(obj, 'bazBool'), false);
      assert.equal((0, _object.get)(obj, 'quzBool'), false);
    }
    ['@test alias'](assert) {
      let obj = {
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _object.defineProperty)(obj, 'bay', (0, _object.computed)(function () {
        return 'apple';
      }));
      (0, _object.defineProperty)(obj, 'barAlias', (0, _computed.alias)('bar'));
      (0, _object.defineProperty)(obj, 'bazAlias', (0, _computed.alias)('baz'));
      (0, _object.defineProperty)(obj, 'quzAlias', (0, _computed.alias)('quz'));
      (0, _object.defineProperty)(obj, 'bayAlias', (0, _computed.alias)('bay'));
      assert.equal((0, _object.get)(obj, 'barAlias'), 'asdf');
      assert.equal((0, _object.get)(obj, 'bazAlias'), null);
      assert.equal((0, _object.get)(obj, 'quzAlias'), false);
      assert.equal((0, _object.get)(obj, 'bayAlias'), 'apple');
      (0, _object.set)(obj, 'barAlias', 'newBar');
      (0, _object.set)(obj, 'bazAlias', 'newBaz');
      (0, _object.set)(obj, 'quzAlias', null);
      assert.equal((0, _object.get)(obj, 'barAlias'), 'newBar');
      assert.equal((0, _object.get)(obj, 'bazAlias'), 'newBaz');
      assert.equal((0, _object.get)(obj, 'quzAlias'), null);
      assert.equal((0, _object.get)(obj, 'bar'), 'newBar');
      assert.equal((0, _object.get)(obj, 'baz'), 'newBaz');
      assert.equal((0, _object.get)(obj, 'quz'), null);
    }
    ['@test alias set'](assert) {
      let obj = {};
      let constantValue = 'always `a`';
      (0, _object.defineProperty)(obj, 'original', (0, _object.computed)({
        get: function () {
          return constantValue;
        },
        set: function () {
          return constantValue;
        }
      }));
      (0, _object.defineProperty)(obj, 'aliased', (0, _computed.alias)('original'));
      assert.equal((0, _object.get)(obj, 'original'), constantValue);
      assert.equal((0, _object.get)(obj, 'aliased'), constantValue);
      (0, _object.set)(obj, 'aliased', 'should not set to this value');
      assert.equal((0, _object.get)(obj, 'original'), constantValue);
      assert.equal((0, _object.get)(obj, 'aliased'), constantValue);
    }
    ['@test match'](assert) {
      let obj = {
        name: 'Paul'
      };
      (0, _object.defineProperty)(obj, 'isPaul', (0, _computed.match)('name', /Paul/));
      assert.equal((0, _object.get)(obj, 'isPaul'), true, 'is Paul');
      (0, _object.set)(obj, 'name', 'Pierre');
      assert.equal((0, _object.get)(obj, 'isPaul'), false, 'is not Paul anymore');
    }
    ['@test notEmpty part 2/2'](assert) {
      let obj = {
        items: [1]
      };
      (0, _object.defineProperty)(obj, 'hasItems', (0, _computed.notEmpty)('items'));
      assert.equal((0, _object.get)(obj, 'hasItems'), true, 'is not empty');
      (0, _object.set)(obj, 'items', []);
      assert.equal((0, _object.get)(obj, 'hasItems'), false, 'is empty');
    }
    ['@test equal'](assert) {
      let obj = {
        name: 'Paul'
      };
      (0, _object.defineProperty)(obj, 'isPaul', (0, _computed.equal)('name', 'Paul'));
      assert.equal((0, _object.get)(obj, 'isPaul'), true, 'is Paul');
      (0, _object.set)(obj, 'name', 'Pierre');
      assert.equal((0, _object.get)(obj, 'isPaul'), false, 'is not Paul anymore');
    }
    ['@test gt'](assert) {
      let obj = {
        number: 2
      };
      (0, _object.defineProperty)(obj, 'isGreaterThenOne', (0, _computed.gt)('number', 1));
      assert.equal((0, _object.get)(obj, 'isGreaterThenOne'), true, 'is gt');
      (0, _object.set)(obj, 'number', 1);
      assert.equal((0, _object.get)(obj, 'isGreaterThenOne'), false, 'is not gt');
      (0, _object.set)(obj, 'number', 0);
      assert.equal((0, _object.get)(obj, 'isGreaterThenOne'), false, 'is not gt');
    }
    ['@test gte'](assert) {
      let obj = {
        number: 2
      };
      (0, _object.defineProperty)(obj, 'isGreaterOrEqualThenOne', (0, _computed.gte)('number', 1));
      assert.equal((0, _object.get)(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');
      (0, _object.set)(obj, 'number', 1);
      assert.equal((0, _object.get)(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');
      (0, _object.set)(obj, 'number', 0);
      assert.equal((0, _object.get)(obj, 'isGreaterOrEqualThenOne'), false, 'is not gte');
    }
    ['@test lt'](assert) {
      let obj = {
        number: 0
      };
      (0, _object.defineProperty)(obj, 'isLesserThenOne', (0, _computed.lt)('number', 1));
      assert.equal((0, _object.get)(obj, 'isLesserThenOne'), true, 'is lt');
      (0, _object.set)(obj, 'number', 1);
      assert.equal((0, _object.get)(obj, 'isLesserThenOne'), false, 'is not lt');
      (0, _object.set)(obj, 'number', 2);
      assert.equal((0, _object.get)(obj, 'isLesserThenOne'), false, 'is not lt');
    }
    ['@test lte'](assert) {
      let obj = {
        number: 0
      };
      (0, _object.defineProperty)(obj, 'isLesserOrEqualThenOne', (0, _computed.lte)('number', 1));
      assert.equal((0, _object.get)(obj, 'isLesserOrEqualThenOne'), true, 'is lte');
      (0, _object.set)(obj, 'number', 1);
      assert.equal((0, _object.get)(obj, 'isLesserOrEqualThenOne'), true, 'is lte');
      (0, _object.set)(obj, 'number', 2);
      assert.equal((0, _object.get)(obj, 'isLesserOrEqualThenOne'), false, 'is not lte');
    }
    ['@test and, with two properties'](assert) {
      let obj = {
        one: true,
        two: true
      };
      (0, _object.defineProperty)(obj, 'oneAndTwo', (0, _computed.and)('one', 'two'));
      assert.equal((0, _object.get)(obj, 'oneAndTwo'), true, 'one and two');
      (0, _object.set)(obj, 'one', false);
      assert.equal((0, _object.get)(obj, 'oneAndTwo'), false, 'one and not two');
      (0, _object.set)(obj, 'one', null);
      (0, _object.set)(obj, 'two', 'Yes');
      assert.equal((0, _object.get)(obj, 'oneAndTwo'), null, 'returns falsy value as in &&');
      (0, _object.set)(obj, 'one', true);
      (0, _object.set)(obj, 'two', 2);
      assert.equal((0, _object.get)(obj, 'oneAndTwo'), 2, 'returns truthy value as in &&');
    }
    ['@test and, with three properties'](assert) {
      let obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _object.defineProperty)(obj, 'oneTwoThree', (0, _computed.and)('one', 'two', 'three'));
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one and two and three');
      (0, _object.set)(obj, 'one', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), false, 'one and not two and not three');
      (0, _object.set)(obj, 'one', true);
      (0, _object.set)(obj, 'two', 2);
      (0, _object.set)(obj, 'three', 3);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
    }
    ['@test and, with expand properties'](assert) {
      let obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _object.defineProperty)(obj, 'oneTwoThree', (0, _computed.and)('{one,two,three}'));
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one and two and three');
      (0, _object.set)(obj, 'one', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), false, 'one and not two and not three');
      (0, _object.set)(obj, 'one', true);
      (0, _object.set)(obj, 'two', 2);
      (0, _object.set)(obj, 'three', 3);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
    }
    ['@test or, with two properties'](assert) {
      let obj = {
        one: true,
        two: true
      };
      (0, _object.defineProperty)(obj, 'oneOrTwo', (0, _computed.or)('one', 'two'));
      assert.equal((0, _object.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _object.set)(obj, 'one', false);
      assert.equal((0, _object.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _object.set)(obj, 'two', false);
      assert.equal((0, _object.get)(obj, 'oneOrTwo'), false, 'nor one nor two');
      (0, _object.set)(obj, 'two', null);
      assert.equal((0, _object.get)(obj, 'oneOrTwo'), null, 'returns last falsy value as in ||');
      (0, _object.set)(obj, 'two', true);
      assert.equal((0, _object.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _object.set)(obj, 'one', 1);
      assert.equal((0, _object.get)(obj, 'oneOrTwo'), 1, 'returns truthy value as in ||');
    }
    ['@test or, with three properties'](assert) {
      let obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _object.defineProperty)(obj, 'oneTwoThree', (0, _computed.or)('one', 'two', 'three'));
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'one', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'two', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'three', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), false, 'one or two or three');
      (0, _object.set)(obj, 'three', null);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');
      (0, _object.set)(obj, 'two', true);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'one', 1);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
    }
    ['@test or, with expand properties'](assert) {
      let obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _object.defineProperty)(obj, 'oneTwoThree', (0, _computed.or)('{one,two,three}'));
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'one', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'two', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'three', false);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), false, 'one or two or three');
      (0, _object.set)(obj, 'three', null);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');
      (0, _object.set)(obj, 'two', true);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _object.set)(obj, 'one', 1);
      assert.equal((0, _object.get)(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
    }
    ['@test or and and, warn about dependent keys with spaces']() {
      let obj = {
        one: true,
        two: true
      };
      expectAssertion(function () {
        (0, _object.defineProperty)(obj, 'oneOrTwo', (0, _computed.or)('one', 'two three'));
      }, /Dependent keys passed to `or` computed macro can't have spaces\./);
      expectAssertion(function () {
        (0, _object.defineProperty)(obj, 'oneAndTwo', (0, _computed.and)('one', 'two three'));
      }, /Dependent keys passed to `and` computed macro can't have spaces\./);
    }
    ['@test oneWay'](assert) {
      let obj = {
        firstName: 'Teddy',
        lastName: 'Zeenny'
      };
      (0, _object.defineProperty)(obj, 'nickName', (0, _computed.oneWay)('firstName'));
      assert.equal((0, _object.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _object.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _object.get)(obj, 'nickName'), 'Teddy');
      (0, _object.set)(obj, 'nickName', 'TeddyBear');
      assert.equal((0, _object.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _object.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _object.get)(obj, 'nickName'), 'TeddyBear');
      (0, _object.set)(obj, 'firstName', 'TEDDDDDDDDYYY');
      assert.equal((0, _object.get)(obj, 'nickName'), 'TeddyBear');
    }
    ['@test readOnly'](assert) {
      let obj = {
        firstName: 'Teddy',
        lastName: 'Zeenny'
      };
      (0, _object.defineProperty)(obj, 'nickName', (0, _computed.readOnly)('firstName'));
      assert.equal((0, _object.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _object.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _object.get)(obj, 'nickName'), 'Teddy');
      assert.throws(function () {
        (0, _object.set)(obj, 'nickName', 'TeddyBear');
      }, / /);
      assert.equal((0, _object.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _object.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _object.get)(obj, 'nickName'), 'Teddy');
      (0, _object.set)(obj, 'firstName', 'TEDDDDDDDDYYY');
      assert.equal((0, _object.get)(obj, 'nickName'), 'TEDDDDDDDDYYY');
    }
    ['@test deprecatingAlias'](assert) {
      let obj = {
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _object.defineProperty)(obj, 'bay', (0, _object.computed)(function () {
        return 'apple';
      }));
      (0, _object.defineProperty)(obj, 'barAlias', (0, _computed.deprecatingAlias)('bar', {
        id: 'bar-deprecation',
        until: 'some.version'
      }));
      (0, _object.defineProperty)(obj, 'bazAlias', (0, _computed.deprecatingAlias)('baz', {
        id: 'baz-deprecation',
        until: 'some.version'
      }));
      (0, _object.defineProperty)(obj, 'quzAlias', (0, _computed.deprecatingAlias)('quz', {
        id: 'quz-deprecation',
        until: 'some.version'
      }));
      (0, _object.defineProperty)(obj, 'bayAlias', (0, _computed.deprecatingAlias)('bay', {
        id: 'bay-deprecation',
        until: 'some.version'
      }));
      expectDeprecation(function () {
        assert.equal((0, _object.get)(obj, 'barAlias'), 'asdf');
      }, 'Usage of `barAlias` is deprecated, use `bar` instead.');
      expectDeprecation(function () {
        assert.equal((0, _object.get)(obj, 'bazAlias'), null);
      }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');
      expectDeprecation(function () {
        assert.equal((0, _object.get)(obj, 'quzAlias'), false);
      }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');
      expectDeprecation(function () {
        assert.equal((0, _object.get)(obj, 'bayAlias'), 'apple');
      }, 'Usage of `bayAlias` is deprecated, use `bay` instead.');
      expectDeprecation(function () {
        (0, _object.set)(obj, 'barAlias', 'newBar');
      }, 'Usage of `barAlias` is deprecated, use `bar` instead.');
      expectDeprecation(function () {
        (0, _object.set)(obj, 'bazAlias', 'newBaz');
      }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');
      expectDeprecation(function () {
        (0, _object.set)(obj, 'quzAlias', null);
      }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');
      assert.equal((0, _object.get)(obj, 'barAlias'), 'newBar');
      assert.equal((0, _object.get)(obj, 'bazAlias'), 'newBaz');
      assert.equal((0, _object.get)(obj, 'quzAlias'), null);
      assert.equal((0, _object.get)(obj, 'bar'), 'newBar');
      assert.equal((0, _object.get)(obj, 'baz'), 'newBaz');
      assert.equal((0, _object.get)(obj, 'quz'), null);
    }
  });
});
define("@ember/object/tests/computed/dependent-key-compat-test", ["@ember/object", "@ember/-internals/metal", "@ember/object/compat", "internal-test-helpers"], function (_object, _metal, _compat, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('dependentKeyCompat', class extends _internalTestHelpers.AbstractTestCase {
    '@test it works with computed properties'(assert) {
      var _dec, _class, _descriptor, _descriptor2;
      let Person = (_dec = (0, _object.computed)('givenName', 'lastName'), (_class = class Person {
        constructor() {
          _initializerDefineProperty(this, "firstName", _descriptor, this);
          _initializerDefineProperty(this, "lastName", _descriptor2, this);
        }
        get givenName() {
          return this.firstName;
        }
        get fullName() {
          return this.givenName + " " + this.lastName;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "firstName", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'Tom';
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "lastName", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 'Dale';
        }
      }), _applyDecoratedDescriptor(_class.prototype, "givenName", [_compat.dependentKeyCompat], Object.getOwnPropertyDescriptor(_class.prototype, "givenName"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fullName", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "fullName"), _class.prototype)), _class));
      let tom = new Person();
      assert.equal(tom.fullName, 'Tom Dale');
      tom.firstName = 'Thomas';
      assert.equal(tom.fullName, 'Thomas Dale');
    }
    '@test it works with classic classes'(assert) {
      let Person = _object.default.extend({
        firstName: (0, _metal.tracked)({
          value: 'Tom'
        }),
        lastName: (0, _metal.tracked)({
          value: 'Dale'
        }),
        givenName: (0, _compat.dependentKeyCompat)({
          get() {
            return this.firstName;
          }
        }),
        fullName: (0, _object.computed)('givenName', 'lastName', function () {
          return this.givenName + " " + this.lastName;
        })
      });
      let tom = Person.create();
      assert.equal(tom.fullName, 'Tom Dale');
      tom.firstName = 'Thomas';
      assert.equal(tom.fullName, 'Thomas Dale');
    }
    async '@test it works with async observers'(assert) {
      let count = 0;
      let Person = _object.default.extend({
        firstName: (0, _metal.tracked)({
          value: 'Tom'
        }),
        lastName: (0, _metal.tracked)({
          value: 'Dale'
        }),
        givenName: (0, _compat.dependentKeyCompat)({
          get() {
            return this.firstName;
          }
        }),
        givenNameObserver: (0, _object.observer)({
          dependentKeys: ['givenName'],
          fn() {
            count++;
          },
          sync: false
        })
      });
      let tom = Person.create();
      assert.equal(count, 0);

      // check the alias, and bootstrap it
      assert.equal(tom.givenName, 'Tom', 'alias works');
      tom.firstName = 'Thomas';
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1);
      tom.destroy();
    }
    '@test it does not work with sync observers'(assert) {
      let count = 0;
      let Person = _object.default.extend({
        firstName: (0, _metal.tracked)({
          value: 'Tom'
        }),
        lastName: (0, _metal.tracked)({
          value: 'Dale'
        }),
        givenName: (0, _compat.dependentKeyCompat)({
          get() {
            return this.firstName;
          }
        }),
        givenNameObserver: (0, _object.observer)({
          dependentKeys: ['givenName'],
          fn() {
            count++;
          },
          sync: true
        })
      });
      let tom = Person.create();
      assert.equal(count, 0);
      tom.firstName = 'Thomas';
      assert.equal(count, 0);
      tom.destroy();
    }
  });
});
define("@ember/object/tests/computed/macro_decorators_test", ["internal-test-helpers", "@ember/-internals/metal", "@ember/object/computed"], function (_internalTestHelpers, _metal, _computed) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('computed macros - decorators - assertions', class extends _internalTestHelpers.AbstractTestCase {
    ['@test and throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class, _descriptor;
        let Foo = (_class = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor, this);
          }
        }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "foo", [_computed.and], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class);
        new Foo();
      }, /You attempted to use @and/);
    }
    ['@test alias throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class3, _descriptor2;
        let Foo = (_class3 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor2, this);
          }
        }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "foo", [_metal.alias], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class3);
        new Foo();
      }, /You attempted to use @alias/);
    }
    ['@test bool throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class5, _descriptor3;
        let Foo = (_class5 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor3, this);
          }
        }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "foo", [_computed.bool], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class5);
        new Foo();
      }, /You attempted to use @bool/);
    }
    ['@test collect throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class7, _descriptor4;
        let Foo = (_class7 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor4, this);
          }
        }, _descriptor4 = _applyDecoratedDescriptor(_class7.prototype, "foo", [_computed.collect], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class7);
        new Foo();
      }, /You attempted to use @collect/);
    }
    ['@test deprecatingAlias throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class9, _descriptor5;
        let Foo = (_class9 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor5, this);
          }
        }, _descriptor5 = _applyDecoratedDescriptor(_class9.prototype, "foo", [_computed.deprecatingAlias], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class9);
        new Foo();
      }, /You attempted to use @deprecatingAlias/);
    }
    ['@test empty throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class11, _descriptor6;
        let Foo = (_class11 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor6, this);
          }
        }, _descriptor6 = _applyDecoratedDescriptor(_class11.prototype, "foo", [_computed.empty], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class11);
        new Foo();
      }, /You attempted to use @empty/);
    }
    ['@test equal throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class13, _descriptor7;
        let Foo = (_class13 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor7, this);
          }
        }, _descriptor7 = _applyDecoratedDescriptor(_class13.prototype, "foo", [_computed.equal], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class13);
        new Foo();
      }, /You attempted to use @equal/);
    }
    ['@test filter throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class15, _descriptor8;
        let Foo = (_class15 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor8, this);
          }
        }, _descriptor8 = _applyDecoratedDescriptor(_class15.prototype, "foo", [_computed.filter], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class15);
        new Foo();
      }, /You attempted to use @filter/);
    }
    ['@test filterBy throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class17, _descriptor9;
        let Foo = (_class17 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor9, this);
          }
        }, _descriptor9 = _applyDecoratedDescriptor(_class17.prototype, "foo", [_computed.filterBy], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class17);
        new Foo();
      }, /You attempted to use @filterBy/);
    }
    ['@test gt throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class19, _descriptor10;
        let Foo = (_class19 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor10, this);
          }
        }, _descriptor10 = _applyDecoratedDescriptor(_class19.prototype, "foo", [_computed.gt], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class19);
        new Foo();
      }, /You attempted to use @gt/);
    }
    ['@test gte throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class21, _descriptor11;
        let Foo = (_class21 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor11, this);
          }
        }, _descriptor11 = _applyDecoratedDescriptor(_class21.prototype, "foo", [_computed.gte], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class21);
        new Foo();
      }, /You attempted to use @gte/);
    }
    ['@test intersect throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class23, _descriptor12;
        let Foo = (_class23 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor12, this);
          }
        }, _descriptor12 = _applyDecoratedDescriptor(_class23.prototype, "foo", [_computed.intersect], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class23);
        new Foo();
      }, /You attempted to use @intersect/);
    }
    ['@test lt throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class25, _descriptor13;
        let Foo = (_class25 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor13, this);
          }
        }, _descriptor13 = _applyDecoratedDescriptor(_class25.prototype, "foo", [_computed.lt], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class25);
        new Foo();
      }, /You attempted to use @lt/);
    }
    ['@test lte throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class27, _descriptor14;
        let Foo = (_class27 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor14, this);
          }
        }, _descriptor14 = _applyDecoratedDescriptor(_class27.prototype, "foo", [_computed.lte], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class27);
        new Foo();
      }, /You attempted to use @lte/);
    }
    ['@test map throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class29, _descriptor15;
        let Foo = (_class29 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor15, this);
          }
        }, _descriptor15 = _applyDecoratedDescriptor(_class29.prototype, "foo", [_computed.map], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class29);
        new Foo();
      }, /You attempted to use @map/);
    }
    ['@test mapBy throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class31, _descriptor16;
        let Foo = (_class31 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor16, this);
          }
        }, _descriptor16 = _applyDecoratedDescriptor(_class31.prototype, "foo", [_computed.mapBy], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class31);
        new Foo();
      }, /You attempted to use @mapBy/);
    }
    ['@test match throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class33, _descriptor17;
        let Foo = (_class33 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor17, this);
          }
        }, _descriptor17 = _applyDecoratedDescriptor(_class33.prototype, "foo", [_computed.match], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class33);
        new Foo();
      }, /You attempted to use @match/);
    }
    ['@test max throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class35, _descriptor18;
        let Foo = (_class35 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor18, this);
          }
        }, _descriptor18 = _applyDecoratedDescriptor(_class35.prototype, "foo", [_computed.max], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class35);
        new Foo();
      }, /You attempted to use @max/);
    }
    ['@test min throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class37, _descriptor19;
        let Foo = (_class37 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor19, this);
          }
        }, _descriptor19 = _applyDecoratedDescriptor(_class37.prototype, "foo", [_computed.min], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class37);
        new Foo();
      }, /You attempted to use @min/);
    }
    ['@test not throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class39, _descriptor20;
        let Foo = (_class39 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor20, this);
          }
        }, _descriptor20 = _applyDecoratedDescriptor(_class39.prototype, "foo", [_computed.not], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class39);
        new Foo();
      }, /You attempted to use @not/);
    }
    ['@test notEmpty throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class41, _descriptor21;
        let Foo = (_class41 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor21, this);
          }
        }, _descriptor21 = _applyDecoratedDescriptor(_class41.prototype, "foo", [_computed.notEmpty], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class41);
        new Foo();
      }, /You attempted to use @notEmpty/);
    }
    ['@test oneWay throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class43, _descriptor22;
        let Foo = (_class43 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor22, this);
          }
        }, _descriptor22 = _applyDecoratedDescriptor(_class43.prototype, "foo", [_computed.oneWay], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class43);
        new Foo();
      }, /You attempted to use @oneWay/);
    }
    ['@test or throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class45, _descriptor23;
        let Foo = (_class45 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor23, this);
          }
        }, _descriptor23 = _applyDecoratedDescriptor(_class45.prototype, "foo", [_computed.or], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class45);
        new Foo();
      }, /You attempted to use @or/);
    }
    ['@test readOnly throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class47, _descriptor24;
        let Foo = (_class47 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor24, this);
          }
        }, _descriptor24 = _applyDecoratedDescriptor(_class47.prototype, "foo", [_computed.readOnly], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class47);
        new Foo();
      }, /You attempted to use @readOnly/);
    }
    ['@test setDiff throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class49, _descriptor25;
        let Foo = (_class49 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor25, this);
          }
        }, _descriptor25 = _applyDecoratedDescriptor(_class49.prototype, "foo", [_computed.setDiff], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class49);
        new Foo();
      }, /You attempted to use @setDiff/);
    }
    ['@test sort throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class51, _descriptor26;
        let Foo = (_class51 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor26, this);
          }
        }, _descriptor26 = _applyDecoratedDescriptor(_class51.prototype, "foo", [_computed.sort], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class51);
        new Foo();
      }, /You attempted to use @sort/);
    }
    ['@test sum throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class53, _descriptor27;
        let Foo = (_class53 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor27, this);
          }
        }, _descriptor27 = _applyDecoratedDescriptor(_class53.prototype, "foo", [_computed.sum], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class53);
        new Foo();
      }, /You attempted to use @sum/);
    }
    ['@test union throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class55, _descriptor28;
        let Foo = (_class55 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor28, this);
          }
        }, _descriptor28 = _applyDecoratedDescriptor(_class55.prototype, "foo", [_computed.union], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class55);
        new Foo();
      }, /You attempted to use @uniq\/@union/);
    }
    ['@test uniq throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class57, _descriptor29;
        let Foo = (_class57 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor29, this);
          }
        }, _descriptor29 = _applyDecoratedDescriptor(_class57.prototype, "foo", [_computed.uniq], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class57);
        new Foo();
      }, /You attempted to use @uniq\/@union/);
    }
    ['@test uniqBy throws an error if used without parameters']() {
      expectAssertion(() => {
        var _class59, _descriptor30;
        let Foo = (_class59 = class Foo {
          constructor() {
            _initializerDefineProperty(this, "foo", _descriptor30, this);
          }
        }, _descriptor30 = _applyDecoratedDescriptor(_class59.prototype, "foo", [_computed.uniqBy], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: null
        }), _class59);
        new Foo();
      }, /You attempted to use @uniqBy/);
    }
  });
});
define("@ember/object/tests/computed/reduce_computed_macros_test", ["@ember/runloop", "@ember/-internals/metal", "@ember/object", "@ember/object/proxy", "@ember/array", "@ember/object/computed", "internal-test-helpers"], function (_runloop, _metal, _object, _proxy, _array, _computed, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  let obj;
  (0, _internalTestHelpers.moduleFor)('map', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        mapped: (0, _computed.map)('array.@each.v', item => item.v),
        mappedObjects: (0, _computed.map)('arrayObjects.@each.v', item => ({
          name: item.v.name
        }))
      }).create({
        arrayObjects: (0, _array.A)([{
          v: {
            name: 'Robert'
          }
        }, {
          v: {
            name: 'Leanna'
          }
        }]),
        array: (0, _array.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test map is readOnly'](assert) {
      assert.throws(function () {
        obj.set('mapped', 1);
      }, /Cannot set read-only property "mapped" on object:/);
    }
    ['@test it maps simple properties'](assert) {
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      obj.get('array').pushObject({
        v: 5
      });
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);
      (0, _array.removeAt)(obj.get('array'), 3);
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
    }
    ['@test it maps simple unshifted properties'](assert) {
      let array = (0, _array.A)();
      obj = _object.default.extend({
        mapped: (0, _computed.map)('array', item => item.toUpperCase())
      }).create({
        array
      });
      array.unshiftObject('c');
      array.unshiftObject('b');
      array.unshiftObject('a');
      array.popObject();
      assert.deepEqual(obj.get('mapped'), ['A', 'B'], 'properties unshifted in sequence are mapped correctly');
    }
    ['@test it has the correct `this`'](assert) {
      obj = _object.default.extend({
        mapped: (0, _computed.map)('array', function (item) {
          assert.equal(this, obj, 'should have correct context');
          return this.upperCase(item);
        }),
        upperCase(string) {
          return string.toUpperCase();
        }
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual(obj.get('mapped'), ['A', 'B', 'C'], 'properties unshifted in sequence are mapped correctly');
    }
    ['@test it passes the index to the callback'](assert) {
      let array = ['a', 'b', 'c'];
      obj = _object.default.extend({
        mapped: (0, _computed.map)('array', (item, index) => index)
      }).create({
        array
      });
      assert.deepEqual(obj.get('mapped'), [0, 1, 2], 'index is passed to callback correctly');
    }
    ['@test it maps objects'](assert) {
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Leanna'
      }]);
      obj.get('arrayObjects').pushObject({
        v: {
          name: 'Eddard'
        }
      });
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Leanna'
      }, {
        name: 'Eddard'
      }]);
      (0, _array.removeAt)(obj.get('arrayObjects'), 1);
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Eddard'
      }]);
      (0, _object.set)(obj.get('arrayObjects')[0], 'v', {
        name: 'Stannis'
      });
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Stannis'
      }, {
        name: 'Eddard'
      }]);
    }
    ['@test it maps unshifted objects with property observers'](assert) {
      let array = (0, _array.A)();
      let cObj = {
        v: 'c'
      };
      obj = _object.default.extend({
        mapped: (0, _computed.map)('array.@each.v', item => (0, _object.get)(item, 'v').toUpperCase())
      }).create({
        array
      });
      array.unshiftObject(cObj);
      array.unshiftObject({
        v: 'b'
      });
      array.unshiftObject({
        v: 'a'
      });
      (0, _object.set)(cObj, 'v', 'd');
      assert.deepEqual(array.mapBy('v'), ['a', 'b', 'd'], 'precond - unmapped array is correct');
      assert.deepEqual(obj.get('mapped'), ['A', 'B', 'D'], 'properties unshifted in sequence are mapped correctly');
    }
    ['@test it updates if additional dependent keys are modified'](assert) {
      obj = _object.default.extend({
        mapped: (0, _computed.map)('array', ['key'], function (item) {
          return item[this.key];
        })
      }).create({
        key: 'name',
        array: (0, _array.A)([{
          name: 'Cercei',
          house: 'Lannister'
        }])
      });
      assert.deepEqual(obj.get('mapped'), ['Cercei'], 'precond - mapped array is initially correct');
      obj.set('key', 'house');
      assert.deepEqual(obj.get('mapped'), ['Lannister'], 'mapped prop updates correctly when additional dependency is updated');
    }
    ['@test it throws on bad inputs']() {
      expectAssertion(() => {
        (0, _computed.map)('items.@each.{prop}', 'foo');
      }, /The final parameter provided to map must be a callback function/);
      expectAssertion(() => {
        (0, _computed.map)('items.@each.{prop}', 'foo', function () {});
      }, /The second parameter provided to map must either be the callback or an array of additional dependent keys/);
      expectAssertion(() => {
        (0, _computed.map)('items.@each.{prop}', function () {}, ['foo']);
      }, /The final parameter provided to map must be a callback function/);
      expectAssertion(() => {
        (0, _computed.map)('items.@each.{prop}', ['foo']);
      }, /The final parameter provided to map must be a callback function/);
    }
  });
  (0, _internalTestHelpers.moduleFor)('mapBy', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        mapped: (0, _computed.mapBy)('array', 'v')
      }).create({
        array: (0, _array.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test mapBy is readOnly'](assert) {
      assert.throws(function () {
        obj.set('mapped', 1);
      }, /Cannot set read-only property "mapped" on object:/);
    }
    ['@test it maps properties'](assert) {
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      obj.get('array').pushObject({
        v: 5
      });
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);
      (0, _array.removeAt)(obj.get('array'), 3);
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
    }
    async ['@test it is observable'](assert) {
      let calls = 0;
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      (0, _metal.addObserver)(obj, 'mapped.@each', () => calls++);
      obj.get('array').pushObject({
        v: 5
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(calls, 1, 'mapBy is observable');
    }
  });
  (0, _internalTestHelpers.moduleFor)('filter', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        filtered: (0, _computed.filter)('array', item => item % 2 === 0)
      }).create({
        array: (0, _array.A)([1, 2, 3, 4, 5, 6, 7, 8])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test filter is readOnly'](assert) {
      assert.throws(function () {
        obj.set('filtered', 1);
      }, /Cannot set read-only property "filtered" on object:/);
    }
    ['@test it filters according to the specified filter function'](assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'filter filters by the specified function');
    }
    ['@test it passes the index to the callback'](assert) {
      obj = _object.default.extend({
        filtered: (0, _computed.filter)('array', (item, index) => index === 1)
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual((0, _object.get)(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
    }
    ['@test it has the correct `this`'](assert) {
      obj = _object.default.extend({
        filtered: (0, _computed.filter)('array', function (item, index) {
          assert.equal(this, obj);
          return this.isOne(index);
        }),
        isOne(value) {
          return value === 1;
        }
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual((0, _object.get)(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
    }
    ['@test it passes the array to the callback'](assert) {
      obj = _object.default.extend({
        filtered: (0, _computed.filter)('array', (item, index, array) => index === (0, _object.get)(array, 'length') - 2)
      }).create({
        array: (0, _array.A)(['a', 'b', 'c'])
      });
      assert.deepEqual(obj.get('filtered'), ['b'], 'array is passed to callback correctly');
    }
    ['@test it caches properly'](assert) {
      let array = obj.get('array');
      let filtered = obj.get('filtered');
      assert.ok(filtered === obj.get('filtered'));
      array.addObject(11);
      let newFiltered = obj.get('filtered');
      assert.ok(filtered !== newFiltered);
      assert.ok(obj.get('filtered') === newFiltered);
    }
    ['@test it updates as the array is modified'](assert) {
      let array = obj.get('array');
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      array.addObject(11);
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'objects not passing the filter are not added');
      array.addObject(12);
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8, 12], 'objects passing the filter are added');
      array.removeObject(3);
      array.removeObject(4);
      assert.deepEqual(obj.get('filtered'), [2, 6, 8, 12], 'objects removed from the dependent array are removed from the computed array');
    }
    ['@test the dependent array can be cleared one at a time'](assert) {
      let array = (0, _object.get)(obj, 'array');
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');

      // clear 1-8 but in a random order
      array.removeObject(3);
      array.removeObject(1);
      array.removeObject(2);
      array.removeObject(4);
      array.removeObject(8);
      array.removeObject(6);
      array.removeObject(5);
      array.removeObject(7);
      assert.deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
    }
    ['@test the dependent array can be `clear`ed directly (#3272)'](assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.get('array').clear();
      assert.deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
    }
    ['@test it updates as the array is replaced'](assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.set('array', [20, 21, 22, 23, 24]);
      assert.deepEqual(obj.get('filtered'), [20, 22, 24], 'computed array is updated when array is changed');
    }
    ['@test it updates properly on @each with {} dependencies'](assert) {
      let item = _object.default.create({
        prop: true
      });
      obj = _object.default.extend({
        filtered: (0, _computed.filter)('items.@each.{prop}', function (item) {
          return item.get('prop') === true;
        })
      }).create({
        items: (0, _array.A)([item])
      });
      assert.deepEqual(obj.get('filtered'), [item]);
      item.set('prop', false);
      assert.deepEqual(obj.get('filtered'), []);
    }
    ['@test it updates if additional dependent keys are modified'](assert) {
      obj = _object.default.extend({
        filtered: (0, _computed.filter)('array', ['modulo'], function (item) {
          return item % this.modulo === 0;
        })
      }).create({
        modulo: 2,
        array: (0, _array.A)([1, 2, 3, 4, 5, 6, 7, 8])
      });
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.set('modulo', 3);
      assert.deepEqual(obj.get('filtered'), [3, 6], 'filtered prop updates correctly when additional dependency is updated');
    }
    ['@test it throws on bad inputs']() {
      expectAssertion(() => {
        (0, _computed.filter)('items.@each.{prop}', 'foo');
      }, /The final parameter provided to filter must be a callback function/);
      expectAssertion(() => {
        (0, _computed.filter)('items.@each.{prop}', 'foo', function () {});
      }, /The second parameter provided to filter must either be the callback or an array of additional dependent keys/);
      expectAssertion(() => {
        (0, _computed.filter)('items.@each.{prop}', function () {}, ['foo']);
      }, /The final parameter provided to filter must be a callback function/);
      expectAssertion(() => {
        (0, _computed.filter)('items.@each.{prop}', ['foo']);
      }, /The final parameter provided to filter must be a callback function/);
    }
  });
  (0, _internalTestHelpers.moduleFor)('filterBy', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        a1s: (0, _computed.filterBy)('array', 'a', 1),
        as: (0, _computed.filterBy)('array', 'a'),
        bs: (0, _computed.filterBy)('array', 'b')
      }).create({
        array: (0, _array.A)([{
          name: 'one',
          a: 1,
          b: false
        }, {
          name: 'two',
          a: 2,
          b: false
        }, {
          name: 'three',
          a: 1,
          b: true
        }, {
          name: 'four',
          b: true
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test filterBy is readOnly'](assert) {
      assert.throws(function () {
        obj.set('as', 1);
      }, /Cannot set read-only property "as" on object:/);
    }
    ['@test properties can be filtered by truthiness'](assert) {
      assert.deepEqual(obj.get('as').mapBy('name'), ['one', 'two', 'three'], 'properties can be filtered by existence');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['three', 'four'], 'booleans can be filtered');
      (0, _object.set)(obj.get('array')[0], 'a', undefined);
      (0, _object.set)(obj.get('array')[3], 'a', true);
      (0, _object.set)(obj.get('array')[0], 'b', true);
      (0, _object.set)(obj.get('array')[3], 'b', false);
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to property changes');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to property changes');
      obj.get('array').pushObject({
        name: 'five',
        a: 6,
        b: true
      });
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four', 'five'], 'arrays computed by filter property respond to added objects');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by filtered property respond to added objects');
      obj.get('array').popObject();
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to removed objects');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to removed objects');
      obj.set('array', [{
        name: 'six',
        a: 12,
        b: true
      }]);
      assert.deepEqual(obj.get('as').mapBy('name'), ['six'], 'arrays computed by filter property respond to array changes');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['six'], 'arrays computed by filtered property respond to array changes');
    }
    ['@test properties can be filtered by values'](assert) {
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'properties can be filtered by matching value');
      obj.get('array').pushObject({
        name: 'five',
        a: 1
      });
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by matching value respond to added objects');
      obj.get('array').popObject();
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'arrays computed by matching value respond to removed objects');
      (0, _object.set)(obj.get('array')[1], 'a', 1);
      (0, _object.set)(obj.get('array')[2], 'a', 2);
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'two'], 'arrays computed by matching value respond to modified properties');
    }
    ['@test properties values can be replaced'](assert) {
      obj = _object.default.extend({
        a1s: (0, _computed.filterBy)('array', 'a', 1),
        a1bs: (0, _computed.filterBy)('a1s', 'b')
      }).create({
        array: []
      });
      assert.deepEqual(obj.get('a1bs').mapBy('name'), [], 'properties can be filtered by matching value');
      (0, _object.set)(obj, 'array', [{
        name: 'item1',
        a: 1,
        b: true
      }]);
      assert.deepEqual(obj.get('a1bs').mapBy('name'), ['item1'], 'properties can be filtered by matching value');
    }
  });
  [['uniq', _computed.uniq], ['union', _computed.union]].forEach(tuple => {
    let [name, macro] = tuple;
    (0, _internalTestHelpers.moduleFor)("CP macro `" + name + "`", class extends _internalTestHelpers.AbstractTestCase {
      beforeEach() {
        obj = _object.default.extend({
          union: macro('array', 'array2', 'array3')
        }).create({
          array: (0, _array.A)([1, 2, 3, 4, 5, 6]),
          array2: (0, _array.A)([4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9]),
          array3: (0, _array.A)([1, 8, 10])
        });
      }
      afterEach() {
        (0, _runloop.run)(obj, 'destroy');
      }
      ["@test " + name + " is readOnly"](assert) {
        assert.throws(function () {
          obj.set('union', 1);
        }, /Cannot set read-only property "union" on object:/);
      }
      ['@test does not include duplicates'](assert) {
        let array = obj.get('array');
        let array2 = obj.get('array2');
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not include duplicates');
        array.pushObject(8);
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not add existing items');
        array.pushObject(11);
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' adds new items');
        (0, _array.removeAt)(array2, 6); // remove 7

        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' does not remove items that are still in the dependent array');
        array2.removeObject(7);
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 8, 9, 10, 11], name + ' removes items when their last instance is gone');
      }
      ['@test has set-union semantics'](assert) {
        let array = obj.get('array');
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' is initially correct');
        array.removeObject(6);
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'objects are not removed if they exist in other dependent arrays');
        array.clear();
        assert.deepEqual(obj.get('union').sort((x, y) => x - y), [1, 4, 5, 6, 7, 8, 9, 10], 'objects are removed when they are no longer in any dependent array');
      }
    });
  });
  (0, _internalTestHelpers.moduleFor)('CP Macro `uniqBy`', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        list: null,
        uniqueById: (0, _computed.uniqBy)('list', 'id')
      }).create({
        list: (0, _array.A)([{
          id: 1,
          value: 'one'
        }, {
          id: 2,
          value: 'two'
        }, {
          id: 1,
          value: 'one'
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test uniqBy is readOnly'](assert) {
      assert.throws(function () {
        obj.set('uniqueById', 1);
      }, /Cannot set read-only property "uniqueById" on object:/);
    }
    ['@test does not include duplicates'](assert) {
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }]);
    }
    ['@test it does not share state among instances'](assert) {
      let MyObject = _object.default.extend({
        list: [],
        uniqueByName: (0, _computed.uniqBy)('list', 'name')
      });
      let a = MyObject.create({
        list: [{
          name: 'bob'
        }, {
          name: 'mitch'
        }, {
          name: 'mitch'
        }]
      });
      let b = MyObject.create({
        list: [{
          name: 'warren'
        }, {
          name: 'mitch'
        }]
      });
      assert.deepEqual(a.get('uniqueByName'), [{
        name: 'bob'
      }, {
        name: 'mitch'
      }]);
      // Making sure that 'mitch' appears
      assert.deepEqual(b.get('uniqueByName'), [{
        name: 'warren'
      }, {
        name: 'mitch'
      }]);
    }
    ['@test it handles changes to the dependent array'](assert) {
      obj.get('list').pushObject({
        id: 3,
        value: 'three'
      });
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 3,
        value: 'three'
      }], 'The list includes three');
      obj.get('list').pushObject({
        id: 3,
        value: 'three'
      });
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 3,
        value: 'three'
      }], 'The list does not include a duplicate three');
    }
    ['@test it returns an empty array when computed on a non-array'](assert) {
      let MyObject = _object.default.extend({
        list: null,
        uniq: (0, _computed.uniqBy)('list', 'name')
      });
      let a = MyObject.create({
        list: 'not an array'
      });
      assert.deepEqual(a.get('uniq'), []);
    }
  });
  (0, _internalTestHelpers.moduleFor)('CP Macro `intersect`', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        intersection: (0, _computed.intersect)('array', 'array2', 'array3')
      }).create({
        array: (0, _array.A)([1, 2, 3, 4, 5, 6]),
        array2: (0, _array.A)([3, 3, 3, 4, 5]),
        array3: (0, _array.A)([3, 5, 6, 7, 8])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test intersect is readOnly'](assert) {
      assert.throws(function () {
        obj.set('intersection', 1);
      }, /Cannot set read-only property "intersection" on object:/);
    }
    ['@test it has set-intersection semantics'](assert) {
      let array2 = obj.get('array2');
      let array3 = obj.get('array3');
      assert.deepEqual(obj.get('intersection').sort((x, y) => x - y), [3, 5], 'intersection is initially correct');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection').sort((x, y) => x - y), [3, 5], 'objects are not removed when they are still in all dependent arrays');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection').sort((x, y) => x - y), [3, 5], 'objects are not removed when they are still in all dependent arrays');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection'), [5], 'objects are removed once they are gone from all dependent arrays');
      array2.pushObject(1);
      assert.deepEqual(obj.get('intersection'), [5], 'objects are not added as long as they are missing from any dependent array');
      array3.pushObject(1);
      assert.deepEqual(obj.get('intersection').sort((x, y) => x - y), [1, 5], 'objects added once they belong to all dependent arrays');
    }
  });
  (0, _internalTestHelpers.moduleFor)('setDiff', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        diff: (0, _computed.setDiff)('array', 'array2')
      }).create({
        array: (0, _array.A)([1, 2, 3, 4, 5, 6, 7]),
        array2: (0, _array.A)([3, 4, 5, 10])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test setDiff is readOnly'](assert) {
      assert.throws(function () {
        obj.set('diff', 1);
      }, /Cannot set read-only property "diff" on object:/);
    }
    ['@test it asserts if given fewer or more than two dependent properties']() {
      expectAssertion(function () {
        _object.default.extend({
          diff: (0, _computed.setDiff)('array')
        }).create({
          array: (0, _array.A)([1, 2, 3, 4, 5, 6, 7]),
          array2: (0, _array.A)([3, 4, 5])
        });
      }, /`setDiff` computed macro requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
      expectAssertion(function () {
        _object.default.extend({
          diff: (0, _computed.setDiff)('array', 'array2', 'array3')
        }).create({
          array: (0, _array.A)([1, 2, 3, 4, 5, 6, 7]),
          array2: (0, _array.A)([3, 4, 5]),
          array3: (0, _array.A)([7])
        });
      }, /`setDiff` computed macro requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
    }
    ['@test it has set-diff semantics'](assert) {
      let array1 = obj.get('array');
      let array2 = obj.get('array2');
      assert.deepEqual(obj.get('diff').sort((x, y) => x - y), [1, 2, 6, 7], 'set-diff is initially correct');
      array2.popObject();
      assert.deepEqual(obj.get('diff').sort((x, y) => x - y), [1, 2, 6, 7], 'removing objects from the remove set has no effect if the object is not in the keep set');
      array2.shiftObject();
      assert.deepEqual(obj.get('diff').sort((x, y) => x - y), [1, 2, 3, 6, 7], "removing objects from the remove set adds them if they're in the keep set");
      array1.removeObject(3);
      assert.deepEqual(obj.get('diff').sort((x, y) => x - y), [1, 2, 6, 7], 'removing objects from the keep array removes them from the computed array');
      array1.pushObject(5);
      assert.deepEqual(obj.get('diff').sort((x, y) => x - y), [1, 2, 6, 7], 'objects added to the keep array that are in the remove array are not added to the computed array');
      array1.pushObject(22);
      assert.deepEqual(obj.get('diff').sort((x, y) => x - y), [1, 2, 6, 7, 22], 'objects added to the keep array not in the remove array are added to the computed array');
    }
  });
  class SortWithSortPropertiesTestCase extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      this.obj = this.buildObject();
    }
    afterEach() {
      if (this.obj) {
        this.cleanupObject();
      }
    }
    ['@test sort is readOnly'](assert) {
      assert.throws(() => {
        (0, _object.set)(this.obj, 'sortedItems', 1);
      }, /Cannot set read-only property "sortedItems" on object:/);
    }
    ['@test arrays are initially sorted'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    }
    ['@test default sort order is correct'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    }
    ['@test changing the dependent array updates the sorted array'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(this.obj, 'items', [{
        fname: 'Roose',
        lname: 'Bolton'
      }, {
        fname: 'Theon',
        lname: 'Greyjoy'
      }, {
        fname: 'Ramsey',
        lname: 'Bolton'
      }, {
        fname: 'Stannis',
        lname: 'Baratheon'
      }]);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    }
    ['@test adding to the dependent array updates the sorted array'](assert) {
      let items = this.obj.items;
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    }
    ['@test removing from the dependent array updates the sorted array'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      this.obj.items.popObject();
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    }
    ['@test distinct items may be sort-equal, although their relative order will not be guaranteed'](assert) {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      let jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };
      let jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };
      let items = this.obj.items;
      items.replace(0, 1, [jaime]);
      items.replace(1, 1, [jaimeInDisguise]);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(jaimeInDisguise, 'fname', 'Jaime');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
      (0, _object.set)(jaimeInDisguise, 'fname', 'Cersei');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    }
    ['@test guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys'](assert) {
      let tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };
      let tyrionInDisguise = _proxy.default.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });
      let items = this.obj.items;
      items.pushObject(tyrion);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
      items.pushObject(tyrionInDisguise);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    }
    ['@test updating sort properties detaches observers for old sort properties'](assert) {
      let objectToRemove = this.obj.items[3];
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(this.obj, 'itemSorting', (0, _array.A)(['fname:desc']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
      this.obj.items.removeObject(objectToRemove);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after removing item array is updated');
      (0, _object.set)(objectToRemove, 'lname', 'Updated-Stark');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after changing removed item array is not updated');
    }
    ['@test sort works if array property is null (non array value) on first evaluation of computed prop'](assert) {
      (0, _object.set)(this.obj, 'items', null);
      assert.deepEqual(this.obj.sortedItems, []);
      (0, _object.set)(this.obj, 'items', (0, _array.A)([{
        fname: 'Cersei',
        lname: 'Lanister'
      }]));
      assert.deepEqual(this.obj.sortedItems, [{
        fname: 'Cersei',
        lname: 'Lanister'
      }]);
    }
    ['@test updating sort properties updates the sorted array'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(this.obj, 'itemSorting', (0, _array.A)(['fname:desc']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
    }
    ['@test updating sort properties invalidates the sorted array'](assert) {
      let sortProps = this.obj.itemSorting;
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      sortProps.clear();
      sortProps.pushObject('fname');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'after updating sort properties array is updated');
    }
    ['@test updating new sort properties invalidates the sorted array'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(this.obj, 'itemSorting', (0, _array.A)(['age:desc', 'fname:asc']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Robb', 'Bran'], 'precond - array is correct after item sorting is changed');
      (0, _object.set)(this.obj.items[1], 'age', 29);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Cersei', 'Robb', 'Bran'], 'after updating sort properties array is updated');
    }
    ['@test sort direction defaults to ascending'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb']);
    }
    ['@test sort direction defaults to ascending (with sort property change)'](assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(this.obj, 'itemSorting', (0, _array.A)(['fname']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'sort direction defaults to ascending');
    }
    ["@test updating an item's sort properties updates the sorted array"](assert) {
      let tyrionInDisguise = this.obj.items[1];
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(tyrionInDisguise, 'fname', 'Tyrion');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], "updating an item's sort properties updates the sorted array");
    }
    ["@test updating several of an item's sort properties updated the sorted array"](assert) {
      let sansaInDisguise = this.obj.items[1];
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.setProperties)(sansaInDisguise, {
        fname: 'Sansa',
        lname: 'Stark'
      });
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Bran', 'Robb', 'Sansa'], "updating an item's sort properties updates the sorted array");
    }
    ["@test updating an item's sort properties does not error when binary search does a self compare (#3273)"](assert) {
      let jaime = {
        name: 'Jaime',
        status: 1
      };
      let cersei = {
        name: 'Cersei',
        status: 2
      };
      this.cleanupObject();
      this.obj = this.buildObject([jaime, cersei], ['status']);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei], 'precond - array is initially sorted');
      (0, _object.set)(cersei, 'status', 3);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei], 'array is sorted correctly');
      (0, _object.set)(cersei, 'status', 2);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei], 'array is sorted correctly');
    }
    ['@test array should not be sorted if sort properties array is empty'](assert) {
      this.cleanupObject();
      // This bug only manifests when array.sort(() => 0) is not equal to array.
      // In order for this to happen, the browser must use an unstable sort and the
      // array must be sufficient large. On Chrome, 12 items is currently sufficient.
      this.obj = this.buildObject((0, _array.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]), []);
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
    }
    ['@test array should update if items to be sorted is replaced when sort properties array is empty'](assert) {
      this.cleanupObject();
      this.obj = this.buildObject((0, _array.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]), (0, _array.A)([]));
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
      (0, _object.set)(this.obj, 'items', (0, _array.A)([5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4]));
      assert.deepEqual(this.obj.sortedItems, [5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4], 'array was updated');
    }
    ['@test array should update if items to be sorted is mutated when sort properties array is empty'](assert) {
      this.cleanupObject();
      this.obj = this.buildObject((0, _array.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]), (0, _array.A)([]));
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
      this.obj.items.pushObject(12);
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 12], 'array was updated');
    }
    ['@test array observers do not leak'](assert) {
      let daria = {
        name: 'Daria'
      };
      let jane = {
        name: 'Jane'
      };
      let sisters = [jane, daria];
      let sortProps = (0, _array.A)(['name']);
      this.cleanupObject();
      this.obj = this.buildObject(sisters, sortProps);
      this.obj.sortedItems;
      this.cleanupObject();
      try {
        sortProps.pushObject({
          name: 'Anna'
        });
        assert.ok(true);
      } catch (e) {
        assert.ok(false, e);
      }
    }
    ['@test property paths in sort properties update the sorted array'](assert) {
      let jaime = {
        relatedObj: {
          status: 1,
          firstName: 'Jaime',
          lastName: 'Lannister'
        }
      };
      let cersei = {
        relatedObj: {
          status: 2,
          firstName: 'Cersei',
          lastName: 'Lannister'
        }
      };
      let sansa = _object.default.create({
        relatedObj: {
          status: 3,
          firstName: 'Sansa',
          lastName: 'Stark'
        }
      });
      this.cleanupObject();
      this.obj = this.buildObject([jaime, cersei, sansa], ['relatedObj.status']);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'precond - array is initially sorted');
      (0, _object.set)(cersei, 'status', 3);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'array is sorted correctly');
      (0, _object.set)(cersei, 'status', 1);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'array is sorted correctly');
      sansa.set('status', 1);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'array is sorted correctly');
      (0, _object.set)(this.obj, 'itemSorting', ['relatedObj.firstName']);
      assert.deepEqual(this.obj.sortedItems, [cersei, jaime, sansa], 'array is sorted correctly');
    }
    ['@test if the dependentKey is neither an array nor object, it will return an empty array'](assert) {
      (0, _object.set)(this.obj, 'items', null);
      assert.ok((0, _array.isArray)(this.obj.sortedItems), 'returns an empty arrays');
      (0, _object.set)(this.obj, 'array', undefined);
      assert.ok((0, _array.isArray)(this.obj.sortedItems), 'returns an empty arrays');
      (0, _object.set)(this.obj, 'array', 'not an array');
      assert.ok((0, _array.isArray)(this.obj.sortedItems), 'returns an empty arrays');
    }
  }
  (0, _internalTestHelpers.moduleFor)('sort - sortProperties - Ember.Object', class extends SortWithSortPropertiesTestCase {
    buildObject(_items, _itemSorting) {
      let items = _items || (0, _array.A)([{
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      }, {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      }, {
        fname: 'Robb',
        lname: 'Stark',
        age: 16
      }, {
        fname: 'Bran',
        lname: 'Stark',
        age: 8
      }]);
      let itemSorting = _itemSorting || (0, _array.A)(['lname', 'fname']);
      return _object.default.extend({
        sortedItems: (0, _computed.sort)('items', 'itemSorting')
      }).create({
        itemSorting,
        items
      });
    }
    cleanupObject() {
      (0, _runloop.run)(this.obj, 'destroy');
    }
  });
  (0, _internalTestHelpers.moduleFor)('sort - sortProperties - Native Class', class extends SortWithSortPropertiesTestCase {
    buildObject(_items, _itemSorting) {
      var _dec, _class, _descriptor;
      let items = _items || (0, _array.A)([{
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      }, {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      }, {
        fname: 'Robb',
        lname: 'Stark',
        age: 16
      }, {
        fname: 'Bran',
        lname: 'Stark',
        age: 8
      }]);
      let itemSorting = _itemSorting || (0, _array.A)(['lname', 'fname']);
      return new (_dec = (0, _computed.sort)('items', 'itemSorting'), (_class = class _class {
        constructor() {
          this.items = items;
          this.itemSorting = itemSorting;
          _initializerDefineProperty(this, "sortedItems", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "sortedItems", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class))();
    }
    cleanupObject() {}
  });
  function sortByLnameFname(a, b) {
    let lna = (0, _object.get)(a, 'lname');
    let lnb = (0, _object.get)(b, 'lname');
    if (lna !== lnb) {
      return lna > lnb ? 1 : -1;
    }
    return sortByFnameAsc(a, b);
  }
  function sortByFnameAsc(a, b) {
    let fna = (0, _object.get)(a, 'fname');
    let fnb = (0, _object.get)(b, 'fname');
    if (fna === fnb) {
      return 0;
    }
    return fna > fnb ? 1 : -1;
  }
  (0, _internalTestHelpers.moduleFor)('sort - sort function', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        sortedItems: (0, _computed.sort)('items.@each.fname', sortByLnameFname)
      }).create({
        items: (0, _array.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test sort has correct `this`'](assert) {
      let obj = _object.default.extend({
        sortedItems: (0, _computed.sort)('items.@each.fname', function (a, b) {
          assert.equal(this, obj, 'expected the object to be `this`');
          return this.sortByLastName(a, b);
        }),
        sortByLastName(a, b) {
          return sortByFnameAsc(a, b);
        }
      }).create({
        items: (0, _array.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
      obj.get('sortedItems');
    }
    ['@test sort (with function) is readOnly'](assert) {
      assert.throws(function () {
        obj.set('sortedItems', 1);
      }, /Cannot set read-only property "sortedItems" on object:/);
    }
    ['@test arrays are initially sorted'](assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    }
    ['@test default sort order is correct'](assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    }
    ['@test changing the dependent array updates the sorted array'](assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('items', [{
        fname: 'Roose',
        lname: 'Bolton'
      }, {
        fname: 'Theon',
        lname: 'Greyjoy'
      }, {
        fname: 'Ramsey',
        lname: 'Bolton'
      }, {
        fname: 'Stannis',
        lname: 'Baratheon'
      }]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    }
    ['@test adding to the dependent array updates the sorted array'](assert) {
      let items = obj.get('items');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    }
    ['@test removing from the dependent array updates the sorted array'](assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.get('items').popObject();
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    }
    ['@test distinct items may be sort-equal, although their relative order will not be guaranteed'](assert) {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      let jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };
      let jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };
      let items = obj.get('items');
      items.replace(0, 1, [jaime]);
      items.replace(1, 1, [jaimeInDisguise]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(jaimeInDisguise, 'fname', 'Jaime');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
      (0, _object.set)(jaimeInDisguise, 'fname', 'Cersei');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    }
    ['@test guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys'](assert) {
      let tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };
      let tyrionInDisguise = _proxy.default.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });
      let items = obj.get('items');
      items.pushObject(tyrion);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
      items.pushObject(tyrionInDisguise);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    }
    ['@test changing item properties specified via @each triggers a resort of the modified item'](assert) {
      let items = (0, _object.get)(obj, 'items');
      let tyrionInDisguise = items[1];
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _object.set)(tyrionInDisguise, 'fname', 'Tyrion');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], 'updating a specified property on an item resorts it');
    }
    ['@test sort updates if additional dependent keys are present'](assert) {
      obj = _object.default.extend({
        sortedItems: (0, _computed.sort)('items', ['sortFunction'], function () {
          return this.sortFunction(...arguments);
        })
      }).create({
        sortFunction: sortByLnameFname,
        items: (0, _array.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
      obj.set('sortFunction', (a, b) => {
        if (a.age > b.age) {
          return -1;
        } else if (a.age < b.age) {
          return 1;
        }
        return 0;
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Cersei', 'Robb', 'Bran'], 'array is updated when dependent key changes');
    }
    ['@test it throws on bad inputs']() {
      expectAssertion(() => {
        (0, _computed.sort)('foo', 'bar', 'baz');
      }, /`sort` computed macro can either be used with an array of sort properties or with a sort function/);
      expectAssertion(() => {
        (0, _computed.sort)('foo', ['bar'], 'baz');
      }, /`sort` computed macro can either be used with an array of sort properties or with a sort function/);
      expectAssertion(() => {
        (0, _computed.sort)('foo', 'bar', function () {});
      }, /`sort` computed macro can either be used with an array of sort properties or with a sort function/);
      expectAssertion(() => {
        (0, _computed.sort)('foo', ['bar'], function () {}, 'baz');
      }, /`sort` computed macro can either be used with an array of sort properties or with a sort function/);
    }
  });
  (0, _internalTestHelpers.moduleFor)('sort - stability', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        sortProps: ['count', 'name'],
        sortedItems: (0, _computed.sort)('items', 'sortProps')
      }).create({
        items: [{
          name: 'A',
          count: 1,
          thing: 4
        }, {
          name: 'B',
          count: 1,
          thing: 3
        }, {
          name: 'C',
          count: 1,
          thing: 2
        }, {
          name: 'D',
          count: 1,
          thing: 4
        }]
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test sorts correctly as only one property changes'](assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _object.set)(obj.get('items')[3], 'count', 2);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'final');
    }
  });
  let klass;
  (0, _internalTestHelpers.moduleFor)('sort - concurrency', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      klass = _object.default.extend({
        sortProps: ['count'],
        sortedItems: (0, _computed.sort)('items', 'sortProps'),
        customSortedItems: (0, _computed.sort)('items.@each.count', (a, b) => a.count - b.count)
      });
      obj = klass.create({
        items: (0, _array.A)([{
          name: 'A',
          count: 1,
          thing: 4,
          id: 1
        }, {
          name: 'B',
          count: 2,
          thing: 3,
          id: 2
        }, {
          name: 'C',
          count: 3,
          thing: 2,
          id: 3
        }, {
          name: 'D',
          count: 4,
          thing: 1,
          id: 4
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test sorts correctly after mutation to the sort properties'](assert) {
      let sorted = obj.get('sortedItems');
      assert.deepEqual(sorted.mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _object.set)(obj.get('items')[1], 'count', 5);
      (0, _object.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    }
    ['@test sort correctly after mutation to the sort'](assert) {
      assert.deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _object.set)(obj.get('items')[1], 'count', 5);
      (0, _object.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    }
    ['@test sort correctly on multiple instances of the same class'](assert) {
      let obj2 = klass.create({
        items: (0, _array.A)([{
          name: 'W',
          count: 23,
          thing: 4
        }, {
          name: 'X',
          count: 24,
          thing: 3
        }, {
          name: 'Y',
          count: 25,
          thing: 2
        }, {
          name: 'Z',
          count: 26,
          thing: 1
        }])
      });
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'X', 'Y', 'Z'], 'initial');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _object.set)(obj.get('items')[1], 'count', 5);
      (0, _object.set)(obj.get('items')[2], 'count', 6);
      (0, _object.set)(obj2.get('items')[1], 'count', 27);
      (0, _object.set)(obj2.get('items')[2], 'count', 28);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'Z', 'X', 'Y'], 'final');
      obj.set('sortProps', ['thing']);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'final');
      obj2.notifyPropertyChange('sortedItems'); // invalidate to flush, to get DK refreshed
      obj2.get('sortedItems'); // flush to get updated DK

      obj2.set('items.firstObject.count', 9999);
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['Z', 'X', 'Y', 'W'], 'final');
    }
    ['@test sort correctly when multiple sorts are chained on the same instance of a class'](assert) {
      let obj2 = klass.extend({
        items: (0, _object.computed)('sibling.sortedItems.[]', function () {
          return this.get('sibling.sortedItems');
        }),
        asdf: (0, _object.observer)('sibling.sortedItems.[]', function () {
          this.get('sibling.sortedItems');
        })
      }).create({
        sibling: obj
      });

      /*
                                                                           
                                             sortedProps                              sortedProps2
                                                                           
                                                                                              
                                                                                 
                                                           CP (sort)        
                                                                                 
                                                                                              
                                                                
                                                                            
         items     items.@each.count  sortedItems  items.@each.count  sortedItems2
                                                                            
                                                                
      */

      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj.sortedItems.name should be sorted alpha');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj2.sortedItems.name should be sorted alpha');
      (0, _object.set)(obj.get('items')[1], 'count', 5);
      (0, _object.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj.sortedItems.name should now have changed');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj2.sortedItems.name should still mirror sortedItems2');
      obj.set('sortProps', ['thing']);
      obj2.set('sortProps', ['id']);
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'we now sort obj2 by id, so we expect a b c d');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'we now sort obj by thing');
      obj2.destroy();
    }
  });
  (0, _internalTestHelpers.moduleFor)('max', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        max: (0, _computed.max)('items')
      }).create({
        items: (0, _array.A)([1, 2, 3])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test max is readOnly'](assert) {
      assert.throws(function () {
        obj.set('max', 1);
      }, /Cannot set read-only property "max" on object:/);
    }
    ['@test max tracks the max number as objects are added'](assert) {
      assert.equal(obj.get('max'), 3, 'precond - max is initially correct');
      let items = obj.get('items');
      items.pushObject(5);
      assert.equal(obj.get('max'), 5, 'max updates when a larger number is added');
      items.pushObject(2);
      assert.equal(obj.get('max'), 5, 'max does not update when a smaller number is added');
    }
    ['@test max recomputes when the current max is removed'](assert) {
      assert.equal(obj.get('max'), 3, 'precond - max is initially correct');
      obj.get('items').removeObject(2);
      assert.equal(obj.get('max'), 3, 'max is unchanged when a non-max item is removed');
      obj.get('items').removeObject(3);
      assert.equal(obj.get('max'), 1, 'max is recomputed when the current max is removed');
    }
  });
  (0, _internalTestHelpers.moduleFor)('min', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        min: (0, _computed.min)('items')
      }).create({
        items: (0, _array.A)([1, 2, 3])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test min is readOnly'](assert) {
      assert.throws(function () {
        obj.set('min', 1);
      }, /Cannot set read-only property "min" on object:/);
    }
    ['@test min tracks the min number as objects are added'](assert) {
      assert.equal(obj.get('min'), 1, 'precond - min is initially correct');
      obj.get('items').pushObject(-2);
      assert.equal(obj.get('min'), -2, 'min updates when a smaller number is added');
      obj.get('items').pushObject(2);
      assert.equal(obj.get('min'), -2, 'min does not update when a larger number is added');
    }
    ['@test min recomputes when the current min is removed'](assert) {
      let items = obj.get('items');
      assert.equal(obj.get('min'), 1, 'precond - min is initially correct');
      items.removeObject(2);
      assert.equal(obj.get('min'), 1, 'min is unchanged when a non-min item is removed');
      items.removeObject(1);
      assert.equal(obj.get('min'), 3, 'min is recomputed when the current min is removed');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Ember.arrayComputed - mixed sugar', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        lannisters: (0, _computed.filterBy)('items', 'lname', 'Lannister'),
        lannisterSorting: (0, _array.A)(['fname']),
        sortedLannisters: (0, _computed.sort)('lannisters', 'lannisterSorting'),
        starks: (0, _computed.filterBy)('items', 'lname', 'Stark'),
        starkAges: (0, _computed.mapBy)('starks', 'age'),
        oldestStarkAge: (0, _computed.max)('starkAges')
      }).create({
        items: (0, _array.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test filtering and sorting can be combined'](assert) {
      let items = obj.get('items');
      assert.deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Jaime'], 'precond - array is initially filtered and sorted');
      items.pushObject({
        fname: 'Tywin',
        lname: 'Lannister'
      });
      items.pushObject({
        fname: 'Lyanna',
        lname: 'Stark'
      });
      items.pushObject({
        fname: 'Gerion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Gerion', 'Jaime', 'Tywin'], 'updates propagate to array');
    }
    ['@test filtering, sorting and reduce (max) can be combined'](assert) {
      let items = obj.get('items');
      assert.equal(16, obj.get('oldestStarkAge'), 'precond - end of chain is initially correct');
      items.pushObject({
        fname: 'Rickon',
        lname: 'Stark',
        age: 5
      });
      assert.equal(16, obj.get('oldestStarkAge'), 'chain is updated correctly');
      items.pushObject({
        fname: 'Eddard',
        lname: 'Stark',
        age: 35
      });
      assert.equal(35, obj.get('oldestStarkAge'), 'chain is updated correctly');
    }
  });
  function todo(name, priority) {
    return _object.default.create({
      name: name,
      priority: priority
    });
  }
  function priorityComparator(todoA, todoB) {
    let pa = parseInt((0, _object.get)(todoA, 'priority'), 10);
    let pb = parseInt((0, _object.get)(todoB, 'priority'), 10);
    return pa - pb;
  }
  function evenPriorities(todo) {
    let p = parseInt((0, _object.get)(todo, 'priority'), 10);
    return p % 2 === 0;
  }
  (0, _internalTestHelpers.moduleFor)('Ember.arrayComputed - chains', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        sorted: (0, _computed.sort)('todos.@each.priority', priorityComparator),
        filtered: (0, _computed.filter)('sorted.@each.priority', evenPriorities)
      }).create({
        todos: (0, _array.A)([todo('E', 4), todo('D', 3), todo('C', 2), todo('B', 1), todo('A', 0)])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test it can filter and sort when both depend on the same item property'](assert) {
      assert.deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos initially correct');
      assert.deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'D', 'E'], 'precond - sorted initially correct');
      assert.deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E'], 'precond - filtered initially correct');
      (0, _object.set)(obj.get('todos')[1], 'priority', 6);
      assert.deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos remain correct');
      assert.deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'E', 'D'], 'precond - sorted updated correctly');
      assert.deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E', 'D'], 'filtered updated correctly');
    }
  });
  let userFnCalls;
  (0, _internalTestHelpers.moduleFor)('Chaining array and reduced CPs', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      userFnCalls = 0;
      obj = _object.default.extend({
        mapped: (0, _computed.mapBy)('array', 'v'),
        max: (0, _computed.max)('mapped'),
        maxDidChange: (0, _object.observer)('max', () => userFnCalls++)
      }).create({
        array: (0, _array.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    async ['@test it computes interdependent array computed properties'](assert) {
      assert.equal(obj.get('max'), 3, 'sanity - it properly computes the maximum value');
      let calls = 0;
      (0, _metal.addObserver)(obj, 'max', () => calls++);
      obj.get('array').pushObject({
        v: 5
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(obj.get('max'), 5, 'maximum value is updated correctly');
      assert.equal(userFnCalls, 1, 'object defined observers fire');
      assert.equal(calls, 1, 'runtime created observers fire');
    }
  });
  (0, _internalTestHelpers.moduleFor)('sum', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = _object.default.extend({
        total: (0, _computed.sum)('array')
      }).create({
        array: (0, _array.A)([1, 2, 3])
      });
    }
    afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    }
    ['@test sum is readOnly'](assert) {
      assert.throws(function () {
        obj.set('total', 1);
      }, /Cannot set read-only property "total" on object:/);
    }
    ['@test sums the values in the dependentKey'](assert) {
      assert.equal(obj.get('total'), 6, 'sums the values');
    }
    ['@test if the dependentKey is neither an array nor object, it will return `0`'](assert) {
      (0, _object.set)(obj, 'array', null);
      assert.equal((0, _object.get)(obj, 'total'), 0, 'returns 0');
      (0, _object.set)(obj, 'array', undefined);
      assert.equal((0, _object.get)(obj, 'total'), 0, 'returns 0');
      (0, _object.set)(obj, 'array', 'not an array');
      assert.equal((0, _object.get)(obj, 'total'), 0, 'returns 0');
    }
    ['@test updates when array is modified'](assert) {
      obj.get('array').pushObject(1);
      assert.equal(obj.get('total'), 7, 'recomputed when elements are added');
      obj.get('array').popObject();
      assert.equal(obj.get('total'), 6, 'recomputes when elements are removed');
    }
  });
  (0, _internalTestHelpers.moduleFor)('collect', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works'](assert) {
      let obj = {
        one: 'foo',
        two: 'bar',
        three: null
      };
      (0, _object.defineProperty)(obj, 'all', (0, _computed.collect)('one', 'two', 'three', 'four'));
      assert.deepEqual((0, _object.get)(obj, 'all'), ['foo', 'bar', null, null], 'have all of them');
      (0, _object.set)(obj, 'four', true);
      assert.deepEqual((0, _object.get)(obj, 'all'), ['foo', 'bar', null, true], 'have all of them');
      let a = [];
      (0, _object.set)(obj, 'one', 0);
      (0, _object.set)(obj, 'three', a);
      assert.deepEqual((0, _object.get)(obj, 'all'), [0, 'bar', a, true], 'have all of them');
    }
  });
});
define("@ember/object/tests/computed_test", ["@ember/-internals/metal", "@ember/object/computed", "@ember/array", "@ember/object", "internal-test-helpers"], function (_metal, _computed, _array, _object, _internalTestHelpers) {
  "use strict";

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function K() {
    return this;
  }
  function testGet(assert, expect, x, y) {
    assert.equal((0, _object.get)(x, y), expect);
    assert.equal((0, _object.get)(x, y), expect);
    assert.equal(x.get(y), expect);
  }
  (0, _internalTestHelpers.moduleFor)('EmberObject computed property', class extends _internalTestHelpers.AbstractTestCase {
    ['@test computed property on instance'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'FOO';
        })
      });
      testGet(assert, 'FOO', MyClass.create(), 'foo');
    }
    ['@test computed property on subclass'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'FOO';
        })
      });
      let Subclass = MyClass.extend({
        foo: (0, _object.computed)(function () {
          return 'BAR';
        })
      });
      testGet(assert, 'BAR', Subclass.create(), 'foo');
    }
    ['@test replacing computed property with regular val'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'FOO';
        })
      });
      let Subclass = MyClass.extend({
        foo: 'BAR'
      });
      testGet(assert, 'BAR', Subclass.create(), 'foo');
    }
    ['@test complex dependent keys'](assert) {
      let MyClass = _object.default.extend({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'bar', {
            baz: 'BIFF'
          });
        },
        count: 0,
        foo: (0, _object.computed)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
          return (0, _object.get)((0, _object.get)(this, 'bar'), 'baz') + ' ' + (0, _object.get)(this, 'count');
        })
      });
      let Subclass = MyClass.extend({
        count: 20
      });
      let obj1 = MyClass.create();
      let obj2 = Subclass.create();
      testGet(assert, 'BIFF 1', obj1, 'foo');
      testGet(assert, 'BIFF 21', obj2, 'foo');
      (0, _object.set)((0, _object.get)(obj1, 'bar'), 'baz', 'BLARG');
      testGet(assert, 'BLARG 2', obj1, 'foo');
      testGet(assert, 'BIFF 21', obj2, 'foo');
      (0, _object.set)((0, _object.get)(obj2, 'bar'), 'baz', 'BOOM');
      testGet(assert, 'BLARG 2', obj1, 'foo');
      testGet(assert, 'BOOM 22', obj2, 'foo');
    }
    ['@test complex dependent keys changing complex dependent keys'](assert) {
      let MyClass = _object.default.extend({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'bar', {
            baz: 'BIFF'
          });
        },
        count: 0,
        foo: (0, _object.computed)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
          return (0, _object.get)((0, _object.get)(this, 'bar'), 'baz') + ' ' + (0, _object.get)(this, 'count');
        })
      });
      let Subclass = MyClass.extend({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'bar2', {
            baz: 'BIFF2'
          });
        },
        count: 0,
        foo: (0, _object.computed)('bar2.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
          return (0, _object.get)((0, _object.get)(this, 'bar2'), 'baz') + ' ' + (0, _object.get)(this, 'count');
        })
      });
      let obj2 = Subclass.create();
      testGet(assert, 'BIFF2 1', obj2, 'foo');
      (0, _object.set)((0, _object.get)(obj2, 'bar'), 'baz', 'BLARG');
      testGet(assert, 'BIFF2 1', obj2, 'foo'); // should not invalidate property

      (0, _object.set)((0, _object.get)(obj2, 'bar2'), 'baz', 'BLARG');
      testGet(assert, 'BLARG 2', obj2, 'foo'); // should not invalidate property
    }

    ['@test can retrieve metadata for a computed property'](assert) {
      let MyClass = _object.default.extend({
        computedProperty: (0, _object.computed)(function () {}).meta({
          key: 'keyValue'
        })
      });
      assert.equal((0, _object.get)(MyClass.metaForProperty('computedProperty'), 'key'), 'keyValue', 'metadata saved on the computed property can be retrieved');
      let ClassWithNoMetadata = _object.default.extend({
        computedProperty: (0, _object.computed)(function () {}),
        staticProperty: 12
      });
      assert.equal(typeof ClassWithNoMetadata.metaForProperty('computedProperty'), 'object', 'returns empty hash if no metadata has been saved');
      expectAssertion(function () {
        ClassWithNoMetadata.metaForProperty('nonexistentProperty');
      }, "metaForProperty() could not find a computed property with key 'nonexistentProperty'.");
      expectAssertion(function () {
        ClassWithNoMetadata.metaForProperty('staticProperty');
      }, "metaForProperty() could not find a computed property with key 'staticProperty'.");
    }
    ['@test overriding a computed property with null removes it from eachComputedProperty iteration'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {}),
        fooDidChange: (0, _object.observer)('foo', function () {}),
        bar: (0, _object.computed)(function () {})
      });
      let SubClass = MyClass.extend({
        foo: null
      });
      let list = [];
      SubClass.eachComputedProperty(name => list.push(name));
      assert.deepEqual(list.sort(), ['bar'], 'overridding with null removes from eachComputedProperty listing');
    }
    ['@test can iterate over a list of computed properties for a class'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {}),
        fooDidChange: (0, _object.observer)('foo', function () {}),
        bar: (0, _object.computed)(function () {}),
        qux: (0, _computed.alias)('foo')
      });
      let SubClass = MyClass.extend({
        baz: (0, _object.computed)(function () {})
      });
      SubClass.reopen({
        bat: (0, _object.computed)(function () {}).meta({
          iAmBat: true
        })
      });
      let list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo', 'qux'], 'watched and unwatched computed properties are iterated');
      list = [];
      SubClass.eachComputedProperty(function (name, meta) {
        list.push(name);
        if (name === 'bat') {
          assert.deepEqual(meta, {
            iAmBat: true
          });
        } else {
          assert.deepEqual(meta, {});
        }
      });
      assert.deepEqual(list.sort(), ['bar', 'bat', 'baz', 'foo', 'qux'], 'all inherited properties are included');
    }
    ['@test list of properties updates when an additional property is added (such cache busting)'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(K),
        fooDidChange: (0, _object.observer)('foo', function () {}),
        bar: (0, _object.computed)(K)
      });
      let list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo'].sort(), 'expected two computed properties');
      MyClass.reopen({
        baz: (0, _object.computed)(K)
      });
      MyClass.create().destroy(); // force apply mixins

      list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo', 'baz'].sort(), 'expected three computed properties');
      (0, _object.defineProperty)(MyClass.prototype, 'qux', (0, _object.computed)(K));
      list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo', 'baz', 'qux'].sort(), 'expected four computed properties');
    }
    ['@test Calling _super in call outside the immediate function of a CP getter works'](assert) {
      function macro(callback) {
        return (0, _object.computed)(function () {
          return callback.call(this);
        });
      }
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'FOO';
        })
      });
      let SubClass = MyClass.extend({
        foo: macro(function () {
          return this._super();
        })
      });
      assert.ok((0, _object.get)(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
    }
    ['@test Calling _super in apply outside the immediate function of a CP getter works'](assert) {
      function macro(callback) {
        return (0, _object.computed)(function () {
          return callback.apply(this);
        });
      }
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'FOO';
        })
      });
      let SubClass = MyClass.extend({
        foo: macro(function () {
          return this._super();
        })
      });
      assert.ok((0, _object.get)(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
    }
    ['@test observing prop installed with computed macro reads and overriding it in create() works'](assert) {
      let Obj = _object.default.extend({
        name: (0, _computed.oneWay)('model.name'),
        nameDidChange: (0, _object.observer)('name', function () {})
      });
      let obj1 = Obj.create({
        name: '1'
      });
      let obj2 = Obj.create({
        name: '2'
      });
      assert.equal(obj1.get('name'), '1');
      assert.equal(obj2.get('name'), '2');
      obj1.destroy();
      obj2.destroy();
    }
    ['@test native getters and setters work'](assert) {
      let MyClass = _object.default.extend({
        bar: 123,
        foo: (0, _object.computed)({
          get() {
            return this.bar;
          },
          set(key, value) {
            this.bar = value;
          }
        })
      });
      let instance = MyClass.create();
      assert.equal(instance.foo, 123, 'getters work');
      instance.foo = 456;
      assert.equal(instance.bar, 456, 'setters work');
    }
    ['@test @each on maybe array'](assert) {
      let Normalizer = _object.default.extend({
        options: null,
        // null | undefined | { value: any } | Array<{ value: any }>

        // Normalize into Array<any>
        normalized: (0, _object.computed)('options', 'options.value', 'options.@each.value', function () {
          let {
            options
          } = this;
          if ((0, _array.isArray)(options)) {
            return options.map(item => item.value);
          } else if (options !== null && typeof options === 'object') {
            return [options.value];
          } else {
            return [];
          }
        })
      });
      let n = Normalizer.create();
      assert.deepEqual(n.normalized, []);
      n.set('options', {
        value: 'foo'
      });
      assert.deepEqual(n.normalized, ['foo']);
      n.set('options.value', 'bar');
      assert.deepEqual(n.normalized, ['bar']);
      n.set('options', {
        extra: 'wat',
        value: 'baz'
      });
      assert.deepEqual(n.normalized, ['baz']);
      n.set('options', (0, _array.A)([{
        value: 'foo'
      }]));
      assert.deepEqual(n.normalized, ['foo']);
      n.options.pushObject({
        value: 'bar'
      });
      assert.deepEqual(n.normalized, ['foo', 'bar']);
      n.options.pushObject({
        extra: 'wat',
        value: 'baz'
      });
      assert.deepEqual(n.normalized, ['foo', 'bar', 'baz']);
      n.options.clear();
      assert.deepEqual(n.normalized, []);
      n.set('options', [{
        value: 'foo'
      }, {
        value: 'bar'
      }]);
      assert.deepEqual(n.normalized, ['foo', 'bar']);
      (0, _object.set)(n.options[0], 'value', 'FOO');
      assert.deepEqual(n.normalized, ['FOO', 'bar']);
      n.set('options', null);
      assert.deepEqual(n.normalized, []);
    }
    ['@test @each works on array with falsy values'](assert) {
      let obj = _object.default.extend({
        falsy: [null, undefined, false, '', 0, {}],
        truthy: [true, 'foo', 123],
        falsyComputed: (0, _object.computed)('falsy.@each.foo', () => {
          assert.ok(true, 'falsy computed');
        }),
        truthyComputed: (0, _object.computed)('truthy.@each.foo', () => {
          assert.ok(true, 'truthy computed');
        })
      }).create();

      // should throw no errors
      obj.falsyComputed;
      expectAssertion(() => {
        obj.truthyComputed;
      }, /When using @each to observe the array `true,foo,123`, the items in the array must be objects/);
    }
    ['@test @each works with array-likes'](assert) {
      class ArrayLike {
        constructor(arr) {
          if (arr === void 0) {
            arr = [];
          }
          this.inner = arr;
        }
        get length() {
          return this.inner.length;
        }
        objectAt(index) {
          return this.inner[index];
        }
        map(fn) {
          return this.inner.map(fn);
        }
      }
      let Normalizer = _object.default.extend({
        options: null,
        // null | ArrayLike<{ value: any }>

        // Normalize into Array<any>
        normalized: (0, _object.computed)('options.@each.value', function () {
          let options = this.options || [];
          return options.map(item => item.value);
        })
      });
      let n = Normalizer.create();
      assert.deepEqual(n.normalized, []);
      let options = new ArrayLike([{
        value: 'foo'
      }]);
      n.set('options', options);
      assert.deepEqual(n.normalized, ['foo']);
      (0, _object.set)(options.objectAt(0), 'value', 'bar');
      assert.deepEqual(n.normalized, ['bar']);
    }
    ['@test lazy computation cannot cause infinite cycles'](assert) {
      // This is based off a real world bug found in ember-cp-validations:
      // https://github.com/offirgolan/ember-cp-validations/issues/659
      let CycleObject = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return _object.default.extend({
            parent: this,
            alias: (0, _computed.alias)('parent.foo')
          }).create();
        }),
        bar: (0, _object.computed)('foo.alias', () => {})
      });
      let obj = CycleObject.create();
      obj.bar;
      obj.foo;
      assert.ok(true);
    }
    ['@test computeds can have cycles'](assert) {
      var _dec, _dec2, _class;
      let CycleObject = (_dec = (0, _object.computed)('bar'), _dec2 = (0, _object.computed)('foo'), (_class = class CycleObject {
        // eslint-disable-next-line getter-return
        get foo() {}

        // eslint-disable-next-line getter-return
        get bar() {}
      }, (_applyDecoratedDescriptor(_class.prototype, "foo", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "foo"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "bar", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "bar"), _class.prototype)), _class));
      let obj = new CycleObject();
      obj.bar;
      obj.foo;
      (0, _metal.notifyPropertyChange)(obj, 'bar');
      obj.foo;
      assert.ok(true);
    }
  });
});
define("@ember/object/tests/create_test", ["@ember/-internals/container", "@ember/-internals/owner", "@ember/object/observers", "@ember/object/mixin", "@ember/service", "@ember/object", "@ember/object/computed", "internal-test-helpers", "@glimmer/destroyable"], function (_container, _owner, _observers, _mixin, _service, _object, _computed, _internalTestHelpers, _destroyable) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('EmberObject.create', class extends _internalTestHelpers.AbstractTestCase {
    ['@test simple properties are set'](assert) {
      expectNoDeprecation();
      let o = _object.default.create({
        ohai: 'there'
      });
      assert.equal(o.get('ohai'), 'there');
    }
    ['@test explicit injection does not raise deprecation'](assert) {
      var _class2, _descriptor;
      expectNoDeprecation();
      let owner = (0, _internalTestHelpers.buildOwner)();
      class FooService extends _service.default {
        constructor() {
          super(...arguments);
          this.bar = 'foo';
        }
      }
      let FooObject = (_class2 = class FooObject extends _object.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "foo", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "foo", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class2);
      owner.register('service:foo', FooService);
      owner.register('foo:main', FooObject);
      let obj = owner.lookup('foo:main');
      assert.equal(obj.foo.bar, 'foo');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test calls computed property setters'](assert) {
      let MyClass = _object.default.extend({
        foo: (0, _object.computed)({
          get() {
            return "this is not the value you're looking for";
          },
          set(key, value) {
            return value;
          }
        })
      });
      let o = MyClass.create({
        foo: 'bar'
      });
      assert.equal(o.get('foo'), 'bar');
    }
    ['@test sets up mandatory setters for simple properties watched with observers'](assert) {
      if (false /* DEBUG */) {
        let MyClass = _object.default.extend({
          foo: null,
          bar: null,
          fooDidChange: (0, _object.observer)('foo', function () {})
        });
        let o = MyClass.create({
          foo: 'bar',
          bar: 'baz'
        });
        assert.equal(o.get('foo'), 'bar');
        let descriptor = Object.getOwnPropertyDescriptor(o, 'foo');
        assert.ok(descriptor.set, 'Mandatory setter was setup');
        descriptor = Object.getOwnPropertyDescriptor(o, 'bar');
        assert.ok(!descriptor.set, 'Mandatory setter was not setup');
        o.destroy();
      } else {
        assert.expect(0);
      }
    }
    ['@test sets up mandatory setters for simple properties watched with computeds'](assert) {
      if (false /* DEBUG */) {
        let MyClass = _object.default.extend({
          foo: null,
          bar: null,
          fooAlias: (0, _object.computed)('foo', function () {
            return this.foo;
          })
        });
        let o = MyClass.create({
          foo: 'bar',
          bar: 'baz'
        });
        assert.equal(o.get('fooAlias'), 'bar');
        let descriptor = Object.getOwnPropertyDescriptor(o, 'foo');
        assert.ok(descriptor.set, 'Mandatory setter was setup');
        descriptor = Object.getOwnPropertyDescriptor(o, 'bar');
        assert.ok(!descriptor.set, 'Mandatory setter was not setup');
        o.destroy();
      } else {
        assert.expect(0);
      }
    }
    ['@test sets up mandatory setters for simple properties watched with aliases'](assert) {
      if (false /* DEBUG */) {
        let MyClass = _object.default.extend({
          foo: null,
          bar: null,
          fooAlias: (0, _computed.alias)('foo')
        });
        let o = MyClass.create({
          foo: 'bar',
          bar: 'baz'
        });
        assert.equal(o.get('fooAlias'), 'bar');
        let descriptor = Object.getOwnPropertyDescriptor(o, 'foo');
        assert.ok(descriptor.set, 'Mandatory setter was setup');
        descriptor = Object.getOwnPropertyDescriptor(o, 'bar');
        assert.ok(!descriptor.set, 'Mandatory setter was not setup');
        o.destroy();
      } else {
        assert.expect(0);
      }
    }
    ['@test does not sets up separate mandatory setters on getters'](assert) {
      if (false /* DEBUG */) {
        let MyClass = _object.default.extend({
          get foo() {
            return 'bar';
          },
          fooDidChange: (0, _object.observer)('foo', function () {})
        });
        let o = MyClass.create({});
        assert.equal(o.get('foo'), 'bar');
        let descriptor = Object.getOwnPropertyDescriptor(o, 'foo');
        assert.ok(!descriptor, 'Mandatory setter was not setup');

        // cleanup
        o.destroy();
      } else {
        assert.expect(0);
      }
    }
    ['@test does not sets up separate mandatory setters on arrays'](assert) {
      if (false /* DEBUG */) {
        let arr = [123];
        (0, _observers.addObserver)(arr, 0, function () {});
        let descriptor = Object.getOwnPropertyDescriptor(arr, 0);
        assert.ok(!descriptor.set, 'Mandatory setter was not setup');
        (0, _destroyable.destroy)(arr);
      } else {
        assert.expect(0);
      }
    }
    ['@test calls setUnknownProperty if undefined'](assert) {
      let setUnknownPropertyCalled = false;
      let MyClass = _object.default.extend({
        setUnknownProperty( /* key, value */
        ) {
          setUnknownPropertyCalled = true;
        }
      });
      MyClass.create({
        foo: 'bar'
      });
      assert.ok(setUnknownPropertyCalled, 'setUnknownProperty was called');
    }
    ['@test throws if you try to define a computed property']() {
      expectAssertion(function () {
        _object.default.create({
          foo: (0, _object.computed)(function () {})
        });
      }, 'EmberObject.create no longer supports defining computed properties. Define computed properties using extend() or reopen() before calling create().');
    }
    ['@test throws if you try to call _super in a method']() {
      expectAssertion(function () {
        _object.default.create({
          foo() {
            this._super(...arguments);
          }
        });
      }, 'EmberObject.create no longer supports defining methods that call _super.');
    }
    ["@test throws if you try to 'mixin' a definition"]() {
      let myMixin = _mixin.default.create({
        adder(arg1, arg2) {
          return arg1 + arg2;
        }
      });
      expectAssertion(function () {
        _object.default.create(myMixin);
      }, 'EmberObject.create no longer supports mixing in other definitions, use .extend & .create separately instead.');
    }
    ['@test inherits properties from passed in EmberObject'](assert) {
      let baseObj = _object.default.create({
        foo: 'bar'
      });
      let secondaryObj = _object.default.create(baseObj);
      assert.equal(secondaryObj.foo, baseObj.foo, 'Em.O.create inherits properties from EmberObject parameter');
    }
    ['@test throws if you try to pass anything a string as a parameter']() {
      let expected = 'EmberObject.create only accepts objects.';
      expectAssertion(() => _object.default.create('some-string'), expected);
    }
    ['@test EmberObject.create can take undefined as a parameter'](assert) {
      let o = _object.default.create(undefined);
      assert.deepEqual(_object.default.create(), o);
    }
    ['@test can use getOwner in a proxy init GH#16484'](assert) {
      let owner = {};
      let options = {};
      (0, _owner.setOwner)(options, owner);
      _object.default.extend({
        init() {
          this._super(...arguments);
          let localOwner = (0, _owner.getOwner)(this);
          assert.equal(localOwner, owner, 'should be able to `getOwner` in init');
        },
        unknownProperty() {
          return undefined;
        }
      }).create(options);
    }
    ['@test does not create enumerable properties for owner and init factory when created by the container factory'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      container.owner = {};
      registry.register('component:foo-bar', _object.default);
      let componentFactory = container.factoryFor('component:foo-bar');
      let instance = componentFactory.create();
      assert.deepEqual(Object.keys(instance), [], 'no enumerable properties were added');
      assert.equal((0, _owner.getOwner)(instance), container.owner, 'owner was defined on the instance');
      assert.ok((0, _container.getFactoryFor)(instance), 'factory was defined on the instance');
    }
    ['@test does not create enumerable properties for owner and init factory when looked up on the container'](assert) {
      let registry = new _container.Registry();
      let container = registry.container();
      container.owner = {};
      registry.register('component:foo-bar', _object.default);
      let instance = container.lookup('component:foo-bar');
      assert.deepEqual(Object.keys(instance), [], 'no enumerable properties were added');
      assert.equal((0, _owner.getOwner)(instance), container.owner, 'owner was defined on the instance');
      assert.ok((0, _container.getFactoryFor)(instance), 'factory was defined on the instance');
    }
  });
});
define("@ember/object/tests/destroy_test", ["@ember/runloop", "@ember/-internals/metal", "@ember/-internals/meta", "@ember/object", "internal-test-helpers"], function (_runloop, _metal, _meta, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/runtime/system/object/destroy_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should schedule objects to be destroyed at the end of the run loop'](assert) {
      let obj = _object.default.create();
      let meta;
      (0, _runloop.run)(() => {
        obj.destroy();
        meta = (0, _meta.peekMeta)(obj);
        assert.ok(meta, 'meta is not destroyed immediately');
        assert.ok((0, _object.get)(obj, 'isDestroying'), 'object is marked as destroying immediately');
        assert.ok(!(0, _object.get)(obj, 'isDestroyed'), 'object is not destroyed immediately');
      });
      meta = (0, _meta.peekMeta)(obj);
      assert.ok((0, _object.get)(obj, 'isDestroyed'), 'object is destroyed after run loop finishes');
    }

    // MANDATORY_SETTER moves value to meta.values
    // a destroyed object removes meta but leaves the accessor
    // that looks it up
    ['@test should raise an exception when modifying watched properties on a destroyed object'](assert) {
      if (false /* DEBUG */) {
        let obj = _object.default.extend({
          fooDidChange: (0, _object.observer)('foo', function () {})
        }).create({
          foo: 'bar'
        });
        (0, _runloop.run)(() => obj.destroy());
        assert.throws(() => (0, _object.set)(obj, 'foo', 'baz'), Error, 'raises an exception');
      } else {
        assert.expect(0);
      }
    }
    async ['@test observers should not fire after an object has been destroyed'](assert) {
      let count = 0;
      let obj = _object.default.extend({
        fooDidChange: (0, _object.observer)('foo', function () {
          count++;
        })
      }).create();
      obj.set('foo', 'bar');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'observer was fired once');
      (0, _metal.beginPropertyChanges)();
      obj.set('foo', 'quux');
      obj.destroy();
      (0, _metal.endPropertyChanges)();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(count, 1, 'observer was not called after object was destroyed');
    }
    async ['@test destroyed objects should not see each others changes during teardown but a long lived object should'](assert) {
      let shouldChange = 0;
      let shouldNotChange = 0;
      let objs = {};
      let A = _object.default.extend({
        objs: objs,
        isAlive: true,
        willDestroy() {
          this.set('isAlive', false);
        },
        bDidChange: (0, _object.observer)('objs.b.isAlive', function () {
          shouldNotChange++;
        }),
        cDidChange: (0, _object.observer)('objs.c.isAlive', function () {
          shouldNotChange++;
        })
      });
      let B = _object.default.extend({
        objs: objs,
        isAlive: true,
        willDestroy() {
          this.set('isAlive', false);
        },
        aDidChange: (0, _object.observer)('objs.a.isAlive', function () {
          shouldNotChange++;
        }),
        cDidChange: (0, _object.observer)('objs.c.isAlive', function () {
          shouldNotChange++;
        })
      });
      let C = _object.default.extend({
        objs: objs,
        isAlive: true,
        willDestroy() {
          this.set('isAlive', false);
        },
        aDidChange: (0, _object.observer)('objs.a.isAlive', function () {
          shouldNotChange++;
        }),
        bDidChange: (0, _object.observer)('objs.b.isAlive', function () {
          shouldNotChange++;
        })
      });
      let LongLivedObject = _object.default.extend({
        objs: objs,
        isAliveDidChange: (0, _object.observer)('objs.a.isAlive', function () {
          shouldChange++;
        })
      });
      objs.a = A.create();
      objs.b = B.create();
      objs.c = C.create();
      let longLived = LongLivedObject.create();
      for (let obj in objs) {
        objs[obj].destroy();
      }
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(shouldNotChange, 0, 'destroyed graph objs should not see change in willDestroy');
      assert.equal(shouldChange, 1, 'long lived should see change in willDestroy');
      longLived.destroy();
    }
  });
});
define("@ember/object/tests/detectInstance_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/detectInstance', class extends _internalTestHelpers.AbstractTestCase {
    ['@test detectInstance detects instances correctly'](assert) {
      let A = _object.default.extend();
      let B = A.extend();
      let C = A.extend();
      let o = _object.default.create();
      let a = A.create();
      let b = B.create();
      let c = C.create();
      assert.ok(_object.default.detectInstance(o), 'o is an instance of EmberObject');
      assert.ok(_object.default.detectInstance(a), 'a is an instance of EmberObject');
      assert.ok(_object.default.detectInstance(b), 'b is an instance of EmberObject');
      assert.ok(_object.default.detectInstance(c), 'c is an instance of EmberObject');
      assert.ok(!A.detectInstance(o), 'o is not an instance of A');
      assert.ok(A.detectInstance(a), 'a is an instance of A');
      assert.ok(A.detectInstance(b), 'b is an instance of A');
      assert.ok(A.detectInstance(c), 'c is an instance of A');
      assert.ok(!B.detectInstance(o), 'o is not an instance of B');
      assert.ok(!B.detectInstance(a), 'a is not an instance of B');
      assert.ok(B.detectInstance(b), 'b is an instance of B');
      assert.ok(!B.detectInstance(c), 'c is not an instance of B');
      assert.ok(!C.detectInstance(o), 'o is not an instance of C');
      assert.ok(!C.detectInstance(a), 'a is not an instance of C');
      assert.ok(!C.detectInstance(b), 'b is not an instance of C');
      assert.ok(C.detectInstance(c), 'c is an instance of C');
    }
  });
});
define("@ember/object/tests/detect_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/detect', class extends _internalTestHelpers.AbstractTestCase {
    ['@test detect detects classes correctly'](assert) {
      let A = _object.default.extend();
      let B = A.extend();
      let C = A.extend();
      assert.ok(_object.default.detect(_object.default), 'EmberObject is an EmberObject class');
      assert.ok(_object.default.detect(A), 'A is an EmberObject class');
      assert.ok(_object.default.detect(B), 'B is an EmberObject class');
      assert.ok(_object.default.detect(C), 'C is an EmberObject class');
      assert.ok(!A.detect(_object.default), 'EmberObject is not an A class');
      assert.ok(A.detect(A), 'A is an A class');
      assert.ok(A.detect(B), 'B is an A class');
      assert.ok(A.detect(C), 'C is an A class');
      assert.ok(!B.detect(_object.default), 'EmberObject is not a B class');
      assert.ok(!B.detect(A), 'A is not a B class');
      assert.ok(B.detect(B), 'B is a B class');
      assert.ok(!B.detect(C), 'C is not a B class');
      assert.ok(!C.detect(_object.default), 'EmberObject is not a C class');
      assert.ok(!C.detect(A), 'A is not a C class');
      assert.ok(!C.detect(B), 'B is not a C class');
      assert.ok(C.detect(C), 'C is a C class');
    }
  });
});
define("@ember/object/tests/es-compatibility-test", ["@ember/object", "@ember/-internals/metal", "@ember/object/mixin", "internal-test-helpers"], function (_object, _metal, _mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EmberObject ES Compatibility', class extends _internalTestHelpers.AbstractTestCase {
    ['@test extending an Ember.Object'](assert) {
      let calls = [];
      class MyObject extends _object.default {
        constructor() {
          calls.push('constructor');
          super(...arguments);
          this.postInitProperty = 'post-init-property';
        }
        init() {
          calls.push('init');
          super.init(...arguments);
          this.initProperty = 'init-property';
        }
      }
      let myObject = MyObject.create({
        passedProperty: 'passed-property'
      });
      assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');
      assert.equal(myObject.postInitProperty, 'post-init-property', 'constructor property available on instance (create)');
      assert.equal(myObject.initProperty, 'init-property', 'init property available on instance (create)');
      assert.equal(myObject.passedProperty, 'passed-property', 'passed property available on instance (create)');
    }
    ['@test normal method super'](assert) {
      let calls = [];
      let Foo = _object.default.extend({
        method() {
          calls.push('foo');
        }
      });
      let Bar = Foo.extend({
        method() {
          this._super();
          calls.push('bar');
        }
      });
      class Baz extends Bar {
        method() {
          super.method();
          calls.push('baz');
        }
      }
      let Qux = Baz.extend({
        method() {
          this._super();
          calls.push('qux');
        }
      });
      let Quux = Qux.extend({
        method() {
          this._super();
          calls.push('quux');
        }
      });
      class Corge extends Quux {
        method() {
          super.method();
          calls.push('corge');
        }
      }
      let callValues = ['foo', 'bar', 'baz', 'qux', 'quux', 'corge'];
      [Foo, Bar, Baz, Qux, Quux, Corge].forEach((Class, index) => {
        calls = [];
        Class.create().method();
        assert.deepEqual(calls, callValues.slice(0, index + 1), 'chain of static methods called with super');
      });
    }
    ['@test static method super'](assert) {
      let calls;
      let Foo = _object.default.extend();
      Foo.reopenClass({
        method() {
          calls.push('foo');
        }
      });
      let Bar = Foo.extend();
      Bar.reopenClass({
        method() {
          this._super();
          calls.push('bar');
        }
      });
      class Baz extends Bar {
        static method() {
          super.method();
          calls.push('baz');
        }
      }
      let Qux = Baz.extend();
      Qux.reopenClass({
        method() {
          this._super();
          calls.push('qux');
        }
      });
      let Quux = Qux.extend();
      Quux.reopenClass({
        method() {
          this._super();
          calls.push('quux');
        }
      });
      class Corge extends Quux {
        static method() {
          super.method();
          calls.push('corge');
        }
      }
      let callValues = ['foo', 'bar', 'baz', 'qux', 'quux', 'corge'];
      [Foo, Bar, Baz, Qux, Quux, Corge].forEach((Class, index) => {
        calls = [];
        Class.method();
        assert.deepEqual(calls, callValues.slice(0, index + 1), 'chain of static methods called with super');
      });
    }
    ['@test using mixins'](assert) {
      let Mixin1 = _mixin.default.create({
        property1: 'data-1'
      });
      let Mixin2 = _mixin.default.create({
        property2: 'data-2'
      });
      class MyObject extends _object.default.extend(Mixin1, Mixin2) {}
      let myObject = MyObject.create();
      assert.equal(myObject.property1, 'data-1', 'includes the first mixin');
      assert.equal(myObject.property2, 'data-2', 'includes the second mixin');
    }
    ['@test using instanceof'](assert) {
      class MyObject extends _object.default {}
      let myObject = MyObject.create();
      assert.ok(myObject instanceof MyObject);
      assert.ok(myObject instanceof _object.default);
    }
    ['@test using Ember.Object#detect'](assert) {
      let Parent = _object.default.extend();
      class Child extends Parent {}
      let Grandchild = Child.extend();
      assert.ok(Parent.detect(Child), 'Parent.detect(Child)');
      assert.ok(Child.detect(Grandchild), 'Child.detect(Grandchild)');
    }
    ['@test extending an ES subclass of EmberObject'](assert) {
      let calls = [];
      class SubEmberObject extends _object.default {
        constructor() {
          calls.push('constructor');
          super(...arguments);
        }
        init() {
          calls.push('init');
          super.init(...arguments);
        }
      }
      class MyObject extends SubEmberObject {}
      MyObject.create();
      assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');
    }
    ['@test calling extend on an ES subclass of EmberObject'](assert) {
      let calls = [];
      class SubEmberObject extends _object.default {
        constructor() {
          calls.push('before constructor');
          super(...arguments);
          calls.push('after constructor');
          this.foo = 123;
        }
        init() {
          calls.push('init');
          super.init(...arguments);
        }
      }
      let MyObject = SubEmberObject.extend({});
      MyObject.create();
      assert.deepEqual(calls, ['before constructor', 'after constructor', 'init'], 'constructor then init called (create)');
      let obj = MyObject.create({
        foo: 456,
        bar: 789
      });
      assert.equal(obj.foo, 456, 'sets class fields on instance correctly');
      assert.equal(obj.bar, 789, 'sets passed in properties on instance correctly');
    }
    ['@test calling metaForProperty on a native class works'](assert) {
      assert.expect(0);
      class SubEmberObject extends _object.default {}
      (0, _metal.defineProperty)(SubEmberObject.prototype, 'foo', (0, _object.computed)('foo', {
        get() {
          return 'bar';
        }
      }));

      // able to get meta without throwing an error
      SubEmberObject.metaForProperty('foo');
    }
    '@test observes / removeObserver on / removeListener interop'(assert) {
      let fooDidChangeBase = 0;
      let fooDidChangeA = 0;
      let fooDidChangeB = 0;
      let someEventBase = 0;
      let someEventA = 0;
      let someEventB = 0;
      class A extends _object.default.extend({
        fooDidChange: (0, _object.observer)('foo', function () {
          fooDidChangeBase++;
        }),
        onSomeEvent: (0, _metal.on)('someEvent', function () {
          someEventBase++;
        })
      }) {
        init() {
          super.init();
          this.foo = 'bar';
        }
        fooDidChange() {
          super.fooDidChange();
          fooDidChangeA++;
        }
        onSomeEvent() {
          super.onSomeEvent();
          someEventA++;
        }
      }
      class B extends A {
        fooDidChange() {
          super.fooDidChange();
          fooDidChangeB++;
        }
        onSomeEvent() {
          super.onSomeEvent();
          someEventB++;
        }
      }
      (0, _metal.removeObserver)(B.prototype, 'foo', null, 'fooDidChange');
      (0, _metal.removeListener)(B.prototype, 'someEvent', null, 'onSomeEvent');
      assert.equal(fooDidChangeBase, 0);
      assert.equal(fooDidChangeA, 0);
      assert.equal(fooDidChangeB, 0);
      assert.equal(someEventBase, 0);
      assert.equal(someEventA, 0);
      assert.equal(someEventB, 0);
      let a = A.create();
      a.set('foo', 'something');

      // TODO: Generator transpilation code doesn't play nice with class definitions/hoisting
      return (0, _internalTestHelpers.runLoopSettled)().then(async () => {
        assert.equal(fooDidChangeBase, 1);
        assert.equal(fooDidChangeA, 1);
        assert.equal(fooDidChangeB, 0);
        (0, _metal.sendEvent)(a, 'someEvent');
        assert.equal(someEventBase, 1);
        assert.equal(someEventA, 1);
        assert.equal(someEventB, 0);
        let b = B.create();
        b.set('foo', 'something');
        await (0, _internalTestHelpers.runLoopSettled)();
        assert.equal(fooDidChangeBase, 1);
        assert.equal(fooDidChangeA, 1);
        assert.equal(fooDidChangeB, 0);
        (0, _metal.sendEvent)(b, 'someEvent');
        assert.equal(someEventBase, 1);
        assert.equal(someEventA, 1);
        assert.equal(someEventB, 0);
        a.destroy();
        b.destroy();
      });
    }
    '@test super and _super interop between old and new methods'(assert) {
      let calls = [];
      let changes = [];
      let events = [];
      let lastProps;
      class A extends _object.default {
        init(props) {
          calls.push('A init');
          lastProps = props;
        }
      }
      let Mixin1 = _mixin.default.create({
        init() {
          calls.push('Mixin1 init before _super');
          this._super(...arguments);
          calls.push('Mixin1 init after _super');
        }
      });
      let Mixin2 = _mixin.default.create({
        init() {
          calls.push('Mixin2 init before _super');
          this._super(...arguments);
          calls.push('Mixin2 init after _super');
        }
      });
      class B extends A.extend(Mixin1, Mixin2) {
        init() {
          calls.push('B init before super.init');
          super.init(...arguments);
          calls.push('B init after super.init');
        }
        onSomeEvent(evt) {
          events.push("B onSomeEvent " + evt);
        }
        fullNameDidChange() {
          changes.push('B fullNameDidChange');
        }
      }

      // // define a CP
      (0, _metal.defineProperty)(B.prototype, 'full', (0, _object.computed)('first', 'last', {
        get() {
          return this.first + ' ' + this.last;
        }
      }));

      // Only string observers are allowed for prototypes
      (0, _metal.addObserver)(B.prototype, 'full', null, 'fullNameDidChange');

      // Only string listeners are allowed for prototypes
      (0, _metal.addListener)(B.prototype, 'someEvent', null, 'onSomeEvent');
      B.reopen({
        init() {
          calls.push('reopen init before _super');
          this._super(...arguments);
          calls.push('reopen init after _super');
        }
      });
      let C = B.extend({
        init() {
          calls.push('C init before _super');
          this._super(...arguments);
          calls.push('C init after _super');
        },
        onSomeEvent(evt) {
          calls.push('C onSomeEvent before _super');
          this._super(evt);
          calls.push('C onSomeEvent after _super');
        },
        fullNameDidChange() {
          calls.push('C fullNameDidChange before _super');
          this._super();
          calls.push('C fullNameDidChange after _super');
        }
      });
      class D extends C {
        init() {
          calls.push('D init before super.init');
          super.init(...arguments);
          calls.push('D init after super.init');
        }
        onSomeEvent(evt) {
          events.push('D onSomeEvent before super.onSomeEvent');
          super.onSomeEvent(evt);
          events.push('D onSomeEvent after super.onSomeEvent');
        }
        fullNameDidChange() {
          changes.push('D fullNameDidChange before super.fullNameDidChange');
          super.fullNameDidChange();
          changes.push('D fullNameDidChange after super.fullNameDidChange');
        }
        triggerSomeEvent() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          (0, _metal.sendEvent)(this, 'someEvent', args);
        }
      }
      assert.deepEqual(calls, [], 'nothing has been called');
      assert.deepEqual(changes, [], 'full has not changed');
      assert.deepEqual(events, [], 'onSomeEvent has not been triggered');
      let d = D.create({
        first: 'Robert',
        last: 'Jackson'
      });
      assert.deepEqual(calls, ['D init before super.init', 'C init before _super', 'reopen init before _super', 'B init before super.init', 'Mixin2 init before _super', 'Mixin1 init before _super', 'A init', 'Mixin1 init after _super', 'Mixin2 init after _super', 'B init after super.init', 'reopen init after _super', 'C init after _super', 'D init after super.init']);
      assert.deepEqual(changes, [], 'full has not changed');
      assert.deepEqual(events, [], 'onSomeEvent has not been triggered');
      assert.deepEqual(lastProps, {
        first: 'Robert',
        last: 'Jackson'
      });
      assert.equal(d.full, 'Robert Jackson');
      d.setProperties({
        first: 'Kris',
        last: 'Selden'
      });

      // TODO: Generator transpilation code doesn't play nice with class definitions/hoisting
      return (0, _internalTestHelpers.runLoopSettled)().then(() => {
        assert.deepEqual(changes, ['D fullNameDidChange before super.fullNameDidChange', 'B fullNameDidChange', 'D fullNameDidChange after super.fullNameDidChange']);
        assert.equal(d.full, 'Kris Selden');
        d.triggerSomeEvent('event arg');
        assert.deepEqual(events, ['D onSomeEvent before super.onSomeEvent', 'B onSomeEvent event arg', 'D onSomeEvent after super.onSomeEvent']);
        d.destroy();
      });
    }
  });
});
define("@ember/object/tests/evented_test", ["@ember/object/core", "@ember/object/evented", "internal-test-helpers"], function (_core, _evented, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.Evented', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works properly on proxy-ish objects'](assert) {
      let eventedProxyObj = _core.default.extend(_evented.default, {
        unknownProperty() {
          return true;
        }
      }).create();
      let noop = function () {};
      eventedProxyObj.on('foo', noop);
      eventedProxyObj.off('foo', noop);
      assert.ok(true, 'An assertion was triggered');
    }
  });
});
define("@ember/object/tests/events_test", ["@ember/object", "@ember/object/evented", "internal-test-helpers"], function (_object, _evented, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Object events', class extends _internalTestHelpers.AbstractTestCase {
    ['@test a listener can be added to an object'](assert) {
      let count = 0;
      let F = function () {
        count++;
      };
      let obj = _object.default.extend(_evented.default).create();
      obj.on('event!', F);
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was triggered');
      obj.trigger('event!');
      assert.equal(count, 2, 'the event was triggered');
    }
    ['@test a listener can be added and removed automatically the first time it is triggered'](assert) {
      let count = 0;
      let F = function () {
        count++;
      };
      let obj = _object.default.extend(_evented.default).create();
      obj.one('event!', F);
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was triggered');
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was not triggered again');
    }
    ['@test triggering an event can have arguments'](assert) {
      let self, args;
      let obj = _object.default.extend(_evented.default).create();
      obj.on('event!', function () {
        args = [].slice.call(arguments);
        self = this;
      });
      obj.trigger('event!', 'foo', 'bar');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(self, obj);
    }
    ['@test a listener can be added and removed automatically and have arguments'](assert) {
      let self, args;
      let count = 0;
      let obj = _object.default.extend(_evented.default).create();
      obj.one('event!', function () {
        args = [].slice.call(arguments);
        self = this;
        count++;
      });
      obj.trigger('event!', 'foo', 'bar');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(self, obj);
      assert.equal(count, 1, 'the event is triggered once');
      obj.trigger('event!', 'baz', 'bat');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(count, 1, 'the event was not triggered again');
      assert.equal(self, obj);
    }
    ['@test binding an event can specify a different target'](assert) {
      let self, args;
      let obj = _object.default.extend(_evented.default).create();
      let target = {};
      obj.on('event!', target, function () {
        args = [].slice.call(arguments);
        self = this;
      });
      obj.trigger('event!', 'foo', 'bar');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(self, target);
    }
    ['@test a listener registered with one can take method as string and can be added with different target'](assert) {
      let count = 0;
      let target = {};
      target.fn = function () {
        count++;
      };
      let obj = _object.default.extend(_evented.default).create();
      obj.one('event!', target, 'fn');
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was triggered');
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was not triggered again');
    }
    ['@test a listener registered with one can be removed with off'](assert) {
      let obj = _object.default.extend(_evented.default, {
        F() {}
      }).create();
      let F = function () {};
      obj.one('event!', F);
      obj.one('event!', obj, 'F');
      assert.equal(obj.has('event!'), true, 'has events');
      obj.off('event!', F);
      obj.off('event!', obj, 'F');
      assert.equal(obj.has('event!'), false, 'has no more events');
    }
    ['@test adding and removing listeners should be chainable'](assert) {
      let obj = _object.default.extend(_evented.default).create();
      let F = function () {};
      let ret = obj.on('event!', F);
      assert.equal(ret, obj, '#on returns self');
      ret = obj.off('event!', F);
      assert.equal(ret, obj, '#off returns self');
      ret = obj.one('event!', F);
      assert.equal(ret, obj, '#one returns self');
    }
  });
});
define("@ember/object/tests/extend_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EmberObject.extend', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Basic extend'](assert) {
      let SomeClass = _object.default.extend({
        foo: 'BAR'
      });
      assert.ok(SomeClass.isClass, 'A class has isClass of true');
      let obj = SomeClass.create();
      assert.equal(obj.foo, 'BAR');
    }
    ['@test Sub-subclass'](assert) {
      let SomeClass = _object.default.extend({
        foo: 'BAR'
      });
      let AnotherClass = SomeClass.extend({
        bar: 'FOO'
      });
      let obj = AnotherClass.create();
      assert.equal(obj.foo, 'BAR');
      assert.equal(obj.bar, 'FOO');
    }
    ['@test Overriding a method several layers deep'](assert) {
      let SomeClass = _object.default.extend({
        fooCnt: 0,
        foo() {
          this.fooCnt++;
        },
        barCnt: 0,
        bar() {
          this.barCnt++;
        }
      });
      let AnotherClass = SomeClass.extend({
        barCnt: 0,
        bar() {
          this.barCnt++;
          this._super(...arguments);
        }
      });
      let FinalClass = AnotherClass.extend({
        fooCnt: 0,
        foo() {
          this.fooCnt++;
          this._super(...arguments);
        }
      });
      let obj = FinalClass.create();
      obj.foo();
      obj.bar();
      assert.equal(obj.fooCnt, 2, 'should invoke both');
      assert.equal(obj.barCnt, 2, 'should invoke both');

      // Try overriding on create also
      obj = FinalClass.extend({
        foo() {
          this.fooCnt++;
          this._super(...arguments);
        }
      }).create();
      obj.foo();
      obj.bar();
      assert.equal(obj.fooCnt, 3, 'should invoke final as well');
      assert.equal(obj.barCnt, 2, 'should invoke both');
    }
    ['@test With concatenatedProperties'](assert) {
      let SomeClass = _object.default.extend({
        things: 'foo',
        concatenatedProperties: ['things']
      });
      let AnotherClass = SomeClass.extend({
        things: 'bar'
      });
      let YetAnotherClass = SomeClass.extend({
        things: 'baz'
      });
      let some = SomeClass.create();
      let another = AnotherClass.create();
      let yetAnother = YetAnotherClass.create();
      assert.deepEqual(some.get('things'), ['foo'], 'base class should have just its value');
      assert.deepEqual(another.get('things'), ['foo', 'bar'], "subclass should have base class' and its own");
      assert.deepEqual(yetAnother.get('things'), ['foo', 'baz'], "subclass should have base class' and its own");
    }
    ['@test With concatenatedProperties class properties'](assert) {
      let SomeClass = _object.default.extend();
      SomeClass.reopenClass({
        concatenatedProperties: ['things'],
        things: 'foo'
      });
      let AnotherClass = SomeClass.extend();
      AnotherClass.reopenClass({
        things: 'bar'
      });
      let YetAnotherClass = SomeClass.extend();
      YetAnotherClass.reopenClass({
        things: 'baz'
      });
      let some = SomeClass.create();
      let another = AnotherClass.create();
      let yetAnother = YetAnotherClass.create();
      assert.deepEqual((0, _object.get)(some.constructor, 'things'), ['foo'], 'base class should have just its value');
      assert.deepEqual((0, _object.get)(another.constructor, 'things'), ['foo', 'bar'], "subclass should have base class' and its own");
      assert.deepEqual((0, _object.get)(yetAnother.constructor, 'things'), ['foo', 'baz'], "subclass should have base class' and its own");
    }
    async ['@test Overriding a computed property with an observer'](assert) {
      let Parent = _object.default.extend({
        foo: (0, _object.computed)(function () {
          return 'FOO';
        })
      });
      let seen = [];
      let Child = Parent.extend({
        foo: (0, _object.observer)('bar', function () {
          seen.push(this.get('bar'));
        })
      });
      let child = Child.create({
        bar: 0
      });
      assert.deepEqual(seen, []);
      child.set('bar', 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.deepEqual(seen, [1]);
      child.set('bar', 2);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.deepEqual(seen, [1, 2]);
      child.destroy();
    }
  });
});
define("@ember/object/tests/framework_test", ["@ember/-internals/owner", "@ember/object/-internals", "internal-test-helpers"], function (_owner, _internals, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('FrameworkObject', class extends _internalTestHelpers.RenderingTestCase {
    ['@test tunnels the owner through to the base constructor for framework classes'](assert) {
      assert.expect(2);
      let testContext = this;
      class Model extends _internals.FrameworkObject {
        constructor(owner) {
          super(owner);
          assert.equal((0, _owner.getOwner)(this), testContext.owner, 'owner was assigned properly in the root constructor');
          assert.equal(owner, testContext.owner, 'owner was passed properly to the constructor');
        }
      }
      this.owner.register('model:blah', Model);
      this.owner.factoryFor('model:blah').create();
    }
  });
});
define("@ember/object/tests/mixin/accessor_test", ["@ember/object/mixin", "internal-test-helpers"], function (_mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin Accessors', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works with getters'](assert) {
      let count = 0;
      let MixinA = _mixin.default.create({
        get prop() {
          return count++;
        }
      });
      let obj = {};
      MixinA.apply(obj);
      assert.equal(obj.prop, 0, 'getter defined correctly');
      assert.equal(obj.prop, 1, 'getter defined correctly');
    }
    ['@test works with setters'](assert) {
      let MixinA = _mixin.default.create({
        set prop(value) {
          this._prop = value + 1;
        }
      });
      let obj = {};
      MixinA.apply(obj);
      obj.prop = 0;
      assert.equal(obj._prop, 1, 'setter defined correctly');
    }
  });
});
define("@ember/object/tests/mixin/apply_test", ["@ember/object", "@ember/object/mixin", "internal-test-helpers"], function (_object, _mixin, _internalTestHelpers) {
  "use strict";

  function K() {}
  (0, _internalTestHelpers.moduleFor)('Mixin.apply', class extends _internalTestHelpers.AbstractTestCase {
    ['@test using apply() should apply properties'](assert) {
      let MixinA = _mixin.default.create({
        foo: 'FOO',
        baz: K
      });
      let obj = {};
      (0, _mixin.mixin)(obj, MixinA);
      assert.equal((0, _object.get)(obj, 'foo'), 'FOO', 'should apply foo');
      assert.equal((0, _object.get)(obj, 'baz'), K, 'should apply foo');
    }
    ['@test applying anonymous properties'](assert) {
      let obj = {};
      (0, _mixin.mixin)(obj, {
        foo: 'FOO',
        baz: K
      });
      assert.equal((0, _object.get)(obj, 'foo'), 'FOO', 'should apply foo');
      assert.equal((0, _object.get)(obj, 'baz'), K, 'should apply foo');
    }
    ['@test applying null values']() {
      expectAssertion(() => (0, _mixin.mixin)({}, null));
    }
    ['@test applying a property with an undefined value'](assert) {
      let obj = {
        tagName: ''
      };
      (0, _mixin.mixin)(obj, {
        tagName: undefined
      });
      assert.strictEqual((0, _object.get)(obj, 'tagName'), '');
    }
  });
});
define("@ember/object/tests/mixin/computed_test", ["@ember/object", "@ember/object/mixin", "internal-test-helpers"], function (_object, _mixin, _internalTestHelpers) {
  "use strict";

  function K() {
    return this;
  }
  (0, _internalTestHelpers.moduleFor)('Mixin Computed Properties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test overriding computed properties'](assert) {
      let MixinA, MixinB, MixinC, MixinD;
      let obj;
      window.testStarted = true;
      MixinA = _mixin.default.create({
        aProp: (0, _object.computed)(function () {
          return 'A';
        })
      });
      MixinB = _mixin.default.create(MixinA, {
        aProp: (0, _object.computed)(function () {
          return this._super(...arguments) + 'B';
        })
      });
      MixinC = _mixin.default.create(MixinA, {
        aProp: (0, _object.computed)(function () {
          return this._super(...arguments) + 'C';
        })
      });
      MixinD = _mixin.default.create({
        aProp: (0, _object.computed)(function () {
          return this._super(...arguments) + 'D';
        })
      });
      obj = {};
      MixinB.apply(obj);
      assert.equal((0, _object.get)(obj, 'aProp'), 'AB', 'should expose super for B');
      obj = {};
      MixinC.apply(obj);
      assert.equal((0, _object.get)(obj, 'aProp'), 'AC', 'should expose super for C');
      obj = {};
      MixinA.apply(obj);
      MixinD.apply(obj);
      assert.equal((0, _object.get)(obj, 'aProp'), 'AD', 'should define super for D');
      obj = {};
      (0, _object.defineProperty)(obj, 'aProp', (0, _object.computed)(function () {
        return 'obj';
      }));
      MixinD.apply(obj);
      assert.equal((0, _object.get)(obj, 'aProp'), 'objD', 'should preserve original computed property');
    }
    ['@test calling set on overridden computed properties'](assert) {
      let SuperMixin, SubMixin;
      let obj;
      let superGetOccurred = false;
      let superSetOccurred = false;
      SuperMixin = _mixin.default.create({
        aProp: (0, _object.computed)({
          get() {
            superGetOccurred = true;
          },
          set() {
            superSetOccurred = true;
          }
        })
      });
      SubMixin = _mixin.default.create(SuperMixin, {
        aProp: (0, _object.computed)({
          get() {
            return this._super(...arguments);
          },
          set() {
            return this._super(...arguments);
          }
        })
      });
      obj = {};
      SubMixin.apply(obj);
      (0, _object.set)(obj, 'aProp', 'set thyself');
      assert.ok(superSetOccurred, 'should pass set to _super');
      superSetOccurred = false; // reset the set assertion

      obj = {};
      SubMixin.apply(obj);
      (0, _object.get)(obj, 'aProp');
      assert.ok(superGetOccurred, 'should pass get to _super');
      (0, _object.set)(obj, 'aProp', 'set thyself');
      assert.ok(superSetOccurred, 'should pass set to _super after getting');
    }
    ['@test setter behavior asserts when overriding computed properties'](assert) {
      let obj = {};
      let MixinA = _mixin.default.create({
        cpWithSetter2: (0, _object.computed)(K),
        cpWithSetter3: (0, _object.computed)(K),
        cpWithoutSetter: (0, _object.computed)(K)
      });
      let cpWasCalled = false;
      let MixinB = _mixin.default.create({
        cpWithSetter2: (0, _object.computed)({
          get: K,
          set() {
            cpWasCalled = true;
          }
        }),
        cpWithSetter3: (0, _object.computed)({
          get: K,
          set() {
            cpWasCalled = true;
          }
        }),
        cpWithoutSetter: (0, _object.computed)(function () {
          cpWasCalled = true;
        })
      });
      MixinA.apply(obj);
      MixinB.apply(obj);
      (0, _object.set)(obj, 'cpWithSetter2', 'test');
      assert.ok(cpWasCalled, 'The computed property setter was called when defined with two args');
      cpWasCalled = false;
      (0, _object.set)(obj, 'cpWithSetter3', 'test');
      assert.ok(cpWasCalled, 'The computed property setter was called when defined with three args');
      cpWasCalled = false;
      expectAssertion(() => {
        (0, _object.set)(obj, 'cpWithoutSetter', 'test');
      }, /Cannot override the computed property `cpWithoutSetter` on \[object Object\]./);
    }
  });
});
define("@ember/object/tests/mixin/concatenated_properties_test", ["@ember/object", "@ember/object/mixin", "internal-test-helpers"], function (_object, _mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin concatenatedProperties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test defining concatenated properties should concat future version'](assert) {
      let MixinA = _mixin.default.create({
        concatenatedProperties: ['foo'],
        foo: ['a', 'b', 'c']
      });
      let MixinB = _mixin.default.create({
        foo: ['d', 'e', 'f']
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _object.get)(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f']);
    }
    ['@test ensure we do not needlessly scan concatenatedProperties array'](assert) {
      let MixinA = _mixin.default.create({
        concatenatedProperties: null
      });
      let MixinB = _mixin.default.create({
        concatenatedProperties: null
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.deepEqual(obj.concatenatedProperties, []);
    }
    ['@test concatenatedProperties should be concatenated'](assert) {
      let MixinA = _mixin.default.create({
        concatenatedProperties: ['foo'],
        foo: ['a', 'b', 'c']
      });
      let MixinB = _mixin.default.create({
        concatenatedProperties: 'bar',
        foo: ['d', 'e', 'f'],
        bar: [1, 2, 3]
      });
      let MixinC = _mixin.default.create({
        bar: [4, 5, 6]
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB, MixinC);
      assert.deepEqual((0, _object.get)(obj, 'concatenatedProperties'), ['foo', 'bar'], 'get concatenatedProperties');
      assert.deepEqual((0, _object.get)(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f'], 'get foo');
      assert.deepEqual((0, _object.get)(obj, 'bar'), [1, 2, 3, 4, 5, 6], 'get bar');
    }
    ['@test adding a prop that is a number should make array'](assert) {
      let MixinA = _mixin.default.create({
        concatenatedProperties: ['foo'],
        foo: [1, 2, 3]
      });
      let MixinB = _mixin.default.create({
        foo: 4
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _object.get)(obj, 'foo'), [1, 2, 3, 4]);
    }
    ['@test adding a prop that is a string should make array'](assert) {
      let MixinA = _mixin.default.create({
        concatenatedProperties: ['foo'],
        foo: 'bar'
      });
      let obj = (0, _mixin.mixin)({}, MixinA);
      assert.deepEqual((0, _object.get)(obj, 'foo'), ['bar']);
    }
    ['@test adding a non-concatenable property that already has a defined value should result in an array with both values'](assert) {
      let mixinA = _mixin.default.create({
        foo: 1
      });
      let mixinB = _mixin.default.create({
        concatenatedProperties: ['foo'],
        foo: 2
      });
      let obj = (0, _mixin.mixin)({}, mixinA, mixinB);
      assert.deepEqual((0, _object.get)(obj, 'foo'), [1, 2]);
    }
    ['@test adding a concatenable property that already has a defined value should result in a concatenated value'](assert) {
      let mixinA = _mixin.default.create({
        foobar: 'foo'
      });
      let mixinB = _mixin.default.create({
        concatenatedProperties: ['foobar'],
        foobar: 'bar'
      });
      let obj = (0, _mixin.mixin)({}, mixinA, mixinB);
      assert.deepEqual((0, _object.get)(obj, 'foobar'), ['foo', 'bar']);
    }
  });
});
define("@ember/object/tests/mixin/detect_test", ["@ember/object/mixin", "internal-test-helpers"], function (_mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin.detect', class extends _internalTestHelpers.AbstractTestCase {
    ['@test detect() finds a directly applied mixin'](assert) {
      let MixinA = _mixin.default.create();
      let obj = {};
      assert.equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');
      MixinA.apply(obj);
      assert.equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
    }
    ['@test detect() finds nested mixins'](assert) {
      let MixinA = _mixin.default.create({});
      let MixinB = _mixin.default.create(MixinA);
      let obj = {};
      assert.equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');
      MixinB.apply(obj);
      assert.equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
    }
    ['@test detect() finds mixins on other mixins'](assert) {
      let MixinA = _mixin.default.create({});
      let MixinB = _mixin.default.create(MixinA);
      assert.equal(MixinA.detect(MixinB), true, 'MixinA is part of MixinB');
      assert.equal(MixinB.detect(MixinA), false, 'MixinB is not part of MixinA');
    }
    ['@test detect handles null values'](assert) {
      let MixinA = _mixin.default.create();
      assert.equal(MixinA.detect(null), false);
    }
  });
});
define("@ember/object/tests/mixin/introspection_test", ["@ember/-internals/utils", "@ember/object/mixin", "internal-test-helpers"], function (_utils, _mixin, _internalTestHelpers) {
  "use strict";

  // NOTE: A previous iteration differentiated between public and private props
  // as well as methods vs props.  We are just keeping these for testing; the
  // current impl doesn't care about the differences as much...

  const PrivateProperty = _mixin.default.create({
    _foo: '_FOO'
  });
  const PublicProperty = _mixin.default.create({
    foo: 'FOO'
  });
  const PrivateMethod = _mixin.default.create({
    _fooMethod() {}
  });
  const PublicMethod = _mixin.default.create({
    fooMethod() {}
  });
  const BarProperties = _mixin.default.create({
    _bar: '_BAR',
    bar: 'bar'
  });
  const BarMethods = _mixin.default.create({
    _barMethod() {},
    barMethod() {}
  });
  const Combined = _mixin.default.create(BarProperties, BarMethods);
  let obj;
  (0, _internalTestHelpers.moduleFor)('Basic introspection', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      obj = {};
      (0, _mixin.mixin)(obj, PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined);
    }
    ['@test Ember.mixins()'](assert) {
      function mapGuids(ary) {
        return ary.map(x => (0, _utils.guidFor)(x));
      }
      assert.deepEqual(mapGuids(_mixin.default.mixins(obj)), mapGuids([PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined, BarProperties, BarMethods]), 'should return included mixins');
    }
  });
});
define("@ember/object/tests/mixin/merged_properties_test", ["@ember/object", "@ember/object/mixin", "internal-test-helpers"], function (_object, _mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin mergedProperties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test defining mergedProperties should merge future version'](assert) {
      let MixinA = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: {
          a: true,
          b: true,
          c: true
        }
      });
      let MixinB = _mixin.default.create({
        foo: {
          d: true,
          e: true,
          f: true
        }
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _object.get)(obj, 'foo'), {
        a: true,
        b: true,
        c: true,
        d: true,
        e: true,
        f: true
      });
    }
    ['@test defining mergedProperties on future mixin should merged into past'](assert) {
      let MixinA = _mixin.default.create({
        foo: {
          a: true,
          b: true,
          c: true
        }
      });
      let MixinB = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: {
          d: true,
          e: true,
          f: true
        }
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _object.get)(obj, 'foo'), {
        a: true,
        b: true,
        c: true,
        d: true,
        e: true,
        f: true
      });
    }
    ['@test defining mergedProperties with null properties should keep properties null'](assert) {
      let MixinA = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: null
      });
      let MixinB = _mixin.default.create({
        foo: null
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.equal((0, _object.get)(obj, 'foo'), null);
    }
    ["@test mergedProperties' properties can get overwritten"](assert) {
      let MixinA = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: {
          a: 1
        }
      });
      let MixinB = _mixin.default.create({
        foo: {
          a: 2
        }
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _object.get)(obj, 'foo'), {
        a: 2
      });
    }
    ['@test mergedProperties should be concatenated'](assert) {
      let MixinA = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: {
          a: true,
          b: true,
          c: true
        }
      });
      let MixinB = _mixin.default.create({
        mergedProperties: 'bar',
        foo: {
          d: true,
          e: true,
          f: true
        },
        bar: {
          a: true,
          l: true
        }
      });
      let MixinC = _mixin.default.create({
        bar: {
          e: true,
          x: true
        }
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB, MixinC);
      assert.deepEqual((0, _object.get)(obj, 'mergedProperties'), ['foo', 'bar'], 'get mergedProperties');
      assert.deepEqual((0, _object.get)(obj, 'foo'), {
        a: true,
        b: true,
        c: true,
        d: true,
        e: true,
        f: true
      }, 'get foo');
      assert.deepEqual((0, _object.get)(obj, 'bar'), {
        a: true,
        l: true,
        e: true,
        x: true
      }, 'get bar');
    }
    ['@test mergedProperties should exist even if not explicitly set on create'](assert) {
      let AnObj = _object.default.extend({
        mergedProperties: ['options'],
        options: {
          a: 'a',
          b: {
            c: 'ccc'
          }
        }
      });
      let obj = AnObj.create({
        options: {
          a: 'A'
        }
      });
      assert.equal((0, _object.get)(obj, 'options').a, 'A');
      assert.equal((0, _object.get)(obj, 'options').b.c, 'ccc');
    }
    ['@test defining mergedProperties at create time should not modify the prototype'](assert) {
      let AnObj = _object.default.extend({
        mergedProperties: ['options'],
        options: {
          a: 1
        }
      });
      let objA = AnObj.create({
        options: {
          a: 2
        }
      });
      let objB = AnObj.create({
        options: {
          a: 3
        }
      });
      assert.equal((0, _object.get)(objA, 'options').a, 2);
      assert.equal((0, _object.get)(objB, 'options').a, 3);
    }
    ["@test mergedProperties' overwriting methods can call _super"](assert) {
      assert.expect(4);
      let MixinA = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: {
          meth(a) {
            assert.equal(a, 'WOOT', "_super successfully called MixinA's `foo.meth` method");
            return 'WAT';
          }
        }
      });
      let MixinB = _mixin.default.create({
        foo: {
          meth() {
            assert.ok(true, "MixinB's `foo.meth` method called");
            return this._super(...arguments);
          }
        }
      });
      let MixinC = _mixin.default.create({
        foo: {
          meth(a) {
            assert.ok(true, "MixinC's `foo.meth` method called");
            return this._super(a);
          }
        }
      });
      let obj = (0, _mixin.mixin)({}, MixinA, MixinB, MixinC);
      assert.equal(obj.foo.meth('WOOT'), 'WAT');
    }
    ['@test Merging an Array should raise an error'](assert) {
      assert.expect(1);
      let MixinA = _mixin.default.create({
        mergedProperties: ['foo'],
        foo: {
          a: true,
          b: true,
          c: true
        }
      });
      let MixinB = _mixin.default.create({
        foo: ['a']
      });
      expectAssertion(() => {
        (0, _mixin.mixin)({}, MixinA, MixinB);
      }, 'You passed in `["a"]` as the value for `foo` but `foo` cannot be an Array');
    }
  });
});
define("@ember/object/tests/mixin/method_test", ["@ember/object/mixin", "internal-test-helpers"], function (_mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin Methods', class extends _internalTestHelpers.AbstractTestCase {
    ['@test defining simple methods'](assert) {
      let MixinA, obj, props;
      props = {
        publicMethod() {
          return 'publicMethod';
        },
        _privateMethod() {
          return 'privateMethod';
        }
      };
      MixinA = _mixin.default.create(props);
      obj = {};
      MixinA.apply(obj);

      // but should be defined
      assert.equal(props.publicMethod(), 'publicMethod', 'publicMethod is func');
      assert.equal(props._privateMethod(), 'privateMethod', 'privateMethod is func');
    }
    ['@test overriding public methods'](assert) {
      let MixinA, MixinB, MixinD, MixinF, obj;
      MixinA = _mixin.default.create({
        publicMethod() {
          return 'A';
        }
      });
      MixinB = _mixin.default.create(MixinA, {
        publicMethod() {
          return this._super(...arguments) + 'B';
        }
      });
      MixinD = _mixin.default.create(MixinA, {
        publicMethod() {
          return this._super(...arguments) + 'D';
        }
      });
      MixinF = _mixin.default.create({
        publicMethod() {
          return this._super(...arguments) + 'F';
        }
      });
      obj = {};
      MixinB.apply(obj);
      assert.equal(obj.publicMethod(), 'AB', 'should define super for A and B');
      obj = {};
      MixinD.apply(obj);
      assert.equal(obj.publicMethod(), 'AD', 'should define super for A and B');
      obj = {};
      MixinA.apply(obj);
      MixinF.apply(obj);
      assert.equal(obj.publicMethod(), 'AF', 'should define super for A and F');
      obj = {
        publicMethod() {
          return 'obj';
        }
      };
      MixinF.apply(obj);
      assert.equal(obj.publicMethod(), 'objF', 'should define super for F');
    }
    ['@test overriding inherited objects'](assert) {
      let cnt = 0;
      let MixinA = _mixin.default.create({
        foo() {
          cnt++;
        }
      });
      let MixinB = _mixin.default.create({
        foo() {
          this._super(...arguments);
          cnt++;
        }
      });
      let objA = {};
      MixinA.apply(objA);
      let objB = Object.create(objA);
      MixinB.apply(objB);
      cnt = 0;
      objB.foo();
      assert.equal(cnt, 2, 'should invoke both methods');
      cnt = 0;
      objA.foo();
      assert.equal(cnt, 1, 'should not screw w/ parent obj');
    }
    ['@test Including the same mixin more than once will only run once'](assert) {
      let cnt = 0;
      let MixinA = _mixin.default.create({
        foo() {
          cnt++;
        }
      });
      let MixinB = _mixin.default.create(MixinA, {
        foo() {
          this._super(...arguments);
        }
      });
      let MixinC = _mixin.default.create(MixinA, {
        foo() {
          this._super(...arguments);
        }
      });
      let MixinD = _mixin.default.create(MixinB, MixinC, MixinA, {
        foo() {
          this._super(...arguments);
        }
      });
      let obj = {};
      MixinD.apply(obj);
      MixinA.apply(obj); // try to apply again..

      cnt = 0;
      obj.foo();
      assert.equal(cnt, 1, 'should invoke MixinA.foo one time');
    }
    ['@test _super from a single mixin with no superclass does not error'](assert) {
      let MixinA = _mixin.default.create({
        foo() {
          this._super(...arguments);
        }
      });
      let obj = {};
      MixinA.apply(obj);
      obj.foo();
      assert.ok(true);
    }
    ['@test _super from a first-of-two mixins with no superclass function does not error'](assert) {
      // _super was previously calling itself in the second assertion.
      // Use remaining count of calls to ensure it doesn't loop indefinitely.
      let remaining = 3;
      let MixinA = _mixin.default.create({
        foo() {
          if (remaining-- > 0) {
            this._super(...arguments);
          }
        }
      });
      let MixinB = _mixin.default.create({
        foo() {
          this._super(...arguments);
        }
      });
      let obj = {};
      MixinA.apply(obj);
      MixinB.apply(obj);
      obj.foo();
      assert.ok(true);
    }
  });

  // ..........................................................
  // CONFLICTS
  //
  (0, _internalTestHelpers.moduleFor)('Method Conflicts', class extends _internalTestHelpers.AbstractTestCase {
    ['@test overriding toString'](assert) {
      let MixinA = _mixin.default.create({
        toString() {
          return 'FOO';
        }
      });
      let obj = {};
      MixinA.apply(obj);
      assert.equal(obj.toString(), 'FOO', 'should override toString w/o error');
      obj = {};
      (0, _mixin.mixin)(obj, {
        toString() {
          return 'FOO';
        }
      });
      assert.equal(obj.toString(), 'FOO', 'should override toString w/o error');
    }
  });

  // ..........................................................
  // BUGS
  //
  (0, _internalTestHelpers.moduleFor)('system/mixin/method_test BUGS', class extends _internalTestHelpers.AbstractTestCase {
    ['@test applying several mixins at once with sup already defined causes infinite loop'](assert) {
      let cnt = 0;
      let MixinA = _mixin.default.create({
        foo() {
          cnt++;
        }
      });
      let MixinB = _mixin.default.create({
        foo() {
          this._super(...arguments);
          cnt++;
        }
      });
      let MixinC = _mixin.default.create({
        foo() {
          this._super(...arguments);
          cnt++;
        }
      });
      let obj = {};
      (0, _mixin.mixin)(obj, MixinA); // sup already exists
      (0, _mixin.mixin)(obj, MixinB, MixinC); // must be more than one mixin

      cnt = 0;
      obj.foo();
      assert.equal(cnt, 3, 'should invoke all 3 methods');
    }
  });
});
define("@ember/object/tests/mixin/observer_test", ["@ember/object", "@ember/object/mixin", "internal-test-helpers", "@glimmer/destroyable"], function (_object, _mixin, _internalTestHelpers, _destroyable) {
  "use strict";

  let obj;
  (0, _internalTestHelpers.moduleFor)('Mixin observer', class extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      if (obj !== undefined) {
        (0, _destroyable.destroy)(obj);
        obj = undefined;
        return (0, _internalTestHelpers.runLoopSettled)();
      }
    }
    async ['@test global observer helper'](assert) {
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({}, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test global observer helper takes multiple params'](assert) {
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar', 'baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({}, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      (0, _object.set)(obj, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 2, 'should invoke observer after change');
      (0, _destroyable.destroy)(obj);
      await (0, _internalTestHelpers.runLoopSettled)();
    }
    async ['@test replacing observer should remove old observer'](assert) {
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let Mixin2 = _mixin.default.create({
        foo: (0, _object.observer)('baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 10);
        })
      });
      obj = (0, _mixin.mixin)({}, MyMixin, Mixin2);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer after change');
      (0, _object.set)(obj, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 10, 'should invoke observer after change');
    }
    async ['@test observing chain with property before'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let MyMixin = _mixin.default.create({
        count: 0,
        bar: obj2,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({}, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test observing chain with property after'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        }),
        bar: obj2
      });
      obj = (0, _mixin.mixin)({}, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test observing chain with property in mixin applied later'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let MyMixin2 = _mixin.default.create({
        bar: obj2
      });
      obj = (0, _mixin.mixin)({}, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      MyMixin2.apply(obj);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test observing chain with existing property'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({
        bar: obj2
      }, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test observing chain with property in mixin before'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let MyMixin2 = _mixin.default.create({
        bar: obj2
      });
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({}, MyMixin2, MyMixin);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test observing chain with property in mixin after'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let MyMixin2 = _mixin.default.create({
        bar: obj2
      });
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({}, MyMixin, MyMixin2);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
    async ['@test observing chain with overridden property'](assert) {
      let obj2 = {
        baz: 'baz'
      };
      let obj3 = {
        baz: 'foo'
      };
      let MyMixin2 = _mixin.default.create({
        bar: obj3
      });
      let MyMixin = _mixin.default.create({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      obj = (0, _mixin.mixin)({
        bar: obj2
      }, MyMixin, MyMixin2);
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj2, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer after change');
      (0, _object.set)(obj3, 'baz', 'BEAR');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
    }
  });
});
define("@ember/object/tests/mixin/reopen_test", ["@ember/object", "@ember/object/mixin", "@ember/runloop", "internal-test-helpers"], function (_object, _mixin, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin#reopen', class extends _internalTestHelpers.AbstractTestCase {
    ['@test using reopen() to add more properties to a simple'](assert) {
      let MixinA = _mixin.default.create({
        foo: 'FOO',
        baz: 'BAZ'
      });
      MixinA.reopen({
        bar: 'BAR',
        foo: 'FOO2'
      });
      let obj = {};
      MixinA.apply(obj);
      assert.equal((0, _object.get)(obj, 'foo'), 'FOO2', 'mixin() should override');
      assert.equal((0, _object.get)(obj, 'baz'), 'BAZ', 'preserve MixinA props');
      assert.equal((0, _object.get)(obj, 'bar'), 'BAR', 'include MixinB props');
    }
    ['@test using reopen() and calling _super where there is not a super function does not cause infinite recursion'](assert) {
      let Taco = _object.default.extend({
        createBreakfast() {
          // There is no original createBreakfast function.
          // Calling the wrapped _super function here
          // used to end in an infinite call loop
          this._super(...arguments);
          return 'Breakfast!';
        }
      });
      Taco.reopen({
        createBreakfast() {
          return this._super(...arguments);
        }
      });
      let taco = Taco.create();
      let result;
      (0, _runloop.run)(() => {
        try {
          result = taco.createBreakfast();
        } catch (e) {
          result = 'Your breakfast was interrupted by an infinite stack error.';
        }
      });
      assert.equal(result, 'Breakfast!');
    }
  });
});
define("@ember/object/tests/mixin/without_test", ["@ember/object/mixin", "internal-test-helpers"], function (_mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('without', class extends _internalTestHelpers.AbstractTestCase {
    ['@test without should create a new mixin excluding named properties'](assert) {
      let MixinA = _mixin.default.create({
        foo: 'FOO',
        bar: 'BAR'
      });
      let MixinB = MixinA.without('bar');
      let obj = {};
      MixinB.apply(obj);
      assert.equal(obj.foo, 'FOO', 'should defined foo');
      assert.equal(obj.bar, undefined, 'should not define bar');
    }
  });
});
define("@ember/object/tests/observable_test", ["@ember/-internals/environment", "@ember/runloop", "@ember/object", "@ember/object/observable", "@ember/array", "internal-test-helpers"], function (_environment, _runloop, _object, _observable, _array, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Added ObservableObject which applies the Ember.Observable mixin.
    * Changed reference to Ember.T_FUNCTION to 'function'
    * Changed all references to sc_super to this._super(...arguments)
    * Changed Ember.objectForPropertyPath() to Ember.getPath()
    * Removed allPropertiesDidChange test - no longer supported
    * Changed test that uses 'ObjectE' as path to 'objectE' to reflect new
      rule on using capital letters for property paths.
    * Removed test passing context to addObserver.  context param is no longer
      supported.
    * removed test in observer around line 862 that expected key/value to be
      the last item in the chained path.  Should be root and chained path
  
  */

  // ========================================================================
  // Ember.Observable Tests
  // ========================================================================
  let object, objectA, objectB, objectC, objectD, objectE, objectF, lookup;
  const ObservableObject = _object.default.extend(_observable.default);
  const originalLookup = _environment.context.lookup;
  class ObservableTestCase extends _internalTestHelpers.AbstractTestCase {
    afterEach() {
      let destroyables = [object, objectA, objectB, objectC, objectD, objectE, objectF].filter(obj => obj && obj.destroy);
      object = objectA = objectC = objectD = objectE = objectF = undefined;
      _environment.context.lookup = originalLookup;
      lookup = undefined;
      destroyables.forEach(obj => obj.destroy());
      return (0, _internalTestHelpers.runLoopSettled)();
    }
  }

  // ..........................................................
  // GET()
  //

  (0, _internalTestHelpers.moduleFor)('object.get()', class extends ObservableTestCase {
    beforeEach() {
      object = ObservableObject.extend(_observable.default, {
        computed: (0, _object.computed)(function () {
          return 'value';
        }),
        method() {
          return 'value';
        },
        unknownProperty(key) {
          this.lastUnknownProperty = key;
          return 'unknown';
        }
      }).create({
        normal: 'value',
        numberVal: 24,
        toggleVal: true,
        nullProperty: null
      });
    }
    ['@test should get normal properties'](assert) {
      assert.equal(object.get('normal'), 'value');
    }
    ['@test should call computed properties and return their result'](assert) {
      assert.equal(object.get('computed'), 'value');
    }
    ['@test should return the function for a non-computed property'](assert) {
      let value = object.get('method');
      assert.equal(typeof value, 'function');
    }
    ['@test should return null when property value is null'](assert) {
      assert.equal(object.get('nullProperty'), null);
    }
    ['@test should call unknownProperty when value is undefined'](assert) {
      assert.equal(object.get('unknown'), 'unknown');
      assert.equal(object.lastUnknownProperty, 'unknown');
    }
  });
  // ..........................................................
  // Ember.GET()
  //
  (0, _internalTestHelpers.moduleFor)('Ember.get()', class extends ObservableTestCase {
    beforeEach() {
      objectA = ObservableObject.extend({
        computed: (0, _object.computed)(function () {
          return 'value';
        }),
        method() {
          return 'value';
        },
        unknownProperty(key) {
          this.lastUnknownProperty = key;
          return 'unknown';
        }
      }).create({
        normal: 'value',
        numberVal: 24,
        toggleVal: true,
        nullProperty: null
      });
      objectB = {
        normal: 'value',
        nullProperty: null
      };
    }
    ['@test should get normal properties on Ember.Observable'](assert) {
      assert.equal((0, _object.get)(objectA, 'normal'), 'value');
    }
    ['@test should call computed properties on Ember.Observable and return their result'](assert) {
      assert.equal((0, _object.get)(objectA, 'computed'), 'value');
    }
    ['@test should return the function for a non-computed property on Ember.Observable'](assert) {
      let value = (0, _object.get)(objectA, 'method');
      assert.equal(typeof value, 'function');
    }
    ['@test should return null when property value is null on Ember.Observable'](assert) {
      assert.equal((0, _object.get)(objectA, 'nullProperty'), null);
    }
    ['@test should call unknownProperty when value is undefined on Ember.Observable'](assert) {
      assert.equal((0, _object.get)(objectA, 'unknown'), 'unknown');
      assert.equal(objectA.lastUnknownProperty, 'unknown');
    }
    ['@test should get normal properties on standard objects'](assert) {
      assert.equal((0, _object.get)(objectB, 'normal'), 'value');
    }
    ['@test should return null when property is null on standard objects'](assert) {
      assert.equal((0, _object.get)(objectB, 'nullProperty'), null);
    }
    ['@test raise if the provided object is undefined']() {
      expectAssertion(function () {
        (0, _object.get)(undefined, 'key');
      }, /Cannot call get with 'key' on an undefined object/i);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Ember.get() with paths', class extends ObservableTestCase {
    ['@test should return a property at a given path relative to the passed object'](assert) {
      let foo = ObservableObject.create({
        bar: ObservableObject.extend({
          baz: (0, _object.computed)(function () {
            return 'blargh';
          })
        }).create()
      });
      assert.equal((0, _object.get)(foo, 'bar.baz'), 'blargh');
    }
    ['@test should return a property at a given path relative to the passed object - JavaScript hash'](assert) {
      let foo = {
        bar: {
          baz: 'blargh'
        }
      };
      assert.equal((0, _object.get)(foo, 'bar.baz'), 'blargh');
    }
  });

  // ..........................................................
  // SET()
  //

  (0, _internalTestHelpers.moduleFor)('object.set()', class extends ObservableTestCase {
    beforeEach() {
      object = ObservableObject.extend({
        computed: (0, _object.computed)({
          get() {
            return this._computed;
          },
          set(key, value) {
            this._computed = value;
            return this._computed;
          }
        }),
        method(key, value) {
          if (value !== undefined) {
            this._method = value;
          }
          return this._method;
        },
        unknownProperty() {
          return this._unknown;
        },
        setUnknownProperty(key, value) {
          this._unknown = value;
          return this._unknown;
        },
        // normal property
        normal: 'value',
        // computed property
        _computed: 'computed',
        // method, but not a property
        _method: 'method',
        // null property
        nullProperty: null,
        // unknown property
        _unknown: 'unknown'
      }).create();
    }
    ['@test should change normal properties and return the value'](assert) {
      let ret = object.set('normal', 'changed');
      assert.equal(object.get('normal'), 'changed');
      assert.equal(ret, 'changed');
    }
    ['@test should call computed properties passing value and return the value'](assert) {
      let ret = object.set('computed', 'changed');
      assert.equal(object.get('_computed'), 'changed');
      assert.equal(ret, 'changed');
    }
    ['@test should change normal properties when passing undefined'](assert) {
      let ret = object.set('normal', undefined);
      assert.equal(object.get('normal'), undefined);
      assert.equal(ret, undefined);
    }
    ['@test should replace the function for a non-computed property and return the value'](assert) {
      let ret = object.set('method', 'changed');
      assert.equal(object.get('_method'), 'method'); // make sure this was NOT run
      assert.ok(typeof object.get('method') !== 'function');
      assert.equal(ret, 'changed');
    }
    ['@test should replace prover when property value is null'](assert) {
      let ret = object.set('nullProperty', 'changed');
      assert.equal(object.get('nullProperty'), 'changed');
      assert.equal(ret, 'changed');
    }
    ['@test should call unknownProperty with value when property is undefined'](assert) {
      let ret = object.set('unknown', 'changed');
      assert.equal(object.get('_unknown'), 'changed');
      assert.equal(ret, 'changed');
    }
  });

  // ..........................................................
  // COMPUTED PROPERTIES
  //

  (0, _internalTestHelpers.moduleFor)('Computed properties', class extends ObservableTestCase {
    beforeEach() {
      lookup = _environment.context.lookup = {};
      object = ObservableObject.extend({
        computed: (0, _object.computed)({
          get() {
            this.computedCalls.push('getter-called');
            return 'computed';
          },
          set(key, value) {
            this.computedCalls.push(value);
          }
        }),
        dependent: (0, _object.computed)('changer', {
          get() {
            this.dependentCalls.push('getter-called');
            return 'dependent';
          },
          set(key, value) {
            this.dependentCalls.push(value);
          }
        }),
        inc: (0, _object.computed)('changer', function () {
          return this.incCallCount++;
        }),
        nestedInc: (0, _object.computed)('inc', function () {
          (0, _object.get)(this, 'inc');
          return this.nestedIncCallCount++;
        }),
        isOn: (0, _object.computed)('state', {
          get() {
            return this.get('state') === 'on';
          },
          set() {
            this.set('state', 'on');
            return this.get('state') === 'on';
          }
        }),
        isOff: (0, _object.computed)('state', {
          get() {
            return this.get('state') === 'off';
          },
          set() {
            this.set('state', 'off');
            return this.get('state') === 'off';
          }
        })
      }).create({
        computedCalls: [],
        changer: 'foo',
        dependentCalls: [],
        incCallCount: 0,
        nestedIncCallCount: 0,
        state: 'on'
      });
    }
    ['@test getting values should call function return value'](assert) {
      // get each property twice. Verify return.
      let keys = ['computed', 'dependent'];
      keys.forEach(function (key) {
        assert.equal(object.get(key), key, "Try #1: object.get(" + key + ") should run function");
        assert.equal(object.get(key), key, "Try #2: object.get(" + key + ") should run function");
      });

      // verify each call count. cached should only be called once
      ['computedCalls', 'dependentCalls'].forEach(key => {
        assert.equal(object[key].length, 1, "non-cached property " + key + " should be called 1x");
      });
    }
    ['@test setting values should call function return value'](assert) {
      // get each property twice. Verify return.
      let keys = ['computed', 'dependent'];
      let values = ['value1', 'value2'];
      keys.forEach(key => {
        assert.equal(object.set(key, values[0]), values[0], "Try #1: object.set(" + key + ", " + values[0] + ") should run function");
        assert.equal(object.set(key, values[1]), values[1], "Try #2: object.set(" + key + ", " + values[1] + ") should run function");
        assert.equal(object.set(key, values[1]), values[1], "Try #3: object.set(" + key + ", " + values[1] + ") should not run function since it is setting same value as before");
      });

      // verify each call count.  cached should only be called once
      keys.forEach(key => {
        let calls = object[key + 'Calls'];
        let idx, expectedLength;

        // Cached properties first check their cached value before setting the
        // property. Other properties blindly call set.
        expectedLength = 3;
        assert.equal(calls.length, expectedLength, "set(" + key + ") should be called the right amount of times");
        for (idx = 0; idx < 2; idx++) {
          assert.equal(calls[idx], values[idx], "call #" + (idx + 1) + " to set(" + key + ") should have passed value " + values[idx]);
        }
      });
    }
    ['@test notify change should clear cache'](assert) {
      // call get several times to collect call count
      object.get('computed'); // should run func
      object.get('computed'); // should not run func

      object.notifyPropertyChange('computed');
      object.get('computed'); // should run again
      assert.equal(object.computedCalls.length, 2, 'should have invoked method 2x');
    }
    ['@test change dependent should clear cache'](assert) {
      // call get several times to collect call count
      let ret1 = object.get('inc'); // should run func
      assert.equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');
      object.set('changer', 'bar');
      assert.equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    }

    ['@test just notifying change of dependent should clear cache'](assert) {
      // call get several times to collect call count
      let ret1 = object.get('inc'); // should run func
      assert.equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');
      object.notifyPropertyChange('changer');
      assert.equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    }

    ['@test changing dependent should clear nested cache'](assert) {
      // call get several times to collect call count
      let ret1 = object.get('nestedInc'); // should run func
      assert.equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');
      object.set('changer', 'bar');
      assert.equal(object.get('nestedInc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    }

    ['@test just notifying change of dependent should clear nested cache'](assert) {
      // call get several times to collect call count
      let ret1 = object.get('nestedInc'); // should run func
      assert.equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');
      object.notifyPropertyChange('changer');
      assert.equal(object.get('nestedInc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    }

    // This verifies a specific bug encountered where observers for computed
    // properties would fire before their prop caches were cleared.
    ['@test change dependent should clear cache when observers of dependent are called'](assert) {
      // call get several times to collect call count
      let ret1 = object.get('inc'); // should run func
      assert.equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');

      // add observer to verify change...
      object.addObserver('inc', this, function () {
        assert.equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
      });

      // now run
      object.set('changer', 'bar');
    }
    ['@test setting one of two computed properties that depend on a third property should clear the kvo cache'](assert) {
      // we have to call set twice to fill up the cache
      object.set('isOff', true);
      object.set('isOn', true);

      // setting isOff to true should clear the kvo cache
      object.set('isOff', true);
      assert.equal(object.get('isOff'), true, 'object.isOff should be true');
      assert.equal(object.get('isOn'), false, 'object.isOn should be false');
    }
    ['@test dependent keys should be able to be specified as property paths'](assert) {
      let depObj = ObservableObject.extend({
        menuPrice: (0, _object.computed)('menu.price', function () {
          return this.get('menu.price');
        })
      }).create({
        menu: ObservableObject.create({
          price: 5
        })
      });
      assert.equal(depObj.get('menuPrice'), 5, 'precond - initial value returns 5');
      depObj.set('menu.price', 6);
      assert.equal(depObj.get('menuPrice'), 6, 'cache is properly invalidated after nested property changes');
    }
    ['@test cacheable nested dependent keys should clear after their dependencies update'](assert) {
      assert.ok(true);
      let DepObj;
      (0, _runloop.run)(function () {
        lookup.DepObj = DepObj = ObservableObject.extend({
          price: (0, _object.computed)('restaurant.menu.price', function () {
            return this.get('restaurant.menu.price');
          })
        }).create({
          restaurant: ObservableObject.create({
            menu: ObservableObject.create({
              price: 5
            })
          })
        });
      });
      assert.equal(DepObj.get('price'), 5, 'precond - computed property is correct');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu.price', 10);
      });
      assert.equal(DepObj.get('price'), 10, 'cacheable computed properties are invalidated even if no run loop occurred');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu.price', 20);
      });
      assert.equal(DepObj.get('price'), 20, 'cacheable computed properties are invalidated after a second get before a run loop');
      assert.equal(DepObj.get('price'), 20, 'precond - computed properties remain correct after a run loop');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu', ObservableObject.create({
          price: 15
        }));
      });
      assert.equal(DepObj.get('price'), 15, 'cacheable computed properties are invalidated after a middle property changes');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu', ObservableObject.create({
          price: 25
        }));
      });
      assert.equal(DepObj.get('price'), 25, 'cacheable computed properties are invalidated after a middle property changes again, before a run loop');
    }
  });

  // ..........................................................
  // OBSERVABLE OBJECTS
  //

  (0, _internalTestHelpers.moduleFor)('Observable objects & object properties ', class extends ObservableTestCase {
    beforeEach() {
      object = ObservableObject.extend({
        getEach() {
          let keys = ['normal', 'abnormal'];
          let ret = [];
          for (let idx = 0; idx < keys.length; idx++) {
            ret[ret.length] = this.get(keys[idx]);
          }
          return ret;
        },
        newObserver() {
          this.abnormal = 'changedValueObserved';
        },
        testObserver: (0, _object.observer)('normal', function () {
          this.abnormal = 'removedObserver';
        }),
        testArrayObserver: (0, _object.observer)('normalArray.[]', function () {
          this.abnormal = 'notifiedObserver';
        })
      }).create({
        normal: 'value',
        abnormal: 'zeroValue',
        numberVal: 24,
        toggleVal: true,
        observedProperty: 'beingWatched',
        testRemove: 'observerToBeRemoved',
        normalArray: (0, _array.A)([1, 2, 3, 4, 5])
      });
    }
    ['@test incrementProperty and decrementProperty'](assert) {
      let newValue = object.incrementProperty('numberVal');
      assert.equal(25, newValue, 'numerical value incremented');
      object.numberVal = 24;
      newValue = object.decrementProperty('numberVal');
      assert.equal(23, newValue, 'numerical value decremented');
      object.numberVal = 25;
      newValue = object.incrementProperty('numberVal', 5);
      assert.equal(30, newValue, 'numerical value incremented by specified increment');
      object.numberVal = 25;
      newValue = object.incrementProperty('numberVal', -5);
      assert.equal(20, newValue, 'minus numerical value incremented by specified increment');
      object.numberVal = 25;
      newValue = object.incrementProperty('numberVal', 0);
      assert.equal(25, newValue, 'zero numerical value incremented by specified increment');
      expectAssertion(function () {
        newValue = object.incrementProperty('numberVal', 0 - void 0); // Increment by NaN
      }, /Must pass a numeric value to incrementProperty/i);
      expectAssertion(function () {
        newValue = object.incrementProperty('numberVal', 'Ember'); // Increment by non-numeric String
      }, /Must pass a numeric value to incrementProperty/i);
      expectAssertion(function () {
        newValue = object.incrementProperty('numberVal', 1 / 0); // Increment by Infinity
      }, /Must pass a numeric value to incrementProperty/i);
      assert.equal(25, newValue, 'Attempting to increment by non-numeric values should not increment value');
      object.numberVal = 25;
      newValue = object.decrementProperty('numberVal', 5);
      assert.equal(20, newValue, 'numerical value decremented by specified increment');
      object.numberVal = 25;
      newValue = object.decrementProperty('numberVal', -5);
      assert.equal(30, newValue, 'minus numerical value decremented by specified increment');
      object.numberVal = 25;
      newValue = object.decrementProperty('numberVal', 0);
      assert.equal(25, newValue, 'zero numerical value decremented by specified increment');
      expectAssertion(function () {
        newValue = object.decrementProperty('numberVal', 0 - void 0); // Decrement by NaN
      }, /Must pass a numeric value to decrementProperty/i);
      expectAssertion(function () {
        newValue = object.decrementProperty('numberVal', 'Ember'); // Decrement by non-numeric String
      }, /Must pass a numeric value to decrementProperty/i);
      expectAssertion(function () {
        newValue = object.decrementProperty('numberVal', 1 / 0); // Decrement by Infinity
      }, /Must pass a numeric value to decrementProperty/i);
      assert.equal(25, newValue, 'Attempting to decrement by non-numeric values should not decrement value');
    }
    ['@test toggle function, should be boolean'](assert) {
      assert.equal(object.toggleProperty('toggleVal', true, false), object.get('toggleVal'));
      assert.equal(object.toggleProperty('toggleVal', true, false), object.get('toggleVal'));
      assert.equal(object.toggleProperty('toggleVal', undefined, undefined), object.get('toggleVal'));
    }
    async ['@test should notify array observer when array changes'](assert) {
      (0, _object.get)(object, 'normalArray').replace(0, 0, [6]);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(object.abnormal, 'notifiedObserver', 'observer should be notified');
    }
  });
  (0, _internalTestHelpers.moduleFor)('object.addObserver()', class extends ObservableTestCase {
    beforeEach() {
      objectE = ObservableObject.create({
        propertyVal: 'chainedProperty'
      });
      objectC = ObservableObject.create({
        objectE,
        normal: 'value',
        normal1: 'zeroValue',
        normal2: 'dependentValue',
        incrementor: 10,
        action() {
          this.normal1 = 'newZeroValue';
        },
        observeOnceAction() {
          this.incrementor = this.incrementor + 1;
        },
        chainedObserver() {
          this.normal2 = 'chainedPropertyObserved';
        }
      });
    }
    async ['@test should register an observer for a property'](assert) {
      objectC.addObserver('normal', objectC, 'action');
      objectC.set('normal', 'newValue');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(objectC.normal1, 'newZeroValue');
    }
    async ['@test should register an observer for a property - Special case of chained property'](assert) {
      objectC.addObserver('objectE.propertyVal', objectC, 'chainedObserver');
      objectC.objectE.set('propertyVal', 'chainedPropertyValue');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal('chainedPropertyObserved', objectC.normal2);
      objectC.normal2 = 'dependentValue';
      objectC.set('objectE', '');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal('chainedPropertyObserved', objectC.normal2);
    }
  });
  (0, _internalTestHelpers.moduleFor)('object.removeObserver()', class extends ObservableTestCase {
    beforeEach() {
      objectF = ObservableObject.create({
        propertyVal: 'chainedProperty'
      });
      objectD = ObservableObject.create({
        objectF,
        normal: 'value',
        normal1: 'zeroValue',
        normal2: 'dependentValue',
        ArrayKeys: ['normal', 'normal1'],
        addAction() {
          this.normal1 = 'newZeroValue';
        },
        removeAction() {
          this.normal2 = 'newDependentValue';
        },
        removeChainedObserver() {
          this.normal2 = 'chainedPropertyObserved';
        },
        observableValue: 'hello world',
        observer1() {
          // Just an observer
        },
        observer2() {
          this.removeObserver('observableValue', null, 'observer1');
          this.removeObserver('observableValue', null, 'observer2');
          this.hasObserverFor('observableValue'); // Tickle 'getMembers()'
          this.removeObserver('observableValue', null, 'observer3');
        },
        observer3() {
          // Just an observer
        }
      });
    }
    async ['@test should unregister an observer for a property'](assert) {
      objectD.addObserver('normal', objectD, 'addAction');
      objectD.set('normal', 'newValue');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(objectD.normal1, 'newZeroValue');
      objectD.set('normal1', 'zeroValue');
      await (0, _internalTestHelpers.runLoopSettled)();
      objectD.removeObserver('normal', objectD, 'addAction');
      objectD.set('normal', 'newValue');
      assert.equal(objectD.normal1, 'zeroValue');
    }
    async ["@test should unregister an observer for a property - special case when key has a '.' in it."](assert) {
      objectD.addObserver('objectF.propertyVal', objectD, 'removeChainedObserver');
      objectD.objectF.set('propertyVal', 'chainedPropertyValue');
      await (0, _internalTestHelpers.runLoopSettled)();
      objectD.removeObserver('objectF.propertyVal', objectD, 'removeChainedObserver');
      objectD.normal2 = 'dependentValue';
      objectD.objectF.set('propertyVal', 'removedPropertyValue');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal('dependentValue', objectD.normal2);
      objectD.set('objectF', '');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal('dependentValue', objectD.normal2);
    }
    async ['@test removing an observer inside of an observer shouldnt cause any problems'](assert) {
      // The observable system should be protected against clients removing
      // observers in the middle of observer notification.
      let encounteredError = false;
      try {
        objectD.addObserver('observableValue', null, 'observer1');
        objectD.addObserver('observableValue', null, 'observer2');
        objectD.addObserver('observableValue', null, 'observer3');
        objectD.set('observableValue', 'hi world');
        await (0, _internalTestHelpers.runLoopSettled)();
      } catch (e) {
        encounteredError = true;
      }
      assert.equal(encounteredError, false);
    }
  });
});
define("@ember/object/tests/observer_test", ["@ember/runloop", "@ember/-internals/metal", "@ember/object", "internal-test-helpers"], function (_runloop, _metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EmberObject observer', class extends _internalTestHelpers.AbstractTestCase {
    async ['@test observer on class'](assert) {
      let MyClass = _object.default.extend({
        count: 0,
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let obj = MyClass.create();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
      obj.destroy();
    }
    async ['@test setting `undefined` value on observed property behaves correctly'](assert) {
      let MyClass = _object.default.extend({
        mood: 'good',
        foo: (0, _object.observer)('mood', function () {})
      });
      let obj = MyClass.create();
      assert.equal((0, _object.get)(obj, 'mood'), 'good');
      (0, _object.set)(obj, 'mood', 'bad');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'mood'), 'bad');
      (0, _object.set)(obj, 'mood', undefined);
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'mood'), undefined);
      (0, _object.set)(obj, 'mood', 'awesome');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'mood'), 'awesome');
      obj.destroy();
    }
    async ['@test observer on subclass'](assert) {
      let MyClass = _object.default.extend({
        count: 0,
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let Subclass = MyClass.extend({
        foo: (0, _object.observer)('baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let obj = Subclass.create();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer after change');
      (0, _object.set)(obj, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
      obj.destroy();
    }
    async ['@test observer on instance'](assert) {
      let obj = _object.default.extend({
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      }).create({
        count: 0
      });
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
      obj.destroy();
      await (0, _internalTestHelpers.runLoopSettled)();
    }
    async ['@test observer on instance overriding class'](assert) {
      let MyClass = _object.default.extend({
        count: 0,
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let obj = MyClass.extend({
        foo: (0, _object.observer)('baz', function () {
          // <-- change property we observe
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      }).create();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer immediately');
      (0, _object.set)(obj, 'bar', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer after change');
      (0, _object.set)(obj, 'baz', 'BAZ');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj, 'count'), 1, 'should invoke observer after change');
      obj.destroy();
    }
    async ['@test observer should not fire after being destroyed'](assert) {
      let obj = _object.default.extend({
        count: 0,
        foo: (0, _object.observer)('bar', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      }).create();
      assert.equal((0, _object.get)(obj, 'count'), 0, 'precond - should not invoke observer immediately');
      (0, _runloop.run)(() => obj.destroy());
      expectAssertion(function () {
        (0, _object.set)(obj, 'bar', 'BAZ');
      }, "calling set on destroyed object: " + obj + ".bar = BAZ");
      assert.equal((0, _object.get)(obj, 'count'), 0, 'should not invoke observer after change');
      obj.destroy();
    }

    // ..........................................................
    // COMPLEX PROPERTIES
    //

    async ['@test chain observer on class'](assert) {
      let MyClass = _object.default.extend({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let obj1 = MyClass.create({
        bar: {
          baz: 'biff'
        }
      });
      let obj2 = MyClass.create({
        bar: {
          baz: 'biff2'
        }
      });
      assert.equal((0, _object.get)(obj1, 'count'), 0, 'should not invoke yet');
      assert.equal((0, _object.get)(obj2, 'count'), 0, 'should not invoke yet');
      (0, _object.set)((0, _object.get)(obj1, 'bar'), 'baz', 'BIFF1');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj1, 'count'), 1, 'should invoke observer on obj1');
      assert.equal((0, _object.get)(obj2, 'count'), 0, 'should not invoke yet');
      (0, _object.set)((0, _object.get)(obj2, 'bar'), 'baz', 'BIFF2');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj1, 'count'), 1, 'should not invoke again');
      assert.equal((0, _object.get)(obj2, 'count'), 1, 'should invoke observer on obj2');
      obj1.destroy();
      obj2.destroy();
    }
    async ['@test clobbering a chain observer on subclass'](assert) {
      let MyClass = _object.default.extend({
        count: 0,
        foo: (0, _object.observer)('bar.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      });
      let obj1 = MyClass.extend().create({
        bar: {
          baz: 'biff'
        }
      });
      let obj2 = MyClass.extend({
        foo: (0, _object.observer)('bar2.baz', function () {
          (0, _object.set)(this, 'count', (0, _object.get)(this, 'count') + 1);
        })
      }).create({
        bar: {
          baz: 'biff2'
        },
        bar2: {
          baz: 'biff3'
        }
      });
      assert.equal((0, _object.get)(obj1, 'count'), 0, 'should not invoke yet');
      assert.equal((0, _object.get)(obj2, 'count'), 0, 'should not invoke yet');
      (0, _object.set)((0, _object.get)(obj1, 'bar'), 'baz', 'BIFF1');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj1, 'count'), 1, 'should invoke observer on obj1');
      assert.equal((0, _object.get)(obj2, 'count'), 0, 'should not invoke yet');
      (0, _object.set)((0, _object.get)(obj2, 'bar'), 'baz', 'BIFF2');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj1, 'count'), 1, 'should not invoke again');
      assert.equal((0, _object.get)(obj2, 'count'), 0, 'should not invoke yet');
      (0, _object.set)((0, _object.get)(obj2, 'bar2'), 'baz', 'BIFF3');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _object.get)(obj1, 'count'), 1, 'should not invoke again');
      assert.equal((0, _object.get)(obj2, 'count'), 1, 'should invoke observer on obj2');
      obj1.destroy();
      obj2.destroy();
    }
    async ['@test chain observer on class that has a reference to an uninitialized object will finish chains that reference it'](assert) {
      let changed = false;
      let ChildClass = _object.default.extend({
        parent: null,
        parentOneTwoDidChange: (0, _object.observer)('parent.one.two', function () {
          changed = true;
        })
      });
      let ParentClass = _object.default.extend({
        one: {
          two: 'old'
        },
        init() {
          this.child = ChildClass.create({
            parent: this
          });
        }
      });
      let parent = ParentClass.create();
      assert.equal(changed, false, 'precond');
      (0, _object.set)(parent, 'one.two', 'new');
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(changed, true, 'child should have been notified of change to path');
      (0, _object.set)(parent, 'one', {
        two: 'newer'
      });
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(changed, true, 'child should have been notified of change to path');
      parent.child.destroy();
      parent.destroy();
    }
    async ['@test cannot re-enter observer while it is flushing'](assert) {
      let changed = false;
      let Class = _object.default.extend({
        bar: 0,
        get foo() {
          // side effects during creation, setting a value and running through
          // sync observers for a second time.
          return this.incrementProperty('bar');
        },
        // Ensures we get `foo` eagerly when attempting to observe it
        fooAlias: (0, _metal.alias)('foo'),
        parentOneTwoDidChange: (0, _object.observer)({
          dependentKeys: ['fooAlias'],
          fn() {
            changed = true;
          },
          sync: true
        })
      });
      let obj = Class.create();
      obj.notifyPropertyChange('foo');
      assert.equal(changed, true, 'observer fired successfully');
      obj.destroy();
    }
  });
});
define("@ember/object/tests/reopenClass_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/reopenClass', class extends _internalTestHelpers.AbstractTestCase {
    ['@test adds new properties to subclass'](assert) {
      let Subclass = _object.default.extend();
      Subclass.reopenClass({
        foo() {
          return 'FOO';
        },
        bar: 'BAR'
      });
      assert.equal(Subclass.foo(), 'FOO', 'Adds method');
      assert.equal((0, _object.get)(Subclass, 'bar'), 'BAR', 'Adds property');
    }
    ['@test class properties inherited by subclasses'](assert) {
      let Subclass = _object.default.extend();
      Subclass.reopenClass({
        foo() {
          return 'FOO';
        },
        bar: 'BAR'
      });
      let SubSub = Subclass.extend();
      assert.equal(SubSub.foo(), 'FOO', 'Adds method');
      assert.equal((0, _object.get)(SubSub, 'bar'), 'BAR', 'Adds property');
    }
  });
});
define("@ember/object/tests/reopen_test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  // TODO: Update these tests (or the title) to match each other.
  (0, _internalTestHelpers.moduleFor)('system/core_object/reopen', class extends _internalTestHelpers.AbstractTestCase {
    ['@test adds new properties to subclass instance'](assert) {
      let Subclass = _object.default.extend();
      Subclass.reopen({
        foo() {
          return 'FOO';
        },
        bar: 'BAR'
      });
      assert.equal(Subclass.create().foo(), 'FOO', 'Adds method');
      assert.equal((0, _object.get)(Subclass.create(), 'bar'), 'BAR', 'Adds property');
    }
    ['@test reopened properties inherited by subclasses'](assert) {
      let Subclass = _object.default.extend();
      let SubSub = Subclass.extend();
      Subclass.reopen({
        foo() {
          return 'FOO';
        },
        bar: 'BAR'
      });
      assert.equal(SubSub.create().foo(), 'FOO', 'Adds method');
      assert.equal((0, _object.get)(SubSub.create(), 'bar'), 'BAR', 'Adds property');
    }
    ['@test allows reopening already instantiated classes'](assert) {
      let Subclass = _object.default.extend();
      Subclass.create();
      Subclass.reopen({
        trololol: true
      });
      assert.equal(Subclass.create().get('trololol'), true, 'reopen works');
    }
  });
});
define("@ember/object/tests/strict-mode-test", ["@ember/object", "internal-test-helpers"], function (_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('strict mode tests', class extends _internalTestHelpers.AbstractTestCase {
    ['@test __superWrapper does not throw errors in strict mode'](assert) {
      let Foo = _object.default.extend({
        blah() {
          return 'foo';
        }
      });
      let Bar = Foo.extend({
        blah() {
          return 'bar';
        },
        callBlah() {
          let blah = this.blah;
          return blah();
        }
      });
      let bar = Bar.create();
      assert.equal(bar.callBlah(), 'bar', 'can call local function without call/apply');
    }
  });
});
define("@ember/object/tests/toString_test", ["@ember/-internals/utils", "@ember/object", "internal-test-helpers"], function (_utils, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/toString', class extends _internalTestHelpers.AbstractTestCase {
    ['@test toString includes toStringExtension if defined'](assert) {
      let Foo = _object.default.extend({
        toStringExtension() {
          return 'fooey';
        }
      });
      let foo = Foo.create();
      let Bar = _object.default.extend({});
      let bar = Bar.create();

      // simulate these classes being defined on a Namespace
      (0, _utils.setName)(Foo, 'Foo');
      (0, _utils.setName)(Bar, 'Bar');
      assert.equal(bar.toString(), '<(unknown):' + (0, _utils.guidFor)(bar) + '>', 'does not include toStringExtension part');
      assert.equal(foo.toString(), '<(unknown):' + (0, _utils.guidFor)(foo) + ':fooey>', 'Includes toStringExtension result');
    }
  });
});
define("@ember/routing/tests/location/hash_location_test", ["@ember/runloop", "@ember/object", "@ember/routing/hash-location", "internal-test-helpers"], function (_runloop, _object, _hashLocation, _internalTestHelpers) {
  "use strict";

  let location;
  function createLocation(options, assert) {
    let HashTestLocation = _hashLocation.default.extend({
      _location: {
        href: 'http://test.com/',
        pathname: '/',
        hash: '',
        search: '',
        replace() {
          assert.ok(false, 'location.replace should not be called during testing');
        }
      }
    });
    if (!options) {
      options = {};
    }
    location = HashTestLocation.create(options);
  }
  function mockBrowserLocation(path) {
    // This is a neat trick to auto-magically extract the hostname from any
    // url by letting the browser do the work ;)
    let tmp = document.createElement('a');
    tmp.href = path;
    let protocol = !tmp.protocol || tmp.protocol === ':' ? 'http' : tmp.protocol;
    let pathname = tmp.pathname.match(/^\//) ? tmp.pathname : '/' + tmp.pathname;
    return {
      hash: tmp.hash,
      host: tmp.host || 'localhost',
      hostname: tmp.hostname || 'localhost',
      href: tmp.href,
      pathname: pathname,
      port: tmp.port || '',
      protocol: protocol,
      search: tmp.search
    };
  }
  function triggerHashchange() {
    let event = document.createEvent('HTMLEvents');
    event.initEvent('hashchange', true, false);
    window.dispatchEvent(event);
  }
  (0, _internalTestHelpers.moduleFor)('HashLocation', class extends _internalTestHelpers.AbstractTestCase {
    teardown() {
      (0, _runloop.run)(function () {
        if (location) {
          location.destroy();
        }
      });
    }
    ['@test HashLocation.getURL() returns the current url'](assert) {
      createLocation({
        _location: mockBrowserLocation('/#/foo/bar')
      }, assert);
      assert.equal(location.getURL(), '/foo/bar');
    }
    ['@test HashLocation.getURL() includes extra hashes'](assert) {
      createLocation({
        _location: mockBrowserLocation('/#/foo#bar#car')
      }, assert);
      assert.equal(location.getURL(), '/foo#bar#car');
    }
    ['@test HashLocation.getURL() assumes location.hash without #/ prefix is not a route path'](assert) {
      createLocation({
        _location: mockBrowserLocation('/#foo#bar')
      }, assert);
      assert.equal(location.getURL(), '/#foo#bar');
    }
    ['@test HashLocation.getURL() returns a normal forward slash when there is no location.hash'](assert) {
      createLocation({
        _location: mockBrowserLocation('/')
      }, assert);
      assert.equal(location.getURL(), '/');
    }
    ['@test HashLocation.setURL() correctly sets the url'](assert) {
      createLocation({}, assert);
      location.setURL('/bar');
      assert.equal((0, _object.get)(location, 'location.hash'), '/bar');
      assert.equal((0, _object.get)(location, 'lastSetURL'), '/bar');
    }
    ['@test HashLocation.replaceURL() correctly replaces to the path with a page reload'](assert) {
      assert.expect(2);
      createLocation({
        _location: {
          replace(path) {
            assert.equal(path, '#/foo');
          }
        }
      }, assert);
      location.replaceURL('/foo');
      assert.equal((0, _object.get)(location, 'lastSetURL'), '/foo');
    }
    ['@test HashLocation.onUpdateURL callback executes as expected'](assert) {
      assert.expect(1);
      createLocation({
        _location: mockBrowserLocation('/#/foo/bar')
      }, assert);
      let callback = function (param) {
        assert.equal(param, '/foo/bar', 'path is passed as param');
      };
      location.onUpdateURL(callback);
      triggerHashchange();
    }
    ["@test HashLocation.onUpdateURL doesn't execute callback if lastSetURL === path"](assert) {
      assert.expect(0);
      createLocation({
        _location: {
          hash: '#/foo/bar'
        },
        lastSetURL: '/foo/bar'
      }, assert);
      let callback = function () {
        assert.ok(false, 'callback should not be called');
      };
      location.onUpdateURL(callback);
      triggerHashchange();
    }
    ['@test HashLocation.formatURL() prepends a # to the provided string'](assert) {
      createLocation({}, assert);
      assert.equal(location.formatURL('/foo#bar'), '#/foo#bar');
    }
    ['@test HashLocation.willDestroy() cleans up hashchange event listener'](assert) {
      assert.expect(1);
      createLocation({}, assert);
      let callback = function () {
        assert.ok(true, 'should invoke callback once');
      };
      location.onUpdateURL(callback);
      triggerHashchange();
      (0, _runloop.run)(location, 'destroy');
      location = null;
      triggerHashchange();
    }
  });
});
define("@ember/routing/tests/location/history_location_test", ["@ember/runloop", "@ember/object", "@ember/routing/history-location", "internal-test-helpers"], function (_runloop, _object, _historyLocation, _internalTestHelpers) {
  "use strict";

  let FakeHistory, HistoryTestLocation, location;
  function createLocation(options) {
    if (!options) {
      options = {};
    }
    location = HistoryTestLocation.create(options);
  }
  function mockBrowserLocation(path) {
    // This is a neat trick to auto-magically extract the hostname from any
    // url by letting the browser do the work ;)
    let tmp = document.createElement('a');
    tmp.href = path;
    let protocol = !tmp.protocol || tmp.protocol === ':' ? 'http' : tmp.protocol;
    let pathname = tmp.pathname.match(/^\//) ? tmp.pathname : '/' + tmp.pathname;
    return {
      hash: tmp.hash,
      host: tmp.host || 'localhost',
      hostname: tmp.hostname || 'localhost',
      href: tmp.href,
      pathname: pathname,
      port: tmp.port || '',
      protocol: protocol,
      search: tmp.search
    };
  }
  (0, _internalTestHelpers.moduleFor)('HistoryLocation', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      FakeHistory = {
        state: null,
        _states: [],
        replaceState(state) {
          this.state = state;
          this._states[0] = state;
        },
        pushState(state) {
          this.state = state;
          this._states.unshift(state);
        }
      };
      HistoryTestLocation = _historyLocation.default.extend({
        history: FakeHistory
      });
    }
    teardown() {
      (0, _runloop.run)(() => {
        if (location) {
          location.destroy();
        }
      });
    }
    ['@test HistoryLocation initState does not get fired on init'](assert) {
      assert.expect(1);
      HistoryTestLocation.reopen({
        init() {
          assert.ok(true, 'init was called');
          this._super(...arguments);
        },
        initState() {
          assert.ok(false, 'initState() should not be called automatically');
        }
      });
      createLocation();
    }
    ["@test webkit doesn't fire popstate on page load"](assert) {
      assert.expect(1);
      HistoryTestLocation.reopen({
        initState() {
          this._super(...arguments);
          // these two should be equal to be able
          // to successfully detect webkit initial popstate
          assert.equal(this._previousURL, this.getURL());
        }
      });
      createLocation();
      location.initState();
    }
    ['@test <base> with href sets `baseURL`'](assert) {
      assert.expect(1);
      let base = document.createElement('base');
      base.setAttribute('href', '/foo/');
      document.head.appendChild(base);
      try {
        createLocation();
        location.initState();
        assert.strictEqual(location.get('baseURL'), '/foo/');
      } finally {
        document.head.removeChild(base);
      }
    }
    ['@test <base> without href is ignored'](assert) {
      assert.expect(1);
      let base = document.createElement('base');
      base.setAttribute('target', '_parent');
      document.head.appendChild(base);
      try {
        createLocation();
        location.initState();
        assert.strictEqual(location.get('baseURL'), '');
      } finally {
        document.head.removeChild(base);
      }
    }
    ['@test base URL is removed when retrieving the current pathname'](assert) {
      assert.expect(1);
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/base/foo/bar'));
          (0, _object.set)(this, 'baseURL', '/base/');
        },
        initState() {
          this._super(...arguments);
          assert.equal(this.getURL(), '/foo/bar');
        }
      });
      createLocation();
      location.initState();
    }
    ['@test base URL is preserved when moving around'](assert) {
      assert.expect(2);
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/base/foo/bar'));
          (0, _object.set)(this, 'baseURL', '/base/');
        }
      });
      createLocation();
      location.initState();
      location.setURL('/one/two');
      assert.equal(location.history.state.path, '/base/one/two');
      assert.ok(location.history.state.uuid);
    }
    ['@test setURL continues to set even with a null state (iframes may set this)'](assert) {
      createLocation();
      location.initState();
      FakeHistory.pushState(null);
      location.setURL('/three/four');
      assert.equal(location.history.state.path, '/three/four');
      assert.ok(location.history.state.uuid);
    }
    ['@test replaceURL continues to set even with a null state (iframes may set this)'](assert) {
      createLocation();
      location.initState();
      FakeHistory.pushState(null);
      location.replaceURL('/three/four');
      assert.equal(location.history.state.path, '/three/four');
      assert.ok(location.history.state.uuid);
    }
    ['@test HistoryLocation.getURL() returns the current url, excluding both rootURL and baseURL'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/base/foo/bar'));
          (0, _object.set)(this, 'rootURL', '/app/');
          (0, _object.set)(this, 'baseURL', '/base/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar');
    }
    ['@test HistoryLocation.getURL() returns the current url, does not remove rootURL if its not at start of url'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/foo/bar/baz'));
          (0, _object.set)(this, 'rootURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar/baz');
    }
    ['@test HistoryLocation.getURL() will not remove the rootURL when only a partial match'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/bars/baz'));
          (0, _object.set)(this, 'rootURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bars/baz');
    }
    ['@test HistoryLocation.getURL() returns the current url, does not remove baseURL if its not at start of url'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/foo/bar/baz'));
          (0, _object.set)(this, 'baseURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar/baz');
    }
    ['@test HistoryLocation.getURL() will not remove the baseURL when only a partial match'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/bars/baz'));
          (0, _object.set)(this, 'baseURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bars/baz');
    }
    ['@test HistoryLocation.getURL() includes location.search'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/foo/bar?time=morphin'));
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar?time=morphin');
    }
    ['@test HistoryLocation.getURL() includes location.hash'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/foo/bar#pink-power-ranger'));
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar#pink-power-ranger');
    }
    ['@test HistoryLocation.getURL() includes location.hash and location.search'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/foo/bar?time=morphin#pink-power-ranger'));
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar?time=morphin#pink-power-ranger');
    }
    ['@test HistoryLocation.getURL() drops duplicate slashes'](assert) {
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          let location = mockBrowserLocation('//admin//profile//');
          location.pathname = '//admin//profile//'; // mockBrowserLocation does not allow for `//`, so force it
          (0, _object.set)(this, 'location', location);
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/admin/profile/');
    }
    ['@test Existing state is preserved on init'](assert) {
      let existingState = {
        path: '/route/path',
        uuid: 'abcd'
      };
      FakeHistory.state = existingState;
      HistoryTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'location', mockBrowserLocation('/route/path'));
        }
      });
      createLocation();
      location.initState();
      assert.deepEqual(location.history.state, existingState);
    }
  });
});
define("@ember/routing/tests/location/none_location_test", ["@ember/runloop", "@ember/object", "@ember/routing/none-location", "internal-test-helpers"], function (_runloop, _object, _noneLocation, _internalTestHelpers) {
  "use strict";

  let NoneTestLocation, location;
  function createLocation(options) {
    if (!options) {
      options = {};
    }
    location = NoneTestLocation.create(options);
  }
  (0, _internalTestHelpers.moduleFor)('NoneLocation', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      NoneTestLocation = _noneLocation.default.extend({});
    }
    teardown() {
      (0, _runloop.run)(() => {
        if (location) {
          location.destroy();
        }
      });
    }
    ['@test NoneLocation.formatURL() returns the current url always appending rootURL'](assert) {
      NoneTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'rootURL', '/en/');
        }
      });
      createLocation();
      assert.equal(location.formatURL('/foo/bar'), '/en/foo/bar');
    }
    ['@test NoneLocation.getURL() returns the current path minus rootURL'](assert) {
      NoneTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'rootURL', '/foo/');
          (0, _object.set)(this, 'path', '/foo/bar');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bar');
    }
    ['@test NoneLocation.getURL() will remove the rootURL only from the beginning of a url'](assert) {
      NoneTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'rootURL', '/bar/');
          (0, _object.set)(this, 'path', '/foo/bar/baz');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar/baz');
    }
    ['@test NoneLocation.getURL() will not remove the rootURL when only a partial match'](assert) {
      NoneTestLocation.reopen({
        init() {
          this._super(...arguments);
          (0, _object.set)(this, 'rootURL', '/bar/');
          (0, _object.set)(this, 'path', '/bars/baz');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bars/baz');
    }
  });
});
define("@ember/routing/tests/location/util_test", ["@ember/routing/lib/location-utils", "internal-test-helpers"], function (_locationUtils, _internalTestHelpers) {
  "use strict";

  function mockBrowserLocation(overrides, assert) {
    return Object.assign({
      href: 'http://test.com/',
      pathname: '/',
      hash: '',
      search: '',
      replace() {
        assert.ok(false, 'location.replace should not be called during testing');
      }
    }, overrides);
  }
  (0, _internalTestHelpers.moduleFor)('Location Utilities', class extends _internalTestHelpers.AbstractTestCase {
    ['@test replacePath cannot be used to redirect to a different origin'](assert) {
      assert.expect(1);
      let expectedURL;
      let location = {
        protocol: 'http:',
        hostname: 'emberjs.com',
        port: '1337',
        replace(url) {
          assert.equal(url, expectedURL);
        }
      };
      expectedURL = 'http://emberjs.com:1337//google.com';
      (0, _locationUtils.replacePath)(location, '//google.com');
    }
    ['@test getPath() should normalize location.pathname, making sure it always returns a leading slash'](assert) {
      let location = mockBrowserLocation({
        pathname: 'test'
      }, assert);
      assert.equal((0, _locationUtils.getPath)(location), '/test', 'When there is no leading slash, one is added.');
      location = mockBrowserLocation({
        pathname: '/test'
      }, assert);
      assert.equal((0, _locationUtils.getPath)(location), '/test', "When a leading slash is already there, it isn't added again");
    }
    ['@test getQuery() should return location.search as-is'](assert) {
      let location = mockBrowserLocation({
        search: '?foo=bar'
      }, assert);
      assert.equal((0, _locationUtils.getQuery)(location), '?foo=bar');
    }
    ['@test getFullPath() should return full pathname including query and hash'](assert) {
      let location = mockBrowserLocation({
        href: 'http://test.com/about?foo=bar#foo',
        pathname: '/about',
        search: '?foo=bar',
        hash: '#foo'
      }, assert);
      assert.equal((0, _locationUtils.getFullPath)(location), '/about?foo=bar#foo');
    }
  });
});
define("@ember/routing/tests/system/cache_test", ["@ember/routing/-internals", "internal-test-helpers"], function (_internals, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('BucketCache', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      this.cache = new _internals.BucketCache();
    }
    ['@test has - returns false when bucket is not in cache'](assert) {
      assert.strictEqual(this.cache.has('foo'), false);
      assert.strictEqual(this.cache.has('constructor'), false);
    }
    ['@test has - returns true when bucket is in cache'](assert) {
      let token = {};
      this.cache.stash('foo', 'bar', token);
      this.cache.stash('constructor', 'bar', token);
      assert.strictEqual(this.cache.has('foo'), true);
      assert.strictEqual(this.cache.has('constructor'), true);
    }
    ['@test lookup - returns stashed value if key does exist in bucket'](assert) {
      let token = {};
      let defaultValue = {};
      this.cache.stash('foo', 'bar', token);
      assert.strictEqual(this.cache.lookup('foo', 'bar', defaultValue), token);
    }
    ['@test lookup - returns default value if key does not exist in bucket'](assert) {
      let token = {};
      let defaultValue = {};
      this.cache.stash('foo', 'bar', token);
      assert.strictEqual(this.cache.lookup('foo', 'boo', defaultValue), defaultValue);
      assert.strictEqual(this.cache.lookup('foo', 'constructor', defaultValue), defaultValue);
    }
    ['@test lookup - returns default value if bucket does not exist'](assert) {
      let defaultValue = {};
      assert.strictEqual(this.cache.lookup('boo', 'bar', defaultValue), defaultValue);
      assert.strictEqual(this.cache.lookup('constructor', 'bar', defaultValue), defaultValue);
    }
  });
});
define("@ember/routing/tests/system/controller_for_test", ["@ember/controller", "@ember/routing/-internals", "internal-test-helpers", "@ember/debug"], function (_controller, _internals, _internalTestHelpers, _debug) {
  "use strict";

  const originalDebug = (0, _debug.getDebugFunction)('debug');
  const noop = function () {};
  (0, _internalTestHelpers.moduleFor)('controllerFor', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      (0, _debug.setDebugFunction)('debug', noop);
      super();
    }
    teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    }
    ['@test controllerFor should lookup for registered controllers'](assert) {
      this.add('controller:app', _controller.default.extend());
      return this.visit('/').then(() => {
        let appInstance = this.applicationInstance;
        let appController = appInstance.lookup('controller:app');
        let controller = (0, _internals.controllerFor)(appInstance, 'app');
        assert.equal(appController, controller, 'should find app controller');
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('generateController', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      (0, _debug.setDebugFunction)('debug', noop);
      super();
    }
    teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    }
    ['@test generateController should return Controller'](assert) {
      return this.visit('/').then(() => {
        let controller = (0, _internals.generateController)(this.applicationInstance, 'home');
        assert.ok(controller instanceof _controller.default, 'should return controller');
      });
    }
    ['@test generateController should return controller:basic if resolved'](assert) {
      let BasicController = _controller.default.extend();
      this.add('controller:basic', BasicController);
      return this.visit('/').then(() => {
        let controller = (0, _internals.generateController)(this.applicationInstance, 'home');
        assert.ok(controller instanceof BasicController, 'should return controller');
      });
    }
    ['@test generateController should return controller:basic if registered'](assert) {
      let BasicController = _controller.default.extend();
      this.application.register('controller:basic', BasicController);
      return this.visit('/').then(() => {
        let controller = (0, _internals.generateController)(this.applicationInstance, 'home');
        assert.ok(controller instanceof BasicController, 'should return base class of controller');
      });
    }
  });
});
define("@ember/routing/tests/system/dsl_test", ["@ember/routing/router", "internal-test-helpers"], function (_router, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Router DSL', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      this.Router = class extends _router.default {};
      this.owner = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      this.routerInstance = new this.Router(this.owner);
    }
    teardown() {
      this.Router = null;
      this.routerInstance = null;
      (0, _internalTestHelpers.runDestroy)(this.owner);
    }
    ['@test should fail when using a reserved route name'](assert) {
      let owners = [];
      let reservedNames = ['basic', 'application'];
      assert.expect(reservedNames.length);
      reservedNames.forEach(reservedName => {
        expectAssertion(() => {
          let Router = class extends this.Router {};
          Router.map(function () {
            this.route(reservedName);
          });
          let owner = (0, _internalTestHelpers.buildOwner)();
          owners.push(owner);
          new Router(owner)._initRouterJs();
        }, "'" + reservedName + "' cannot be used as a route name.");
      });
      owners.forEach(o => (0, _internalTestHelpers.runDestroy)(o));
    }
    ['@test [GH#16642] better error when using a colon in a route name']() {
      expectAssertion(() => {
        this.Router.map(function () {
          this.route('resource/:id');
        });
        this.routerInstance._initRouterJs();
      }, "'resource/:id' is not a valid route name. It cannot contain a ':'. You may want to use the 'path' option instead.");
    }
    ['@test should retain resource namespace if nested with routes'](assert) {
      this.Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.route('blork');
          });
        });
      });
      let router = this.routerInstance;
      router._initRouterJs();
      assert.ok(router._routerMicrolib.recognizer.names['bleep'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop.blork'], 'parent name was used as base of nested routes');
    }
    ['@test should add loading and error routes if _isRouterMapResult is true'](assert) {
      this.Router.map(function () {
        this.route('blork');
      });
      this.routerInstance.reopen({
        _hasModuleBasedResolver() {
          return true;
        }
      });
      let router = this.routerInstance;
      router._initRouterJs();
      assert.ok(router._routerMicrolib.recognizer.names['blork'], 'main route was created');
      assert.ok(router._routerMicrolib.recognizer.names['blork_loading'], 'loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blork_error'], 'error route was added');
    }
    ['@test should not add loading and error routes if _isRouterMapResult is false'](assert) {
      this.Router.map(function () {
        this.route('blork');
      });
      let router = this.routerInstance;
      router._initRouterJs(false);
      assert.ok(router._routerMicrolib.recognizer.names['blork'], 'main route was created');
      assert.ok(!router._routerMicrolib.recognizer.names['blork_loading'], 'loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['blork_error'], 'error route was not added');
    }
    ['@test should reset namespace of loading and error routes for routes with resetNamespace'](assert) {
      this.Router.map(function () {
        this.route('blork', function () {
          this.route('blorp');
          this.route('bleep', {
            resetNamespace: true
          });
        });
      });
      this.routerInstance.reopen({
        _hasModuleBasedResolver() {
          return true;
        }
      });
      let router = this.routerInstance;
      router._initRouterJs();
      assert.ok(router._routerMicrolib.recognizer.names['blork.blorp'], 'nested route was created');
      assert.ok(router._routerMicrolib.recognizer.names['blork.blorp_loading'], 'nested loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blork.blorp_error'], 'nested error route was added');
      assert.ok(router._routerMicrolib.recognizer.names['bleep'], 'reset route was created');
      assert.ok(router._routerMicrolib.recognizer.names['bleep_loading'], 'reset loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['bleep_error'], 'reset error route was added');
      assert.ok(!router._routerMicrolib.recognizer.names['blork.bleep'], 'nested reset route was not created');
      assert.ok(!router._routerMicrolib.recognizer.names['blork.bleep_loading'], 'nested reset loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['blork.bleep_error'], 'nested reset error route was not added');
    }
    ['@test should throw an error when defining a route serializer outside an engine'](assert) {
      this.Router.map(function () {
        assert.throws(() => {
          this.route('posts', {
            serialize: function () {}
          });
        }, /Defining a route serializer on route 'posts' outside an Engine is not allowed/);
      });
      this.routerInstance._initRouterJs();
    }
  });
  (0, _internalTestHelpers.moduleFor)('Ember Router DSL with engines', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      this.Router = class extends _router.default {};
      this.owner = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      this.routerInstance = new this.Router(this.owner);
    }
    teardown() {
      (0, _internalTestHelpers.runDestroy)(this.owner);
      this.Router = null;
      this.routerInstance = null;
    }
    ['@test should allow mounting of engines'](assert) {
      assert.expect(3);
      this.Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.mount('chat');
          });
        });
      });
      let router = this.routerInstance;
      router._initRouterJs();
      assert.ok(router._routerMicrolib.recognizer.names['bleep'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop.chat'], 'parent name was used as base of mounted engine');
    }
    ['@test should allow mounting of engines at a custom path'](assert) {
      assert.expect(1);
      this.Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.mount('chat', {
              path: 'custom-chat'
            });
          });
        });
      });
      let router = this.routerInstance;
      router._initRouterJs();
      assert.deepEqual(router._routerMicrolib.recognizer.names['bleep.bloop.chat'].segments.slice(1, 4).map(s => s.value), ['bleep', 'bloop', 'custom-chat'], 'segments are properly associated with mounted engine');
    }
    ['@test should allow aliasing of engine names with `as`'](assert) {
      assert.expect(1);
      this.Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.mount('chat', {
              as: 'blork'
            });
          });
        });
      });
      let router = this.routerInstance;
      router._initRouterJs();
      assert.deepEqual(router._routerMicrolib.recognizer.names['bleep.bloop.blork'].segments.slice(1, 4).map(s => s.value), ['bleep', 'bloop', 'blork'], 'segments are properly associated with mounted engine with aliased name');
    }
    ['@test should add loading and error routes to a mount if _isRouterMapResult is true'](assert) {
      this.Router.map(function () {
        this.mount('chat');
      });
      this.routerInstance.reopen({
        _hasModuleBasedResolver() {
          return true;
        }
      });
      this.routerInstance._initRouterJs();
      let router = this.routerInstance;
      assert.ok(router._routerMicrolib.recognizer.names['chat'], 'main route was created');
      assert.ok(router._routerMicrolib.recognizer.names['chat_loading'], 'loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['chat_error'], 'error route was added');
    }
    ['@test should add loading and error routes to a mount alias if _isRouterMapResult is true'](assert) {
      this.Router.map(function () {
        this.mount('chat', {
          as: 'shoutbox'
        });
      });
      this.routerInstance.reopen({
        _hasModuleBasedResolver() {
          return true;
        }
      });
      this.routerInstance._initRouterJs();
      let router = this.routerInstance;
      assert.ok(router._routerMicrolib.recognizer.names['shoutbox'], 'main route was created');
      assert.ok(router._routerMicrolib.recognizer.names['shoutbox_loading'], 'loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['shoutbox_error'], 'error route was added');
    }
    ['@test should not add loading and error routes to a mount if _isRouterMapResult is false'](assert) {
      this.Router.map(function () {
        this.mount('chat');
      });
      let router = this.routerInstance;
      router._initRouterJs(false);
      assert.ok(router._routerMicrolib.recognizer.names['chat'], 'main route was created');
      assert.ok(!router._routerMicrolib.recognizer.names['chat_loading'], 'loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['chat_error'], 'error route was not added');
    }
    ['@test should reset namespace of loading and error routes for mounts with resetNamespace'](assert) {
      this.Router.map(function () {
        this.route('news', function () {
          this.mount('chat');
          this.mount('blog', {
            resetNamespace: true
          });
        });
      });
      this.routerInstance.reopen({
        _hasModuleBasedResolver() {
          return true;
        }
      });
      this.routerInstance._initRouterJs();
      let router = this.routerInstance;
      assert.ok(router._routerMicrolib.recognizer.names['news.chat'], 'nested route was created');
      assert.ok(router._routerMicrolib.recognizer.names['news.chat_loading'], 'nested loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['news.chat_error'], 'nested error route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blog'], 'reset route was created');
      assert.ok(router._routerMicrolib.recognizer.names['blog_loading'], 'reset loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blog_error'], 'reset error route was added');
      assert.ok(!router._routerMicrolib.recognizer.names['news.blog'], 'nested reset route was not created');
      assert.ok(!router._routerMicrolib.recognizer.names['news.blog_loading'], 'nested reset loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['news.blog_error'], 'nested reset error route was not added');
    }
  });
});
define("@ember/routing/tests/system/route_test", ["@ember/-internals/owner", "internal-test-helpers", "@ember/service", "@ember/object", "@ember/routing/route", "@ember/object/proxy", "@ember/debug"], function (_owner, _internalTestHelpers, _service, _object, _route, _proxy, _debug) {
  "use strict";

  let route, routeOne, routeTwo, lookupHash;
  (0, _internalTestHelpers.moduleFor)('Route', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      route = _route.default.create();
    }
    teardown() {
      super.teardown();
      (0, _internalTestHelpers.runDestroy)(route);
      route = routeOne = routeTwo = lookupHash = undefined;
    }
    ['@test default store utilizes the container to acquire the model factory'](assert) {
      assert.expect(5);
      let Post = _object.default.extend();
      let post = {};
      Post.reopenClass({
        find() {
          return post;
        }
      });
      let ownerOptions = {
        ownerOptions: {
          hasRegistration() {
            return true;
          },
          factoryFor(fullName) {
            assert.equal(fullName, 'model:post', 'correct factory was looked up');
            return {
              class: Post,
              create() {
                return Post.create();
              }
            };
          }
        }
      };
      let owner = (0, _internalTestHelpers.buildOwner)(ownerOptions);
      (0, _owner.setOwner)(route, owner);
      expectDeprecation(() => ignoreAssertion(() => {
        assert.equal(route.model({
          post_id: 1
        }), post);
        assert.equal(route.findModel('post', 1), post, '#findModel returns the correct post');
      }), /The implicit model loading behavior for routes is deprecated./);
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test default store can be overridden'](assert) {
      (0, _internalTestHelpers.runDestroy)(route);
      let calledFind = false;
      route = _route.default.extend({
        store: {
          find() {
            calledFind = true;
          }
        }
      }).create();
      route.store.find();
      assert.true(calledFind, 'store.find was called');
    }
    ["@test assert if 'store.find' method is not found"]() {
      (0, _internalTestHelpers.runDestroy)(route);
      let owner = (0, _internalTestHelpers.buildOwner)();
      let Post = _object.default.extend();
      owner.register('route:index', _route.default.extend({
        routeName: 'index'
      }));
      owner.register('model:post', Post);
      route = owner.lookup('route:index');
      ignoreDeprecation(() => expectAssertion(function () {
        route.findModel('post', 1);
      }, "You used the dynamic segment `post_id` in your route " + "`index` for which Ember requires you provide a " + "data-loading implementation. Commonly, that is done by " + "adding a model hook implementation on the route " + "(`model({post_id}) {`) or by injecting an implemention of " + "a data store: `@service store;`.\n\n" + "Rarely, applications may attempt to use a legacy behavior where " + "the model class (in this case `post`) is resolved and the " + "`find` method on that class is invoked to load data. In this " + "application, a model of `post` was found but it did not " + "provide a `find` method. You should not add a `find` " + "method to your model. Instead, please implement an appropriate " + "`model` hook on the `index` route."));
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test asserts if model class is not found']() {
      (0, _internalTestHelpers.runDestroy)(route);
      let owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('route:index', _route.default.extend({
        routeName: 'index'
      }));
      route = owner.lookup('route:index');
      ignoreDeprecation(() => expectAssertion(function () {
        route.model({
          post_id: 1
        });
      }, "You used the dynamic segment `post_id` in your route " + "`index` for which Ember requires you provide a " + "data-loading implementation. Commonly, that is done by " + "adding a model hook implementation on the route " + "(`model({post_id}) {`) or by injecting an implemention of " + "a data store: `@service store;`."));
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ["@test 'store' does not need to be injected"](assert) {
      (0, _internalTestHelpers.runDestroy)(route);
      let owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('route:index', _route.default);
      route = owner.lookup('route:index');
      ignoreDeprecation(() => ignoreAssertion(() => route.model({
        post_id: 1
      })));
      assert.ok(true, 'no error was raised');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ["@test modelFor doesn't require the router"](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      (0, _owner.setOwner)(route, owner);
      let foo = {
        name: 'foo'
      };
      let FooRoute = _route.default.extend({
        currentModel: foo
      });
      owner.register('route:foo', FooRoute);
      assert.strictEqual(route.modelFor('foo'), foo);
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test _optionsForQueryParam should work with nested properties'](assert) {
      let route = _route.default.extend({
        queryParams: {
          'nested.foo': {
            // By default, controller query param properties don't
            // cause a full transition when they are changed, but
            // rather only cause the URL to update. Setting
            // `refreshModel` to true will cause an "in-place"
            // transition to occur, whereby the model hooks for
            // this route (and any child routes) will re-fire, allowing
            // you to reload models (e.g., from the server) using the
            // updated query param values.
            refreshModel: true,
            // By default, the query param URL key is the same name as
            // the controller property name. Use `as` to specify a
            // different URL key.
            as: 'foobar'
          }
        }
      }).create();
      assert.strictEqual(route._optionsForQueryParam({
        prop: 'nested.foo',
        urlKey: 'foobar'
      }), route.queryParams['nested.foo']);
    }
    ["@test modelFor doesn't require the routerMicrolib"](assert) {
      let route = _route.default.create({
        _router: {
          _routerMicrolib: null
        }
      });
      let owner = (0, _internalTestHelpers.buildOwner)();
      (0, _owner.setOwner)(route, owner);
      let foo = {
        name: 'foo'
      };
      let FooRoute = _route.default.extend({
        currentModel: foo
      });
      owner.register('route:foo', FooRoute);
      assert.strictEqual(route.modelFor('foo'), foo);
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test .send just calls an action if the router is absent'](assert) {
      assert.expect(7);
      let route = _route.default.extend({
        actions: {
          returnsTrue(foo, bar) {
            assert.equal(foo, 1);
            assert.equal(bar, 2);
            assert.equal(this, route);
            return true;
          },
          returnsFalse() {
            assert.ok(true, 'returnsFalse was called');
            return false;
          }
        }
      }).create();
      assert.equal(route.send('returnsTrue', 1, 2), true);
      assert.equal(route.send('returnsFalse'), false);
      assert.equal(route.send('nonexistent', 1, 2, 3), undefined);
      (0, _internalTestHelpers.runDestroy)(route);
    }
    ['@test .send just calls an action if the routers internal router property is absent'](assert) {
      assert.expect(7);
      let route = _route.default.extend({
        router: {},
        actions: {
          returnsTrue(foo, bar) {
            assert.equal(foo, 1);
            assert.equal(bar, 2);
            assert.equal(this, route);
            return true;
          },
          returnsFalse() {
            assert.ok(true, 'returnsFalse was called');
            return false;
          }
        }
      }).create();
      assert.equal(true, route.send('returnsTrue', 1, 2));
      assert.equal(false, route.send('returnsFalse'));
      assert.equal(undefined, route.send('nonexistent', 1, 2, 3));
      (0, _internalTestHelpers.runDestroy)(route);
    }
    ['@test .send asserts if called on a destroyed route']() {
      route.routeName = 'rip-alley';
      (0, _internalTestHelpers.runDestroy)(route);
      expectAssertion(() => {
        route.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed route 'rip-alley'.");
    }
  });
  (0, _internalTestHelpers.moduleFor)('Route serialize', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      route = _route.default.create();
    }
    teardown() {
      (0, _internalTestHelpers.runDestroy)(route);
    }
    ['@test returns the models properties if params does not include *_id'](assert) {
      let model = {
        id: 2,
        firstName: 'Ned',
        lastName: 'Ryerson'
      };
      assert.deepEqual(route.serialize(model, ['firstName', 'lastName']), {
        firstName: 'Ned',
        lastName: 'Ryerson'
      }, 'serialized correctly');
    }
    ['@test returns model.id if params include *_id'](assert) {
      let model = {
        id: 2
      };
      assert.deepEqual(route.serialize(model, ['post_id']), {
        post_id: 2
      }, 'serialized correctly');
    }
    ['@test returns checks for existence of model.post_id before trying model.id'](assert) {
      let model = {
        post_id: 3
      };
      assert.deepEqual(route.serialize(model, ['post_id']), {
        post_id: 3
      }, 'serialized correctly');
    }
    ['@test returns model.id if model is a Proxy'](assert) {
      let model = _proxy.default.create({
        content: {
          id: 3
        }
      });
      assert.deepEqual(route.serialize(model, ['id']), {
        id: 3
      }, 'serialized Proxy correctly');
    }
    ['@test returns undefined if model is not set'](assert) {
      assert.equal(route.serialize(undefined, ['post_id']), undefined, 'serialized correctly');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Route interaction', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();

      // Disable assertions for these tests so we can use fake controllers
      this.originalAssert = (0, _debug.getDebugFunction)('assert');
      (0, _debug.setDebugFunction)('assert', () => {});
      let owner = {
        lookup(fullName) {
          return lookupHash[fullName];
        }
      };
      routeOne = _route.default.create({
        routeName: 'one'
      });
      routeTwo = _route.default.create({
        routeName: 'two'
      });
      (0, _owner.setOwner)(routeOne, owner);
      (0, _owner.setOwner)(routeTwo, owner);
      lookupHash = {
        'route:one': routeOne,
        'route:two': routeTwo
      };
    }
    teardown() {
      (0, _internalTestHelpers.runDestroy)(routeOne);
      (0, _internalTestHelpers.runDestroy)(routeTwo);
      (0, _debug.setDebugFunction)('assert', this.originalAssert);
    }
    ['@test route._qp does not crash if the controller has no QP, or setProperties'](assert) {
      lookupHash['controller:test'] = {};
      routeOne.controllerName = 'test';
      let qp = routeOne.get('_qp');
      assert.deepEqual(qp.map, {}, 'map should be empty');
      assert.deepEqual(qp.propertyNames, [], 'property names should be empty');
      assert.deepEqual(qp.qps, [], 'qps is should be empty');
    }
    ["@test controllerFor uses route's controllerName if specified"](assert) {
      let testController = {};
      lookupHash['controller:test'] = testController;
      routeOne.controllerName = 'test';
      assert.equal(routeTwo.controllerFor('one'), testController);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Route injected properties', class extends _internalTestHelpers.AbstractTestCase {
    ['@test services can be injected into routes'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('route:application', _route.default.extend({
        authService: (0, _service.service)('auth')
      }));
      owner.register('service:auth', _service.default.extend());
      let appRoute = owner.lookup('route:application');
      let authService = owner.lookup('service:auth');
      assert.equal(authService, appRoute.get('authService'), 'service.auth is injected');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Route with engines', class extends _internalTestHelpers.AbstractTestCase {
    ["@test paramsFor considers an engine's mountPoint"](assert) {
      let router = {
        _deserializeQueryParams() {},
        _routerMicrolib: {
          state: {
            routeInfos: [{
              name: 'posts'
            }],
            params: {
              'foo.bar': {
                a: 'b'
              },
              'foo.bar.posts': {
                c: 'd'
              }
            }
          }
        }
      };
      let engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar',
          lookup(name) {
            if (name === 'route:posts') {
              return postsRoute;
            } else if (name === 'route:application') {
              return applicationRoute;
            }
          }
        }
      });
      let applicationRoute = _route.default.create({
        _router: router,
        routeName: 'application',
        fullRouteName: 'foo.bar'
      });
      let postsRoute = _route.default.create({
        _router: router,
        routeName: 'posts',
        fullRouteName: 'foo.bar.posts'
      });
      let route = _route.default.create({
        _router: router
      });
      (0, _owner.setOwner)(applicationRoute, engineInstance);
      (0, _owner.setOwner)(postsRoute, engineInstance);
      (0, _owner.setOwner)(route, engineInstance);
      assert.deepEqual(route.paramsFor('application'), {
        a: 'b'
      }, 'params match for root `application` route in engine');
      assert.deepEqual(route.paramsFor('posts'), {
        c: 'd'
      }, 'params match for `posts` route in engine');
      (0, _internalTestHelpers.runDestroy)(engineInstance);
    }
    ["@test modelFor considers an engine's mountPoint"](assert) {
      let applicationModel = {
        id: '1'
      };
      let postsModel = {
        id: '2'
      };
      let router = {
        _routerMicrolib: {
          activeTransition: {
            resolvedModels: {
              'foo.bar': applicationModel,
              'foo.bar.posts': postsModel
            }
          }
        }
      };
      let engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar',
          lookup(name) {
            if (name === 'route:posts') {
              return postsRoute;
            } else if (name === 'route:application') {
              return applicationRoute;
            }
          }
        }
      });
      let applicationRoute = _route.default.create({
        _router: router,
        routeName: 'application'
      });
      let postsRoute = _route.default.create({
        _router: router,
        routeName: 'posts'
      });
      let route = _route.default.create({
        _router: router
      });
      (0, _owner.setOwner)(applicationRoute, engineInstance);
      (0, _owner.setOwner)(postsRoute, engineInstance);
      (0, _owner.setOwner)(route, engineInstance);
      assert.strictEqual(route.modelFor('application'), applicationModel);
      assert.strictEqual(route.modelFor('posts'), postsModel);
      (0, _internalTestHelpers.runDestroy)(engineInstance);
    }
    ["@test intermediateTransitionTo considers an engine's mountPoint"](assert) {
      let lastRoute;
      let router = {
        intermediateTransitionTo(route) {
          lastRoute = route;
        }
      };
      let engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar'
        }
      });
      let route = _route.default.create({
        _router: router
      });
      (0, _owner.setOwner)(route, engineInstance);
      route.intermediateTransitionTo('application');
      assert.strictEqual(lastRoute, 'foo.bar.application', 'properly prefixes application route');
      route.intermediateTransitionTo('posts');
      assert.strictEqual(lastRoute, 'foo.bar.posts', 'properly prefixes child routes');
      assert.throws(() => route.intermediateTransitionTo('/posts'), 'throws when trying to use a url');
      let queryParams = {};
      route.intermediateTransitionTo(queryParams);
      assert.strictEqual(lastRoute, queryParams, 'passes query param only transitions through');
      (0, _internalTestHelpers.runDestroy)(engineInstance);
    }
  });
});
define("@ember/routing/tests/system/router_test", ["@ember/routing/hash-location", "@ember/routing/history-location", "@ember/routing/none-location", "@ember/routing/router", "internal-test-helpers"], function (_hashLocation, _historyLocation, _noneLocation, _router, _internalTestHelpers) {
  "use strict";

  let owner;
  function createRouter(_temp) {
    let {
      settings = {},
      options = {}
    } = _temp === void 0 ? {} : _temp;
    let CustomRouter = class extends _router.default {};
    let router = new CustomRouter(owner);
    for (let setting in settings) {
      router[setting] = settings[setting];
    }
    if (!options.disableSetup) {
      router.setupRouter();
    }
    return router;
  }
  (0, _internalTestHelpers.moduleFor)('Ember Router', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      owner = (0, _internalTestHelpers.buildOwner)();

      //register the HashLocation (the default)
      owner.register('location:hash', _hashLocation.default);
      owner.register('location:history', _historyLocation.default);
      owner.register('location:none', _noneLocation.default);
    }
    teardown() {
      (0, _internalTestHelpers.runDestroy)(owner);
      owner = null;
    }
    ['@test [GH#15237] EmberError is imported correctly'](assert) {
      // If we get the right message it means Error is being imported correctly.
      assert.throws(function () {
        (0, _router.triggerEvent)(null, false, []);
      }, /because your app hasn't finished transitioning/);
    }
    ['@test should not create a router.js instance upon init'](assert) {
      let router = createRouter({
        options: {
          disableSetup: true
        }
      });
      assert.ok(!router._routerMicrolib);
    }
    ['@test should create a router.js instance after setupRouter'](assert) {
      let router = createRouter({
        options: {
          disableSetup: false
        }
      });
      assert.ok(router._didSetupRouter);
      assert.ok(router._routerMicrolib);
    }
    ['@test should return false if setupRouter is called multiple times'](assert) {
      let router = createRouter({
        options: {
          disableSetup: true
        }
      });
      assert.ok(router.setupRouter());
      assert.notOk(router.setupRouter());
    }
    ['@test should not reify location until setupRouter is called'](assert) {
      let router = createRouter({
        options: {
          disableSetup: true
        }
      });
      assert.equal(typeof router.location, 'string', 'location is specified as a string');
      router.setupRouter();
      assert.equal(typeof router.location, 'object', 'location is reified into an object');
    }
    ['@test should destroy its location upon destroying the routers owner.'](assert) {
      let router = createRouter();
      let location = router.get('location');
      (0, _internalTestHelpers.runDestroy)(owner);
      assert.ok(location.isDestroyed, 'location should be destroyed');
    }
    ['@test should instantiate its location with its `rootURL`'](assert) {
      let router = createRouter({
        settings: {
          rootURL: '/rootdir/'
        }
      });
      let location = router.get('location');
      assert.equal(location.get('rootURL'), '/rootdir/');
    }
    ['@test Router._routePath should consume identical prefixes'](assert) {
      createRouter();
      function routePath() {
        let routeInfos = Array.prototype.slice.call(arguments).map(function (s) {
          return {
            name: s
          };
        });
        routeInfos.unshift({
          name: 'ignored'
        });
        return _router.default._routePath(routeInfos);
      }
      assert.equal(routePath('foo'), 'foo');
      assert.equal(routePath('foo', 'bar', 'baz'), 'foo.bar.baz');
      assert.equal(routePath('foo', 'foo.bar'), 'foo.bar');
      assert.equal(routePath('foo', 'foo.bar', 'foo.bar.baz'), 'foo.bar.baz');
      assert.equal(routePath('foo', 'foo.bar', 'foo.bar.baz.wow'), 'foo.bar.baz.wow');
      assert.equal(routePath('foo', 'foo.bar.baz.wow'), 'foo.bar.baz.wow');
      assert.equal(routePath('foo.bar', 'bar.baz.wow'), 'foo.bar.baz.wow');

      // This makes no sense, not trying to handle it, just
      // making sure it doesn't go boom.
      assert.equal(routePath('foo.bar.baz', 'foo'), 'foo.bar.baz.foo');
    }
    ['@test Router should cancel routing setup when the Location class says so via cancelRouterSetup'](assert) {
      assert.expect(0);
      let router;
      let FakeLocation = {
        cancelRouterSetup: true,
        create() {
          return this;
        }
      };
      owner.register('location:fake', FakeLocation);
      router = createRouter({
        location: 'fake',
        _setupRouter() {
          assert.ok(false, '_setupRouter should not be called');
        }
      });
      router.startRouting();
    }
    ['@test Router#handleURL should remove any #hashes before doing URL transition'](assert) {
      assert.expect(2);
      let router = createRouter({
        settings: {
          _doURLTransition(routerJsMethod, url) {
            assert.equal(routerJsMethod, 'handleURL');
            assert.equal(url, '/foo/bar?time=morphin');
          }
        }
      });
      router.handleURL('/foo/bar?time=morphin#pink-power-ranger');
    }
    ['@test Router#triggerEvent allows actions to bubble when returning true'](assert) {
      assert.expect(2);
      let routeInfos = [{
        name: 'application',
        route: {
          actions: {
            loading() {
              assert.ok(false, 'loading not handled by application route');
            }
          }
        }
      }, {
        name: 'about',
        route: {
          actions: {
            loading() {
              assert.ok(true, 'loading handled by about route');
              return false;
            }
          }
        }
      }, {
        name: 'about.me',
        route: {
          actions: {
            loading() {
              assert.ok(true, 'loading handled by about.me route');
              return true;
            }
          }
        }
      }];
      (0, _router.triggerEvent)(routeInfos, false, ['loading']);
    }
    ['@test Router#triggerEvent ignores handlers that have not loaded yet'](assert) {
      assert.expect(1);
      let routeInfos = [{
        name: 'about',
        route: {
          actions: {
            loading() {
              assert.ok(true, 'loading handled by about route');
            }
          }
        }
      }, {
        name: 'about.me',
        route: undefined
      }];
      (0, _router.triggerEvent)(routeInfos, false, ['loading']);
    }
    ['@test transitionTo should throw an error when called after owner is destroyed']() {
      let router = createRouter();
      (0, _internalTestHelpers.runDestroy)(router);
      router.currentRouteName = 'route-a';
      expectAssertion(function () {
        router.transitionTo('route-b');
      }, "A transition was attempted from 'route-a' to 'route-b' but the application instance has already been destroyed.");
      expectAssertion(function () {
        router.transitionTo('./route-b/1');
      }, "A transition was attempted from 'route-a' to './route-b/1' but the application instance has already been destroyed.");
    }
    ['@test computed url when location is a string should not crash'](assert) {
      let router = createRouter({
        options: {
          disableSetup: true
        }
      });
      assert.equal(router.url, undefined);
    }
  });
});
define("@ember/routing/tests/utils_test", ["@ember/routing/lib/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Routing query parameter utils - normalizeControllerQueryParams', class extends _internalTestHelpers.AbstractTestCase {
    ['@test converts array style into verbose object style'](assert) {
      let paramName = 'foo';
      let params = [paramName];
      let normalized = (0, _utils.normalizeControllerQueryParams)(params);
      assert.ok(normalized[paramName], 'turns the query param name into key');
      assert.equal(normalized[paramName].as, null, "includes a blank alias in 'as' key");
      assert.equal(normalized[paramName].scope, 'model', 'defaults scope to model');
    }
    ["@test converts object style [{foo: 'an_alias'}]"](assert) {
      let paramName = 'foo';
      let params = [{
        foo: 'an_alias'
      }];
      let normalized = (0, _utils.normalizeControllerQueryParams)(params);
      assert.ok(normalized[paramName], 'retains the query param name as key');
      assert.equal(normalized[paramName].as, 'an_alias', "includes the provided alias in 'as' key");
      assert.equal(normalized[paramName].scope, 'model', 'defaults scope to model');
    }
    ["@test retains maximally verbose object style [{foo: {as: 'foo'}}]"](assert) {
      let paramName = 'foo';
      let params = [{
        foo: {
          as: 'an_alias'
        }
      }];
      let normalized = (0, _utils.normalizeControllerQueryParams)(params);
      assert.ok(normalized[paramName], 'retains the query param name as key');
      assert.equal(normalized[paramName].as, 'an_alias', "includes the provided alias in 'as' key");
      assert.equal(normalized[paramName].scope, 'model', 'defaults scope to model');
    }
  });
});
define("@ember/runloop/tests/debounce_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('debounce', class extends _internalTestHelpers.AbstractTestCase {
    ['@test debounce - with target, with method, without args'](assert) {
      let done = assert.async();
      let calledWith = [];
      let target = {
        someFunc() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          calledWith.push(args);
        }
      };
      (0, _runloop.debounce)(target, target.someFunc, 10);
      (0, _runloop.debounce)(target, target.someFunc, 10);
      (0, _runloop.debounce)(target, target.someFunc, 10);
      setTimeout(() => {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    }
    ['@test debounce - with target, with method name, without args'](assert) {
      let done = assert.async();
      let calledWith = [];
      let target = {
        someFunc() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          calledWith.push(args);
        }
      };
      (0, _runloop.debounce)(target, 'someFunc', 10);
      (0, _runloop.debounce)(target, 'someFunc', 10);
      (0, _runloop.debounce)(target, 'someFunc', 10);
      setTimeout(() => {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    }
    ['@test debounce - without target, without args'](assert) {
      let done = assert.async();
      let calledWith = [];
      function someFunc() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        calledWith.push(args);
      }
      (0, _runloop.debounce)(someFunc, 10);
      (0, _runloop.debounce)(someFunc, 10);
      (0, _runloop.debounce)(someFunc, 10);
      setTimeout(() => {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    }
    ['@test debounce - without target, with args'](assert) {
      let done = assert.async();
      let calledWith = [];
      function someFunc() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        calledWith.push(args);
      }
      (0, _runloop.debounce)(someFunc, {
        isFoo: true
      }, 10);
      (0, _runloop.debounce)(someFunc, {
        isBar: true
      }, 10);
      (0, _runloop.debounce)(someFunc, {
        isBaz: true
      }, 10);
      setTimeout(() => {
        assert.deepEqual(calledWith, [[{
          isBaz: true
        }]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    }
  });
});
define("@ember/runloop/tests/later_test", ["internal-test-helpers", "@ember/runloop"], function (_internalTestHelpers, _runloop) {
  "use strict";

  const originalSetTimeout = window.setTimeout;
  const originalDateValueOf = Date.prototype.valueOf;
  const originalPlatform = _runloop._backburner._platform;
  function wait(callback, maxWaitCount) {
    if (maxWaitCount === void 0) {
      maxWaitCount = 100;
    }
    originalSetTimeout(() => {
      if (maxWaitCount > 0 && ((0, _runloop._hasScheduledTimers)() || (0, _runloop._getCurrentRunLoop)())) {
        wait(callback, maxWaitCount - 1);
        return;
      }
      callback();
    }, 10);
  }

  // Synchronous "sleep". This simulates work being done
  // after later was called but before the run loop
  // has flushed. In previous versions, this would have
  // caused the later callback to have run from
  // within the run loop flush, since by the time the
  // run loop has to flush, it would have considered
  // the timer already expired.
  function pauseUntil(time) {
    while (Date.now() < time) {
      /* do nothing - sleeping */
    }
  }
  (0, _internalTestHelpers.moduleFor)('runloop `later`', class extends _internalTestHelpers.AbstractTestCase {
    teardown() {
      _runloop._backburner._platform = originalPlatform;
      window.setTimeout = originalSetTimeout;
      Date.prototype.valueOf = originalDateValueOf;
    }
    ['@test should invoke after specified period of time - function only'](assert) {
      let done = assert.async();
      let invoked = false;
      (0, _runloop.run)(() => {
        (0, _runloop.later)(() => invoked = true, 100);
      });
      wait(() => {
        assert.equal(invoked, true, 'should have invoked later item');
        done();
      });
    }
    ['@test should invoke after specified period of time - target/method'](assert) {
      let done = assert.async();
      let obj = {
        invoked: false
      };
      (0, _runloop.run)(() => {
        (0, _runloop.later)(obj, function () {
          this.invoked = true;
        }, 100);
      });
      wait(() => {
        assert.equal(obj.invoked, true, 'should have invoked later item');
        done();
      });
    }
    ['@test should invoke after specified period of time - target/method/args'](assert) {
      let done = assert.async();
      let obj = {
        invoked: 0
      };
      (0, _runloop.run)(() => {
        (0, _runloop.later)(obj, function (amt) {
          this.invoked += amt;
        }, 10, 100);
      });
      wait(() => {
        assert.equal(obj.invoked, 10, 'should have invoked later item');
        done();
      });
    }
    ['@test should always invoke within a separate runloop'](assert) {
      let done = assert.async();
      let obj = {
        invoked: 0
      };
      let firstRunLoop, secondRunLoop;
      (0, _runloop.run)(() => {
        firstRunLoop = (0, _runloop._getCurrentRunLoop)();
        (0, _runloop.later)(obj, function (amt) {
          this.invoked += amt;
          secondRunLoop = (0, _runloop._getCurrentRunLoop)();
        }, 10, 1);
        pauseUntil(Date.now() + 100);
      });
      assert.ok(firstRunLoop, 'first run loop captured');
      assert.ok(!(0, _runloop._getCurrentRunLoop)(), "shouldn't be in a run loop after flush");
      assert.equal(obj.invoked, 0, "shouldn't have invoked later item yet");
      wait(() => {
        assert.equal(obj.invoked, 10, 'should have invoked later item');
        assert.ok(secondRunLoop, 'second run loop took place');
        assert.ok(secondRunLoop !== firstRunLoop, 'two different run loops took place');
        done();
      });
    }

    // Our current implementation doesn't allow us to correctly enforce this ordering.
    // We should probably implement a queue to provide this guarantee.
    // See https://github.com/emberjs/ember.js/issues/3526 for more information.

    // asyncTest('callback order', function() {
    //   let array = [];
    //   function fn(val) { array.push(val); }

    //   run(function() {
    //     later(this, fn, 4, 5);
    //     later(this, fn, 1, 1);
    //     later(this, fn, 5, 10);
    //     later(this, fn, 2, 3);
    //     later(this, fn, 3, 3);
    //   });

    //   deepEqual(array, []);

    //   wait(function() {
    //     QUnit.start();
    //     deepEqual(array, [1,2,3,4,5], 'callbacks were called in expected order');
    //   });
    // });

    // Out current implementation doesn't allow us to properly enforce what is tested here.
    // We should probably fix it, but it's not technically a bug right now.
    // See https://github.com/emberjs/ember.js/issues/3522 for more information.

    // asyncTest('callbacks coalesce into same run loop if expiring at the same time', function() {
    //   let array = [];
    //   function fn(val) { array.push(getCurrentRunLoop()); }

    //   run(function() {

    //     // Force +new Date to return the same result while scheduling
    //     // later timers. Otherwise: non-determinism!
    //     let now = +new Date();
    //     Date.prototype.valueOf = function() { return now; };

    //     later(this, fn, 10);
    //     later(this, fn, 200);
    //     later(this, fn, 200);

    //     Date.prototype.valueOf = originalDateValueOf;
    //   });

    //   deepEqual(array, []);

    //   wait(function() {
    //     QUnit.start();
    //     equal(array.length, 3, 'all callbacks called');
    //     ok(array[0] !== array[1], 'first two callbacks have different run loops');
    //     ok(array[0], 'first runloop present');
    //     ok(array[1], 'second runloop present');
    //     equal(array[1], array[2], 'last two callbacks got the same run loop');
    //   });
    // });

    ['@test inception calls to later should run callbacks in separate run loops'](assert) {
      let done = assert.async();
      let runLoop, finished;
      (0, _runloop.run)(() => {
        runLoop = (0, _runloop._getCurrentRunLoop)();
        assert.ok(runLoop);
        (0, _runloop.later)(() => {
          assert.ok((0, _runloop._getCurrentRunLoop)() && (0, _runloop._getCurrentRunLoop)() !== runLoop, 'first later callback has own run loop');
          runLoop = (0, _runloop._getCurrentRunLoop)();
          (0, _runloop.later)(() => {
            assert.ok((0, _runloop._getCurrentRunLoop)() && (0, _runloop._getCurrentRunLoop)() !== runLoop, 'second later callback has own run loop');
            finished = true;
          }, 40);
        }, 40);
      });
      wait(() => {
        assert.ok(finished, 'all .later callbacks run');
        done();
      });
    }
    ['@test setTimeout should never run with a negative wait'](assert) {
      let done = assert.async();
      // Rationale: The old run loop code was susceptible to an occasional
      // bug where invokeLaterTimers would be scheduled with a setTimeout
      // with a negative wait. Modern browsers normalize this to 0, but
      // older browsers (IE <= 8) break with a negative wait, which
      // happens when an expired timer callback takes a while to run,
      // which is what we simulate here.
      let newSetTimeoutUsed;
      _runloop._backburner._platform = Object.assign({}, originalPlatform, {
        setTimeout() {
          let wait = arguments[arguments.length - 1];
          newSetTimeoutUsed = true;
          assert.ok(!isNaN(wait) && wait >= 0, 'wait is a non-negative number');
          return originalPlatform.setTimeout.apply(originalPlatform, arguments);
        }
      });
      let count = 0;
      (0, _runloop.run)(() => {
        (0, _runloop.later)(() => {
          count++;

          // This will get run first. Waste some time.
          // This is intended to break invokeLaterTimers code by taking a
          // long enough time that other timers should technically expire. It's
          // fine that they're not called in this run loop; just need to
          // make sure that invokeLaterTimers doesn't end up scheduling
          // a negative setTimeout.
          pauseUntil(Date.now() + 60);
        }, 1);
        (0, _runloop.later)(() => {
          assert.equal(count, 1, 'callbacks called in order');
        }, 50);
      });
      wait(() => {
        assert.ok(newSetTimeoutUsed, 'stub setTimeout was used');
        done();
      });
    }
  });
});
define("@ember/runloop/tests/next_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('runloop `next`', class extends _internalTestHelpers.AbstractTestCase {
    ['@test should invoke immediately on next timeout'](assert) {
      let done = assert.async();
      let invoked = false;
      (0, _runloop.run)(() => (0, _runloop.next)(() => invoked = true));
      assert.equal(invoked, false, 'should not have invoked yet');
      setTimeout(() => {
        assert.equal(invoked, true, 'should have invoked later item');
        done();
      }, 20);
    }
    ['@test callback should be called from within separate loop'](assert) {
      let done = assert.async();
      let firstRunLoop, secondRunLoop;
      (0, _runloop.run)(() => {
        firstRunLoop = (0, _runloop._getCurrentRunLoop)();
        (0, _runloop.next)(() => secondRunLoop = (0, _runloop._getCurrentRunLoop)());
      });
      setTimeout(() => {
        assert.ok(secondRunLoop, 'callback was called from within run loop');
        assert.ok(firstRunLoop && secondRunLoop !== firstRunLoop, 'two separate run loops were invoked');
        done();
      }, 20);
    }
    ['@test multiple calls to next share coalesce callbacks into same run loop'](assert) {
      let done = assert.async();
      let secondRunLoop, thirdRunLoop;
      (0, _runloop.run)(() => {
        (0, _runloop.next)(() => secondRunLoop = (0, _runloop._getCurrentRunLoop)());
        (0, _runloop.next)(() => thirdRunLoop = (0, _runloop._getCurrentRunLoop)());
      });
      setTimeout(() => {
        assert.ok(secondRunLoop && secondRunLoop === thirdRunLoop, 'callbacks coalesced into same run loop');
        done();
      }, 20);
    }
  });
});
define("@ember/runloop/tests/once_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/once_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test calling invokeOnce more than once invokes only once'](assert) {
      let count = 0;
      (0, _runloop.run)(() => {
        function F() {
          count++;
        }
        (0, _runloop.once)(F);
        (0, _runloop.once)(F);
        (0, _runloop.once)(F);
      });
      assert.equal(count, 1, 'should have invoked once');
    }
    ['@test should differentiate based on target'](assert) {
      let A = {
        count: 0
      };
      let B = {
        count: 0
      };
      (0, _runloop.run)(() => {
        function F() {
          this.count++;
        }
        (0, _runloop.once)(A, F);
        (0, _runloop.once)(B, F);
        (0, _runloop.once)(A, F);
        (0, _runloop.once)(B, F);
      });
      assert.equal(A.count, 1, 'should have invoked once on A');
      assert.equal(B.count, 1, 'should have invoked once on B');
    }
    ['@test should ignore other arguments - replacing previous ones'](assert) {
      let A = {
        count: 0
      };
      let B = {
        count: 0
      };
      (0, _runloop.run)(() => {
        function F(amt) {
          this.count += amt;
        }
        (0, _runloop.once)(A, F, 10);
        (0, _runloop.once)(B, F, 20);
        (0, _runloop.once)(A, F, 30);
        (0, _runloop.once)(B, F, 40);
      });
      assert.equal(A.count, 30, 'should have invoked once on A');
      assert.equal(B.count, 40, 'should have invoked once on B');
    }
    ['@test should be inside of a runloop when running'](assert) {
      (0, _runloop.run)(() => {
        (0, _runloop.once)(() => assert.ok(Boolean((0, _runloop._getCurrentRunLoop)()), 'should have a runloop'));
      });
    }
  });
});
define("@ember/runloop/tests/onerror_test", ["@ember/runloop", "@ember/-internals/error-handling", "@ember/debug", "internal-test-helpers"], function (_runloop, _errorHandling, _debug, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/onerror_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test With Ember.onerror undefined, errors in run are thrown'](assert) {
      let thrown = new Error('Boom!');
      let original = (0, _errorHandling.getOnerror)();
      let caught;
      (0, _errorHandling.setOnerror)(undefined);
      try {
        (0, _runloop.run)(() => {
          throw thrown;
        });
      } catch (error) {
        caught = error;
      } finally {
        (0, _errorHandling.setOnerror)(original);
      }
      assert.deepEqual(caught, thrown);
    }
    ['@test With Ember.onerror set, errors in run are caught'](assert) {
      let thrown = new Error('Boom!');
      let original = (0, _errorHandling.getOnerror)();
      let originalDispatchOverride = (0, _errorHandling.getDispatchOverride)();
      let originalIsTesting = (0, _debug.isTesting)();
      let caught;
      (0, _errorHandling.setOnerror)(error => {
        caught = error;
      });
      (0, _errorHandling.setDispatchOverride)(null);
      (0, _debug.setTesting)(false);
      try {
        (0, _runloop.run)(() => {
          throw thrown;
        });
      } finally {
        (0, _errorHandling.setOnerror)(original);
        (0, _errorHandling.setDispatchOverride)(originalDispatchOverride);
        (0, _debug.setTesting)(originalIsTesting);
      }
      assert.deepEqual(caught, thrown);
    }
  });
});
define("@ember/runloop/tests/run_bind_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/run_bind_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test bind builds a run-loop wrapped callback handler'](assert) {
      assert.expect(3);
      let obj = {
        value: 0,
        increment(increment) {
          assert.ok((0, _runloop._getCurrentRunLoop)(), 'expected a run-loop');
          return this.value += increment;
        }
      };
      let proxiedFunction = (0, _runloop.bind)(obj, obj.increment, 1);
      assert.equal(proxiedFunction(), 1);
      assert.equal(obj.value, 1);
    }
    ['@test bind keeps the async callback arguments'](assert) {
      assert.expect(4);
      function asyncCallback(increment, increment2, increment3) {
        assert.ok((0, _runloop._getCurrentRunLoop)(), 'expected a run-loop');
        assert.equal(increment, 1);
        assert.equal(increment2, 2);
        assert.equal(increment3, 3);
      }
      function asyncFunction(fn) {
        fn(2, 3);
      }
      asyncFunction((0, _runloop.bind)(asyncCallback, asyncCallback, 1));
    }
    ['@test [GH#16652] bind throws an error if callback is undefined']() {
      let assertBindThrows = function (msg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        expectAssertion(function () {
          (0, _runloop.bind)(...args);
        }, /could not find a suitable method to bind/, msg);
      };
      assertBindThrows('without arguments');
      assertBindThrows('with one arguments that is not a function', 'myMethod');
      assertBindThrows('if second parameter is not a function and not a property in first parameter', Object.create(null), 'myMethod');
    }
  });
});
define("@ember/runloop/tests/run_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/run_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test run invokes passed function, returning value'](assert) {
      let obj = {
        foo() {
          return [this.bar, 'FOO'];
        },
        bar: 'BAR',
        checkArgs(arg1, arg2) {
          return [arg1, this.bar, arg2];
        }
      };
      assert.equal((0, _runloop.run)(() => 'FOO'), 'FOO', 'pass function only');
      assert.deepEqual((0, _runloop.run)(obj, obj.foo), ['BAR', 'FOO'], 'pass obj and obj.method');
      assert.deepEqual((0, _runloop.run)(obj, 'foo'), ['BAR', 'FOO'], 'pass obj and "method"');
      assert.deepEqual((0, _runloop.run)(obj, obj.checkArgs, 'hello', 'world'), ['hello', 'BAR', 'world'], 'pass obj, obj.method, and extra arguments');
    }
  });
});
define("@ember/runloop/tests/schedule_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/schedule_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test scheduling item in queue should defer until finished'](assert) {
      let cnt = 0;
      (0, _runloop.run)(() => {
        (0, _runloop.schedule)('actions', () => cnt++);
        (0, _runloop.schedule)('actions', () => cnt++);
        assert.equal(cnt, 0, 'should not run action yet');
      });
      assert.equal(cnt, 2, 'should flush actions now');
    }
    ['@test a scheduled item can be canceled'](assert) {
      let hasRan = false;
      (0, _runloop.run)(() => {
        let cancelId = (0, _runloop.schedule)('actions', () => hasRan = true);
        (0, _runloop.cancel)(cancelId);
      });
      assert.notOk(hasRan, 'should not have ran callback run');
    }
    ['@test nested runs should queue each phase independently'](assert) {
      let cnt = 0;
      (0, _runloop.run)(() => {
        (0, _runloop.schedule)('actions', () => cnt++);
        assert.equal(cnt, 0, 'should not run action yet');
        (0, _runloop.run)(() => {
          (0, _runloop.schedule)('actions', () => cnt++);
        });
        assert.equal(cnt, 1, 'should not run action yet');
      });
      assert.equal(cnt, 2, 'should flush actions now');
    }
    ['@test prior queues should be flushed before moving on to next queue'](assert) {
      let order = [];
      (0, _runloop.run)(() => {
        let runLoop = (0, _runloop._getCurrentRunLoop)();
        assert.ok(runLoop, 'run loop present');
        (0, _runloop.schedule)('actions', () => {
          order.push('actions');
          assert.equal(runLoop, (0, _runloop._getCurrentRunLoop)(), 'same run loop used');
        });
        (0, _runloop.schedule)('afterRender', () => {
          order.push('afterRender');
          assert.equal(runLoop, (0, _runloop._getCurrentRunLoop)(), 'same run loop used');
          (0, _runloop.schedule)('afterRender', () => {
            order.push('afterRender');
            assert.equal(runLoop, (0, _runloop._getCurrentRunLoop)(), 'same run loop used');
          });
          (0, _runloop.schedule)('actions', () => {
            order.push('actions');
            assert.equal(runLoop, (0, _runloop._getCurrentRunLoop)(), 'same run loop used');
          });
        });
        (0, _runloop.schedule)('destroy', () => {
          order.push('destroy');
          assert.equal(runLoop, (0, _runloop._getCurrentRunLoop)(), 'same run loop used');
        });
      });
      assert.deepEqual(order, ['actions', 'afterRender', 'actions', 'afterRender', 'destroy']);
    }
  });
});
define("@ember/runloop/tests/unwind_test", ["@ember/runloop", "internal-test-helpers"], function (_runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/unwind_test', class extends _internalTestHelpers.AbstractTestCase {
    ['@test RunLoop unwinds despite unhandled exception'](assert) {
      let initialRunLoop = (0, _runloop._getCurrentRunLoop)();
      assert.throws(() => {
        (0, _runloop.run)(() => {
          (0, _runloop.schedule)('actions', function () {
            throw new Error('boom!');
          });
        });
      }, Error, 'boom!');

      // The real danger at this point is that calls to autorun will stick
      // tasks into the already-dead runloop, which will never get
      // flushed. I can't easily demonstrate this in a unit test because
      // autorun explicitly doesn't work in test mode. - ef4
      assert.equal((0, _runloop._getCurrentRunLoop)(), initialRunLoop, 'Previous run loop should be cleaned up despite exception');
    }
    ['@test run unwinds despite unhandled exception'](assert) {
      let initialRunLoop = (0, _runloop._getCurrentRunLoop)();
      assert.throws(() => {
        (0, _runloop.run)(function () {
          throw new Error('boom!');
        });
      }, Error, 'boom!');
      assert.equal((0, _runloop._getCurrentRunLoop)(), initialRunLoop, 'Previous run loop should be cleaned up despite exception');
    }
  });
});
define("@ember/service/tests/service_test", ["@ember/service", "@ember/object", "internal-test-helpers"], function (_service, _object, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('inject - decorator', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works with native decorators'](assert) {
      var _dec, _class, _descriptor;
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      let Foo = (_dec = (0, _service.inject)('main'), (_class = class Foo extends _object.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "main", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "main", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class));
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test uses the decorated property key if not provided'](assert) {
      var _class3, _descriptor2;
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      let Foo = (_class3 = class Foo extends _object.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "main", _descriptor2, this);
        }
      }, _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "main", [_service.inject], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class3);
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
  (0, _internalTestHelpers.moduleFor)('service - decorator', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works with native decorators'](assert) {
      var _dec2, _class5, _descriptor3;
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      let Foo = (_dec2 = (0, _service.service)('main'), (_class5 = class Foo extends _object.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "main", _descriptor3, this);
        }
      }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "main", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class5));
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test uses the decorated property key if not provided'](assert) {
      var _class7, _descriptor4;
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      let Foo = (_class7 = class Foo extends _object.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "main", _descriptor4, this);
        }
      }, _descriptor4 = _applyDecoratedDescriptor(_class7.prototype, "main", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class7);
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
});
define("@ember/service/tests/service_ts_test", ["@ember/service", "@ember/object", "internal-test-helpers"], function (_service, _object, _internalTestHelpers) {
  "use strict";

  var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  (0, _internalTestHelpers.moduleFor)('inject - decorator (TS)', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works with native decorators'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      class Foo extends _object.default {}
      __decorate([(0, _service.inject)('main')], Foo.prototype, "main", void 0);
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test uses the decorated property key if not provided'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      class Foo extends _object.default {}
      __decorate([_service.inject], Foo.prototype, "main", void 0);
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
  (0, _internalTestHelpers.moduleFor)('service - decorator (TS)', class extends _internalTestHelpers.AbstractTestCase {
    ['@test works with native decorators'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      class Foo extends _object.default {}
      __decorate([(0, _service.service)('main')], Foo.prototype, "main", void 0);
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
    ['@test uses the decorated property key if not provided'](assert) {
      let owner = (0, _internalTestHelpers.buildOwner)();
      class MainService extends _service.default {}
      class Foo extends _object.default {}
      __decorate([_service.service], Foo.prototype, "main", void 0);
      owner.register('service:main', MainService);
      owner.register('foo:main', Foo);
      let foo = owner.lookup('foo:main');
      assert.ok(foo.main instanceof _service.default, 'service injected correctly');
      (0, _internalTestHelpers.runDestroy)(owner);
    }
  });
});
define("@ember/utils/tests/compare_test", ["@ember/utils", "@ember/object", "@ember/-internals/runtime", "internal-test-helpers"], function (_utils, _object, _runtime, _internalTestHelpers) {
  "use strict";

  let data = [];
  let Comp = _object.default.extend(_runtime.Comparable);
  Comp.reopenClass({
    compare(obj) {
      return obj.get('val');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Ember.compare()', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      data[0] = null;
      data[1] = false;
      data[2] = true;
      data[3] = -12;
      data[4] = 3.5;
      data[5] = 'a string';
      data[6] = 'another string';
      data[7] = 'last string';
      data[8] = [1, 2];
      data[9] = [1, 2, 3];
      data[10] = [1, 3];
      data[11] = {
        a: 'hash'
      };
      data[12] = _object.default.create();
      data[13] = function (a) {
        return a;
      };
      data[14] = new Date('2012/01/01');
      data[15] = new Date('2012/06/06');
    }
    ['@test ordering should work'](assert) {
      let suspect, comparable, failureMessage, suspectIndex, comparableIndex;
      for (suspectIndex = 0; suspectIndex < data.length; suspectIndex++) {
        suspect = data[suspectIndex];
        assert.equal((0, _utils.compare)(suspect, suspect), 0, suspectIndex + ' should equal itself');
        for (comparableIndex = suspectIndex + 1; comparableIndex < data.length; comparableIndex++) {
          comparable = data[comparableIndex];
          failureMessage = 'data[' + suspectIndex + '] (' + (0, _utils.typeOf)(suspect) + ') should be smaller than data[' + comparableIndex + '] (' + (0, _utils.typeOf)(comparable) + ')';
          assert.equal((0, _utils.compare)(suspect, comparable), -1, failureMessage);
        }
      }
    }
    ['@test comparables should return values in the range of -1, 0, 1'](assert) {
      let negOne = Comp.create({
        val: -1
      });
      let zero = Comp.create({
        val: 0
      });
      let one = Comp.create({
        val: 1
      });
      assert.equal((0, _utils.compare)(negOne, 'a'), -1, 'First item comparable - returns -1 (not negated)');
      assert.equal((0, _utils.compare)(zero, 'b'), 0, 'First item comparable - returns  0 (not negated)');
      assert.equal((0, _utils.compare)(one, 'c'), 1, 'First item comparable - returns  1 (not negated)');
      assert.equal((0, _utils.compare)('a', negOne), 1, 'Second item comparable - returns -1 (negated)');
      assert.equal((0, _utils.compare)('b', zero), 0, 'Second item comparable - returns  0 (negated)');
      assert.equal((0, _utils.compare)('c', one), -1, 'Second item comparable - returns  1 (negated)');
    }
  });
});
define("@ember/utils/tests/is_blank_test", ["@ember/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isBlank', class extends _internalTestHelpers.AbstractTestCase {
    ['@test isBlank'](assert) {
      let string = 'string';
      let fn = function () {};
      let object = {
        length: 0
      };
      assert.equal(true, (0, _utils.isBlank)(null), 'for null');
      assert.equal(true, (0, _utils.isBlank)(undefined), 'for undefined');
      assert.equal(true, (0, _utils.isBlank)(''), 'for an empty String');
      assert.equal(true, (0, _utils.isBlank)('  '), 'for a whitespace String');
      assert.equal(true, (0, _utils.isBlank)('\n\t'), 'for another whitespace String');
      assert.equal(false, (0, _utils.isBlank)('\n\t Hi'), 'for a String with whitespaces');
      assert.equal(false, (0, _utils.isBlank)(true), 'for true');
      assert.equal(false, (0, _utils.isBlank)(false), 'for false');
      assert.equal(false, (0, _utils.isBlank)(string), 'for a String');
      assert.equal(false, (0, _utils.isBlank)(fn), 'for a Function');
      assert.equal(false, (0, _utils.isBlank)(0), 'for 0');
      assert.equal(true, (0, _utils.isBlank)([]), 'for an empty Array');
      assert.equal(false, (0, _utils.isBlank)({}), 'for an empty Object');
      assert.equal(true, (0, _utils.isBlank)(object), "for an Object that has zero 'length'");
      assert.equal(false, (0, _utils.isBlank)([1, 2, 3]), 'for a non-empty array');
    }
  });
});
define("@ember/utils/tests/is_empty_test", ["@ember/utils", "internal-test-helpers", "@ember/object/proxy"], function (_utils, _internalTestHelpers, _proxy) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isEmpty', class extends _internalTestHelpers.AbstractTestCase {
    ['@test isEmpty'](assert) {
      let string = 'string';
      let fn = function () {};
      let object = {
        length: 0
      };
      let proxy = _proxy.default.create({
        content: {
          size: 0
        }
      });
      assert.equal(true, (0, _utils.isEmpty)(null), 'for null');
      assert.equal(true, (0, _utils.isEmpty)(undefined), 'for undefined');
      assert.equal(true, (0, _utils.isEmpty)(''), 'for an empty String');
      assert.equal(false, (0, _utils.isEmpty)('  '), 'for a whitespace String');
      assert.equal(false, (0, _utils.isEmpty)('\n\t'), 'for another whitespace String');
      assert.equal(false, (0, _utils.isEmpty)(true), 'for true');
      assert.equal(false, (0, _utils.isEmpty)(false), 'for false');
      assert.equal(false, (0, _utils.isEmpty)(string), 'for a String');
      assert.equal(false, (0, _utils.isEmpty)(fn), 'for a Function');
      assert.equal(false, (0, _utils.isEmpty)(0), 'for 0');
      assert.equal(true, (0, _utils.isEmpty)([]), 'for an empty Array');
      assert.equal(false, (0, _utils.isEmpty)({}), 'for an empty Object');
      assert.equal(true, (0, _utils.isEmpty)(object), "for an Object that has zero 'length'");
      assert.equal(true, (0, _utils.isEmpty)(proxy), "for a proxy that has zero 'size'");
    }
  });
});
define("@ember/utils/tests/is_none_test", ["@ember/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isNone', class extends _internalTestHelpers.AbstractTestCase {
    ['@test isNone'](assert) {
      let string = 'string';
      let fn = function () {};
      assert.equal(true, (0, _utils.isNone)(null), 'for null');
      assert.equal(true, (0, _utils.isNone)(undefined), 'for undefined');
      assert.equal(false, (0, _utils.isNone)(''), 'for an empty String');
      assert.equal(false, (0, _utils.isNone)(true), 'for true');
      assert.equal(false, (0, _utils.isNone)(false), 'for false');
      assert.equal(false, (0, _utils.isNone)(string), 'for a String');
      assert.equal(false, (0, _utils.isNone)(fn), 'for a Function');
      assert.equal(false, (0, _utils.isNone)(0), 'for 0');
      assert.equal(false, (0, _utils.isNone)([]), 'for an empty Array');
      assert.equal(false, (0, _utils.isNone)({}), 'for an empty Object');
    }
  });
});
define("@ember/utils/tests/is_present_test", ["@ember/utils", "internal-test-helpers"], function (_utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isPresent', class extends _internalTestHelpers.AbstractTestCase {
    ['@test isPresent'](assert) {
      let string = 'string';
      let fn = function () {};
      let object = {
        length: 0
      };
      assert.equal(false, (0, _utils.isPresent)(), 'for no params');
      assert.equal(false, (0, _utils.isPresent)(null), 'for null');
      assert.equal(false, (0, _utils.isPresent)(undefined), 'for undefined');
      assert.equal(false, (0, _utils.isPresent)(''), 'for an empty String');
      assert.equal(false, (0, _utils.isPresent)('  '), 'for a whitespace String');
      assert.equal(false, (0, _utils.isPresent)('\n\t'), 'for another whitespace String');
      assert.equal(true, (0, _utils.isPresent)('\n\t Hi'), 'for a String with whitespaces');
      assert.equal(true, (0, _utils.isPresent)(true), 'for true');
      assert.equal(true, (0, _utils.isPresent)(false), 'for false');
      assert.equal(true, (0, _utils.isPresent)(string), 'for a String');
      assert.equal(true, (0, _utils.isPresent)(fn), 'for a Function');
      assert.equal(true, (0, _utils.isPresent)(0), 'for 0');
      assert.equal(false, (0, _utils.isPresent)([]), 'for an empty Array');
      assert.equal(true, (0, _utils.isPresent)({}), 'for an empty Object');
      assert.equal(false, (0, _utils.isPresent)(object), "for an Object that has zero 'length'");
      assert.equal(true, (0, _utils.isPresent)([1, 2, 3]), 'for a non-empty array');
    }
  });
});
define("@ember/utils/tests/type_of_test", ["@ember/utils", "@ember/object", "@ember/-internals/browser-environment", "internal-test-helpers"], function (_utils, _object, _browserEnvironment, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Type Checking', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Ember.typeOf'](assert) {
      let MockedDate = function () {};
      MockedDate.prototype = new Date();
      let mockedDate = new MockedDate();
      let date = new Date();
      let error = new Error('boum');
      let object = {
        a: 'b'
      };
      let a = null;
      let arr = [1, 2, 3];
      let obj = {};
      let instance = _object.default.create({
        method() {},
        async asyncMethod() {}
      });
      assert.equal((0, _utils.typeOf)(), 'undefined', 'undefined');
      assert.equal((0, _utils.typeOf)(null), 'null', 'null');
      assert.equal((0, _utils.typeOf)('Cyril'), 'string', 'Cyril');
      assert.equal((0, _utils.typeOf)(101), 'number', '101');
      assert.equal((0, _utils.typeOf)(true), 'boolean', 'true');
      assert.equal((0, _utils.typeOf)([1, 2, 90]), 'array', '[1,2,90]');
      assert.equal((0, _utils.typeOf)(/abc/), 'regexp', '/abc/');
      assert.equal((0, _utils.typeOf)(date), 'date', 'new Date()');
      assert.equal((0, _utils.typeOf)(mockedDate), 'date', 'mocked date');
      assert.equal((0, _utils.typeOf)(error), 'error', 'error');
      assert.equal((0, _utils.typeOf)(object), 'object', 'object');
      assert.equal((0, _utils.typeOf)(undefined), 'undefined', 'item of type undefined');
      assert.equal((0, _utils.typeOf)(a), 'null', 'item of type null');
      assert.equal((0, _utils.typeOf)(arr), 'array', 'item of type array');
      assert.equal((0, _utils.typeOf)(obj), 'object', 'item of type object');
      assert.equal((0, _utils.typeOf)(instance), 'instance', 'item of type instance');
      assert.equal((0, _utils.typeOf)(instance.method), 'function', 'item of type function');
      assert.equal((0, _utils.typeOf)(instance.asyncMethod), 'function', 'item of type async function');
      assert.equal((0, _utils.typeOf)(_object.default.extend()), 'class', 'item of type class');
      assert.equal((0, _utils.typeOf)(new Error()), 'error', 'item of type error');
    }
    ['@test Ember.typeOf(fileList)'](assert) {
      if (_browserEnvironment.window && typeof _browserEnvironment.window.FileList === 'function') {
        let fileListElement = document.createElement('input');
        fileListElement.type = 'file';
        let fileList = fileListElement.files;
        assert.equal((0, _utils.typeOf)(fileList), 'filelist', 'item of type filelist');
      } else {
        assert.ok(true, 'FileList is not present on window');
      }
    }
  });
});
define("ember-template-compiler/index", ["exports", "ember-template-compiler/lib/public-api", "@ember/template-compilation", "ember-template-compiler/lib/system/bootstrap", "ember-template-compiler/lib/system/initializer"], function (_exports, ETC, _templateCompilation, _bootstrap, _initializer) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.keys(ETC).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in _exports && _exports[key] === ETC[key]) return;
    Object.defineProperty(_exports, key, {
      enumerable: true,
      get: function () {
        return ETC[key];
      }
    });
  });
  (0, _templateCompilation.__registerTemplateCompiler)(ETC);
  // used to bootstrap templates

  // add domTemplates initializer (only does something if `ember-template-compiler`
  // is loaded already)
});
define("ember-template-compiler/lib/plugins/assert-against-attrs", ["exports", "@ember/debug", "ember-template-compiler/lib/system/calculate-location-display"], function (_exports, _debug, _calculateLocationDisplay) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = assertAgainstAttrs;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that asserts against
  
    ```handlebars
    {{attrs.foo.bar}}
    ```
  
    ...as well as `{{#if attrs.foo}}`, `{{deeply (nested attrs.foobar.baz)}}`.
  
    @private
    @class AssertAgainstAttrs
  */
  function assertAgainstAttrs(env) {
    var _env$meta;
    let {
      builders: b
    } = env.syntax;
    let moduleName = (_env$meta = env.meta) == null ? void 0 : _env$meta.moduleName;
    let stack = [[]];
    function updateBlockParamsStack(blockParams) {
      let parent = stack[stack.length - 1];
      (false && !(parent) && (0, _debug.assert)('has parent', parent));
      stack.push(parent.concat(blockParams));
    }
    return {
      name: 'assert-against-attrs',
      visitor: {
        Program: {
          enter(node) {
            updateBlockParamsStack(node.blockParams);
          },
          exit() {
            stack.pop();
          }
        },
        ElementNode: {
          enter(node) {
            updateBlockParamsStack(node.blockParams);
          },
          exit() {
            stack.pop();
          }
        },
        PathExpression(node) {
          if (isAttrs(node, stack[stack.length - 1])) {
            let path = b.path(node.original.substring(6));
            (false && !(node.this !== false) && (0, _debug.assert)("Using {{attrs}} to reference named arguments is not supported. {{attrs." + path.original + "}} should be updated to {{@" + path.original + "}}. " + (0, _calculateLocationDisplay.default)(moduleName, node.loc), node.this !== false));
          }
        }
      }
    };
  }
  function isAttrs(node, symbols) {
    let name = node.parts[0];
    if (name && symbols.indexOf(name) !== -1) {
      return false;
    }
    if (name === 'attrs') {
      if (node.this === true) {
        node.parts.shift();
        node.original = node.original.slice(5);
      }
      return true;
    }
    return false;
  }
});
define("ember-template-compiler/lib/plugins/assert-against-named-outlets", ["exports", "@ember/debug", "ember-template-compiler/lib/system/calculate-location-display"], function (_exports, _debug, _calculateLocationDisplay) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = assertAgainstNamedOutlets;
  /**
   @module ember
  */
  /**
    Prevents usage of named outlets, a legacy concept in Ember removed in 4.0.
  
    @private
    @class AssertAgainstNamedOutlets
  */
  function assertAgainstNamedOutlets(env) {
    var _env$meta;
    let moduleName = (_env$meta = env.meta) == null ? void 0 : _env$meta.moduleName;
    return {
      name: 'assert-against-named-outlets',
      visitor: {
        MustacheStatement(node) {
          if (node.path.type === 'PathExpression' && node.path.original === 'outlet' && node.params[0]) {
            let sourceInformation = (0, _calculateLocationDisplay.default)(moduleName, node.loc);
            (false && !(false) && (0, _debug.assert)("Named outlets were removed in Ember 4.0. See https://deprecations.emberjs.com/v3.x#toc_route-render-template for guidance on alternative APIs for named outlet use cases. " + sourceInformation));
          }
        }
      }
    };
  }
});
define("ember-template-compiler/lib/plugins/assert-input-helper-without-block", ["exports", "@ember/debug", "ember-template-compiler/lib/system/calculate-location-display", "ember-template-compiler/lib/plugins/utils"], function (_exports, _debug, _calculateLocationDisplay, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = errorOnInputWithContent;
  function errorOnInputWithContent(env) {
    var _env$meta;
    let moduleName = (_env$meta = env.meta) == null ? void 0 : _env$meta.moduleName;
    return {
      name: 'assert-input-helper-without-block',
      visitor: {
        BlockStatement(node) {
          if ((0, _utils.isPath)(node.path) && node.path.original === 'input') {
            (false && !(false) && (0, _debug.assert)(assertMessage(moduleName, node)));
          }
        }
      }
    };
  }
  function assertMessage(moduleName, node) {
    let sourceInformation = (0, _calculateLocationDisplay.default)(moduleName, node.loc);
    return "The {{input}} helper cannot be used in block form. " + sourceInformation;
  }
});
define("ember-template-compiler/lib/plugins/assert-reserved-named-arguments", ["exports", "@ember/debug", "ember-template-compiler/lib/system/calculate-location-display"], function (_exports, _debug, _calculateLocationDisplay) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = assertReservedNamedArguments;
  function assertReservedNamedArguments(env) {
    var _env$meta;
    let moduleName = (_env$meta = env.meta) == null ? void 0 : _env$meta.moduleName;
    return {
      name: 'assert-reserved-named-arguments',
      visitor: {
        // In general, we don't assert on the invocation side to avoid creating migration
        // hazards (e.g. using angle bracket to invoke a classic component that uses
        // `this.someReservedName`. However, we want to avoid leaking special internal
        // things, such as `__ARGS__`, so those would need to be asserted on both sides.
        AttrNode(_ref) {
          let {
            name,
            loc
          } = _ref;
          if (name === '@__ARGS__') {
            (false && !(false) && (0, _debug.assert)(assertMessage(name) + " " + (0, _calculateLocationDisplay.default)(moduleName, loc)));
          }
        },
        HashPair(_ref2) {
          let {
            key,
            loc
          } = _ref2;
          if (key === '__ARGS__') {
            (false && !(false) && (0, _debug.assert)(assertMessage(key) + " " + (0, _calculateLocationDisplay.default)(moduleName, loc)));
          }
        },
        PathExpression(_ref3) {
          let {
            original,
            loc
          } = _ref3;
          if (isReserved(original)) {
            (false && !(false) && (0, _debug.assert)(assertMessage(original) + " " + (0, _calculateLocationDisplay.default)(moduleName, loc)));
          }
        }
      }
    };
  }
  const RESERVED = ['@arguments', '@args', '@block', '@else'];
  function isReserved(name) {
    return RESERVED.indexOf(name) !== -1 || Boolean(name.match(/^@[^a-z]/));
  }
  function assertMessage(name) {
    return "'" + name + "' is reserved.";
  }
});
define("ember-template-compiler/lib/plugins/assert-splattribute-expression", ["exports", "@ember/debug", "ember-template-compiler/lib/system/calculate-location-display"], function (_exports, _debug, _calculateLocationDisplay) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = assertSplattributeExpressions;
  function assertSplattributeExpressions(env) {
    var _env$meta;
    let moduleName = (_env$meta = env.meta) == null ? void 0 : _env$meta.moduleName;
    return {
      name: 'assert-splattribute-expressions',
      visitor: {
        PathExpression(_ref) {
          let {
            original,
            loc
          } = _ref;
          if (original === '...attributes') {
            (false && !(false) && (0, _debug.assert)(errorMessage() + " " + (0, _calculateLocationDisplay.default)(moduleName, loc)));
          }
        }
      }
    };
  }
  function errorMessage() {
    return '`...attributes` can only be used in the element position e.g. `<div ...attributes />`. It cannot be used as a path.';
  }
});
define("ember-template-compiler/lib/plugins/index", ["exports", "ember-template-compiler/lib/plugins/assert-against-attrs", "ember-template-compiler/lib/plugins/assert-against-named-outlets", "ember-template-compiler/lib/plugins/assert-input-helper-without-block", "ember-template-compiler/lib/plugins/assert-reserved-named-arguments", "ember-template-compiler/lib/plugins/assert-splattribute-expression", "ember-template-compiler/lib/plugins/transform-action-syntax", "ember-template-compiler/lib/plugins/transform-each-in-into-each", "ember-template-compiler/lib/plugins/transform-each-track-array", "ember-template-compiler/lib/plugins/transform-in-element", "ember-template-compiler/lib/plugins/transform-quoted-bindings-into-just-bindings", "ember-template-compiler/lib/plugins/transform-resolutions", "ember-template-compiler/lib/plugins/transform-wrap-mount-and-outlet"], function (_exports, _assertAgainstAttrs, _assertAgainstNamedOutlets, _assertInputHelperWithoutBlock, _assertReservedNamedArguments, _assertSplattributeExpression, _transformActionSyntax, _transformEachInIntoEach, _transformEachTrackArray, _transformInElement, _transformQuotedBindingsIntoJustBindings, _transformResolutions, _transformWrapMountAndOutlet) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.STRICT_MODE_TRANSFORMS = _exports.RESOLUTION_MODE_TRANSFORMS = void 0;
  // order of plugins is important
  const RESOLUTION_MODE_TRANSFORMS = _exports.RESOLUTION_MODE_TRANSFORMS = Object.freeze([_transformQuotedBindingsIntoJustBindings.default, _assertReservedNamedArguments.default, _transformActionSyntax.default, _assertAgainstAttrs.default, _transformEachInIntoEach.default, _assertInputHelperWithoutBlock.default, _transformInElement.default, _assertSplattributeExpression.default, _transformEachTrackArray.default, _assertAgainstNamedOutlets.default, _transformWrapMountAndOutlet.default, _transformResolutions.default].filter(notNull));
  const STRICT_MODE_TRANSFORMS = _exports.STRICT_MODE_TRANSFORMS = Object.freeze([_transformQuotedBindingsIntoJustBindings.default, _assertReservedNamedArguments.default, _transformActionSyntax.default, _transformEachInIntoEach.default, _transformInElement.default, _assertSplattributeExpression.default, _transformEachTrackArray.default, _assertAgainstNamedOutlets.default, _transformWrapMountAndOutlet.default].filter(notNull));
  function notNull(value) {
    return value !== null;
  }
});
define("ember-template-compiler/lib/plugins/transform-action-syntax", ["exports", "ember-template-compiler/lib/plugins/utils"], function (_exports, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformActionSyntax;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that replaces all instances of
  
    ```handlebars
   <button {{action 'foo'}}>
   <button onblur={{action 'foo'}}>
   <button onblur={{action (action 'foo') 'bar'}}>
    ```
  
    with
  
    ```handlebars
   <button {{action this 'foo'}}>
   <button onblur={{action this 'foo'}}>
   <button onblur={{action this (action this 'foo') 'bar'}}>
    ```
  
    @private
    @class TransformActionSyntax
  */
  function transformActionSyntax(_ref) {
    let {
      syntax
    } = _ref;
    let {
      builders: b
    } = syntax;
    return {
      name: 'transform-action-syntax',
      visitor: {
        ElementModifierStatement(node) {
          if (isAction(node)) {
            insertThisAsFirstParam(node, b);
          }
        },
        MustacheStatement(node) {
          if (isAction(node)) {
            insertThisAsFirstParam(node, b);
          }
        },
        SubExpression(node) {
          if (isAction(node)) {
            insertThisAsFirstParam(node, b);
          }
        }
      }
    };
  }
  function isAction(node) {
    return (0, _utils.isPath)(node.path) && node.path.original === 'action';
  }
  function insertThisAsFirstParam(node, builders) {
    node.params.unshift(builders.path('this'));
  }
});
define("ember-template-compiler/lib/plugins/transform-each-in-into-each", ["exports", "ember-template-compiler/lib/plugins/utils"], function (_exports, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformEachInIntoEach;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that replaces all instances of
  
    ```handlebars
    {{#each-in iterableThing as |key value|}}
    ```
  
    with
  
    ```handlebars
    {{#each (-each-in iterableThing) as |value key|}}
    ```
  
    @private
    @class TransformHasBlockSyntax
  */
  function transformEachInIntoEach(env) {
    let {
      builders: b
    } = env.syntax;
    return {
      name: 'transform-each-in-into-each',
      visitor: {
        BlockStatement(node) {
          if ((0, _utils.isPath)(node.path) && node.path.original === 'each-in') {
            node.params[0] = b.sexpr(b.path('-each-in'), [node.params[0]]);
            let blockParams = node.program.blockParams;
            if (!blockParams || blockParams.length === 0) {
              // who uses {{#each-in}} without block params?!
            } else if (blockParams.length === 1) {
              // insert a dummy variable for the first slot
              // pick a name that won't parse so it won't shadow any real variables
              blockParams = ['( unused value )', blockParams[0]];
            } else {
              let key = blockParams.shift();
              let value = blockParams.shift();
              blockParams = [value, key, ...blockParams];
            }
            node.program.blockParams = blockParams;
            return b.block(b.path('each'), node.params, node.hash, node.program, node.inverse, node.loc);
          }
        }
      }
    };
  }
});
define("ember-template-compiler/lib/plugins/transform-each-track-array", ["exports", "@ember/debug", "ember-template-compiler/lib/plugins/utils"], function (_exports, _debug, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformEachTrackArray;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that replaces all instances of
  
    ```handlebars
    {{#each iterableThing as |key value|}}
    ```
  
    with
  
    ```handlebars
    {{#each (-track-array iterableThing) as |key value|}}
    ```
  
    @private
    @class TransformHasBlockSyntax
  */
  function transformEachTrackArray(env) {
    let {
      builders: b
    } = env.syntax;
    return {
      name: 'transform-each-track-array',
      visitor: {
        BlockStatement(node) {
          if ((0, _utils.isPath)(node.path) && node.path.original === 'each') {
            let firstParam = node.params[0];
            (false && !(firstParam) && (0, _debug.assert)('has firstParam', firstParam));
            if (firstParam.type === 'SubExpression' && firstParam.path.type === 'PathExpression' && firstParam.path.original === '-each-in') {
              return;
            }
            node.params[0] = b.sexpr(b.path('-track-array'), [firstParam]);
            return b.block(b.path('each'), node.params, node.hash, node.program, node.inverse, node.loc);
          }
        }
      }
    };
  }
});
define("ember-template-compiler/lib/plugins/transform-in-element", ["exports", "@ember/debug", "ember-template-compiler/lib/plugins/utils"], function (_exports, _debug, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformInElement;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that handles the public `{{in-element}}` as per RFC287.
  
    Issues a build time assertion for:
  
    ```handlebars
    {{#in-element someElement insertBefore="some-none-null-value"}}
      {{modal-display text=text}}
    {{/in-element}}
    ```
  
    @private
    @class TransformInElement
  */
  function transformInElement(env) {
    let {
      builders: b
    } = env.syntax;
    return {
      name: 'transform-in-element',
      visitor: {
        BlockStatement(node) {
          if (!(0, _utils.isPath)(node.path)) return;
          if (node.path.original === 'in-element') {
            let originalValue = node.params[0];
            if (originalValue && !env.isProduction) {
              let subExpr = b.sexpr('-in-el-null', [originalValue]);
              node.params.shift();
              node.params.unshift(subExpr);
            }
            node.hash.pairs.forEach(pair => {
              if (pair.key === 'insertBefore') {
                (false && !(pair.value.type === 'NullLiteral' || pair.value.type === 'UndefinedLiteral') && (0, _debug.assert)("Can only pass null to insertBefore in in-element, received: " + JSON.stringify(pair.value), pair.value.type === 'NullLiteral' || pair.value.type === 'UndefinedLiteral'));
              }
            });
          }
        }
      }
    };
  }
});
define("ember-template-compiler/lib/plugins/transform-quoted-bindings-into-just-bindings", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformQuotedBindingsIntoJustBindings;
  function transformQuotedBindingsIntoJustBindings( /* env */
  ) {
    return {
      name: 'transform-quoted-bindings-into-just-bindings',
      visitor: {
        ElementNode(node) {
          let styleAttr = getStyleAttr(node);
          if (!validStyleAttr(styleAttr)) {
            return;
          }
          styleAttr.value = styleAttr.value.parts[0];
        }
      }
    };
  }
  function validStyleAttr(attr) {
    if (!attr) {
      return false;
    }
    let value = attr.value;
    if (!value || value.type !== 'ConcatStatement' || value.parts.length !== 1) {
      return false;
    }
    let onlyPart = value.parts[0];
    return onlyPart.type === 'MustacheStatement';
  }
  function getStyleAttr(node) {
    let attributes = node.attributes;
    for (let attribute of attributes) {
      if (attribute.name === 'style') {
        return attribute;
      }
    }
    return undefined;
  }
});
define("ember-template-compiler/lib/plugins/transform-resolutions", ["exports", "@ember/debug", "@glimmer/syntax", "ember-template-compiler/lib/system/calculate-location-display", "ember-template-compiler/lib/plugins/utils"], function (_exports, _debug, _syntax, _calculateLocationDisplay, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformResolutions;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that replaces all instances of
  
    ```handlebars
    {{helper "..." ...}}
    ```
  
    with
  
    ```handlebars
    {{helper (-resolve "helper:...") ...}}
    ```
  
    and
  
    ```handlebars
    {{helper ... ...}}
    ```
  
    with
  
    ```handlebars
    {{helper (-disallow-dynamic-resolution ...) ...}}
    ```
  
    and
  
    ```handlebars
    {{modifier "..." ...}}
    ```
  
    with
  
    ```handlebars
    {{modifier (-resolve "modifier:...") ...}}
    ```
    and
  
    ```handlebars
    {{modifier ... ...}}
    ```
  
    with
  
    ```handlebars
    {{modifier (-disallow-dynamic-resolution ...) ...}}
    ```
  
    @private
    @class TransformResolutions
  */
  const TARGETS = Object.freeze(['helper', 'modifier']);
  function transformResolutions(env) {
    var _env$meta;
    let {
      builders: b
    } = env.syntax;
    let moduleName = (_env$meta = env.meta) == null ? void 0 : _env$meta.moduleName;
    let {
      hasLocal,
      node: tracker
    } = (0, _utils.trackLocals)();
    let seen;
    return {
      name: 'transform-resolutions',
      visitor: {
        Template: {
          enter() {
            seen = new Set();
          },
          exit() {
            seen = undefined;
          }
        },
        Block: tracker,
        ElementNode: {
          keys: {
            children: tracker
          }
        },
        MustacheStatement(node) {
          (false && !(seen) && (0, _debug.assert)('[BUG] seen set should be available', seen));
          if (seen.has(node)) {
            return;
          }
          if ((0, _utils.isPath)(node.path) && !isLocalVariable(node.path, hasLocal) && TARGETS.indexOf(node.path.original) !== -1) {
            let result = b.mustache(node.path, transformParams(b, node.params, node.path.original, moduleName, node.loc), node.hash, node.trusting, node.loc, node.strip);
            // Avoid double/infinite-processing
            seen.add(result);
            return result;
          }
        },
        SubExpression(node) {
          (false && !(seen) && (0, _debug.assert)('[BUG] seen set should be available', seen));
          if (seen.has(node)) {
            return;
          }
          if ((0, _utils.isPath)(node.path) && !isLocalVariable(node.path, hasLocal) && TARGETS.indexOf(node.path.original) !== -1) {
            let result = b.sexpr(node.path, transformParams(b, node.params, node.path.original, moduleName, node.loc), node.hash, node.loc);
            // Avoid double/infinite-processing
            seen.add(result);
            return result;
          }
        }
      }
    };
  }
  function isLocalVariable(node, hasLocal) {
    return !node.this && node.parts.length === 1 && hasLocal(node.parts[0]);
  }
  function transformParams(b, params, type, moduleName, loc) {
    let [first, ...rest] = params;
    (false && !(first) && (0, _debug.assert)("The " + type + " keyword requires at least one positional arguments " + (0, _calculateLocationDisplay.default)(moduleName, loc), first));
    if ((0, _utils.isStringLiteral)(first)) {
      return [b.sexpr(b.path('-resolve', first.loc), [b.string(type + ":" + first.value)], undefined, first.loc), ...rest];
    } else if (false /* DEBUG */) {
      return [b.sexpr(b.path('-disallow-dynamic-resolution', first.loc), [first], b.hash([b.pair('type', b.string(type), first.loc), b.pair('loc', b.string((0, _calculateLocationDisplay.default)(moduleName, loc)), first.loc), b.pair('original', b.string((0, _syntax.print)(first)))]), first.loc), ...rest];
    } else {
      return params;
    }
  }
});
define("ember-template-compiler/lib/plugins/transform-wrap-mount-and-outlet", ["exports", "ember-template-compiler/lib/plugins/utils"], function (_exports, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = transformWrapMountAndOutlet;
  /**
   @module ember
  */
  /**
    A Glimmer2 AST transformation that replaces all instances of
  
    ```handlebars
    {{mount "engine" model=this.model}}
    ```
  
    with
  
    ```handlebars
    {{component (-mount "engine" model=this.model)}}
    ```
  
    and
  
    ```handlebars
    {{outlet}}
    ```
  
    with
  
    ```handlebars
    {{component (-outlet)}}
    ```
  
    @private
    @class TransformHasBlockSyntax
  */
  function transformWrapMountAndOutlet(env) {
    let {
      builders: b
    } = env.syntax;
    let {
      hasLocal,
      node
    } = (0, _utils.trackLocals)();
    return {
      name: 'transform-wrap-mount-and-outlet',
      visitor: {
        Program: node,
        ElementNode: node,
        MustacheStatement(node) {
          if ((0, _utils.isPath)(node.path) && (node.path.original === 'mount' || node.path.original === 'outlet') && !hasLocal(node.path.original)) {
            let subexpression = b.sexpr(b.path("-" + node.path.original), node.params, node.hash, node.loc);
            return b.mustache(b.path('component'), [subexpression], b.hash(), undefined, node.loc);
          }
        }
      }
    };
  }
});
define("ember-template-compiler/lib/plugins/utils", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.isPath = isPath;
  _exports.isStringLiteral = isStringLiteral;
  _exports.isSubExpression = isSubExpression;
  _exports.trackLocals = trackLocals;
  function isPath(node) {
    return node.type === 'PathExpression';
  }
  function isSubExpression(node) {
    return node.type === 'SubExpression';
  }
  function isStringLiteral(node) {
    return node.type === 'StringLiteral';
  }
  function trackLocals() {
    let locals = new Map();
    let node = {
      enter(node) {
        for (let param of node.blockParams) {
          let value = locals.get(param) || 0;
          locals.set(param, value + 1);
        }
      },
      exit(node) {
        for (let param of node.blockParams) {
          let value = locals.get(param) - 1;
          if (value === 0) {
            locals.delete(param);
          } else {
            locals.set(param, value);
          }
        }
      }
    };
    return {
      hasLocal: key => locals.has(key),
      node
    };
  }
});
define("ember-template-compiler/lib/public-api", ["exports", "ember", "ember/version", "@glimmer/syntax", "ember-template-compiler/lib/system/precompile", "ember-template-compiler/lib/system/compile", "ember-template-compiler/lib/system/compile-options", "ember-template-compiler/lib/plugins", "@glimmer/compiler"], function (_exports, _ember, _version, _GlimmerSyntax, _precompile, _compile, _compileOptions, _plugins, _compiler) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "RESOLUTION_MODE_TRANSFORMS", {
    enumerable: true,
    get: function () {
      return _plugins.RESOLUTION_MODE_TRANSFORMS;
    }
  });
  Object.defineProperty(_exports, "STRICT_MODE_TRANSFORMS", {
    enumerable: true,
    get: function () {
      return _plugins.STRICT_MODE_TRANSFORMS;
    }
  });
  Object.defineProperty(_exports, "VERSION", {
    enumerable: true,
    get: function () {
      return _version.default;
    }
  });
  Object.defineProperty(_exports, "_Ember", {
    enumerable: true,
    get: function () {
      return _ember.default;
    }
  });
  _exports._GlimmerSyntax = void 0;
  Object.defineProperty(_exports, "_buildCompileOptions", {
    enumerable: true,
    get: function () {
      return _compileOptions.buildCompileOptions;
    }
  });
  Object.defineProperty(_exports, "_precompile", {
    enumerable: true,
    get: function () {
      return _compiler.precompile;
    }
  });
  Object.defineProperty(_exports, "_preprocess", {
    enumerable: true,
    get: function () {
      return _GlimmerSyntax.preprocess;
    }
  });
  Object.defineProperty(_exports, "_print", {
    enumerable: true,
    get: function () {
      return _GlimmerSyntax.print;
    }
  });
  Object.defineProperty(_exports, "_transformsFor", {
    enumerable: true,
    get: function () {
      return _compileOptions.transformsFor;
    }
  });
  Object.defineProperty(_exports, "compile", {
    enumerable: true,
    get: function () {
      return _compile.default;
    }
  });
  Object.defineProperty(_exports, "compileOptions", {
    enumerable: true,
    get: function () {
      return _compileOptions.default;
    }
  });
  Object.defineProperty(_exports, "precompile", {
    enumerable: true,
    get: function () {
      return _precompile.default;
    }
  });
  _exports._GlimmerSyntax = _GlimmerSyntax;
});
define("ember-template-compiler/lib/system/bootstrap", ["exports", "ember-template-compiler/lib/system/compile"], function (_exports, _compile) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  /**
  @module ember
  */

  /**
    Find templates stored in the head tag as script tags and make them available
    to `Ember.CoreView` in the global `Ember.TEMPLATES` object.
  
    Script tags with `text/x-handlebars` will be compiled
    with Ember's template compiler and are suitable for use as a view's template.
  
    @private
    @method bootstrap
    @for Ember.HTMLBars
    @static
    @param ctx
  */
  function bootstrap(_ref) {
    let {
      context,
      hasTemplate,
      setTemplate
    } = _ref;
    if (!context) {
      context = document;
    }
    let selector = 'script[type="text/x-handlebars"]';
    let elements = context.querySelectorAll(selector);
    for (let script of elements) {
      // Get the name of the script
      // First look for data-template-name attribute, then fall back to its
      // id if no name is found.
      let templateName = script.getAttribute('data-template-name') || script.getAttribute('id') || 'application';
      let template;
      template = (0, _compile.default)(script.innerHTML, {
        moduleName: templateName
      });
      // Check if template of same name already exists.
      if (hasTemplate(templateName)) {
        throw new Error("Template named \"" + templateName + "\" already exists.");
      }
      // For templates which have a name, we save them and then remove them from the DOM.
      setTemplate(templateName, template);
      // Remove script tag from DOM.
      script.parentNode.removeChild(script);
    }
  }
  var _default = _exports.default = bootstrap;
});
define("ember-template-compiler/lib/system/calculate-location-display", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = calculateLocationDisplay;
  function calculateLocationDisplay(moduleName, loc) {
    let moduleInfo = '';
    if (moduleName) {
      moduleInfo += "'" + moduleName + "' ";
    }
    if (loc) {
      let {
        column,
        line
      } = loc.start || {
        line: undefined,
        column: undefined
      };
      if (line !== undefined && column !== undefined) {
        if (moduleName) {
          // only prepend @ if the moduleName was present
          moduleInfo += '@ ';
        }
        moduleInfo += "L" + line + ":C" + column;
      }
    }
    if (moduleInfo) {
      moduleInfo = "(" + moduleInfo + ") ";
    }
    return moduleInfo;
  }
});
define("ember-template-compiler/lib/system/compile-options", ["exports", "@ember/debug", "ember-template-compiler/lib/plugins/index", "ember-template-compiler/lib/system/dasherize-component-name"], function (_exports, _debug, _index, _dasherizeComponentName) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.buildCompileOptions = buildCompileOptions;
  _exports.default = compileOptions;
  _exports.transformsFor = transformsFor;
  let USER_PLUGINS = [];
  function malformedComponentLookup(string) {
    return string.indexOf('::') === -1 && string.indexOf(':') > -1;
  }
  function buildCompileOptions(_options) {
    let moduleName = _options.moduleName;
    let options = Object.assign({
      meta: {},
      isProduction: false,
      plugins: {
        ast: []
      }
    }, _options, {
      moduleName,
      customizeComponentName(tagname) {
        (false && !(!malformedComponentLookup(tagname)) && (0, _debug.assert)("You tried to invoke a component named <" + tagname + " /> in \"" + (moduleName != null ? moduleName : '[NO MODULE]') + "\", but that is not a valid name for a component. Did you mean to use the \"::\" syntax for nested components?", !malformedComponentLookup(tagname)));
        return _dasherizeComponentName.default.get(tagname);
      }
    });
    if ('locals' in options && !options.locals) {
      // Glimmer's precompile options declare `locals` like:
      //    locals?: string[]
      // but many in-use versions of babel-plugin-htmlbars-inline-precompile will
      // set locals to `null`. This used to work but only because glimmer was
      // ignoring locals for non-strict templates, and now it supports that case.
      delete options.locals;
    }
    // move `moduleName` into `meta` property
    if (options.moduleName) {
      let meta = options.meta;
      (false && !(meta) && (0, _debug.assert)('has meta', meta)); // We just set it
      meta.moduleName = options.moduleName;
    }
    return options;
  }
  function transformsFor(options) {
    return options.strictMode ? _index.STRICT_MODE_TRANSFORMS : _index.RESOLUTION_MODE_TRANSFORMS;
  }
  function compileOptions(_options) {
    if (_options === void 0) {
      _options = {};
    }
    let options = buildCompileOptions(_options);
    let builtInPlugins = transformsFor(options);
    if (!_options.plugins) {
      options.plugins = {
        ast: [...USER_PLUGINS, ...builtInPlugins]
      };
    } else {
      let potententialPugins = [...USER_PLUGINS, ...builtInPlugins];
      (false && !(options.plugins) && (0, _debug.assert)('expected plugins', options.plugins));
      let pluginsToAdd = potententialPugins.filter(plugin => {
        (false && !(options.plugins) && (0, _debug.assert)('expected plugins', options.plugins));
        return options.plugins.ast.indexOf(plugin) === -1;
      });
      options.plugins.ast = options.plugins.ast.concat(pluginsToAdd);
    }
    return options;
  }
});
define("ember-template-compiler/lib/system/compile", ["exports", "ember-template-compiler/lib/system/precompile", "@ember/-internals/glimmer"], function (_exports, _precompile, _glimmer) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = compile;
  /**
    Uses HTMLBars `compile` function to process a string into a compiled template.
    This is not present in production builds.
    @private
    @method compile
    @param {String} templateString This is the string to be compiled by HTMLBars.
    @param {Object} options This is an options hash to augment the compiler options.
  */
  function compile(templateString, options) {
    if (options === void 0) {
      options = {};
    }
    if (!_glimmer.template) {
      throw new Error('Cannot call `compile` with only the template compiler loaded. Please load `ember.debug.js` or `ember.prod.js` prior to calling `compile`.');
    }
    return (0, _glimmer.template)(evaluate((0, _precompile.default)(templateString, options)));
  }
  function evaluate(precompiled) {
    return new Function("return " + precompiled)();
  }
});
define("ember-template-compiler/lib/system/dasherize-component-name", ["exports", "@ember/-internals/utils"], function (_exports, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  /*
    This diverges from `Ember.String.dasherize` so that`<XFoo />` can resolve to `x-foo`.
    `Ember.String.dasherize` would resolve it to `xfoo`..
  */
  const SIMPLE_DASHERIZE_REGEXP = /[A-Z]|::/g;
  const ALPHA = /[A-Za-z0-9]/;
  var _default = _exports.default = new _utils.Cache(1000, key => key.replace(SIMPLE_DASHERIZE_REGEXP, (char, index) => {
    if (char === '::') {
      return '/';
    }
    if (index === 0 || !ALPHA.test(key[index - 1])) {
      return char.toLowerCase();
    }
    return "-" + char.toLowerCase();
  }));
});
define("ember-template-compiler/lib/system/initializer", ["ember-template-compiler/lib/system/bootstrap", "@ember/-internals/browser-environment", "@ember/-internals/glimmer", "@ember/application"], function (_bootstrap, emberEnv, emberGlimmer, emberApp) {
  "use strict";

  // Globals mode template compiler
  if (emberApp.default) {
    let Application = emberApp.default;
    let {
      hasTemplate,
      setTemplate
    } = emberGlimmer;
    let {
      hasDOM
    } = emberEnv;
    Application.initializer({
      name: 'domTemplates',
      initialize() {
        if (hasDOM) {
          (0, _bootstrap.default)({
            context: document,
            hasTemplate,
            setTemplate
          });
        }
      }
    });
  }
});
define("ember-template-compiler/lib/system/precompile", ["exports", "@glimmer/compiler", "ember-template-compiler/lib/system/compile-options"], function (_exports, _compiler, _compileOptions) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = precompile;
  /**
  @module ember
  */

  /**
    Uses HTMLBars `compile` function to process a string into a compiled template string.
    The returned string must be passed through `Ember.HTMLBars.template`.
  
    This is not present in production builds.
  
    @private
    @method precompile
    @param {String} templateString This is the string to be compiled by HTMLBars.
  */
  function precompile(templateString, options) {
    if (options === void 0) {
      options = {};
    }
    return (0, _compiler.precompile)(templateString, (0, _compileOptions.default)(options));
  }
});
define("ember-template-compiler/lib/types", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
});
define("ember-template-compiler/minimal", ["exports", "ember-template-compiler/lib/system/precompile", "ember-template-compiler/lib/system/compile-options", "@glimmer/syntax"], function (_exports, _precompile, _compileOptions, _syntax) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "_buildCompileOptions", {
    enumerable: true,
    get: function () {
      return _compileOptions.buildCompileOptions;
    }
  });
  Object.defineProperty(_exports, "_preprocess", {
    enumerable: true,
    get: function () {
      return _syntax.preprocess;
    }
  });
  Object.defineProperty(_exports, "_print", {
    enumerable: true,
    get: function () {
      return _syntax.print;
    }
  });
  Object.defineProperty(_exports, "precompile", {
    enumerable: true,
    get: function () {
      return _precompile.default;
    }
  });
});
define("ember-template-compiler/tests/basic-usage-test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  function removeDataTest() {
    return {
      name: 'remove-data-test',
      visitor: {
        ElementNode(node) {
          for (let i = 0; i < node.attributes.length; i++) {
            let attribute = node.attributes[i];
            if (attribute.name === 'data-test') {
              node.attributes.splice(i, 1);
            }
          }
        }
      }
    };
  }
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: Embroider-like compilation', class extends _internalTestHelpers.RenderingTestCase {
    '@test can process a subset of AST plugins and print'(assert) {
      let template = '<div data-test="foo" data-blah="derp" class="hahaha">&nbsp;</div>';

      // build up options including strictMode default values, customizeComponentName, meta.moduleName, etc
      let options = (0, _index._buildCompileOptions)({
        mode: 'codemod',
        moduleName: 'components/foo',
        plugins: {
          ast: [removeDataTest]
        }
      });
      let transformedTemplateAST = (0, _index._preprocess)(template, options);

      // print back to a handlebars string
      let result = (0, _index._print)(transformedTemplateAST, {
        entityEncoding: 'raw'
      });
      assert.equal(result, '<div data-blah="derp" class="hahaha">&nbsp;</div>');
    }
  });
});
define("ember-template-compiler/tests/plugins/assert-against-attrs-test", ["ember-template-compiler/tests/utils/transform-test-case", "internal-test-helpers"], function (_transformTestCase, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert against attrs', class extends _transformTestCase.default {
    ['@test it asserts against attrs']() {
      expectAssertion(() => {
        this.assertTransformed("{{attrs.foo}}", "{{attrs.foo}}");
      }, /Using {{attrs}} to reference named arguments is not supported. {{attrs.foo}} should be updated to {{@foo}}./);
      expectAssertion(() => {
        this.assertTransformed("{{attrs.foo.bar}}", "{{attrs.foo.bar}}");
      }, /Using {{attrs}} to reference named arguments is not supported. {{attrs.foo.bar}} should be updated to {{@foo.bar}}./);
      expectAssertion(() => {
        this.assertTransformed("{{if attrs.foo \"foo\"}}", "{{if attrs.foo \"foo\"}}");
      }, /Using {{attrs}} to reference named arguments is not supported. {{attrs.foo}} should be updated to {{@foo}}./);
      expectAssertion(() => {
        this.assertTransformed("{{#if attrs.foo}}{{/if}}", "{{#if attrs.foo}}{{/if}}");
      }, /Using {{attrs}} to reference named arguments is not supported. {{attrs.foo}} should be updated to {{@foo}}./);
      expectAssertion(() => {
        this.assertTransformed("{{deeply (nested attrs.foo.bar)}}", "{{deeply (nested attrs.foo.bar)}}");
      }, /Using {{attrs}} to reference named arguments is not supported. {{attrs.foo.bar}} should be updated to {{@foo.bar}}./);
    }
    ['@test it does not assert against this.attrs']() {
      this.assertTransformed("{{this.attrs.foo}}", "{{this.attrs.foo}}");
      this.assertTransformed("{{if this.attrs.foo \"foo\"}}", "{{if this.attrs.foo \"foo\"}}");
      this.assertTransformed("{{#if this.attrs.foo}}{{/if}}", "{{#if this.attrs.foo}}{{/if}}");
      this.assertTransformed("{{deeply (nested this.attrs.foo.bar)}}", "{{deeply (nested this.attrs.foo.bar)}}");
    }
  });
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: not asserting against block params named "attrs"', class extends _internalTestHelpers.RenderingTestCase {
    ["@test it doesn't assert block params"]() {
      this.registerComponent('foo', {
        template: '{{#let "foo" as |attrs|}}{{attrs}}{{/let}}'
      });
      this.render('<Foo />');
      this.assertComponentElement(this.firstChild, {
        content: 'foo'
      });
    }
    ["@test it doesn't assert component block params"]() {
      this.registerComponent('foo', {
        template: '{{yield "foo"}}'
      });
      this.render('<Foo as |attrs|>{{attrs}}</Foo>');
      this.assertComponentElement(this.firstChild, {
        content: 'foo'
      });
    }
    ["@test it doesn't assert block params with nested keys"]() {
      this.registerComponent('foo', {
        template: '{{yield (hash bar="baz")}}'
      });
      this.render('<Foo as |attrs|>{{attrs.bar}}</Foo>');
      this.assertComponentElement(this.firstChild, {
        content: 'baz'
      });
    }
  });
});
define("ember-template-compiler/tests/plugins/assert-against-named-outlets-test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-against-named-outlets', class extends _internalTestHelpers.AbstractTestCase {
    ["named outlets are asserted against"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{outlet 'foo'}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Named outlets were removed in Ember 4.0. See https://deprecations.emberjs.com/v3.x#toc_route-render-template for guidance on alternative APIs for named outlet use cases. ('baz/foo-bar' @ L1:C5) ");
      expectAssertion(() => {
        (0, _index.compile)("{{outlet foo}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Named outlets were removed in Ember 4.0. See https://deprecations.emberjs.com/v3.x#toc_route-render-template for guidance on alternative APIs for named outlet use cases. ('baz/foo-bar' @ L1:C5) ");

      // No assertion
      (0, _index.compile)("{{outlet}}", {
        moduleName: 'baz/foo-bar'
      });
    }
  });
});
define("ember-template-compiler/tests/plugins/assert-input-helper-without-block-test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-input-helper-without-block', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Using {{#input}}{{/input}} is not valid']() {
      let expectedMessage = "The {{input}} helper cannot be used in block form. ('baz/foo-bar' @ L1:C0) ";
      expectAssertion(() => {
        (0, _index.compile)('{{#input value="123"}}Completely invalid{{/input}}', {
          moduleName: 'baz/foo-bar'
        });
      }, expectedMessage);
    }
  });
});
define("ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-reserved-named-arguments', class extends _internalTestHelpers.AbstractTestCase {
    ["@test '@arguments' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@arguments}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @arguments}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @arguments \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@args' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@args}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@args' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @args}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@args' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @args \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@args' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@block' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@block}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@block' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @block}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@block' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @block \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@block' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@else' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@else}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@else' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @else}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@else' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @else \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@else' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }

    // anything else that doesn't start with a lower case letter
    ["@test '@Arguments' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@Arguments}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @Arguments}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @Arguments \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@Args' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@Args}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @Args}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @Args \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@FOO' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@FOO}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @FOO}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @FOO \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@Foo' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@Foo}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @Foo}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @Foo \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@.' is reserved"](assert) {
      assert.throws(() => {
        (0, _index.compile)("{{@.}}", {
          moduleName: 'baz/foo-bar'
        });
      }, /Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z/);
      assert.throws(() => {
        (0, _index.compile)("{{#if @.}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, /Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z/);
      assert.throws(() => {
        (0, _index.compile)("{{input type=(if @. \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, /Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z/);
    }
    ["@test '@_' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@_}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@_' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @_}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@_' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @_ \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@_' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@-' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@-}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@-' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @-}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@-' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @- \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@-' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@$' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("{{@$}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@$' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @$}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@$' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @$ \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@$' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@__ARGS__' is reserved"]() {
      expectAssertion(() => {
        (0, _index.compile)("<Foo @__ARGS__=\"bar\" />", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C5) ");
      expectAssertion(() => {
        (0, _index.compile)("{{foo __ARGS__=\"bar\"}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'__ARGS__' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#let (component \"foo\" __ARGS__=\"bar\") as |c|}}{{c}}{{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'__ARGS__' is reserved. ('baz/foo-bar' @ L1:C24) ");
      expectAssertion(() => {
        (0, _index.compile)("{{@__ARGS__}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(() => {
        (0, _index.compile)("{{#if @__ARGS__}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(() => {
        (0, _index.compile)("{{input type=(if @__ARGS__ \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C17) ");
    }
    ["@test '@' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @ "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
    ["@test '@0' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@0}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @0}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @0 "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
    ["@test '@1' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@1}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @1}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @1 "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
    ["@test '@2' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@2}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @2}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @2 "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
    ["@test '@@' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@@}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @@}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @@ "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
    ["@test '@=' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@=}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @=}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @= "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
    ["@test '@!' is de facto reserved (parse error)"](assert) {
      assert.throws(() => {
        (0, _index.compile)('{{@!}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{#if @!}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(() => {
        (0, _index.compile)('{{input type=(if @! "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    }
  });
});
define("ember-template-compiler/tests/plugins/assert-splattribute-expression-test", ["internal-test-helpers", "ember-template-compiler/index"], function (_internalTestHelpers, _index) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-splattribute-expression', class extends _internalTestHelpers.AbstractTestCase {
    expectedMessage(locInfo) {
      return "`...attributes` can only be used in the element position e.g. `<div ...attributes />`. It cannot be used as a path. (" + locInfo + ") ";
    }
    '@test ...attributes is in element space'(assert) {
      assert.expect(0);
      (0, _index.compile)('<div ...attributes>Foo</div>');
    }
    '@test {{...attributes}} is not valid'() {
      expectAssertion(() => {
        (0, _index.compile)('<div>{{...attributes}}</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    }
    '@test {{...attributes}} is not valid path expression'() {
      expectAssertion(() => {
        (0, _index.compile)('<div>{{...attributes}}</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    }
    '@test {{...attributes}} is not valid modifier'() {
      expectAssertion(() => {
        (0, _index.compile)('<div {{...attributes}}>Wat</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    }
    '@test {{...attributes}} is not valid attribute'() {
      expectAssertion(() => {
        (0, _index.compile)('<div class={{...attributes}}>Wat</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C13"));
    }
  });
});
define("ember-template-compiler/tests/plugins/transform-component-invocation-test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforms component invocation', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Does not throw a compiler error for component invocations'](assert) {
      assert.expect(0);
      ['{{this.modal open}}', '{{this.modal isOpen=true}}', '{{#this.modal}}Woot{{/this.modal}}', '{{@modal open}}',
      // RFC#311
      '{{@modal isOpen=true}}',
      // RFC#311
      '{{#@modal}}Woot{{/@modal}}',
      // RFC#311
      '{{c.modal open}}', '{{c.modal isOpen=true}}', '{{#c.modal}}Woot{{/c.modal}}', '{{#my-component as |c|}}{{c name="Chad"}}{{/my-component}}',
      // RFC#311
      '{{#my-component as |c|}}{{c "Chad"}}{{/my-component}}',
      // RFC#311
      '{{#my-component as |c|}}{{#c}}{{/c}}{{/my-component}}',
      // RFC#311
      '<input disabled={{true}}>',
      // GH#15740
      '<td colspan={{3}}></td>' // GH#15217
      ].forEach((layout, i) => {
        (0, _index.compile)(layout, {
          moduleName: "example-" + i
        });
      });
    }
  });
});
define("ember-template-compiler/tests/plugins/transform-input-type-syntax-test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: input type syntax', class extends _internalTestHelpers.AbstractTestCase {
    ['@test Can compile an {{input}} helper that has a sub-expression value as its type'](assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type=(if true 'password' 'text')}}");
    }
    ['@test Can compile an {{input}} helper with a string literal type'](assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type='text'}}");
    }
    ['@test Can compile an {{input}} helper with a type stored in a var'](assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type=_type}}");
    }
  });
});
define("ember-template-compiler/tests/system/bootstrap-test", ["@ember/runloop", "@ember/-internals/glimmer", "ember-template-compiler/lib/system/bootstrap", "internal-test-helpers"], function (_runloop, _glimmer, _bootstrap, _internalTestHelpers) {
  "use strict";

  let component, fixture;
  function checkTemplate(templateName, assert) {
    (0, _runloop.run)(() => (0, _bootstrap.default)({
      context: fixture,
      hasTemplate: _glimmer.hasTemplate,
      setTemplate: _glimmer.setTemplate
    }));
    let template = (0, _glimmer.getTemplate)(templateName);
    let qunitFixture = document.querySelector('#qunit-fixture');
    assert.ok(template, 'template is available on Ember.TEMPLATES');
    assert.notOk(qunitFixture.querySelector('script'), 'script removed');
    let owner = (0, _internalTestHelpers.buildOwner)();
    owner.register('template:-top-level', template);
    owner.register('component:-top-level', _glimmer.Component.extend({
      layoutName: '-top-level',
      firstName: 'Tobias',
      drug: 'teamocil'
    }));
    component = owner.lookup('component:-top-level');
    (0, _internalTestHelpers.runAppend)(component);
    assert.equal(qunitFixture.textContent.trim(), 'Tobias takes teamocil', 'template works');
    (0, _internalTestHelpers.runDestroy)(owner);
  }
  (0, _internalTestHelpers.moduleFor)('ember-templates: bootstrap', class extends _internalTestHelpers.AbstractTestCase {
    constructor() {
      super();
      fixture = document.getElementById('qunit-fixture');
    }
    teardown() {
      (0, _glimmer.setTemplates)({});
      fixture = component = null;
    }
    ['@test template with data-template-name should add a new template to Ember.TEMPLATES'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" data-template-name="funkyTemplate">{{this.firstName}} takes {{this.drug}}</script>';
      checkTemplate('funkyTemplate', assert);
    }
    ['@test template with id instead of data-template-name should add a new template to Ember.TEMPLATES'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" id="funkyTemplate" >{{this.firstName}} takes {{this.drug}}</script>';
      checkTemplate('funkyTemplate', assert);
    }
    ['@test template without data-template-name or id should default to application'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">{{this.firstName}} takes {{this.drug}}</script>';
      checkTemplate('application', assert);
    }

    // Add this test case, only for typeof Handlebars === 'object';
    [(typeof Handlebars === 'object' ? '@test' : '@skip') + " template with type text/x-raw-handlebars should be parsed"](assert) {
      fixture.innerHTML = '<script type="text/x-raw-handlebars" data-template-name="funkyTemplate">{{this.name}}</script>';
      (0, _runloop.run)(() => (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      }));
      let template = (0, _glimmer.getTemplate)('funkyTemplate');
      assert.ok(template, 'template with name funkyTemplate available');

      // This won't even work with Ember templates
      assert.equal(template({
        name: 'Tobias'
      }).trim(), 'Tobias');
    }
    ['@test duplicated default application templates should throw exception'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars">second</script>';
      assert.throws(() => (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      }), /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    }
    ['@test default default application template and id application template present should throw exception'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars" id="application">second</script>';
      assert.throws(() => (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      }), /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    }
    ['@test default application template and data-template-name application template present should throw exception'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars" data-template-name="application">second</script>';
      assert.throws(() => (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      }), /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    }
    ['@test duplicated template id should throw exception'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" id="funkyTemplate">first</script><script type="text/x-handlebars" id="funkyTemplate">second</script>';
      assert.throws(() => (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      }), /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    }
    ['@test duplicated template data-template-name should throw exception'](assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" data-template-name="funkyTemplate">first</script><script type="text/x-handlebars" data-template-name="funkyTemplate">second</script>';
      assert.throws(() => (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      }), /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    }
  });
});
define("ember-template-compiler/tests/system/compile_options_test", ["ember-template-compiler/index", "internal-test-helpers"], function (_index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: default compile options', class extends _internalTestHelpers.AbstractTestCase {
    ['@test default options are a new copy'](assert) {
      assert.notEqual((0, _index.compileOptions)(), (0, _index.compileOptions)());
    }
    ['@test customizeComponentName asserts name is well formed'](assert) {
      let options = (0, _index.compileOptions)({
        moduleName: 'test.js'
      });
      expectAssertion(() => {
        options.customizeComponentName('Foo:Bar');
      }, /You tried to invoke a component named <Foo:Bar \/> in "test.js", but that is not a valid name for a component. Did you mean to use the "::" syntax for nested components\?/);
      assert.ok(options.customizeComponentName('Foo::Bar'));
    }
    ['@test has default AST plugins in resolution mode'](assert) {
      assert.expect(_index.RESOLUTION_MODE_TRANSFORMS.length);
      let plugins = (0, _index.compileOptions)().plugins.ast;
      for (let i = 0; i < _index.RESOLUTION_MODE_TRANSFORMS.length; i++) {
        let plugin = _index.RESOLUTION_MODE_TRANSFORMS[i];
        assert.ok(plugins.indexOf(plugin) > -1, "includes " + plugin);
      }
    }
    ['@test has default AST plugins in strict mode'](assert) {
      assert.expect(_index.STRICT_MODE_TRANSFORMS.length);
      let plugins = (0, _index.compileOptions)({
        strictMode: true
      }).plugins.ast;
      for (let i = 0; i < _index.STRICT_MODE_TRANSFORMS.length; i++) {
        let plugin = _index.STRICT_MODE_TRANSFORMS[i];
        assert.ok(plugins.indexOf(plugin) > -1, "includes " + plugin);
      }
    }
  });
  function customTransform() {
    return {
      name: 'remove-data-test',
      visitor: {
        ElementNode(node) {
          for (let i = 0; i < node.attributes.length; i++) {
            let attribute = node.attributes[i];
            if (attribute.name === 'data-test') {
              node.attributes.splice(i, 1);
            }
          }
        }
      }
    };
  }
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: custom plugins passed to compile', class extends _internalTestHelpers.RenderingTestCase {
    // override so that we can provide custom AST plugins to compile
    compile(templateString) {
      return (0, _index.compile)(templateString, {
        plugins: {
          ast: [customTransform]
        }
      });
    }
  });
});
define("ember-template-compiler/tests/system/dasherize-component-name-test", ["ember-template-compiler/lib/system/dasherize-component-name", "internal-test-helpers"], function (_dasherizeComponentName, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('dasherize-component-name', class extends _internalTestHelpers.AbstractTestCase {
    ['@test names are correctly dasherized'](assert) {
      assert.equal(_dasherizeComponentName.default.get('Foo'), 'foo');
      assert.equal(_dasherizeComponentName.default.get('foo-bar'), 'foo-bar');
      assert.equal(_dasherizeComponentName.default.get('FooBar'), 'foo-bar');
      assert.equal(_dasherizeComponentName.default.get('F3Bar'), 'f3-bar');
      assert.equal(_dasherizeComponentName.default.get('Foo3Bar'), 'foo3-bar');
      assert.equal(_dasherizeComponentName.default.get('Foo3barBaz'), 'foo3bar-baz');
      assert.equal(_dasherizeComponentName.default.get('FooB3ar'), 'foo-b3ar');
      assert.equal(_dasherizeComponentName.default.get('XBlah'), 'x-blah');
      assert.equal(_dasherizeComponentName.default.get('X-Blah'), 'x-blah');
      assert.equal(_dasherizeComponentName.default.get('Foo@BarBaz'), 'foo@bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo@Bar-Baz'), 'foo@bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo::BarBaz'), 'foo/bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo::Bar-Baz'), 'foo/bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo::BarBaz::Bang'), 'foo/bar-baz/bang');
    }
  });
});
define("ember-template-compiler/tests/utils/transform-test-case", ["exports", "@glimmer/compiler", "internal-test-helpers", "ember-template-compiler/index"], function (_exports, _compiler, _internalTestHelpers, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class _default extends _internalTestHelpers.AbstractTestCase {
    assertTransformed(before, after) {
      this.assert.deepEqual(deloc(ast(before)), deloc(ast(after)));
    }
  }
  _exports.default = _default;
  function ast(template) {
    var _options$plugins;
    let program = null;
    function extractProgram() {
      return {
        name: 'extract-program',
        visitor: {
          Program: {
            exit(node) {
              program = clone(node);
            }
          }
        }
      };
    }
    let options = (0, _index.compileOptions)({
      moduleName: '-top-level'
    });
    if ((_options$plugins = options.plugins) != null && _options$plugins.ast) {
      options.plugins.ast.push(extractProgram);
    }
    (0, _compiler.precompile)(template, options);
    return program;
  }
  function clone(node) {
    let out = Object.create(null);
    let keys = Object.keys(node);
    keys.forEach(key => {
      let value = node[key];
      if (value !== null && typeof value === 'object') {
        out[key] = clone(value);
      } else {
        out[key] = value;
      }
    });
    return out;
  }
  function deloc(node) {
    let out = Object.create(null);
    let keys = Object.keys(node);
    keys.forEach(key => {
      let value = node[key];
      if (key === 'loc') {
        return;
      } else if (value !== null && typeof value === 'object') {
        out[key] = deloc(value);
      } else {
        out[key] = value;
      }
    });
    return out;
  }
});
define("ember/tests/application_lifecycle_test", ["internal-test-helpers", "@ember/application", "@ember/routing/route", "@ember/routing/router", "@ember/-internals/glimmer", "@ember/debug"], function (_internalTestHelpers, _application, _route, _router, _glimmer, _debug) {
  "use strict";

  const originalDebug = (0, _debug.getDebugFunction)('debug');
  const noop = function () {};
  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - route hooks', class extends _internalTestHelpers.AutobootApplicationTestCase {
    createApplication() {
      let application = super.createApplication(...arguments);
      this.add('router:main', _router.default.extend({
        location: 'none'
      }));
      return application;
    }
    constructor() {
      (0, _debug.setDebugFunction)('debug', noop);
      super();
      let menuItem = this.menuItem = {};
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication();
        let SettingRoute = _route.default.extend({
          setupController() {
            this.controller.set('selectedMenuItem', menuItem);
          },
          deactivate() {
            this.controller.set('selectedMenuItem', null);
          }
        });
        this.add('route:index', SettingRoute);
        this.add('route:application', SettingRoute);
      });
    }
    teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    }
    get indexController() {
      return this.applicationInstance.lookup('controller:index');
    }
    get applicationController() {
      return this.applicationInstance.lookup('controller:application');
    }
    ["@test Resetting the application allows controller properties to be set when a route deactivates"](assert) {
      let {
        indexController,
        applicationController
      } = this;
      assert.equal(indexController.get('selectedMenuItem'), this.menuItem);
      assert.equal(applicationController.get('selectedMenuItem'), this.menuItem);
      this.application.reset();
      assert.equal(indexController.get('selectedMenuItem'), null);
      assert.equal(applicationController.get('selectedMenuItem'), null);
    }
    ["@test Destroying the application resets the router before the appInstance is destroyed"](assert) {
      let {
        indexController,
        applicationController
      } = this;
      assert.equal(indexController.get('selectedMenuItem'), this.menuItem);
      assert.equal(applicationController.get('selectedMenuItem'), this.menuItem);
      (0, _internalTestHelpers.runTask)(() => {
        this.application.destroy();
      });
      assert.equal(indexController.get('selectedMenuItem'), null);
      assert.equal(applicationController.get('selectedMenuItem'), null);
    }
  });
  (0, _internalTestHelpers.moduleFor)('Application Lifecycle', class extends _internalTestHelpers.AutobootApplicationTestCase {
    createApplication() {
      let application = super.createApplication(...arguments);
      this.add('router:main', _router.default.extend({
        location: 'none'
      }));
      return application;
    }
    ["@test Destroying a route after the router does create an undestroyed 'toplevelView'"](assert) {
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication();
        this.addTemplate('index', "Index!");
        this.addTemplate('application', "Application! {{outlet}}");
      });
      let router = this.applicationInstance.lookup('router:main');
      let route = this.applicationInstance.lookup('route:index');
      (0, _internalTestHelpers.runTask)(() => router.destroy());
      assert.equal(router._toplevelView, null, 'the toplevelView was cleared');
      (0, _internalTestHelpers.runTask)(() => route.destroy());
      assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
      (0, _internalTestHelpers.runTask)(() => this.application.destroy());
      assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
    }
    ["@test initializers can augment an applications customEvents hash"](assert) {
      assert.expect(1);
      let MyApplication = _application.default.extend();
      MyApplication.initializer({
        name: 'customize-things',
        initialize(application) {
          application.customEvents = {
            wowza: 'wowza'
          };
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication({}, MyApplication);
        this.add('component:foo-bar', _glimmer.Component.extend({
          wowza() {
            assert.ok(true, 'fired the event!');
          }
        }));
        this.addTemplate('application', "{{foo-bar}}");
        this.addTemplate('components/foo-bar', "<div id='wowza-thingy'></div>");
      });
      this.$('#wowza-thingy').trigger('wowza');
    }
    ["@test instanceInitializers can augment an the customEvents hash"](assert) {
      assert.expect(1);
      let MyApplication = _application.default.extend();
      MyApplication.instanceInitializer({
        name: 'customize-things',
        initialize(application) {
          application.customEvents = {
            herky: 'jerky'
          };
        }
      });
      (0, _internalTestHelpers.runTask)(() => {
        this.createApplication({}, MyApplication);
        this.add('component:foo-bar', _glimmer.Component.extend({
          jerky() {
            assert.ok(true, 'fired the event!');
          }
        }));
        this.addTemplate('application', "{{foo-bar}}");
        this.addTemplate('components/foo-bar', "<div id='herky-thingy'></div>");
      });
      this.$('#herky-thingy').trigger('herky');
    }
  });
});
define("ember/tests/component_context_test", ["@ember/controller", "@ember/-internals/glimmer", "internal-test-helpers"], function (_controller, _glimmer, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Component Context', class extends _internalTestHelpers.ApplicationTestCase {
    ['@test Components with a block should have the proper content when a template is provided'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}{{this.text}}{{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        }),
        template: "{{this.text}}-{{yield}}"
      });
      return this.visit('/').then(() => {
        let text = (0, _internalTestHelpers.getTextOf)(this.element.querySelector('#wrapper'));
        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    }
    ['@test Components with a block should yield the proper content without a template provided'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}{{this.text}}{{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        })
      });
      return this.visit('/').then(() => {
        let text = (0, _internalTestHelpers.getTextOf)(this.element.querySelector('#wrapper'));
        assert.equal(text, 'outer', 'The component is composed correctly');
      });
    }
    ['@test Components without a block should have the proper content when a template is provided'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        }),
        template: '{{this.text}}'
      });
      return this.visit('/').then(() => {
        let text = (0, _internalTestHelpers.getTextOf)(this.element.querySelector('#wrapper'));
        assert.equal(text, 'inner', 'The component is composed correctly');
      });
    }
    ['@test Components without a block should have the proper content'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement() {
            this.element.innerHTML = 'Some text inserted';
          }
        })
      });
      return this.visit('/').then(() => {
        let text = (0, _internalTestHelpers.getTextOf)(this.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    }
    ['@test properties of a component without a template should not collide with internal structures [DEPRECATED]'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component data=this.foo}}</div>");
      this.add('controller:application', _controller.default.extend({
        text: 'outer',
        foo: 'Some text inserted'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement() {
            this.element.innerHTML = this.get('data');
          }
        })
      });
      return this.visit('/').then(() => {
        let text = (0, _internalTestHelpers.getTextOf)(this.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    }
    ['@test attrs property of a component without a template should not collide with internal structures'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component attrs=this.foo}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer',
        foo: 'Some text inserted'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement() {
            this.element.innerHTML = this.get('attrs.attrs.value');
          }
        })
      });
      return this.visit('/').then(() => {
        let text = (0, _internalTestHelpers.getTextOf)(this.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    }
    ['@test Components trigger actions in the parents context when called from within a block'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}\n          <a href='#' id='fizzbuzz' {{action 'fizzbuzz'}}>Fizzbuzz</a>\n        {{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        actions: {
          fizzbuzz() {
            assert.ok(true, 'action triggered on parent');
          }
        }
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({})
      });
      return this.visit('/').then(() => {
        this.$('#fizzbuzz', '#wrapper').click();
      });
    }
    ['@test Components trigger actions in the components context when called from within its template'](assert) {
      this.addTemplate('application', "\n      <div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        actions: {
          fizzbuzz() {
            assert.ok(false, 'action on the wrong context');
          }
        }
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          actions: {
            fizzbuzz() {
              assert.ok(true, 'action triggered on component');
            }
          }
        }),
        template: "<a href='#' id='fizzbuzz' {{action 'fizzbuzz'}}>Fizzbuzz</a>"
      });
      return this.visit('/').then(() => {
        this.$('#fizzbuzz', '#wrapper').click();
      });
    }
  });
});
define("ember/tests/component_registration_test", ["@ember/application", "@ember/controller", "@ember/-internals/glimmer", "ember-template-compiler", "internal-test-helpers", "@ember/-internals/environment"], function (_application, _controller, _glimmer, _emberTemplateCompiler, _internalTestHelpers, _environment) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Component Registration', class extends _internalTestHelpers.ApplicationTestCase {
    // This is necessary for this.application.instanceInitializer to not leak between tests
    createApplication(options) {
      return super.createApplication(options, _application.default.extend());
    }
    ['@test The helper becomes the body of the component'](assert) {
      if (_environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS) {
        assert.expect(0);
        return;
      }
      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', 'Hello world {{#expand-it}}world{{/expand-it}}');
      return this.visit('/').then(() => {
        this.assertText('Hello world hello world');
        this.assertComponentElement(this.element.firstElementChild, {
          tagName: 'div',
          content: '<p>hello world</p>'
        });
      });
    }
    ['@test The helper becomes the body of the component (ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;)'](assert) {
      if (!_environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS) {
        assert.expect(0);
        return;
      }
      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', 'Hello world {{#expand-it}}world{{/expand-it}}');
      return this.visit('/').then(() => {
        this.assertInnerHTML('Hello world <p>hello world</p>');
        _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = false;
      });
    }
    ['@test If a component is registered, it is used'](assert) {
      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', "Hello world {{#expand-it}}world{{/expand-it}}");
      this.application.instanceInitializer({
        name: 'expand-it-component',
        initialize(applicationInstance) {
          applicationInstance.register('component:expand-it', _glimmer.Component.extend({
            classNames: 'testing123'
          }));
        }
      });
      return this.visit('/').then(() => {
        let text = this.$('div.testing123').text().trim();
        assert.equal(text, 'hello world', 'The component is composed correctly');
      });
    }
    ['@test Late-registered components can be rendered with custom `layout` property'](assert) {
      this.addTemplate('application', "<div id='wrapper'>there goes {{my-hero}}</div>");
      this.application.instanceInitializer({
        name: 'my-hero-component',
        initialize(applicationInstance) {
          applicationInstance.register('component:my-hero', _glimmer.Component.extend({
            classNames: 'testing123',
            layout: (0, _emberTemplateCompiler.compile)('watch him as he GOES')
          }));
        }
      });
      return this.visit('/').then(() => {
        let text = this.$('#wrapper').text().trim();
        assert.equal(text, 'there goes watch him as he GOES', 'The component is composed correctly');
      });
    }
    ['@test Late-registered components can be rendered with template registered on the container'](assert) {
      this.addTemplate('application', "<div id='wrapper'>hello world {{sally-rutherford}}-{{#sally-rutherford}}!!!{{/sally-rutherford}}</div>");
      this.application.instanceInitializer({
        name: 'sally-rutherford-component-template',
        initialize(applicationInstance) {
          applicationInstance.register('template:components/sally-rutherford', (0, _emberTemplateCompiler.compile)('funkytowny{{yield}}'));
        }
      });
      this.application.instanceInitializer({
        name: 'sally-rutherford-component',
        initialize(applicationInstance) {
          applicationInstance.register('component:sally-rutherford', _glimmer.Component);
        }
      });
      return this.visit('/').then(() => {
        let text = this.$('#wrapper').text().trim();
        assert.equal(text, 'hello world funkytowny-funkytowny!!!', 'The component is composed correctly');
      });
    }
    ['@test Late-registered components can be rendered with ONLY the template registered on the container'](assert) {
      this.addTemplate('application', "<div id='wrapper'>hello world {{borf-snorlax}}-{{#borf-snorlax}}!!!{{/borf-snorlax}}</div>");
      this.application.instanceInitializer({
        name: 'borf-snorlax-component-template',
        initialize(applicationInstance) {
          applicationInstance.register('template:components/borf-snorlax', (0, _emberTemplateCompiler.compile)('goodfreakingTIMES{{yield}}'));
        }
      });
      return this.visit('/').then(() => {
        let text = this.$('#wrapper').text().trim();
        assert.equal(text, 'hello world goodfreakingTIMES-goodfreakingTIMES!!!', 'The component is composed correctly');
      });
    }
    ['@test Assigning layoutName to a component should setup the template as a layout'](assert) {
      assert.expect(1);
      this.addTemplate('application', "<div id='wrapper'>{{#my-component}}{{this.text}}{{/my-component}}</div>");
      this.addTemplate('foo-bar-baz', '{{this.text}}-{{yield}}');
      this.application.instanceInitializer({
        name: 'application-controller',
        initialize(applicationInstance) {
          applicationInstance.register('controller:application', _controller.default.extend({
            text: 'outer'
          }));
        }
      });
      this.application.instanceInitializer({
        name: 'my-component-component',
        initialize(applicationInstance) {
          applicationInstance.register('component:my-component', _glimmer.Component.extend({
            text: 'inner',
            layoutName: 'foo-bar-baz'
          }));
        }
      });
      return this.visit('/').then(() => {
        let text = this.$('#wrapper').text().trim();
        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    }
    ['@test Assigning layoutName and layout to a component should use the `layout` value'](assert) {
      assert.expect(1);
      this.addTemplate('application', "<div id='wrapper'>{{#my-component}}{{this.text}}{{/my-component}}</div>");
      this.addTemplate('foo-bar-baz', 'No way!');
      this.application.instanceInitializer({
        name: 'application-controller-layout',
        initialize(applicationInstance) {
          applicationInstance.register('controller:application', _controller.default.extend({
            text: 'outer'
          }));
        }
      });
      this.application.instanceInitializer({
        name: 'my-component-component-layout',
        initialize(applicationInstance) {
          applicationInstance.register('component:my-component', _glimmer.Component.extend({
            text: 'inner',
            layoutName: 'foo-bar-baz',
            layout: (0, _emberTemplateCompiler.compile)('{{this.text}}-{{yield}}')
          }));
        }
      });
      return this.visit('/').then(() => {
        let text = this.$('#wrapper').text().trim();
        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    }
    async ['@test Using name of component that does not exist'](assert) {
      this.addTemplate('application', "<div id='wrapper'>{{#no-good}} {{/no-good}}</div>");
      if (false /* DEBUG */) {
        await assert.rejectsAssertion(this.visit('/'), /Attempted to resolve `no-good`/);
      } else {
        // Rejects with a worse error message in production
        await assert.rejects(this.visit('/'));
      }
    }
  });
});
define("ember/tests/controller_test", ["@ember/controller", "internal-test-helpers", "@ember/-internals/glimmer"], function (_controller, _internalTestHelpers, _glimmer) {
  "use strict";

  /*
   In Ember 1.x, controllers subtly affect things like template scope
   and action targets in exciting and often inscrutable ways. This test
   file contains integration tests that verify the correct behavior of
   the many parts of the system that change and rely upon controller scope,
   from the runtime up to the templating layer.
  */

  (0, _internalTestHelpers.moduleFor)('Template scoping examples', class extends _internalTestHelpers.ApplicationTestCase {
    ['@test Actions inside an outlet go to the associated controller'](assert) {
      this.add('controller:index', _controller.default.extend({
        actions: {
          componentAction() {
            assert.ok(true, 'controller received the action');
          }
        }
      }));
      this.addComponent('component-with-action', {
        ComponentClass: _glimmer.Component.extend({
          classNames: ['component-with-action'],
          click() {
            this.action();
          }
        })
      });
      this.addTemplate('index', '{{component-with-action action=(action "componentAction")}}');
      return this.visit('/').then(() => {
        (0, _internalTestHelpers.runTask)(() => this.$('.component-with-action').click());
      });
    }
  });
});
define("ember/tests/ember-test-helpers-test", ["rsvp", "@ember/application", "@ember/runloop", "ember-template-compiler", "internal-test-helpers"], function (_rsvp, _application, _runloop, _emberTemplateCompiler, _internalTestHelpers) {
  "use strict";

  const {
    module,
    test
  } = QUnit;

  /*
    This test file is intended to emulate what @ember/test-helpers does, and
    should be considered a "smoke test" of when a given change will break
    existing versions of @ember/test-helpers.
  
    This generally means that we will have to represent multiple versions of
    `@ember/test-helpers` here (will make a nested module for each significant
    revision).
  */
  module('@ember/test-helpers emulation test', function () {
    module('v1.6.1', function () {
      let EMPTY_TEMPLATE = (0, _emberTemplateCompiler.compile)('');
      function lookupTemplate(owner, templateFullName) {
        let template = owner.lookup(templateFullName);
        if (typeof template === 'function') return template(owner);
        return template;
      }
      function settled() {
        return new _rsvp.Promise(function (resolve) {
          let watcher = setInterval(() => {
            if ((0, _runloop._getCurrentRunLoop)() || (0, _runloop._hasScheduledTimers)()) {
              return;
            }

            // Stop polling
            clearInterval(watcher);

            // Synchronously resolve the promise
            (0, _runloop.run)(null, resolve);
          }, 10);
        });
      }
      async function setupContext(context) {
        // condensed version of https://github.com/emberjs/ember-test-helpers/blob/v1.6.0/addon-test-support/%40ember/test-helpers/build-owner.ts#L38
        // without support for "custom resolver"
        await context.application.boot();
        context.owner = await context.application.buildInstance().boot();
      }
      function setupRenderingContext(context) {
        let {
          owner
        } = context;
        let OutletView = owner.factoryFor('view:-outlet');
        let environment = owner.lookup('-environment:main');
        let outletTemplateFactory = owner.lookup('template:-outlet');
        let toplevelView = OutletView.create({
          environment,
          template: outletTemplateFactory
        });
        owner.register('-top-level-view:main', {
          create() {
            return toplevelView;
          }
        });

        // initially render a simple empty template
        return render(EMPTY_TEMPLATE, context).then(() => {
          let rootElement = document.querySelector(owner.rootElement);
          (0, _runloop.run)(toplevelView, 'appendTo', rootElement);
          context.element = rootElement;
          return settled();
        });
      }
      let templateId = 0;
      function render(template, context) {
        let {
          owner
        } = context;
        let toplevelView = owner.lookup('-top-level-view:main');
        let OutletTemplate = lookupTemplate(owner, 'template:-outlet');
        templateId += 1;
        let templateFullName = "template:-undertest-" + templateId;
        owner.register(templateFullName, template);
        let outletState = {
          render: {
            owner,
            into: undefined,
            outlet: 'main',
            name: 'application',
            controller: undefined,
            ViewClass: undefined,
            template: OutletTemplate
          },
          outlets: {
            main: {
              render: {
                owner,
                into: undefined,
                outlet: 'main',
                name: 'index',
                controller: context,
                ViewClass: undefined,
                template: lookupTemplate(owner, templateFullName),
                outlets: {}
              },
              outlets: {}
            }
          }
        };
        toplevelView.setOutletState(outletState);
        return settled();
      }
      module('setupRenderingContext', function (hooks) {
        hooks.beforeEach(async function () {
          this.application = _application.default.create({
            rootElement: '#qunit-fixture',
            autoboot: false,
            Resolver: _internalTestHelpers.ModuleBasedTestResolver
          });
          await setupContext(this);
          await setupRenderingContext(this);
        });
        hooks.afterEach(function () {
          (0, _runloop.run)(this.owner, 'destroy');
          (0, _runloop.run)(this.application, 'destroy');
        });
        test('it basically works', async function (assert) {
          await render((0, _emberTemplateCompiler.compile)('Hi!'), this);
          assert.equal(this.element.textContent, 'Hi!');
        });
      });
    });
    module('v1.6.0', function () {
      let EMPTY_TEMPLATE = (0, _emberTemplateCompiler.compile)('');
      function settled() {
        return new _rsvp.Promise(function (resolve) {
          let watcher = setInterval(() => {
            if ((0, _runloop._getCurrentRunLoop)() || (0, _runloop._hasScheduledTimers)()) {
              return;
            }

            // Stop polling
            clearInterval(watcher);

            // Synchronously resolve the promise
            (0, _runloop.run)(null, resolve);
          }, 10);
        });
      }
      async function setupContext(context) {
        // condensed version of https://github.com/emberjs/ember-test-helpers/blob/v1.6.0/addon-test-support/%40ember/test-helpers/build-owner.ts#L38
        // without support for "custom resolver"
        await context.application.boot();
        context.owner = await context.application.buildInstance().boot();
      }
      function setupRenderingContext(context) {
        let {
          owner
        } = context;
        let OutletView = owner.factoryFor('view:-outlet');
        let environment = owner.lookup('-environment:main');
        let outletTemplateFactory = owner.lookup('template:-outlet');
        let toplevelView = OutletView.create({
          environment,
          template: outletTemplateFactory
        });
        owner.register('-top-level-view:main', {
          create() {
            return toplevelView;
          }
        });

        // initially render a simple empty template
        return render(EMPTY_TEMPLATE, context).then(() => {
          let rootElement = document.querySelector(owner.rootElement);
          (0, _runloop.run)(toplevelView, 'appendTo', rootElement);
          context.element = rootElement;
          return settled();
        });
      }
      let templateId = 0;
      function render(template, context) {
        let {
          owner
        } = context;
        let toplevelView = owner.lookup('-top-level-view:main');
        templateId += 1;
        let templateFullName = "template:-undertest-" + templateId;
        owner.register(templateFullName, template);
        let outletState = {
          render: {
            owner,
            into: undefined,
            outlet: 'main',
            name: 'application',
            controller: undefined,
            ViewClass: undefined,
            template: owner.lookup('template:-outlet')
          },
          outlets: {
            main: {
              render: {
                owner,
                into: undefined,
                outlet: 'main',
                name: 'index',
                controller: context,
                ViewClass: undefined,
                template: owner.lookup(templateFullName),
                outlets: {}
              },
              outlets: {}
            }
          }
        };
        toplevelView.setOutletState(outletState);
        return settled();
      }
      module('setupRenderingContext', function (hooks) {
        hooks.beforeEach(async function () {
          expectDeprecation(/The `template` property of `OutletState` should be a `Template` rather than a `TemplateFactory`/);
          this.application = _application.default.create({
            rootElement: '#qunit-fixture',
            autoboot: false,
            Resolver: _internalTestHelpers.ModuleBasedTestResolver
          });
          await setupContext(this);
          await setupRenderingContext(this);
        });
        hooks.afterEach(function () {
          (0, _runloop.run)(this.owner, 'destroy');
          (0, _runloop.run)(this.application, 'destroy');
        });
        test('it basically works', async function (assert) {
          await render((0, _emberTemplateCompiler.compile)('Hi!'), this);
          assert.equal(this.element.textContent, 'Hi!');
        });
      });
    });
  });
});
define("ember/tests/error_handler_test", ["@ember/debug", "@ember/runloop", "@ember/-internals/error-handling", "rsvp", "internal-test-helpers"], function (_debug, _runloop, _errorHandling, _rsvp, _internalTestHelpers) {
  "use strict";

  const HAS_UNHANDLED_REJECTION_HANDLER = ('onunhandledrejection' in window);
  let QUNIT_ON_UNCAUGHT_EXCEPTION = QUnit.onUncaughtException;
  let WINDOW_ONERROR;
  function runThatThrowsSync(message) {
    if (message === void 0) {
      message = 'Error for testing error handling';
    }
    return (0, _runloop.run)(() => {
      throw new Error(message);
    });
  }
  (0, _internalTestHelpers.moduleFor)('error_handler', class extends _internalTestHelpers.AbstractTestCase {
    beforeEach() {
      // capturing this outside of module scope to ensure we grab
      // the test frameworks own window.onerror to reset it
      WINDOW_ONERROR = window.onerror;
    }
    afterEach() {
      (0, _debug.setTesting)(_debug.isTesting);
      window.onerror = WINDOW_ONERROR;
      (0, _errorHandling.setOnerror)(undefined);
      QUnit.onUncaughtException = QUNIT_ON_UNCAUGHT_EXCEPTION;
    }
    ['@test by default there is no onerror - sync run'](assert) {
      assert.strictEqual((0, _errorHandling.getOnerror)(), undefined, 'precond - there should be no Ember.onerror set by default');
      assert.throws(runThatThrowsSync, Error, 'errors thrown sync are catchable');
    }
    ['@test when Ember.onerror (which rethrows) is registered - sync run'](assert) {
      assert.expect(2);
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'onerror called');
        throw error;
      });
      assert.throws(runThatThrowsSync, Error, 'error is thrown');
    }
    ['@test when Ember.onerror (which does not rethrow) is registered - sync run'](assert) {
      assert.expect(2);
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror called');
      });
      runThatThrowsSync();
      assert.ok(true, 'no error was thrown, Ember.onerror can intercept errors');
    }
    ['@test does not swallow exceptions by default (Ember.testing = true, no Ember.onerror) - sync run'](assert) {
      (0, _debug.setTesting)(true);
      let error = new Error('the error');
      assert.throws(() => {
        (0, _runloop.run)(() => {
          throw error;
        });
      }, error);
    }
    ['@test does not swallow exceptions by default (Ember.testing = false, no Ember.onerror) - sync run'](assert) {
      (0, _debug.setTesting)(false);
      let error = new Error('the error');
      assert.throws(() => {
        (0, _runloop.run)(() => {
          throw error;
        });
      }, error);
    }
    ['@test does not swallow exceptions (Ember.testing = false, Ember.onerror which rethrows) - sync run'](assert) {
      assert.expect(2);
      (0, _debug.setTesting)(false);
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'Ember.onerror was called');
        throw error;
      });
      let error = new Error('the error');
      assert.throws(() => {
        (0, _runloop.run)(() => {
          throw error;
        });
      }, error);
    }
    ['@test Ember.onerror can intercept errors (aka swallow) by not rethrowing (Ember.testing = false) - sync run'](assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'Ember.onerror was called');
      });
      let error = new Error('the error');
      try {
        (0, _runloop.run)(() => {
          throw error;
        });
      } catch (e) {
        assert.notOk(true, 'Ember.onerror that does not rethrow is intentionally swallowing errors, try / catch wrapping does not see error');
      }
    }
    ['@test does not swallow exceptions by default (Ember.testing = true, no Ember.onerror) - async run'](assert) {
      let done = assert.async();
      let caughtByWindowOnerror;
      (0, _debug.setTesting)(true);
      window.onerror = function (message) {
        caughtByWindowOnerror = message;
        // prevent "bubbling" and therefore failing the test
        return true;
      };
      (0, _runloop.later)(() => {
        throw new Error('the error');
      }, 10);
      setTimeout(() => {
        assert.pushResult({
          result: /the error/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    }
    ['@test does not swallow exceptions by default (Ember.testing = false, no Ember.onerror) - async run'](assert) {
      let done = assert.async();
      let caughtByWindowOnerror;
      (0, _debug.setTesting)(false);
      window.onerror = function (message) {
        caughtByWindowOnerror = message;
        // prevent "bubbling" and therefore failing the test
        return true;
      };
      (0, _runloop.later)(() => {
        throw new Error('the error');
      }, 10);
      setTimeout(() => {
        assert.pushResult({
          result: /the error/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    }
    ['@test Ember.onerror can intercept errors (aka swallow) by not rethrowing (Ember.testing = false) - async run'](assert) {
      let done = assert.async();
      (0, _debug.setTesting)(false);
      window.onerror = function () {
        assert.notOk(true, 'window.onerror is never invoked when Ember.onerror intentionally swallows errors');
        // prevent "bubbling" and therefore failing the test
        return true;
      };
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called with the error');
      });
      (0, _runloop.later)(() => {
        throw thrown;
      }, 10);
      setTimeout(done, 20);
    }
    ["@test errors in promise constructor when Ember.onerror which does not rethrow is present - rsvp"](assert) {
      assert.expect(1);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise constructor when Ember.onerror which does rethrow is present - rsvp"](assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }
      assert.expect(2);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      // prevent QUnit handler from failing test
      QUnit.onUncaughtException = () => {};
      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };
      new _rsvp.default.Promise(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise constructor when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"](assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise constructor when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"](assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }
      assert.expect(2);
      (0, _debug.setTesting)(false);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      // prevent QUnit handler from failing test
      QUnit.onUncaughtException = () => {};
      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };
      new _rsvp.default.Promise(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise .then callback when Ember.onerror which does not rethrow is present - rsvp"](assert) {
      assert.expect(1);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      _rsvp.default.resolve().then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise .then callback when Ember.onerror which does rethrow is present - rsvp"](assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }
      assert.expect(2);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      // prevent QUnit handler from failing test
      QUnit.onUncaughtException = () => {};
      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };
      _rsvp.default.resolve().then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise .then callback when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"](assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      _rsvp.default.resolve().then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in promise .then callback when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"](assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }
      assert.expect(2);
      (0, _debug.setTesting)(false);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      // prevent QUnit handler from failing test
      QUnit.onUncaughtException = () => {};
      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };
      _rsvp.default.resolve().then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 10));
    }
    ["@test errors in async promise .then callback when Ember.onerror which does not rethrow is present - rsvp"](assert) {
      assert.expect(1);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(resolve => setTimeout(resolve, 10)).then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 20));
    }
    ["@test errors in async promise .then callback when Ember.onerror which does rethrow is present - rsvp"](assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }
      assert.expect(2);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      // prevent QUnit handler from failing test
      QUnit.onUncaughtException = () => {};
      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };
      new _rsvp.default.Promise(resolve => setTimeout(resolve, 10)).then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 20));
    }
    ["@test errors in async promise .then callback when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"](assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(resolve => setTimeout(resolve, 10)).then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 20));
    }
    ["@test errors in async promise .then callback when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"](assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }
      assert.expect(2);
      (0, _debug.setTesting)(false);
      let thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      // prevent QUnit handler from failing test
      QUnit.onUncaughtException = () => {};
      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };
      new _rsvp.default.Promise(resolve => setTimeout(resolve, 10)).then(() => {
        throw thrown;
      });

      // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed
      return new _rsvp.default.Promise(resolve => setTimeout(resolve, 20));
    }
  });
});
define("ember/tests/homepage_example_test", ["@ember/routing/route", "@ember/object", "@ember/array", "internal-test-helpers"], function (_route, _object, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('The example renders correctly', class extends _internalTestHelpers.ApplicationTestCase {
    async ['@test Render index template into application outlet'](assert) {
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', '<h1>People</h1><ul>{{#each @model as |person|}}<li>Hello, <b>{{person.fullName}}</b>!</li>{{/each}}</ul>');
      let Person = _object.default.extend({
        firstName: null,
        lastName: null,
        fullName: (0, _object.computed)('firstName', 'lastName', function () {
          return this.get('firstName') + " " + this.get('lastName');
        })
      });
      this.add('route:index', _route.default.extend({
        model() {
          return (0, _array.A)([Person.create({
            firstName: 'Tom',
            lastName: 'Dale'
          }), Person.create({
            firstName: 'Yehuda',
            lastName: 'Katz'
          })]);
        }
      }));
      await this.visit('/');
      let $ = this.$();
      assert.equal($.findAll('h1').text(), 'People');
      assert.equal($.findAll('li').length, 2);
      assert.equal($.findAll('li:nth-of-type(1)').text(), 'Hello, Tom Dale!');
      assert.equal($.findAll('li:nth-of-type(2)').text(), 'Hello, Yehuda Katz!');
    }
  });
});
define("ember/tests/integration/multiple-app-test", ["internal-test-helpers", "@ember/application", "@ember/-internals/glimmer", "@ember/-internals/owner", "rsvp"], function (_internalTestHelpers, _application, _glimmer, _owner, _rsvp) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View Integration', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      document.getElementById('qunit-fixture').innerHTML = "\n      <div id=\"one\"></div>\n      <div id=\"two\"></div>\n    ";
      super();
      (0, _internalTestHelpers.runTask)(() => {
        this.createSecondApplication();
      });
    }
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        rootElement: '#one',
        router: null
      });
    }
    createSecondApplication(options) {
      let {
        applicationOptions
      } = this;
      let secondApplicationOptions = {
        rootElement: '#two'
      };
      let myOptions = Object.assign(applicationOptions, secondApplicationOptions, options);
      this.secondApp = _application.default.create(myOptions);
      this.secondResolver = this.secondApp.__registry__.resolver;
      return this.secondApp;
    }
    teardown() {
      super.teardown();
      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(() => {
          this.secondApp.destroy();
        });
      }
    }
    addFactoriesToResolver(actions, resolver) {
      resolver.add('component:special-button', _glimmer.Component.extend({
        actions: {
          doStuff() {
            let rootElement = (0, _owner.getOwner)(this).application.rootElement;
            actions.push(rootElement);
          }
        }
      }));
      resolver.add('template:index', this.compile("\n        <h1>Node 1</h1>{{special-button}}\n      ", {
        moduleName: 'my-app/templates/index.hbs'
      }));
      resolver.add('template:components/special-button', this.compile("\n        <button class='do-stuff' {{action 'doStuff'}}>Button</button>\n      ", {
        moduleName: 'my-app/templates/components/special-button.hbs'
      }));
    }
    ["@test booting multiple applications can properly handle events"](assert) {
      let actions = [];
      this.addFactoriesToResolver(actions, this.resolver);
      this.addFactoriesToResolver(actions, this.secondResolver);
      return (0, _rsvp.resolve)().then(() => this.application.visit('/')).then(() => this.secondApp.visit('/')).then(() => {
        document.querySelector('#two .do-stuff').click();
        document.querySelector('#one .do-stuff').click();
        assert.deepEqual(actions, ['#two', '#one']);
      });
    }
  });
});
define("ember/tests/production_build_test", ["@ember/debug", "internal-test-helpers"], function (_debug, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('production builds', class extends _internalTestHelpers.AbstractTestCase {
    ['@test assert does not throw in production builds'](assert) {
      if (!false /* DEBUG */) {
        assert.expect(1);
        try {
          (false && !(false) && (0, _debug.assert)('Should not throw'));
          assert.ok(true, 'Ember.assert did not throw');
        } catch (e) {
          assert.ok(false, "Expected assert not to throw but it did: " + e.message);
        }
      } else {
        assert.expect(0);
      }
    }
    ['@test runInDebug does not run the callback in production builds'](assert) {
      if (!false /* DEBUG */) {
        let fired = false;
        (0, _debug.runInDebug)(() => fired = true);
        assert.equal(fired, false, 'runInDebug callback should not be ran');
      } else {
        assert.expect(0);
      }
    }
  });
});
define("ember/tests/reexports_test", ["ember/index", "@ember/canary-features", "internal-test-helpers", "@ember/application", "@ember/application/instance", "@ember/application/namespace", "@ember/array", "@ember/array/mutable", "@ember/array/proxy", "@ember/component", "@ember/component/helper", "@ember/component/template-only", "@ember/controller", "@ember/debug", "@ember/debug/container-debug-adapter", "@ember/debug/data-adapter", "@ember/destroyable", "@ember/engine", "@ember/engine/instance", "@ember/enumerable", "@ember/instrumentation", "@ember/modifier", "@ember/helper", "@ember/object", "@ember/object/compat", "@ember/object/computed", "@ember/object/core", "@ember/object/evented", "@ember/object/events", "@ember/object/internals", "@ember/object/mixin", "@ember/object/observable", "@ember/object/observers", "@ember/object/promise-proxy-mixin", "@ember/object/proxy", "@ember/routing/hash-location", "@ember/routing/history-location", "@ember/routing/none-location", "@ember/routing/route", "@ember/routing/router", "@ember/runloop", "@ember/service", "@ember/template", "@ember/template-compilation", "@ember/template-factory", "@ember/test", "@ember/test/adapter", "@ember/utils", "@ember/version", "@glimmer/tracking", "@glimmer/tracking/primitives/cache", "@ember/-internals/environment", "@ember/-internals/utils", "@ember/-internals/container", "@ember/-internals/metal", "@ember/-internals/error-handling", "@ember/-internals/meta", "@ember/-internals/views", "@ember/-internals/glimmer", "@ember/-internals/runtime", "@ember/-internals/routing", "backburner.js", "rsvp"], function (_index, _canaryFeatures, _internalTestHelpers, test0, test1, test2, test3, test4, test5, test7, test8, test9, test10, test11, test12, test13, test14, test15, test16, test17, test18, test19, test20, test21, test22, test23, test24, test25, test26, test27, test28, test29, test30, test31, test32, test33, test34, test35, test36, test37, test38, test39, test40, test41, test42, test43, test44, test45, test46, test47, test48, test49, test50, test51, test52, test53, test54, test55, test56, test57, test58, test59, test60) {
  "use strict";

  var test6 = _canaryFeatures;
  (0, _internalTestHelpers.moduleFor)('ember reexports', class extends _internalTestHelpers.AbstractTestCase {
    ["@test Ember exports correctly"](assert) {
      allExports.forEach(reexport => {
        let [path, moduleId, exportName, mod] = reexport;

        // default path === exportName if none present
        if (!exportName) {
          exportName = path;
        }
        (0, _internalTestHelpers.confirmExport)(_index.default, assert, path, moduleId, exportName, mod);
      });
    }
    '@test Ember.FEATURES is exported'(assert) {
      if (Object.keys(_canaryFeatures.FEATURES).length === 0) {
        assert.expect(0);
      }
      for (let feature in _canaryFeatures.FEATURES) {
        assert.equal(_index.default.FEATURES[feature], _canaryFeatures.FEATURES[feature], 'Ember.FEATURES contains ${feature} with correct value');
      }
    }
  });
  let allExports = [['Application', '@ember/application', 'default', test0], ['getOwner', '@ember/application', 'getOwner', test0], ['onLoad', '@ember/application', 'onLoad', test0], ['runLoadHooks', '@ember/application', 'runLoadHooks', test0], ['setOwner', '@ember/application', 'setOwner', test0], ['ApplicationInstance', '@ember/application/instance', 'default', test1], ['Namespace', '@ember/application/namespace', 'default', test2], ['Array', '@ember/array', 'default', test3], ['A', '@ember/array', 'A', test3], ['NativeArray', '@ember/array', 'NativeArray', test3], ['isArray', '@ember/array', 'isArray', test3], ['makeArray', '@ember/array', 'makeArray', test3], ['MutableArray', '@ember/array/mutable', 'default', test4], ['ArrayProxy', '@ember/array/proxy', 'default', test5], ['FEATURES.isEnabled', '@ember/canary-features', 'isEnabled', test6], ['Component', '@ember/component', 'default', test7], ['_componentManagerCapabilities', '@ember/component', 'capabilities', test7], ['_getComponentTemplate', '@ember/component', 'getComponentTemplate', test7], ['_setComponentManager', '@ember/component', 'setComponentManager', test7], ['_setComponentTemplate', '@ember/component', 'setComponentTemplate', test7], ['Helper', '@ember/component/helper', 'default', test8], ['Helper.helper', '@ember/component/helper', 'helper', test8], ['_templateOnlyComponent', '@ember/component/template-only', 'default', test9], ['Controller', '@ember/controller', 'default', test10], ['ControllerMixin', '@ember/controller', 'ControllerMixin', test10], ['inject.controller', '@ember/controller', 'inject', test10], ['deprecateFunc', '@ember/debug', 'deprecateFunc', test11], ['deprecate', '@ember/debug', 'deprecate', test11], ['assert', '@ember/debug', 'assert', test11], ['debug', '@ember/debug', 'debug', test11], ['inspect', '@ember/debug', 'inspect', test11], ['Debug.registerDeprecationHandler', '@ember/debug', 'registerDeprecationHandler', test11], ['Debug.registerWarnHandler', '@ember/debug', 'registerWarnHandler', test11], ['runInDebug', '@ember/debug', 'runInDebug', test11], ['warn', '@ember/debug', 'warn', test11], ['testing', '@ember/debug', {
    get: 'isTesting',
    set: 'setTesting'
  }, test11], ['_captureRenderTree', '@ember/debug', 'captureRenderTree', test11], ['ContainerDebugAdapter', '@ember/debug/container-debug-adapter', 'default', test12], ['DataAdapter', '@ember/debug/data-adapter', 'default', test13], false /* DEBUG */ ? ['_assertDestroyablesDestroyed', '@ember/destroyable', 'assertDestroyablesDestroyed', test14] : null, ['_associateDestroyableChild', '@ember/destroyable', 'associateDestroyableChild', test14], ['destroy', '@ember/destroyable', 'destroy', test14], false /* DEBUG */ ? ['_enableDestroyableTracking', '@ember/destroyable', 'enableDestroyableTracking', test14] : null, ['_isDestroyed', '@ember/destroyable', 'isDestroyed', test14], ['_isDestroying', '@ember/destroyable', 'isDestroying', test14], ['_registerDestructor', '@ember/destroyable', 'registerDestructor', test14], ['_unregisterDestructor', '@ember/destroyable', 'unregisterDestructor', test14], ['Engine', '@ember/engine', 'default', test15], ['EngineInstance', '@ember/engine/instance', 'default', test16], ['Enumerable', '@ember/enumerable', 'default', test17], ['instrument', '@ember/instrumentation', 'instrument', test18], ['subscribe', '@ember/instrumentation', 'subscribe', test18], ['Instrumentation.instrument', '@ember/instrumentation', 'instrument', test18], ['Instrumentation.reset', '@ember/instrumentation', 'reset', test18], ['Instrumentation.subscribe', '@ember/instrumentation', 'subscribe', test18], ['Instrumentation.unsubscribe', '@ember/instrumentation', 'unsubscribe', test18], ['_modifierManagerCapabilities', '@ember/modifier', 'capabilities', test19], ['_setModifierManager', '@ember/modifier', 'setModifierManager', test19], ['_on', '@ember/modifier', 'on', test19], ['_helperManagerCapabilities', '@ember/helper', 'capabilities', test20], ['_setHelperManager', '@ember/helper', 'setHelperManager', test20], ['_invokeHelper', '@ember/helper', 'invokeHelper', test20], ['_fn', '@ember/helper', 'fn', test20], ['_array', '@ember/helper', 'array', test20], ['_hash', '@ember/helper', 'hash', test20], ['_get', '@ember/helper', 'get', test20], ['_concat', '@ember/helper', 'concat', test20], ['Object', '@ember/object', 'default', test21], ['_action', '@ember/object', 'action', test21], ['computed', '@ember/object', 'computed', test21], ['defineProperty', '@ember/object', 'defineProperty', test21], ['get', '@ember/object', 'get', test21], ['getProperties', '@ember/object', 'getProperties', test21], ['notifyPropertyChange', '@ember/object', 'notifyPropertyChange', test21], ['observer', '@ember/object', 'observer', test21], ['set', '@ember/object', 'set', test21], ['setProperties', '@ember/object', 'setProperties', test21], ['trySet', '@ember/object', 'trySet', test21], ['_dependentKeyCompat', '@ember/object/compat', 'dependentKeyCompat', test22], ['ComputedProperty', '@ember/object/computed', 'default', test23], ['expandProperties', '@ember/object/computed', 'expandProperties', test23], ['CoreObject', '@ember/object/core', 'default', test24], ['Evented', '@ember/object/evented', 'default', test25], ['on', '@ember/object/evented', 'on', test25], ['addListener', '@ember/object/events', 'addListener', test26], ['removeListener', '@ember/object/events', 'removeListener', test26], ['sendEvent', '@ember/object/events', 'sendEvent', test26], ['cacheFor', '@ember/object/internals', 'cacheFor', test27], ['guidFor', '@ember/object/internals', 'guidFor', test27], ['Mixin', '@ember/object/mixin', 'default', test28], ['Observable', '@ember/object/observable', 'default', test29], ['addObserver', '@ember/object/observers', 'addObserver', test30], ['removeObserver', '@ember/object/observers', 'removeObserver', test30], ['PromiseProxyMixin', '@ember/object/promise-proxy-mixin', 'default', test31], ['ObjectProxy', '@ember/object/proxy', 'default', test32], ['HashLocation', '@ember/routing/hash-location', 'default', test33], ['HistoryLocation', '@ember/routing/history-location', 'default', test34], ['NoneLocation', '@ember/routing/none-location', 'default', test35], ['Route', '@ember/routing/route', 'default', test36], ['Router', '@ember/routing/router', 'default', test37], ['run', '@ember/runloop', 'run', test38], ['Service', '@ember/service', 'default', test39], ['inject.service', '@ember/service', 'service', test39], [null, '@ember/template', 'htmlSafe', test40], [null, '@ember/template', 'isHTMLSafe', test40], ['HTMLBars.compile', '@ember/template-compilation', 'compileTemplate', test41], ['Handlebars.template', '@ember/template-factory', 'createTemplateFactory', test42], ['HTMLBars.template', '@ember/template-factory', 'createTemplateFactory', test42], ['Test.registerAsyncHelper', '@ember/test', 'registerAsyncHelper', test43], ['Test.registerHelper', '@ember/test', 'registerHelper', test43], ['Test.registerWaiter', '@ember/test', 'registerWaiter', test43], ['Test.unregisterHelper', '@ember/test', 'unregisterHelper', test43], ['Test.unregisterWaiter', '@ember/test', 'unregisterWaiter', test43], ['Test.Adapter', '@ember/test/adapter', 'default', test44], ['compare', '@ember/utils', 'compare', test45], ['isBlank', '@ember/utils', 'isBlank', test45], ['isEmpty', '@ember/utils', 'isEmpty', test45], ['isEqual', '@ember/utils', 'isEqual', test45], ['isNone', '@ember/utils', 'isNone', test45], ['isPresent', '@ember/utils', 'isPresent', test45], ['typeOf', '@ember/utils', 'typeOf', test45], ['VERSION', '@ember/version', 'VERSION', test46], ['_tracked', '@glimmer/tracking', 'tracked', test47], ['_createCache', '@glimmer/tracking/primitives/cache', 'createCache', test48], ['_cacheGetValue', '@glimmer/tracking/primitives/cache', 'getValue', test48], ['_cacheIsConst', '@glimmer/tracking/primitives/cache', 'isConst', test48], ['ENV', '@ember/-internals/environment', {
    get: 'getENV'
  }, test49], ['lookup', '@ember/-internals/environment', {
    get: 'getLookup',
    set: 'setLookup'
  }, test49], ['GUID_KEY', '@ember/-internals/utils', null, test50], ['uuid', '@ember/-internals/utils', null, test50], ['generateGuid', '@ember/-internals/utils', null, test50], ['canInvoke', '@ember/-internals/utils', null, test50], ['wrap', '@ember/-internals/utils', null, test50], ['_Cache', '@ember/-internals/utils', 'Cache', test50], ['Registry', '@ember/-internals/container', 'Registry', test51], ['Container', '@ember/-internals/container', 'Container', test51], ['_descriptor', '@ember/-internals/metal', 'nativeDescDecorator', test52], ['_setClassicDecorator', '@ember/-internals/metal', 'setClassicDecorator', test52], ['_getPath', '@ember/-internals/metal', null, test52], ['hasListeners', '@ember/-internals/metal', null, test52], ['beginPropertyChanges', '@ember/-internals/metal', null, test52], ['endPropertyChanges', '@ember/-internals/metal', null, test52], ['changeProperties', '@ember/-internals/metal', null, test52], ['libraries', '@ember/-internals/metal', null, test52], ['BOOTED', '@ember/-internals/metal', {
    get: 'isNamespaceSearchDisabled',
    set: 'setNamespaceSearchDisabled'
  }, test52], ['onerror', '@ember/-internals/error-handling', {
    get: 'getOnerror',
    set: 'setOnerror'
  }, test53], ['meta', '@ember/-internals/meta', null, test54], ['ViewUtils.isSimpleClick', '@ember/-internals/views', 'isSimpleClick', test55], ['ViewUtils.getElementView', '@ember/-internals/views', 'getElementView', test55], ['ViewUtils.getViewElement', '@ember/-internals/views', 'getViewElement', test55], ['ViewUtils.getViewBounds', '@ember/-internals/views', 'getViewBounds', test55], ['ViewUtils.getViewClientRects', '@ember/-internals/views', 'getViewClientRects', test55], ['ViewUtils.getViewBoundingClientRect', '@ember/-internals/views', 'getViewBoundingClientRect', test55], ['ViewUtils.getRootViews', '@ember/-internals/views', 'getRootViews', test55], ['ViewUtils.getChildViews', '@ember/-internals/views', 'getChildViews', test55], ['ViewUtils.isSerializationFirstNode', '@ember/-internals/glimmer', 'isSerializationFirstNode', test56], ['ComponentLookup', '@ember/-internals/views', null, test55], ['EventDispatcher', '@ember/-internals/views', null, test55], ['TEMPLATES', '@ember/-internals/glimmer', {
    get: 'getTemplates',
    set: 'setTemplates'
  }, test56], ['Handlebars.Utils.escapeExpression', '@ember/-internals/glimmer', 'escapeExpression', test56], ['_Input', '@ember/-internals/glimmer', 'Input', test56], ['_RegistryProxyMixin', '@ember/-internals/runtime', 'RegistryProxyMixin', test57], ['_ContainerProxyMixin', '@ember/-internals/runtime', 'ContainerProxyMixin', test57], ['Comparable', '@ember/-internals/runtime', null, test57], ['ActionHandler', '@ember/-internals/runtime', null, test57], ['MutableEnumerable', '@ember/-internals/runtime', null, test57], ['_ProxyMixin', '@ember/-internals/runtime', null, test57], ['controllerFor', '@ember/-internals/routing', null, test58], ['generateControllerFactory', '@ember/-internals/routing', null, test58], ['generateController', '@ember/-internals/routing', null, test58], ['RouterDSL', '@ember/-internals/routing', null, test58], ['_Backburner', 'backburner.js', 'default', test59], [null, 'rsvp', 'default', test60], [null, 'rsvp', 'Promise', test60], [null, 'rsvp', 'all', test60], [null, 'rsvp', 'allSettled', test60], [null, 'rsvp', 'defer', test60], [null, 'rsvp', 'denodeify', test60], [null, 'rsvp', 'filter', test60], [null, 'rsvp', 'hash', test60], [null, 'rsvp', 'hashSettled', test60], [null, 'rsvp', 'map', test60], [null, 'rsvp', 'off', test60], [null, 'rsvp', 'on', test60], [null, 'rsvp', 'race', test60], [null, 'rsvp', 'reject', test60], [null, 'rsvp', 'resolve', test60]].filter(Boolean);
});
define("ember/tests/routing/decoupled_basic_test", ["@ember/-internals/owner", "rsvp", "ember-template-compiler", "@ember/routing/route", "@ember/routing/none-location", "@ember/routing/history-location", "@ember/controller", "@ember/object", "internal-test-helpers", "@ember/runloop", "@ember/-internals/metal", "@ember/object/mixin", "@ember/service", "@ember/engine", "router_js"], function (_owner, _rsvp, _emberTemplateCompiler, _route, _noneLocation, _historyLocation, _controller, _object, _internalTestHelpers, _runloop, _metal, _mixin, _service, _engine, _router_js) {
  "use strict";

  /* eslint-disable no-console */

  let originalConsoleError;
  function handleURLRejectsWith(context, assert, path, expectedReason) {
    return context.visit(path).then(() => {
      assert.ok(false, 'expected handleURLing: `' + path + '` to fail');
    }).catch(reason => {
      assert.equal(reason.message, expectedReason);
    });
  }
  (0, _internalTestHelpers.moduleFor)('Basic Routing - Decoupled from global resolver', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.addTemplate('home', '<h3 class="hours">Hours</h3>');
      this.addTemplate('camelot', '<section id="camelot"><h3>Is a silly place</h3></section>');
      this.addTemplate('homepage', '<h3 id="troll">Megatroll</h3><p>{{this.name}}</p>');
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      originalConsoleError = console.error;
    }
    teardown() {
      super.teardown();
      console.error = originalConsoleError;
    }
    handleURLAborts(assert, path) {
      (0, _runloop.run)(() => {
        let router = this.applicationInstance.lookup('router:main');
        router.handleURL(path).then(function () {
          assert.ok(false, 'url: `' + path + '` was NOT to be handled');
        }, function (reason) {
          assert.ok(reason && reason.message === 'TransitionAborted', 'url: `' + path + '` was to be aborted');
        });
      });
    }
    async ['@test warn on URLs not included in the route set'](assert) {
      await this.visit('/');
      await assert.rejects(this.visit('/what-is-this-i-dont-even'), /\/what-is-this-i-dont-even/);
    }
    ['@test The Homepage'](assert) {
      return this.visit('/').then(() => {
        assert.equal(this.appRouter.currentPath, 'home', 'currently on the home route');
        let text = this.$('.hours').text();
        assert.equal(text, 'Hours', 'the home template was rendered');
      });
    }
    ["@test The Homepage and the Camelot page with multiple Router.map calls"](assert) {
      this.router.map(function () {
        this.route('camelot', {
          path: '/camelot'
        });
      });
      return this.visit('/camelot').then(() => {
        assert.equal(this.appRouter.currentPath, 'camelot');
        let text = this.$('#camelot').text();
        assert.equal(text, 'Is a silly place', 'the camelot template was rendered');
        return this.visit('/');
      }).then(() => {
        assert.equal(this.appRouter.currentPath, 'home');
        let text = this.$('.hours').text();
        assert.equal(text, 'Hours', 'the home template was rendered');
      });
    }
    ['@test The Special Page returning a promise puts the app into a loading state until the promise is resolved']() {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      let menuItem, resolve;
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          menuItem = MenuItem.create({
            id: id
          });
          return new _rsvp.default.Promise(function (res) {
            resolve = res;
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      let SpecialRoute = class extends _route.default {
        model(_ref) {
          let {
            menu_item_id
          } = _ref;
          return MenuItem.find(menu_item_id);
        }
      };
      this.add('route:special', SpecialRoute);
      this.addTemplate('special', '<p>{{@model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      let promise;
      ignoreDeprecation(() => {
        let visited = (0, _internalTestHelpers.runTask)(() => this.visit('/specials/1'));
        this.assertText('LOADING!', 'The app is in the loading state');
        resolve(menuItem);
        promise = visited.then(() => {
          this.assertText('1', 'The app is now in the specials state');
        });
      });
      return promise;
    }
    ["@test The loading state doesn't get entered for promises that resolve on the same run loop"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          return {
            id: id
          };
        }
      });
      this.add('model:menu_item', MenuItem);
      let SpecialRoute = class extends _route.default {
        model(_ref2) {
          let {
            menu_item_id
          } = _ref2;
          return MenuItem.find(menu_item_id);
        }
      };
      this.add('route:special', SpecialRoute);
      this.add('route:loading', _route.default.extend({
        enter() {
          assert.ok(false, "LoadingRoute shouldn't have been entered.");
        }
      }));
      this.addTemplate('special', '<p>{{@model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      return this.visit('/specials/1').then(() => {
        let text = this.$('p').text();
        assert.equal(text, '1', 'The app is now in the specials state');
      });
    }
    ["@test The Special page returning an error invokes SpecialRoute's error handler"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      let menuItem, promise, resolve;
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          menuItem = MenuItem.create({
            id: id
          });
          promise = new _rsvp.default.Promise(res => resolve = res);
          return promise;
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:special', _route.default.extend({
        setup() {
          throw new Error('Setup error');
        },
        actions: {
          error(reason) {
            assert.equal(reason.message, 'Setup error', 'SpecialRoute#error received the error thrown from setup');
            return true;
          }
        }
      }));
      ignoreDeprecation(() => {
        (0, _internalTestHelpers.runTask)(() => handleURLRejectsWith(this, assert, 'specials/1', 'Setup error'));
      });
      resolve(menuItem);
    }
    ["@test ApplicationRoute's default error handler can be overridden"](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      let menuItem, resolve;
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          menuItem = MenuItem.create({
            id: id
          });
          return new _rsvp.default.Promise(res => resolve = res);
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:application', _route.default.extend({
        actions: {
          error(reason) {
            assert.equal(reason.message, 'Setup error', 'error was correctly passed to custom ApplicationRoute handler');
            return true;
          }
        }
      }));
      this.add('route:special', _route.default.extend({
        model(_ref3) {
          let {
            menu_item_id
          } = _ref3;
          return MenuItem.find(menu_item_id);
        },
        setup() {
          throw new Error('Setup error');
        }
      }));
      let promise = (0, _internalTestHelpers.runTask)(() => handleURLRejectsWith(this, assert, '/specials/1', 'Setup error'));
      resolve(menuItem);
      return promise;
    }
    async ['@test Events are triggered on the controller if a matching action name is implemented'](assert) {
      let done = assert.async();
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      let model = {
        name: 'Tom Dale'
      };
      let stateIsNotCalled = true;
      this.add('route:home', _route.default.extend({
        model() {
          return model;
        },
        actions: {
          showStuff() {
            stateIsNotCalled = false;
          }
        }
      }));
      this.addTemplate('home', '<a {{action "showStuff" @model}}>{{this.name}}</a>');
      this.add('controller:home', _controller.default.extend({
        actions: {
          showStuff(context) {
            assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
            assert.deepEqual(context, {
              name: 'Tom Dale'
            }, 'an event with context is passed');
            done();
          }
        }
      }));
      await this.visit('/');
      document.getElementById('qunit-fixture').querySelector('a').click();
    }
    async ['@test Events are triggered on the current state when defined in `actions` object'](assert) {
      let done = assert.async();
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      let model = {
        name: 'Tom Dale'
      };
      let HomeRoute = _route.default.extend({
        model() {
          return model;
        },
        actions: {
          showStuff(obj) {
            assert.ok(this instanceof HomeRoute, 'the handler is an App.HomeRoute');
            assert.deepEqual(Object.assign({}, obj), {
              name: 'Tom Dale'
            }, 'the context is correct');
            done();
          }
        }
      });
      this.add('route:home', HomeRoute);
      this.addTemplate('home', '<a {{action "showStuff" @model}}>{{@model.name}}</a>');
      await this.visit('/');
      document.getElementById('qunit-fixture').querySelector('a').click();
    }
    async ['@test Events defined in `actions` object are triggered on the current state when routes are nested'](assert) {
      let done = assert.async();
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      let model = {
        name: 'Tom Dale'
      };
      let RootRoute = _route.default.extend({
        actions: {
          showStuff(obj) {
            assert.ok(this instanceof RootRoute, 'the handler is an App.HomeRoute');
            assert.deepEqual(Object.assign({}, obj), {
              name: 'Tom Dale'
            }, 'the context is correct');
            done();
          }
        }
      });
      this.add('route:root', RootRoute);
      this.add('route:root.index', _route.default.extend({
        model() {
          return model;
        }
      }));
      this.addTemplate('root.index', '<a {{action "showStuff" @model}}>{{@model.name}}</a>');
      await this.visit('/');
      document.getElementById('qunit-fixture').querySelector('a').click();
    }
    ['@test Events can be handled by inherited event handlers'](assert) {
      assert.expect(4);
      let SuperRoute = _route.default.extend({
        actions: {
          foo() {
            assert.ok(true, 'foo');
          },
          bar(msg) {
            assert.equal(msg, 'HELLO', 'bar hander in super route');
          }
        }
      });
      let RouteMixin = _mixin.default.create({
        actions: {
          bar(msg) {
            assert.equal(msg, 'HELLO', 'bar handler in mixin');
            this._super(msg);
          }
        }
      });
      this.add('route:home', SuperRoute.extend(RouteMixin, {
        actions: {
          baz() {
            assert.ok(true, 'baz', 'baz hander in route');
          }
        }
      }));
      this.addTemplate('home', "\n      <a class=\"do-foo\" {{action \"foo\"}}>Do foo</a>\n      <a class=\"do-bar-with-arg\" {{action \"bar\" \"HELLO\"}}>Do bar with arg</a>\n      <a class=\"do-baz\" {{action \"baz\"}}>Do bar</a>\n    ");
      return this.visit('/').then(() => {
        let rootElement = document.getElementById('qunit-fixture');
        rootElement.querySelector('.do-foo').click();
        rootElement.querySelector('.do-bar-with-arg').click();
        rootElement.querySelector('.do-baz').click();
      });
    }
    async ['@test Actions are not triggered on the controller if a matching action name is implemented as a method'](assert) {
      let done = assert.async();
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      let model = {
        name: 'Tom Dale'
      };
      let stateIsNotCalled = true;
      this.add('route:home', _route.default.extend({
        model() {
          return model;
        },
        actions: {
          showStuff(context) {
            assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
            assert.deepEqual(context, {
              name: 'Tom Dale'
            }, 'an event with context is passed');
            done();
          }
        }
      }));
      this.addTemplate('home', '<a {{action "showStuff" @model}}>{{this.name}}</a>');
      this.add('controller:home', _controller.default.extend({
        showStuff() {
          stateIsNotCalled = false;
          assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
        }
      }));
      await this.visit('/');
      document.getElementById('qunit-fixture').querySelector('a').click();
    }
    async ['@test actions can be triggered with multiple arguments'](assert) {
      let done = assert.async();
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      let model1 = {
        name: 'Tilde'
      };
      let model2 = {
        name: 'Tom Dale'
      };
      let RootRoute = _route.default.extend({
        actions: {
          showStuff(obj1, obj2) {
            assert.ok(this instanceof RootRoute, 'the handler is an App.HomeRoute');
            assert.deepEqual(Object.assign({}, obj1), {
              name: 'Tilde'
            }, 'the first context is correct');
            assert.deepEqual(Object.assign({}, obj2), {
              name: 'Tom Dale'
            }, 'the second context is correct');
            done();
          }
        }
      });
      this.add('route:root', RootRoute);
      this.add('controller:root.index', _controller.default.extend({
        model1: model1,
        model2: model2
      }));
      this.addTemplate('root.index', '<a {{action "showStuff" this.model1 this.model2}}>{{this.model1.name}}</a>');
      await this.visit('/');
      document.getElementById('qunit-fixture').querySelector('a').click();
    }
    ['@test transitioning multiple times in a single run loop only sets the URL once'](assert) {
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
        this.route('bar');
      });
      return this.visit('/').then(() => {
        let urlSetCount = 0;
        let router = this.applicationInstance.lookup('router:main');
        router.get('location').setURL = function (path) {
          urlSetCount++;
          (0, _object.set)(this, 'path', path);
        };
        assert.equal(urlSetCount, 0);
        (0, _runloop.run)(function () {
          router.transitionTo('foo');
          router.transitionTo('bar');
        });
        assert.equal(urlSetCount, 1);
        assert.equal(router.get('location').getURL(), '/bar');
      });
    }
    ['@test navigating away triggers a url property change'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo', {
          path: '/foo'
        });
        this.route('bar', {
          path: '/bar'
        });
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        (0, _metal.addObserver)(router, 'url', function () {
          assert.ok(true, 'url change event was fired');
        });
        ['foo', 'bar', '/foo'].forEach(destination => (0, _runloop.run)(router, 'transitionTo', destination));
      });
    }
    ['@test using replaceWith calls location.replaceURL if available'](assert) {
      let setCount = 0;
      let replaceCount = 0;
      this.router.reopen({
        location: _noneLocation.default.create({
          setURL(path) {
            setCount++;
            (0, _object.set)(this, 'path', path);
          },
          replaceURL(path) {
            replaceCount++;
            (0, _object.set)(this, 'path', path);
          }
        })
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        assert.equal(setCount, 1);
        assert.equal(replaceCount, 0);
        (0, _runloop.run)(() => router.replaceWith('foo'));
        assert.equal(setCount, 1, 'should not call setURL');
        assert.equal(replaceCount, 1, 'should call replaceURL once');
        assert.equal(router.get('location').getURL(), '/foo');
      });
    }
    ['@test using replaceWith calls setURL if location.replaceURL is not defined'](assert) {
      let setCount = 0;
      this.router.reopen({
        location: _noneLocation.default.create({
          setURL(path) {
            setCount++;
            (0, _object.set)(this, 'path', path);
          }
        })
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        assert.equal(setCount, 1);
        (0, _runloop.run)(() => router.replaceWith('foo'));
        assert.equal(setCount, 2, 'should call setURL once');
        assert.equal(router.get('location').getURL(), '/foo');
      });
    }
    ['@test A redirection hook is provided'](assert) {
      this.router.map(function () {
        this.route('choose', {
          path: '/'
        });
        this.route('home');
      });
      let chooseFollowed = 0;
      let destination = 'home';
      this.add('route:choose', _route.default.extend({
        router: (0, _service.service)(),
        redirect() {
          if (destination) {
            this.router.transitionTo(destination);
          }
        },
        setupController() {
          chooseFollowed++;
        }
      }));
      return this.visit('/').then(() => {
        let rootElement = document.getElementById('qunit-fixture');
        assert.equal(chooseFollowed, 0, "The choose route wasn't entered since a transition occurred");
        assert.equal(rootElement.querySelectorAll('h3.hours').length, 1, 'The home template was rendered');
        assert.equal(this.appRouter.currentPath, 'home');
      });
    }
    ['@test Redirecting from the middle of a route aborts the remainder of the routes'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      this.add('route:bar', _route.default.extend({
        router: (0, _service.service)(),
        redirect() {
          this.router.transitionTo('home');
        },
        setupController() {
          assert.ok(false, 'Should transition before setupController');
        }
      }));
      this.add('route:bar-baz', _route.default.extend({
        enter() {
          assert.ok(false, 'Should abort transition getting to next route');
        }
      }));
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        this.handleURLAborts(assert, '/foo/bar/baz');
        assert.equal(router.currentPath, 'home');
        assert.equal(router.get('location').getURL(), '/home');
      });
    }
    ['@test Redirecting to the current target in the middle of a route does not abort initial routing'](assert) {
      assert.expect(5);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      let successCount = 0;
      this.add('route:bar', _route.default.extend({
        router: (0, _service.service)(),
        redirect() {
          return this.router.transitionTo('bar.baz').then(function () {
            successCount++;
          });
        },
        setupController() {
          assert.ok(true, "Should still invoke bar's setupController");
        }
      }));
      this.add('route:bar.baz', _route.default.extend({
        setupController() {
          assert.ok(true, "Should still invoke bar.baz's setupController");
        }
      }));
      return this.visit('/foo/bar/baz').then(() => {
        assert.ok(true, '/foo/bar/baz has been handled');
        assert.equal(this.appRouter.currentPath, 'foo.bar.baz');
        assert.equal(successCount, 1, 'transitionTo success handler was called once');
      });
    }
    ['@test Redirecting to the current target with a different context aborts the remainder of the routes'](assert) {
      assert.expect(4);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            path: 'bar/:id',
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      let model = {
        id: 2
      };
      let count = 0;
      this.add('route:bar', _route.default.extend({
        router: (0, _service.service)(),
        afterModel() {
          if (count++ > 10) {
            assert.ok(false, 'infinite loop');
          } else {
            this.router.transitionTo('bar.baz', model);
          }
        }
      }));
      this.add('route:bar.baz', _route.default.extend({
        setupController() {
          assert.ok(true, 'Should still invoke setupController');
        }
      }));
      return this.visit('/').then(() => {
        this.handleURLAborts(assert, '/foo/bar/1/baz');
        assert.equal(this.appRouter.currentPath, 'foo.bar.baz');
        assert.equal(this.applicationInstance.lookup('router:main').get('location').getURL(), '/foo/bar/2/baz');
      });
    }
    ['@test Transitioning from a parent event does not prevent currentPath from being set'](assert) {
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
          this.route('qux');
        });
      });
      this.add('route:foo', _route.default.extend({
        router: (0, _service.service)(),
        actions: {
          goToQux() {
            this.router.transitionTo('foo.qux');
          }
        }
      }));
      return this.visit('/foo/bar/baz').then(() => {
        assert.ok(true, '/foo/bar/baz has been handled');
        let router = this.applicationInstance.lookup('router:main');
        assert.equal(router.currentPath, 'foo.bar.baz');
        (0, _runloop.run)(() => router.send('goToQux'));
        assert.equal(router.currentPath, 'foo.qux');
        assert.equal(router.get('location').getURL(), '/foo/qux');
      });
    }
    ['@test Router accounts for rootURL on page load when using history location'](assert) {
      let rootURL = window.location.pathname + '/app';
      let postsTemplateRendered = false;
      let setHistory;
      setHistory = function (obj, path) {
        obj.set('history', {
          state: {
            path: path
          }
        });
      };
      let location = _historyLocation.default.create({
        initState() {
          let path = rootURL + '/posts';
          setHistory(this, path);
          this.set('location', {
            pathname: path,
            href: 'http://localhost/' + path
          });
        },
        replaceState(path) {
          setHistory(this, path);
        },
        pushState(path) {
          setHistory(this, path);
        }
      });
      this.router.reopen({
        // location: 'historyTest',
        location,
        rootURL: rootURL
      });
      this.router.map(function () {
        this.route('posts', {
          path: '/posts'
        });
      });
      this.add('route:posts', _route.default.extend({
        model() {},
        setupController() {
          postsTemplateRendered = true;
          this._super(...arguments);
        }
      }));
      return this.visit('/').then(() => {
        assert.ok(postsTemplateRendered, 'Posts route successfully stripped from rootURL');
        (0, _internalTestHelpers.runDestroy)(location);
        location = null;
      });
    }
    ['@test The rootURL is passed properly to the location implementation'](assert) {
      assert.expect(1);
      let rootURL = '/blahzorz';
      this.add('location:history-test', _historyLocation.default.extend({
        rootURL: 'this is not the URL you are looking for',
        history: {
          pushState() {}
        },
        initState() {
          assert.equal(this.get('rootURL'), rootURL);
        }
      }));
      this.router.reopen({
        location: 'history-test',
        rootURL: rootURL,
        // if we transition in this test we will receive failures
        // if the tests are run from a static file
        _doURLTransition() {
          return _rsvp.default.resolve('');
        }
      });
      return this.visit('/');
    }
    ['@test Generating a URL should not affect currentModel'](assert) {
      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      let posts = {
        1: {
          id: 1
        },
        2: {
          id: 2
        }
      };
      this.add('route:post', _route.default.extend({
        model(params) {
          return posts[params.post_id];
        }
      }));
      return this.visit('/posts/1').then(() => {
        assert.ok(true, '/posts/1 has been handled');
        let route = this.applicationInstance.lookup('route:post');
        assert.equal(route.modelFor('post'), posts[1]);
        let url = this.applicationInstance.lookup('router:main').generate('post', posts[2]);
        assert.equal(url, '/posts/2');
        assert.equal(route.modelFor('post'), posts[1]);
      });
    }
    ["@test Nested index route is not overridden by parent's implicit index route"](assert) {
      this.router.map(function () {
        this.route('posts', function () {
          this.route('index', {
            path: ':category'
          });
        });
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        return router.transitionTo('posts', {
          category: 'emberjs'
        });
      }).then(() => {
        let router = this.applicationInstance.lookup('router:main');
        assert.deepEqual(router.location.path, '/posts/emberjs');
      });
    }
    ['@test Promises encountered on app load put app into loading state until resolved'](assert) {
      assert.expect(2);
      let deferred = _rsvp.default.defer();
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:index', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      this.addTemplate('index', '<p>INDEX</p>');
      this.addTemplate('loading', '<p>LOADING</p>');
      (0, _runloop.run)(() => this.visit('/'));
      let rootElement = document.getElementById('qunit-fixture');
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'LOADING', 'The loading state is displaying.');
      (0, _runloop.run)(deferred.resolve);
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'INDEX', 'The index route is display.');
    }
    ['@test Aborting/redirecting the transition in `willTransition` prevents LoadingRoute from being entered'](assert) {
      assert.expect(5);
      this.router.map(function () {
        this.route('index');
        this.route('nork');
        this.route('about');
      });
      let redirect = false;
      this.add('route:index', _route.default.extend({
        router: (0, _service.service)(),
        actions: {
          willTransition(transition) {
            assert.ok(true, 'willTransition was called');
            if (redirect) {
              // router.js won't refire `willTransition` for this redirect
              this.router.transitionTo('about');
            } else {
              transition.abort();
            }
          }
        }
      }));
      let deferred = null;
      this.add('route:loading', _route.default.extend({
        activate() {
          assert.ok(deferred, 'LoadingRoute should be entered at this time');
        },
        deactivate() {
          assert.ok(true, 'LoadingRoute was exited');
        }
      }));
      this.add('route:nork', _route.default.extend({
        activate() {
          assert.ok(true, 'NorkRoute was entered');
        }
      }));
      this.add('route:about', _route.default.extend({
        activate() {
          assert.ok(true, 'AboutRoute was entered');
        },
        model() {
          if (deferred) {
            return deferred.promise;
          }
        }
      }));
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        // Attempted transitions out of index should abort.
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(router, 'handleURL', '/nork');

        // Attempted transitions out of index should redirect to about
        redirect = true;
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(router, 'transitionTo', 'index');

        // Redirected transitions out of index to a route with a
        // promise model should pause the transition and
        // activate LoadingRoute
        deferred = _rsvp.default.defer();
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(deferred.resolve);
      });
    }
    ['@test `activate` event fires on the route'](assert) {
      assert.expect(4);
      let eventFired = 0;
      this.router.map(function () {
        this.route('nork');
      });
      this.add('route:nork', _route.default.extend({
        init() {
          this._super(...arguments);
          this.on('activate', function (transition) {
            assert.equal(++eventFired, 1, 'activate event is fired once');
            assert.ok(transition, 'transition is passed to activate event');
          });
        },
        activate(transition) {
          assert.ok(true, 'activate hook is called');
          assert.ok(transition, 'transition is passed to activate hook');
        }
      }));
      return this.visit('/nork');
    }
    ['@test `deactivate` event fires on the route'](assert) {
      assert.expect(4);
      let eventFired = 0;
      this.router.map(function () {
        this.route('nork');
        this.route('dork');
      });
      this.add('route:nork', _route.default.extend({
        init() {
          this._super(...arguments);
          this.on('deactivate', function (transition) {
            assert.equal(++eventFired, 1, 'deactivate event is fired once');
            assert.ok(transition, 'transition is passed');
          });
        },
        deactivate(transition) {
          assert.ok(true, 'deactivate hook is called');
          assert.ok(transition, 'transition is passed');
        }
      }));
      return this.visit('/nork').then(() => this.visit('/dork'));
    }
    ['@test Actions can be handled by inherited action handlers'](assert) {
      assert.expect(4);
      let SuperRoute = _route.default.extend({
        actions: {
          foo() {
            assert.ok(true, 'foo');
          },
          bar(msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });
      let RouteMixin = _mixin.default.create({
        actions: {
          bar(msg) {
            assert.equal(msg, 'HELLO');
            this._super(msg);
          }
        }
      });
      this.add('route:home', SuperRoute.extend(RouteMixin, {
        actions: {
          baz() {
            assert.ok(true, 'baz');
          }
        }
      }));
      this.addTemplate('home', "\n      <a class=\"do-foo\" {{action \"foo\"}}>Do foo</a>\n      <a class=\"do-bar-with-arg\" {{action \"bar\" \"HELLO\"}}>Do bar with arg</a>\n      <a class=\"do-baz\" {{action \"baz\"}}>Do bar</a>\n    ");
      return this.visit('/').then(() => {
        let rootElement = document.getElementById('qunit-fixture');
        rootElement.querySelector('.do-foo').click();
        rootElement.querySelector('.do-bar-with-arg').click();
        rootElement.querySelector('.do-baz').click();
      });
    }
    ['@test transitionTo returns Transition when passed a route name'](assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('bar');
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        let transition = (0, _runloop.run)(() => router.transitionTo('bar'));
        assert.equal(transition instanceof _router_js.InternalTransition, true);
      });
    }
    ['@test transitionTo returns Transition when passed a url'](assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('bar', function () {
          this.route('baz');
        });
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        let transition = (0, _runloop.run)(() => router.transitionTo('/bar/baz'));
        assert.equal(transition instanceof _router_js.InternalTransition, true);
      });
    }
    ['@test currentRouteName is a property installed on Router that can be used in transitionTo'](assert) {
      assert.expect(24);
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
        this.route('be', function () {
          this.route('excellent', {
            resetNamespace: true
          }, function () {
            this.route('to', {
              resetNamespace: true
            }, function () {
              this.route('each', {
                resetNamespace: true
              }, function () {
                this.route('other');
              });
            });
          });
        });
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        function transitionAndCheck(path, expectedPath, expectedRouteName) {
          if (path) {
            (0, _runloop.run)(router, 'transitionTo', path);
          }
          assert.equal(router.currentPath, expectedPath);
          assert.equal(router.currentRouteName, expectedRouteName);
        }
        transitionAndCheck(null, 'index', 'index');
        transitionAndCheck('/be', 'be.index', 'be.index');
        transitionAndCheck('/be/excellent', 'be.excellent.index', 'excellent.index');
        transitionAndCheck('/be/excellent/to', 'be.excellent.to.index', 'to.index');
        transitionAndCheck('/be/excellent/to/each', 'be.excellent.to.each.index', 'each.index');
        transitionAndCheck('/be/excellent/to/each/other', 'be.excellent.to.each.other', 'each.other');
        transitionAndCheck('index', 'index', 'index');
        transitionAndCheck('be', 'be.index', 'be.index');
        transitionAndCheck('excellent', 'be.excellent.index', 'excellent.index');
        transitionAndCheck('to.index', 'be.excellent.to.index', 'to.index');
        transitionAndCheck('each', 'be.excellent.to.each.index', 'each.index');
        transitionAndCheck('each.other', 'be.excellent.to.each.other', 'each.other');
      });
    }
    ["@test Redirecting with null model doesn't error out"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('about', {
          path: '/about/:hurhurhur'
        });
      });
      this.add('route:about', _route.default.extend({
        serialize: function (model) {
          if (model === null) {
            return {
              hurhurhur: 'TreeklesMcGeekles'
            };
          }
        }
      }));
      this.add('route:home', _route.default.extend({
        router: (0, _service.service)(),
        beforeModel() {
          this.router.transitionTo('about', null);
        }
      }));
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        assert.equal(router.get('location.path'), '/about/TreeklesMcGeekles');
      });
    }
    async ['@test rejecting the model hooks promise with a non-error prints the `message` property'](assert) {
      assert.expect(5);
      let rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
      let rejectedStack = 'Yeah, buddy: stack gets printed too.';
      this.router.map(function () {
        this.route('yippie', {
          path: '/'
        });
      });
      console.error = function (initialMessage, errorMessage, errorStack) {
        assert.equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
        assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
        assert.equal(errorStack, rejectedStack, "the rejected reason's stack property is logged");
      };
      this.add('route:yippie', _route.default.extend({
        model() {
          return _rsvp.default.reject({
            message: rejectedMessage,
            stack: rejectedStack
          });
        }
      }));
      await assert.rejects(this.visit('/'), function (err) {
        assert.equal(err.message, rejectedMessage);
        return true;
      }, 'expected an exception');
    }
    async ['@test rejecting the model hooks promise with an error with `errorThrown` property prints `errorThrown.message` property'](assert) {
      assert.expect(5);
      let rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
      let rejectedStack = 'Yeah, buddy: stack gets printed too.';
      this.router.map(function () {
        this.route('yippie', {
          path: '/'
        });
      });
      console.error = function (initialMessage, errorMessage, errorStack) {
        assert.equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
        assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
        assert.equal(errorStack, rejectedStack, "the rejected reason's stack property is logged");
      };
      this.add('route:yippie', _route.default.extend({
        model() {
          return _rsvp.default.reject({
            errorThrown: {
              message: rejectedMessage,
              stack: rejectedStack
            }
          });
        }
      }));
      await assert.rejects(this.visit('/'), function (_ref4) {
        let {
          errorThrown: err
        } = _ref4;
        assert.equal(err.message, rejectedMessage);
        return true;
      }, 'expected an exception');
    }
    async ['@test rejecting the model hooks promise with no reason still logs error'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('wowzers', {
          path: '/'
        });
      });
      console.error = function (initialMessage) {
        assert.equal(initialMessage, 'Error while processing route: wowzers', 'a message with the current route name is printed');
      };
      this.add('route:wowzers', _route.default.extend({
        model() {
          return _rsvp.default.reject();
        }
      }));
      await assert.rejects(this.visit('/'));
    }
    async ['@test rejecting the model hooks promise with a string shows a good error'](assert) {
      assert.expect(3);
      let rejectedMessage = 'Supercalifragilisticexpialidocious';
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
      });
      console.error = function (initialMessage, errorMessage) {
        assert.equal(initialMessage, 'Error while processing route: yondo', 'a message with the current route name is printed');
        assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
      };
      this.add('route:yondo', _route.default.extend({
        model() {
          return _rsvp.default.reject(rejectedMessage);
        }
      }));
      await assert.rejects(this.visit('/'), new RegExp(rejectedMessage), 'expected an exception');
    }
    ["@test willLeave, willChangeContext, willChangeModel actions don't fire unless feature flag enabled"](assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('about');
      });
      function shouldNotFire() {
        assert.ok(false, "this action shouldn't have been received");
      }
      this.add('route:index', _route.default.extend({
        actions: {
          willChangeModel: shouldNotFire,
          willChangeContext: shouldNotFire,
          willLeave: shouldNotFire
        }
      }));
      this.add('route:about', _route.default.extend({
        setupController() {
          assert.ok(true, 'about route was entered');
        }
      }));
      return this.visit('/about');
    }
    async ['@test Errors in transitionTo within redirect hook are logged'](assert) {
      assert.expect(4);
      let actual = [];
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
        this.route('stink-bomb');
      });
      this.add('route:yondo', _route.default.extend({
        router: (0, _service.service)(),
        redirect() {
          this.router.transitionTo('stink-bomb', {
            something: 'goes boom'
          });
        }
      }));
      console.error = function () {
        // push the arguments onto an array so we can detect if the error gets logged twice
        actual.push(arguments);
      };
      await assert.rejects(this.visit('/'), /More context objects were passed/);
      assert.equal(actual.length, 1, 'the error is only logged once');
      assert.equal(actual[0][0], 'Error while processing route: yondo', 'source route is printed');
      assert.ok(actual[0][1].match(/More context objects were passed than there are dynamic segments for the route: stink-bomb/), 'the error is printed');
    }
    ['@test Errors in transition show error template if available'](assert) {
      this.addTemplate('error', "<div id='error'>Error!</div>");
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
        this.route('stink-bomb');
      });
      this.add('route:yondo', _route.default.extend({
        router: (0, _service.service)(),
        redirect() {
          this.transitionTo('stink-bomb', {
            something: 'goes boom'
          });
        }
      }));
      console.error = () => {};
      return this.visit('/').then(() => {
        let rootElement = document.querySelector('#qunit-fixture');
        assert.equal(rootElement.querySelectorAll('#error').length, 1, 'Error template was rendered.');
      });
    }
    ['@test Route#resetController gets fired when changing models and exiting routes'](assert) {
      assert.expect(4);
      this.router.map(function () {
        this.route('a', function () {
          this.route('b', {
            path: '/b/:id',
            resetNamespace: true
          }, function () {});
          this.route('c', {
            path: '/c/:id',
            resetNamespace: true
          }, function () {});
        });
        this.route('out');
      });
      let calls = [];
      let SpyRoute = _route.default.extend({
        setupController( /* controller, model, transition */
        ) {
          calls.push(['setup', this.routeName]);
        },
        resetController( /* controller */
        ) {
          calls.push(['reset', this.routeName]);
        }
      });
      this.add('route:a', SpyRoute.extend());
      this.add('route:b', SpyRoute.extend());
      this.add('route:c', SpyRoute.extend());
      this.add('route:out', SpyRoute.extend());
      let router;
      return this.visit('/').then(() => {
        router = this.applicationInstance.lookup('router:main');
        assert.deepEqual(calls, []);
        return (0, _runloop.run)(router, 'transitionTo', 'b', 'b-1');
      }).then(() => {
        assert.deepEqual(calls, [['setup', 'a'], ['setup', 'b']]);
        calls.length = 0;
        return (0, _runloop.run)(router, 'transitionTo', 'c', 'c-1');
      }).then(() => {
        assert.deepEqual(calls, [['reset', 'b'], ['setup', 'c']]);
        calls.length = 0;
        return (0, _runloop.run)(router, 'transitionTo', 'out');
      }).then(() => {
        assert.deepEqual(calls, [['reset', 'c'], ['reset', 'a'], ['setup', 'out']]);
      });
    }
    async ['@test Exception during initialization of non-initial route is not swallowed'](assert) {
      this.router.map(function () {
        this.route('boom');
      });
      this.add('route:boom', _route.default.extend({
        init() {
          throw new Error('boom!');
        }
      }));
      await assert.rejects(this.visit('/boom'), /\bboom\b/);
    }
    async ['@test Exception during initialization of initial route is not swallowed'](assert) {
      this.router.map(function () {
        this.route('boom', {
          path: '/'
        });
      });
      this.add('route:boom', _route.default.extend({
        init() {
          throw new Error('boom!');
        }
      }));
      await assert.rejects(this.visit('/'), /\bboom\b/);
    }
    async ['@test Doesnt swallow exception thrown from willTransition'](assert) {
      assert.expect(1);
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', 'index');
      this.addTemplate('other', 'other');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
        this.route('other', function () {});
      });
      this.add('route:index', _route.default.extend({
        actions: {
          willTransition() {
            throw new Error('boom');
          }
        }
      }));
      await this.visit('/');
      await assert.rejects(this.visit('/other'), /boom/, 'expected an exception but none was thrown');
    }
    ['@test Route serializers work for Engines'](assert) {
      assert.expect(2);

      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      this.add('engine:blog', BlogEngine);

      // Register engine route map
      let postSerialize = function (params) {
        assert.ok(true, 'serialize hook runs');
        return {
          post_id: params.id
        };
      };
      let BlogMap = function () {
        this.route('post', {
          path: '/post/:post_id',
          serialize: postSerialize
        });
      };
      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(() => {
        let router = this.applicationInstance.lookup('router:main');
        assert.equal(router._routerMicrolib.generate('blog.post', {
          id: '13'
        }), '/blog/post/13', 'url is generated properly');
      });
    }
    async ['@test Defining a Route#serialize method in an Engine throws an error'](assert) {
      assert.expect(1);

      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      this.add('engine:blog', BlogEngine);

      // Register engine route map
      let BlogMap = function () {
        this.route('post');
      };
      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      await this.visit('/');
      let router = this.applicationInstance.lookup('router:main');
      let PostRoute = _route.default.extend({
        serialize() {}
      });
      this.applicationInstance.lookup('engine:blog').register('route:post', PostRoute);
      try {
        // TODO: for some reason this doesn't work with assert.reject
        await router.transitionTo('blog.post');
      } catch (e) {
        assert.ok(e.message.match(/Defining a custom serialize method on an Engine route is not supported/));
      }
    }
    ['@test App.destroy does not leave undestroyed views after clearing engines'](assert) {
      assert.expect(4);
      let engineInstance;
      // Register engine
      let BlogEngine = _engine.default.extend({
        Resolver: _internalTestHelpers.ModuleBasedTestResolver
      });
      this.add('engine:blog', BlogEngine);
      let EngineIndexRoute = _route.default.extend({
        init() {
          this._super(...arguments);
          engineInstance = (0, _owner.getOwner)(this);
        }
      });

      // Register engine route map
      let BlogMap = function () {
        this.route('post');
      };
      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(() => {
        let engine = this.applicationInstance.lookup('engine:blog');
        engine.register('route:index', EngineIndexRoute);
        engine.register('template:index', (0, _emberTemplateCompiler.compile)('Engine Post!'));
        return this.visit('/blog');
      }).then(() => {
        assert.ok(true, '/blog has been handled');
        let route = engineInstance.lookup('route:index');
        let router = this.applicationInstance.lookup('router:main');
        (0, _runloop.run)(router, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was cleared');
        (0, _runloop.run)(route, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
        (0, _runloop.run)(this.applicationInstance, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
      });
    }
    ["@test Generated route should be an instance of App's default route if provided"](assert) {
      let generatedRoute;
      this.router.map(function () {
        this.route('posts');
      });
      let AppRoute = _route.default.extend();
      this.add('route:basic', AppRoute);
      return this.visit('/posts').then(() => {
        generatedRoute = this.applicationInstance.lookup('route:posts');
        assert.ok(generatedRoute instanceof AppRoute, 'should extend the correct route');
      });
    }
  });
});
define("ember/tests/routing/model_loading_test", ["@ember/routing/route", "@ember/controller", "@ember/object", "@ember/array", "internal-test-helpers", "@ember/runloop", "@ember/service"], function (_route, _controller, _object, _array, _internalTestHelpers, _runloop, _service) {
  "use strict";

  /* eslint-disable no-console */

  let originalConsoleError;
  (0, _internalTestHelpers.moduleFor)('Route - model loading', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.addTemplate('home', '<h3 class="hours">Hours</h3>');
      this.addTemplate('camelot', '<section id="camelot"><h3>Is a silly place</h3></section>');
      this.addTemplate('homepage', '<h3 id="troll">Megatroll</h3><p>{{this.name}}</p>');
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      originalConsoleError = console.error;
    }
    teardown() {
      super.teardown();
      console.error = originalConsoleError;
    }
    async ['@test warn on URLs not included in the route set'](assert) {
      await this.visit('/');
      await assert.rejects(this.visit('/what-is-this-i-dont-even'), /\/what-is-this-i-dont-even/);
    }
    ['@test properties that autotrack the model update when the model changes'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('track', {
          path: '/track/:id'
        });
      });
      class HomeRoute extends _route.default {
        async model(_ref) {
          let {
            id
          } = _ref;
          return {
            value: id
          };
        }
      }
      class HomeController extends _controller.default {
        get derivedProperty() {
          return this.model.value || 'value is unset';
        }
      }
      this.add('route:track', HomeRoute);
      this.add('controller:track', HomeController);
      this.addTemplate('track', '<h3 class="derivedProperty">{{this.derivedProperty}}</h3>');
      return this.visit('/track/2').then(() => {
        assert.equal(document.querySelector('h3').innerText, '2', 'the derived property matches the id');
      }).then(() => {
        return this.visit('/track/3').then(() => {
          assert.equal(document.querySelector('h3').innerText, '3', 'the derived property matches the id');
        });
      });
    }
    ['@test The Homepage with a `setupController` hook'](assert) {
      this.addTemplate('home', "<ul>{{#each this.hours as |entry|}}\n        <li>{{entry}}</li>\n      {{/each}}\n      </ul>\n    ");
      this.add('route:home', _route.default.extend({
        setupController(controller) {
          controller.set('hours', ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
        }
      }));
      return this.visit('/').then(() => {
        let text = this.$('ul li:nth-child(3)').text();
        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    }
    ["@test The route controller is still set when overriding the setupController hook"](assert) {
      this.add('route:home', _route.default.extend({
        setupController() {
          // no-op
          // importantly, we are not calling this._super
        }
      }));
      this.add('controller:home', _controller.default.extend());
      return this.visit('/').then(() => {
        let homeRoute = this.applicationInstance.lookup('route:home');
        let homeController = this.applicationInstance.lookup('controller:home');
        assert.equal(homeRoute.controller, homeController, 'route controller is the home controller');
      });
    }
    ['@test the route controller can be specified via controllerName'](assert) {
      this.addTemplate('home', '<p>{{this.myValue}}</p>');
      this.add('route:home', _route.default.extend({
        controllerName: 'myController'
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'foo'
      }));
      return this.visit('/').then(() => {
        let homeRoute = this.applicationInstance.lookup('route:home');
        let myController = this.applicationInstance.lookup('controller:myController');
        let text = this.$('p').text();
        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'foo', 'The homepage template was rendered with data from the custom controller');
      });
    }
    ["@test The route controller specified via controllerName is used in render even when a controller with the routeName is available"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.addTemplate('home', '<p>home: {{this.myValue}}</p>');
      this.add('route:home', _route.default.extend({
        controllerName: 'myController'
      }));
      this.add('controller:home', _controller.default.extend({
        myValue: 'home'
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'myController'
      }));
      return this.visit('/').then(() => {
        let homeRoute = this.applicationInstance.lookup('route:home');
        let myController = this.applicationInstance.lookup('controller:myController');
        let text = this.$('p').text();
        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'home: myController', 'The homepage template was rendered with data from the custom controller');
      });
    }
    ["@test The Homepage with a 'setupController' hook modifying other controllers"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _route.default.extend({
        setupController( /* controller */
        ) {
          this.controllerFor('home').set('hours', ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
        }
      }));
      this.addTemplate('home', '<ul>{{#each this.hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>');
      return this.visit('/').then(() => {
        let text = this.$('ul li:nth-child(3)').text();
        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    }
    ["@test The Homepage with a computed model that does not get overridden"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('controller:home', _controller.default.extend({
        model: (0, _object.computed)(function () {
          return ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm'];
        })
      }));
      this.addTemplate('home', '<ul>{{#each this.model as |passage|}}<li>{{passage}}</li>{{/each}}</ul>');
      return this.visit('/').then(() => {
        let text = this.$('ul li:nth-child(3)').text();
        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the context intact');
      });
    }
    ["@test The Homepage getting its controller context via model"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _route.default.extend({
        model() {
          return ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm'];
        },
        setupController(controller, model) {
          assert.equal(this.controllerFor('home'), controller);
          this.controllerFor('home').set('hours', model);
        }
      }));
      this.addTemplate('home', '<ul>{{#each this.hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>');
      return this.visit('/').then(() => {
        let text = this.$('ul li:nth-child(3)').text();
        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    }
    ["@test The Specials Page getting its model by deserializing the params hash"](assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      this.add('route:special', _route.default.extend({
        model(params) {
          return _object.default.create({
            menuItemId: params.menu_item_id
          });
        }
      }));
      this.addTemplate('special', '<p>{{@model.menuItemId}}</p>');
      return this.visit('/specials/1').then(() => {
        let text = this.$('p').text();
        assert.equal(text, '1', 'The model was used to render the template');
      });
    }
    ['@test The Specials Page defaults to looking models up via `find`']() {
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          return MenuItem.create({
            id
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      let SpecialRoute = class extends _route.default {
        model(_ref2) {
          let {
            menu_item_id
          } = _ref2;
          return MenuItem.find(menu_item_id);
        }
      };
      this.add('route:special', SpecialRoute);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      this.addTemplate('special', '{{@model.id}}');
      return this.visit('/specials/1').then(() => {
        this.assertText('1', 'The model was used to render the template');
      });
    }
    ['@test Moving from one page to another triggers the correct callbacks'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          return MenuItem.create({
            id: id
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      let SpecialRoute = class extends _route.default {
        model(_ref3) {
          let {
            menu_item_id
          } = _ref3;
          return MenuItem.find(menu_item_id);
        }
      };
      this.add('route:special', SpecialRoute);
      this.addTemplate('home', '<h3>Home</h3>');
      this.addTemplate('special', '<p>{{@model.id}}</p>');
      return this.visit('/').then(() => {
        this.assertText('Home', 'The app is now in the initial state');
        let promiseContext = MenuItem.create({
          id: 1
        });
        return this.visit('/specials/1', promiseContext);
      }).then(() => {
        assert.equal(this.currentURL, '/specials/1');
        this.assertText('1', 'The app is now transitioned');
      });
    }
    ['@test Nested callbacks are not exited when moving to siblings'](assert) {
      let rootSetup = 0;
      let rootModel = 0;
      let rootSerialize = 0;
      let menuItem;
      let rootElement;
      let MenuItem = _object.default.extend();
      MenuItem.reopenClass({
        find(id) {
          menuItem = MenuItem.create({
            id: id
          });
          return menuItem;
        }
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('special', {
            path: '/specials/:menu_item_id',
            resetNamespace: true
          });
        });
      });
      this.add('route:root', _route.default.extend({
        model() {
          rootModel++;
          return this._super(...arguments);
        },
        setupController() {
          rootSetup++;
        },
        serialize() {
          rootSerialize++;
          return this._super(...arguments);
        }
      }));
      this.add('route:loading', _route.default.extend({}));
      this.add('route:home', _route.default.extend({}));
      this.add('route:special', _route.default.extend({
        model(_ref4) {
          let {
            menu_item_id
          } = _ref4;
          return MenuItem.find(menu_item_id);
        },
        setupController(controller, model) {
          (0, _object.set)(controller, 'model', model);
        }
      }));
      this.addTemplate('root.index', '<h3>Home</h3>');
      this.addTemplate('special', '<p>{{@model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      return this.visit('/').then(() => {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('h3')), 'Home', 'The app is now in the initial state');
        assert.equal(rootSetup, 1, 'The root setup was triggered');
        assert.equal(rootSerialize, 0, 'The root serialize was not called');
        assert.equal(rootModel, 1, 'The root model was called');
        let router = this.applicationInstance.lookup('router:main');
        let menuItem = MenuItem.create({
          id: 1
        });
        return router.transitionTo('special', menuItem).then(function () {
          assert.equal(rootSetup, 1, 'The root setup was not triggered again');
          assert.equal(rootSerialize, 0, 'The root serialize was not called');

          // TODO: Should this be changed?
          assert.equal(rootModel, 1, 'The root model was called again');
          assert.deepEqual(router.location.path, '/specials/1');
          assert.equal(router.currentPath, 'root.special');
        });
      });
    }
    ['@test Route inherits model from parent route'](assert) {
      assert.expect(9);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments');
          this.route('shares', {
            path: '/shares/:share_id',
            resetNamespace: true
          }, function () {
            this.route('share');
          });
        });
      });
      let post1 = {};
      let post2 = {};
      let post3 = {};
      let share1 = {};
      let share2 = {};
      let share3 = {};
      let posts = {
        1: post1,
        2: post2,
        3: post3
      };
      let shares = {
        1: share1,
        2: share2,
        3: share3
      };
      this.add('route:the-post', _route.default.extend({
        model(params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:the-post.comments', _route.default.extend({
        afterModel(post /*, transition */) {
          let parent_model = this.modelFor('the-post');
          assert.equal(post, parent_model);
        }
      }));
      this.add('route:shares', _route.default.extend({
        model(params) {
          return shares[params.share_id];
        }
      }));
      this.add('route:shares.share', _route.default.extend({
        afterModel(share /*, transition */) {
          let parent_model = this.modelFor('shares');
          assert.equal(share, parent_model);
        }
      }));
      return this.visit('/posts/1/comments').then(() => {
        assert.ok(true, 'url: /posts/1/comments was handled');
        return this.visit('/posts/1/shares/1');
      }).then(() => {
        assert.ok(true, 'url: /posts/1/shares/1 was handled');
        return this.visit('/posts/2/comments');
      }).then(() => {
        assert.ok(true, 'url: /posts/2/comments was handled');
        return this.visit('/posts/2/shares/2');
      }).then(() => {
        assert.ok(true, 'url: /posts/2/shares/2 was handled');
        return this.visit('/posts/3/comments');
      }).then(() => {
        assert.ok(true, 'url: /posts/3/shares was handled');
        return this.visit('/posts/3/shares/3');
      }).then(() => {
        assert.ok(true, 'url: /posts/3/shares/3 was handled');
      });
    }
    ['@test Routes with { resetNamespace: true } inherits model from parent route'](assert) {
      assert.expect(6);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          }, function () {});
        });
      });
      let post1 = {};
      let post2 = {};
      let post3 = {};
      let posts = {
        1: post1,
        2: post2,
        3: post3
      };
      this.add('route:the-post', _route.default.extend({
        model(params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:comments', _route.default.extend({
        afterModel(post /*, transition */) {
          let parent_model = this.modelFor('the-post');
          assert.equal(post, parent_model);
        }
      }));
      return this.visit('/posts/1/comments').then(() => {
        assert.ok(true, '/posts/1/comments');
        return this.visit('/posts/2/comments');
      }).then(() => {
        assert.ok(true, '/posts/2/comments');
        return this.visit('/posts/3/comments');
      }).then(() => {
        assert.ok(true, '/posts/3/comments');
      });
    }
    ['@test It is possible to get the model from a parent route'](assert) {
      assert.expect(6);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          });
        });
      });
      let post1 = {};
      let post2 = {};
      let post3 = {};
      let currentPost;
      let posts = {
        1: post1,
        2: post2,
        3: post3
      };
      this.add('route:the-post', _route.default.extend({
        model(params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:comments', _route.default.extend({
        model() {
          assert.equal(this.modelFor('the-post'), currentPost);
        }
      }));
      currentPost = post1;
      return this.visit('/posts/1/comments').then(() => {
        assert.ok(true, '/posts/1/comments has been handled');
        currentPost = post2;
        return this.visit('/posts/2/comments');
      }).then(() => {
        assert.ok(true, '/posts/2/comments has been handled');
        currentPost = post3;
        return this.visit('/posts/3/comments');
      }).then(() => {
        assert.ok(true, '/posts/3/comments has been handled');
      });
    }
    ['@test Parent route context change'](assert) {
      let editCount = 0;
      let editedPostIds = (0, _array.A)();
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('post', '{{outlet}}');
      this.addTemplate('post/index', 'showing');
      this.addTemplate('post/edit', 'editing');
      this.router.map(function () {
        this.route('posts', function () {
          this.route('post', {
            path: '/:postId',
            resetNamespace: true
          }, function () {
            this.route('edit');
          });
        });
      });
      this.add('route:posts', _route.default.extend({
        router: (0, _service.service)(),
        actions: {
          showPost(context) {
            this.router.transitionTo('post', context);
          }
        }
      }));
      this.add('route:post', _route.default.extend({
        router: (0, _service.service)(),
        model(params) {
          return {
            id: params.postId
          };
        },
        serialize(model) {
          return {
            postId: model.id
          };
        },
        actions: {
          editPost() {
            this.router.transitionTo('post.edit');
          }
        }
      }));
      this.add('route:post.edit', _route.default.extend({
        model() {
          let postId = this.modelFor('post').id;
          editedPostIds.push(postId);
          return null;
        },
        setup() {
          this._super(...arguments);
          editCount++;
        }
      }));
      return this.visit('/posts/1').then(() => {
        assert.ok(true, '/posts/1 has been handled');
        let router = this.applicationInstance.lookup('router:main');
        (0, _runloop.run)(() => router.send('editPost'));
        (0, _runloop.run)(() => router.send('showPost', {
          id: '2'
        }));
        (0, _runloop.run)(() => router.send('editPost'));
        assert.equal(editCount, 2, 'set up the edit route twice without failure');
        assert.deepEqual(editedPostIds, ['1', '2'], 'modelFor posts.post returns the right context');
      });
    }
    ['@test ApplicationRoute with model does not proxy the currentPath'](assert) {
      // TODO: FIXME:
      let model = {};
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _route.default.extend({
        model() {
          return model;
        }
      }));
      return this.visit('/').then(() => {
        let routerService = this.applicationInstance.lookup('service:router');
        assert.equal(routerService.currentRouteName, 'index', 'currentPath is index');
        assert.equal('currentPath' in model, false, 'should have defined currentPath on controller');
      });
    }
    ['@test Route model hook finds the same model as a manual find'](assert) {
      let post;
      let Post = _object.default.extend();
      Post.reopenClass({
        find() {
          post = this;
          return {};
        }
      });
      this.add('model:post', Post);
      let PostRoute = class extends _route.default {
        model(_ref5) {
          let {
            post_id
          } = _ref5;
          return Post.find(post_id);
        }
      };
      this.add('route:post', PostRoute);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:post_id'
        });
      });
      return this.visit('/post/1').then(() => {
        assert.equal(Post, post);
      });
    }
    ['@test Routes can refresh themselves causing their model hooks to be re-run'](assert) {
      this.router.map(function () {
        this.route('parent', {
          path: '/parent/:parent_id'
        }, function () {
          this.route('child');
        });
      });
      let appcount = 0;
      this.add('route:application', _route.default.extend({
        model() {
          ++appcount;
        }
      }));
      let parentcount = 0;
      this.add('route:parent', _route.default.extend({
        model(params) {
          assert.equal(params.parent_id, '123');
          ++parentcount;
        },
        actions: {
          refreshParent() {
            this.refresh();
          }
        }
      }));
      let childcount = 0;
      this.add('route:parent.child', _route.default.extend({
        model() {
          ++childcount;
        }
      }));
      let router;
      return this.visit('/').then(() => {
        router = this.applicationInstance.lookup('router:main');
        assert.equal(appcount, 1);
        assert.equal(parentcount, 0);
        assert.equal(childcount, 0);
        return (0, _runloop.run)(router, 'transitionTo', 'parent.child', '123');
      }).then(() => {
        assert.equal(appcount, 1);
        assert.equal(parentcount, 1);
        assert.equal(childcount, 1);
        return (0, _runloop.run)(router, 'send', 'refreshParent');
      }).then(() => {
        assert.equal(appcount, 1);
        assert.equal(parentcount, 2);
        assert.equal(childcount, 2);
      });
    }
  });
});
define("ember/tests/routing/query_params_test", ["@ember/controller", "@ember/-internals/string", "@ember/object", "@ember/-internals/runtime", "@ember/array", "@ember/runloop", "@ember/-internals/meta", "@ember/-internals/metal", "@ember/routing/route", "router_js", "@ember/service", "internal-test-helpers"], function (_controller, _string, _object, _runtime, _array, _runloop, _meta, _metal, _route, _router_js, _service, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('Query Params - main', class extends _internalTestHelpers.QueryParamTestCase {
    async refreshModelWhileLoadingTest(loadingReturn) {
      let assert = this.assert;
      assert.expect(9);
      let appModelCount = 0;
      let promiseResolve;
      this.add('route:application', _route.default.extend({
        queryParams: {
          appomg: {
            defaultValue: 'applol'
          }
        },
        model( /* params */
        ) {
          appModelCount++;
        }
      }));
      this.setSingleQPController('index', 'omg', undefined, {
        omg: undefined
      });
      let actionName = typeof loadingReturn !== 'undefined' ? 'loading' : 'ignore';
      let indexModelCount = 0;
      this.add('route:index', _route.default.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        actions: {
          [actionName]: function () {
            return loadingReturn;
          }
        },
        model(params) {
          indexModelCount++;
          if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            });
            return new _runtime.RSVP.Promise(function (resolve) {
              promiseResolve = resolve;
              return;
            });
          } else if (indexModelCount === 3) {
            assert.deepEqual(params, {
              omg: 'hello'
            }, "Model hook reruns even if the previous one didn't finish");
          }
        }
      }));
      await this.visit('/');
      assert.equal(appModelCount, 1, 'appModelCount is 1');
      assert.equal(indexModelCount, 1);
      let indexController = this.getController('index');
      await this.setAndFlush(indexController, 'omg', 'lex');
      assert.equal(appModelCount, 1, 'appModelCount is 1');
      assert.equal(indexModelCount, 2);
      await this.setAndFlush(indexController, 'omg', 'hello');
      assert.equal(appModelCount, 1, 'appModelCount is 1');
      assert.equal(indexModelCount, 3);
      (0, _runloop.run)(function () {
        promiseResolve();
      });
      assert.equal((0, _object.get)(indexController, 'omg'), 'hello', 'At the end last value prevails');
    }
    ["@test No replaceURL occurs on startup because default values don't show up in URL"](assert) {
      assert.expect(1);
      this.setSingleQPController('index');
      return this.visitAndAssert('/');
    }
    ['@test Calling transitionTo does not lose query params already on the activeTransition'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
          this.route('sibling');
        });
      });
      this.add('route:parent.child', _route.default.extend({
        router: (0, _service.service)(),
        afterModel() {
          this.router.transitionTo('parent.sibling');
        }
      }));
      this.setSingleQPController('parent');
      return this.visit('/parent/child?foo=lol').then(() => {
        this.assertCurrentPath('/parent/sibling?foo=lol', 'redirected to the sibling route, instead of child route');
        assert.equal(this.getController('parent').get('foo'), 'lol', 'controller has value from the active transition');
      });
    }
    ['@test Calling transitionTo does not serialize query params already serialized on the activeTransition'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
          this.route('sibling');
        });
      });
      this.add('route:parent.child', _route.default.extend({
        router: (0, _service.service)(),
        afterModel() {
          this.router.transitionTo('parent.sibling');
        }
      }));
      this.add('controller:parent', _controller.default.extend({
        queryParams: ['array', 'string'],
        array: [],
        string: ''
      }));

      // `/parent/child?array=["one",2]&string=hello`
      return this.visit('/parent/child?array=%5B%22one%22%2C2%5D&string=hello').then(() => {
        this.assertCurrentPath('/parent/sibling?array=%5B%22one%22%2C2%5D&string=hello', 'redirected to the sibling route, instead of child route');
        assert.equal(this.getController('parent').get('string'), 'hello', 'controller has value from the active transition');
        assert.deepEqual(this.getController('parent').get('array'), ['one', 2], 'controller has value from the active transition');
      });
    }
    async ['@test Single query params can be set on the controller and reflected in the url'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.setSingleQPController('home');
      await this.visitAndAssert('/');
      let controller = this.getController('home');
      await this.setAndFlush(controller, 'foo', '456');
      this.assertCurrentPath('/?foo=456');
      await this.setAndFlush(controller, 'foo', '987');
      this.assertCurrentPath('/?foo=987');
    }
    async ['@test Query params can map to different url keys configured on the controller'](assert) {
      assert.expect(6);
      this.add('controller:index', _controller.default.extend({
        queryParams: [{
          foo: 'other_foo',
          bar: {
            as: 'other_bar'
          }
        }],
        foo: 'FOO',
        bar: 'BAR'
      }));
      await this.visitAndAssert('/');
      let controller = this.getController('index');
      await this.setAndFlush(controller, 'foo', 'LEX');
      this.assertCurrentPath('/?other_foo=LEX', "QP mapped correctly without 'as'");
      await this.setAndFlush(controller, 'foo', 'WOO');
      this.assertCurrentPath('/?other_foo=WOO', "QP updated correctly without 'as'");
      await this.transitionTo('/?other_foo=NAW');
      assert.equal(controller.get('foo'), 'NAW', 'QP managed correctly on URL transition');
      await this.setAndFlush(controller, 'bar', 'NERK');
      this.assertCurrentPath('/?other_bar=NERK&other_foo=NAW', "QP mapped correctly with 'as'");
      await this.setAndFlush(controller, 'bar', 'NUKE');
      this.assertCurrentPath('/?other_bar=NUKE&other_foo=NAW', "QP updated correctly with 'as'");
    }
    async ['@test Routes have a private overridable serializeQueryParamKey hook'](assert) {
      assert.expect(2);
      this.add('route:index', _route.default.extend({
        serializeQueryParamKey: _string.dasherize
      }));
      this.setSingleQPController('index', 'funTimes', '');
      await this.visitAndAssert('/');
      let controller = this.getController('index');
      await this.setAndFlush(controller, 'funTimes', 'woot');
      this.assertCurrentPath('/?fun-times=woot');
    }
    async ['@test Can override inherited QP behavior by specifying queryParams as a computed property'](assert) {
      assert.expect(3);
      this.setSingleQPController('index', 'a', 0, {
        queryParams: (0, _object.computed)(function () {
          return ['c'];
        }),
        c: true
      });
      await this.visitAndAssert('/');
      let indexController = this.getController('index');
      await this.setAndFlush(indexController, 'a', 1);
      this.assertCurrentPath('/', 'QP did not update due to being overriden');
      await this.setAndFlush(indexController, 'c', false);
      this.assertCurrentPath('/?c=false', 'QP updated with overridden param');
    }
    async ['@test Can concatenate inherited QP behavior by specifying queryParams as an array'](assert) {
      assert.expect(3);
      this.setSingleQPController('index', 'a', 0, {
        queryParams: ['c'],
        c: true
      });
      await this.visitAndAssert('/');
      let indexController = this.getController('index');
      await this.setAndFlush(indexController, 'a', 1);
      this.assertCurrentPath('/?a=1', 'Inherited QP did update');
      await this.setAndFlush(indexController, 'c', false);
      this.assertCurrentPath('/?a=1&c=false', 'New QP did update');
    }
    ['@test model hooks receives query params'](assert) {
      assert.expect(2);
      this.setSingleQPController('index');
      this.add('route:index', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            foo: 'bar'
          });
        }
      }));
      return this.visitAndAssert('/');
    }
    ['@test model hooks receives query params with dynamic segment params'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:id'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            foo: 'bar',
            id: 'baz'
          });
        }
      }));
      return this.visitAndAssert('/baz');
    }
    ['@test model hooks receives query params (overridden by incoming url value)'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:id'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            foo: 'baz',
            id: 'boo'
          });
        }
      }));
      return this.visitAndAssert('/boo?foo=baz');
    }
    async ['@test error is thrown if dynamic segment and query param have same name'](assert) {
      this.router.map(function () {
        this.route('index', {
          path: '/:foo'
        });
      });
      this.setSingleQPController('index');
      await assert.rejectsAssertion(this.visitAndAssert('/boo?foo=baz'), "The route 'index' has both a dynamic segment and query param with name 'foo'. Please rename one to avoid collisions.");
    }
    ['@test query params have been set by the time setupController is called'](assert) {
      assert.expect(2);
      this.setSingleQPController('application');
      this.add('route:application', _route.default.extend({
        setupController(controller) {
          assert.equal(controller.get('foo'), 'YEAH', "controller's foo QP property set before setupController called");
        }
      }));
      return this.visitAndAssert('/?foo=YEAH');
    }
    ['@test mapped query params have been set by the time setupController is called'](assert) {
      assert.expect(2);
      this.setSingleQPController('application', {
        faz: 'foo'
      });
      this.add('route:application', _route.default.extend({
        setupController(controller) {
          assert.equal(controller.get('faz'), 'YEAH', "controller's foo QP property set before setupController called");
        }
      }));
      return this.visitAndAssert('/?foo=YEAH');
    }
    ['@test Route#paramsFor fetches query params with default value'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _route.default.extend({
        model( /* params, transition */
        ) {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: 'bar'
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz');
    }
    ['@test Route#paramsFor fetches query params with non-default value'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _route.default.extend({
        model( /* params, transition */
        ) {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: 'boo'
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz?foo=boo');
    }
    ['@test Route#paramsFor fetches default falsy query params'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index', 'foo', false);
      this.add('route:index', _route.default.extend({
        model( /* params, transition */
        ) {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: false
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz');
    }
    ['@test Route#paramsFor fetches non-default falsy query params'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index', 'foo', true);
      this.add('route:index', _route.default.extend({
        model( /* params, transition */
        ) {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: false
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz?foo=false');
    }
    ['@test model hook can query prefix-less application params'](assert) {
      assert.expect(4);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:application', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            appomg: 'applol'
          });
        }
      }));
      this.add('route:index', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            omg: 'lol'
          });
          assert.deepEqual(this.paramsFor('application'), {
            appomg: 'applol'
          });
        }
      }));
      return this.visitAndAssert('/');
    }
    ['@test model hook can query prefix-less application params (overridden by incoming url value)'](assert) {
      assert.expect(4);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:application', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            appomg: 'appyes'
          });
        }
      }));
      this.add('route:index', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            omg: 'yes'
          });
          assert.deepEqual(this.paramsFor('application'), {
            appomg: 'appyes'
          });
        }
      }));
      return this.visitAndAssert('/?appomg=appyes&omg=yes');
    }
    async ['@test can opt into full transition by setting refreshModel in route queryParams'](assert) {
      assert.expect(7);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      let appModelCount = 0;
      this.add('route:application', _route.default.extend({
        model( /* params, transition */
        ) {
          appModelCount++;
        }
      }));
      let indexModelCount = 0;
      this.add('route:index', _route.default.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        model(params) {
          indexModelCount++;
          if (indexModelCount === 1) {
            assert.deepEqual(params, {
              omg: 'lol'
            }, 'params are correct on first pass');
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            }, 'params are correct on second pass');
          }
        }
      }));
      await this.visitAndAssert('/');
      assert.equal(appModelCount, 1, 'app model hook ran');
      assert.equal(indexModelCount, 1, 'index model hook ran');
      let indexController = this.getController('index');
      await this.setAndFlush(indexController, 'omg', 'lex');
      assert.equal(appModelCount, 1, 'app model hook did not run again');
      assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');
    }
    async ['@test refreshModel and replace work together'](assert) {
      assert.expect(8);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      let appModelCount = 0;
      this.add('route:application', _route.default.extend({
        model( /* params */
        ) {
          appModelCount++;
        }
      }));
      let indexModelCount = 0;
      this.add('route:index', _route.default.extend({
        queryParams: {
          omg: {
            refreshModel: true,
            replace: true
          }
        },
        model(params) {
          indexModelCount++;
          if (indexModelCount === 1) {
            assert.deepEqual(params, {
              omg: 'lol'
            }, 'params are correct on first pass');
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            }, 'params are correct on second pass');
          }
        }
      }));
      await this.visitAndAssert('/');
      assert.equal(appModelCount, 1, 'app model hook ran');
      assert.equal(indexModelCount, 1, 'index model hook ran');
      let indexController = this.getController('index');
      this.expectedReplaceURL = '/?omg=lex';
      await this.setAndFlush(indexController, 'omg', 'lex');
      assert.equal(appModelCount, 1, 'app model hook did not run again');
      assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');
    }
    async ['@test multiple QP value changes only cause a single model refresh'](assert) {
      assert.expect(2);
      this.setSingleQPController('index', 'alex', 'lol');
      this.setSingleQPController('index', 'steely', 'lel');
      let refreshCount = 0;
      this.add('route:index', _route.default.extend({
        queryParams: {
          alex: {
            refreshModel: true
          },
          steely: {
            refreshModel: true
          }
        },
        refresh() {
          refreshCount++;
        }
      }));
      await this.visitAndAssert('/');
      let indexController = this.getController('index');
      await this.setAndFlush(indexController, {
        alex: 'fran',
        steely: 'david'
      });
      assert.equal(refreshCount, 1, 'index refresh hook only run once');
    }
    ['@test refreshModel does not cause a second transition during app boot '](assert) {
      assert.expect(1);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:index', _route.default.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        refresh() {
          assert.ok(false);
        }
      }));
      return this.visitAndAssert('/?appomg=hello&omg=world');
    }
    async ['@test queryParams are updated when a controller property is set and the route is refreshed. Issue #13263  '](assert) {
      this.addTemplate('application', '<button id="test-button" {{action \'increment\'}}>Increment</button><span id="test-value">{{this.foo}}</span>{{outlet}}');
      this.setSingleQPController('application', 'foo', 1, {
        actions: {
          increment() {
            this.incrementProperty('foo');
            this.send('refreshRoute');
          }
        }
      });
      this.add('route:application', _route.default.extend({
        actions: {
          refreshRoute() {
            this.refresh();
          }
        }
      }));
      await this.visitAndAssert('/');
      assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '1');
      document.getElementById('test-button').click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '2');
      this.assertCurrentPath('/?foo=2');
      document.getElementById('test-button').click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '3');
      this.assertCurrentPath('/?foo=3');
    }
    async ["@test Use Ember.get to retrieve query params 'refreshModel' configuration"](assert) {
      assert.expect(7);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      let appModelCount = 0;
      this.add('route:application', _route.default.extend({
        model( /* params */
        ) {
          appModelCount++;
        }
      }));
      let indexModelCount = 0;
      this.add('route:index', _route.default.extend({
        queryParams: _object.default.create({
          unknownProperty() {
            return {
              refreshModel: true
            };
          }
        }),
        model(params) {
          indexModelCount++;
          if (indexModelCount === 1) {
            assert.deepEqual(params, {
              omg: 'lol'
            });
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            });
          }
        }
      }));
      await this.visitAndAssert('/');
      assert.equal(appModelCount, 1);
      assert.equal(indexModelCount, 1);
      let indexController = this.getController('index');
      await this.setAndFlush(indexController, 'omg', 'lex');
      assert.equal(appModelCount, 1);
      assert.equal(indexModelCount, 2);
    }
    async ['@test can use refreshModel even with URL changes that remove QPs from address bar'](assert) {
      assert.expect(4);
      this.setSingleQPController('index', 'omg', 'lol');
      let indexModelCount = 0;
      this.add('route:index', _route.default.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        model(params) {
          indexModelCount++;
          let data;
          if (indexModelCount === 1) {
            data = 'foo';
          } else if (indexModelCount === 2) {
            data = 'lol';
          }
          assert.deepEqual(params, {
            omg: data
          }, 'index#model receives right data');
        }
      }));
      await this.visitAndAssert('/?omg=foo');
      await this.transitionTo('/');
      let indexController = this.getController('index');
      assert.equal(indexController.get('omg'), 'lol');
    }
    async ['@test can opt into a replace query by specifying replace:true in the Route config hash'](assert) {
      assert.expect(2);
      this.setSingleQPController('application', 'alex', 'matchneer');
      this.add('route:application', _route.default.extend({
        queryParams: {
          alex: {
            replace: true
          }
        }
      }));
      await this.visitAndAssert('/');
      let appController = this.getController('application');
      this.expectedReplaceURL = '/?alex=wallace';
      await this.setAndFlush(appController, 'alex', 'wallace');
    }
    async ['@test Route query params config can be configured using property name instead of URL key'](assert) {
      assert.expect(2);
      this.add('controller:application', _controller.default.extend({
        queryParams: [{
          commitBy: 'commit_by'
        }]
      }));
      this.add('route:application', _route.default.extend({
        queryParams: {
          commitBy: {
            replace: true
          }
        }
      }));
      await this.visitAndAssert('/');
      let appController = this.getController('application');
      this.expectedReplaceURL = '/?commit_by=igor_seb';
      await this.setAndFlush(appController, 'commitBy', 'igor_seb');
    }
    async ['@test An explicit replace:false on a changed QP always wins and causes a pushState'](assert) {
      assert.expect(3);
      this.add('controller:application', _controller.default.extend({
        queryParams: ['alex', 'steely'],
        alex: 'matchneer',
        steely: 'dan'
      }));
      this.add('route:application', _route.default.extend({
        queryParams: {
          alex: {
            replace: true
          },
          steely: {
            replace: false
          }
        }
      }));
      await this.visit('/');
      let appController = this.getController('application');
      this.expectedPushURL = '/?alex=wallace&steely=jan';
      await this.setAndFlush(appController, {
        alex: 'wallace',
        steely: 'jan'
      });
      this.expectedPushURL = '/?alex=wallace&steely=fran';
      await this.setAndFlush(appController, {
        steely: 'fran'
      });
      this.expectedReplaceURL = '/?alex=sriracha&steely=fran';
      await this.setAndFlush(appController, 'alex', 'sriracha');
    }
    async ['@test can opt into full transition by setting refreshModel in route queryParams when transitioning from child to parent'](assert) {
      this.addTemplate('parent', '{{outlet}}');
      this.addTemplate('parent.child', "<LinkTo @route='parent' @query={{hash foo='change'}} id='parent-link'>Parent</LinkTo>");
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      let parentModelCount = 0;
      this.add('route:parent', class extends _route.default {
        constructor() {
          super(...arguments);
          this.queryParams = {
            foo: {
              refreshModel: true
            }
          };
        }
        model() {
          parentModelCount++;
        }
      });
      this.setSingleQPController('parent', 'foo', 'abc');
      await this.visit('/parent/child?foo=lol');
      assert.equal(parentModelCount, 1);
      (0, _runloop.run)(document.getElementById('parent-link'), 'click');
      assert.equal(parentModelCount, 2);
    }
    async ["@test Use Ember.get to retrieve query params 'replace' configuration"](assert) {
      assert.expect(2);
      this.setSingleQPController('application', 'alex', 'matchneer');
      this.add('route:application', _route.default.extend({
        queryParams: _object.default.create({
          unknownProperty( /* keyName */
          ) {
            // We are simulating all qps requiring refresh
            return {
              replace: true
            };
          }
        })
      }));
      await this.visitAndAssert('/');
      let appController = this.getController('application');
      this.expectedReplaceURL = '/?alex=wallace';
      await this.setAndFlush(appController, 'alex', 'wallace');
    }
    async ['@test can override incoming QP values in setupController'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('about');
      });
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:index', _route.default.extend({
        setupController(controller) {
          assert.ok(true, 'setupController called');
          controller.set('omg', 'OVERRIDE');
        },
        actions: {
          queryParamsDidChange() {
            assert.ok(false, "queryParamsDidChange shouldn't fire");
          }
        }
      }));
      await this.visitAndAssert('/about');
      await this.transitionTo('index');
      this.assertCurrentPath('/?omg=OVERRIDE');
    }
    async ['@test can override incoming QP array values in setupController'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('about');
      });
      this.setSingleQPController('index', 'omg', ['lol']);
      this.add('route:index', _route.default.extend({
        setupController(controller) {
          assert.ok(true, 'setupController called');
          controller.set('omg', ['OVERRIDE']);
        },
        actions: {
          queryParamsDidChange() {
            assert.ok(false, "queryParamsDidChange shouldn't fire");
          }
        }
      }));
      await this.visitAndAssert('/about');
      await this.transitionTo('index');
      this.assertCurrentPath('/?omg=' + encodeURIComponent(JSON.stringify(['OVERRIDE'])));
    }
    ['@test URL transitions that remove QPs still register as QP changes'](assert) {
      assert.expect(2);
      this.setSingleQPController('index', 'omg', 'lol');
      return this.visit('/?omg=borf').then(() => {
        let indexController = this.getController('index');
        assert.equal(indexController.get('omg'), 'borf');
        this.transitionTo('/');
        assert.equal(indexController.get('omg'), 'lol');
      });
    }
    async ['@test Subresource naming style is supported'](assert) {
      this.router.map(function () {
        this.route('abc.def', {
          path: '/abcdef'
        }, function () {
          this.route('zoo');
        });
      });
      this.addTemplate('application', "\n        <LinkTo @route='abc.def' @query={{hash foo='123'}} id='one'>A</LinkTo>\n        <LinkTo @route='abc.def.zoo' @query={{hash foo='123' bar='456'}} id='two'>B</LinkTo>\n        {{outlet}}\n        ");
      this.setSingleQPController('abc.def', 'foo', 'lol');
      this.setSingleQPController('abc.def.zoo', 'bar', 'haha');
      await this.visitAndAssert('/');
      assert.equal(this.$('#one').attr('href'), '/abcdef?foo=123');
      assert.equal(this.$('#two').attr('href'), '/abcdef/zoo?bar=456&foo=123');
      (0, _runloop.run)(this.$('#one'), 'click');
      this.assertCurrentPath('/abcdef?foo=123');
      (0, _runloop.run)(this.$('#two'), 'click');
      this.assertCurrentPath('/abcdef/zoo?bar=456&foo=123');
    }
    async ['@test transitionTo supports query params']() {
      this.setSingleQPController('index', 'foo', 'lol');
      await this.visitAndAssert('/');
      await this.transitionTo({
        queryParams: {
          foo: 'borf'
        }
      });
      this.assertCurrentPath('/?foo=borf', 'shorthand supported');
      await this.transitionTo({
        queryParams: {
          'index:foo': 'blaf'
        }
      });
      this.assertCurrentPath('/?foo=blaf', 'longform supported');
      await this.transitionTo({
        queryParams: {
          'index:foo': false
        }
      });
      this.assertCurrentPath('/?foo=false', 'longform supported (bool)');
      await this.transitionTo({
        queryParams: {
          foo: false
        }
      });
      this.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');
    }
    async ['@test transitionTo supports query params (multiple)']() {
      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: 'lol',
        bar: 'wat'
      }));
      await this.visitAndAssert('/');
      await this.transitionTo({
        queryParams: {
          foo: 'borf'
        }
      });
      this.assertCurrentPath('/?foo=borf', 'shorthand supported');
      await this.transitionTo({
        queryParams: {
          'index:foo': 'blaf'
        }
      });
      this.assertCurrentPath('/?foo=blaf', 'longform supported');
      await this.transitionTo({
        queryParams: {
          'index:foo': false
        }
      });
      this.assertCurrentPath('/?foo=false', 'longform supported (bool)');
      await this.transitionTo({
        queryParams: {
          foo: false
        }
      });
      this.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');
    }
    async ["@test setting controller QP to empty string doesn't generate null in URL"](assert) {
      assert.expect(1);
      this.setSingleQPController('index', 'foo', '123');
      await this.visit('/');
      let controller = this.getController('index');
      this.expectedPushURL = '/?foo=';
      await this.setAndFlush(controller, 'foo', '');
    }
    async ["@test setting QP to empty string doesn't generate null in URL"](assert) {
      assert.expect(1);
      this.add('route:index', _route.default.extend({
        queryParams: {
          foo: {
            defaultValue: '123'
          }
        }
      }));
      await this.visit('/');
      let controller = this.getController('index');
      this.expectedPushURL = '/?foo=';
      await this.setAndFlush(controller, 'foo', '');
    }
    ['@test A default boolean value deserializes QPs as booleans rather than strings'](assert) {
      assert.expect(3);
      this.setSingleQPController('index', 'foo', false);
      this.add('route:index', _route.default.extend({
        model(params) {
          assert.equal(params.foo, true, 'model hook received foo as boolean true');
        }
      }));
      return this.visit('/?foo=true').then(() => {
        let controller = this.getController('index');
        assert.equal(controller.get('foo'), true);
        this.transitionTo('/?foo=false');
        assert.equal(controller.get('foo'), false);
      });
    }
    ['@test Query param without value are empty string'](assert) {
      assert.expect(1);
      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: ''
      }));
      return this.visit('/?foo=').then(() => {
        let controller = this.getController('index');
        assert.equal(controller.get('foo'), '');
      });
    }
    async ['@test Array query params can be set'](assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.setSingleQPController('home', 'foo', []);
      await this.visit('/');
      let controller = this.getController('home');
      await this.setAndFlush(controller, 'foo', [1, 2]);
      this.assertCurrentPath('/?foo=%5B1%2C2%5D');
      await this.setAndFlush(controller, 'foo', [3, 4]);
      this.assertCurrentPath('/?foo=%5B3%2C4%5D');
    }
    async ['@test (de)serialization: arrays'](assert) {
      assert.expect(4);
      this.setSingleQPController('index', 'foo', [1]);
      await this.visitAndAssert('/');
      await this.transitionTo({
        queryParams: {
          foo: [2, 3]
        }
      });
      this.assertCurrentPath('/?foo=%5B2%2C3%5D', 'shorthand supported');
      await this.transitionTo({
        queryParams: {
          'index:foo': [4, 5]
        }
      });
      this.assertCurrentPath('/?foo=%5B4%2C5%5D', 'longform supported');
      await this.transitionTo({
        queryParams: {
          foo: []
        }
      });
      this.assertCurrentPath('/?foo=%5B%5D', 'longform supported');
    }
    ['@test Url with array query param sets controller property to array'](assert) {
      assert.expect(1);
      this.setSingleQPController('index', 'foo', '');
      return this.visit('/?foo[]=1&foo[]=2&foo[]=3').then(() => {
        let controller = this.getController('index');
        assert.deepEqual(controller.get('foo'), ['1', '2', '3']);
      });
    }
    async ['@test Array query params can be pushed/popped'](assert) {
      assert.expect(17);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.setSingleQPController('home', 'foo', (0, _array.A)());
      await this.visitAndAssert('/');
      let controller = this.getController('home');
      controller.foo.pushObject(1);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B1%5D');
      assert.deepEqual(controller.foo, [1]);
      controller.foo.popObject();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/');
      assert.deepEqual(controller.foo, []);
      controller.foo.pushObject(1);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B1%5D');
      assert.deepEqual(controller.foo, [1]);
      controller.foo.popObject();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/');
      assert.deepEqual(controller.foo, []);
      controller.foo.pushObject(1);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B1%5D');
      assert.deepEqual(controller.foo, [1]);
      controller.foo.pushObject(2);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B1%2C2%5D');
      assert.deepEqual(controller.foo, [1, 2]);
      controller.foo.popObject();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B1%5D');
      assert.deepEqual(controller.foo, [1]);
      controller.foo.unshiftObject('lol');
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B%22lol%22%2C1%5D');
      assert.deepEqual(controller.foo, ['lol', 1]);
    }
    async ["@test Overwriting with array with same content shouldn't refire update"](assert) {
      assert.expect(4);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      let modelCount = 0;
      this.add('route:home', _route.default.extend({
        model() {
          modelCount++;
        }
      }));
      this.setSingleQPController('home', 'foo', (0, _array.A)([1]));
      await this.visitAndAssert('/');
      assert.equal(modelCount, 1);
      let controller = this.getController('home');
      await this.setAndFlush(controller, 'model', (0, _array.A)([1]));
      assert.equal(modelCount, 1);
      this.assertCurrentPath('/');
    }
    ['@test Defaulting to params hash as the model should not result in that params object being watched'](assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('other');
      });

      // This causes the params hash, which is returned as a route's
      // model if no other model could be resolved given the provided
      // params (and no custom model hook was defined), to be watched,
      // unless we return a copy of the params hash.
      this.setSingleQPController('application', 'woot', 'wat');
      this.add('route:other', _route.default.extend({
        model(p, trans) {
          let m = (0, _meta.peekMeta)(trans[_router_js.PARAMS_SYMBOL].application);
          assert.ok(m === null, "A meta object isn't constructed for this params POJO");
        }
      }));
      return this.visit('/').then(() => {
        return this.transitionTo('other');
      });
    }
    async ['@test Setting bound query param property to null or undefined does not serialize to url'](assert) {
      assert.expect(9);
      this.router.map(function () {
        this.route('home');
      });
      this.setSingleQPController('home', 'foo', [1, 2]);
      await this.visitAndAssert('/home');
      let controller = this.getController('home');
      assert.deepEqual(controller.get('foo'), [1, 2]);
      this.assertCurrentPath('/home');
      await this.setAndFlush(controller, 'foo', (0, _array.A)([1, 3]));
      this.assertCurrentPath('/home?foo=%5B1%2C3%5D');
      await this.transitionTo('/home');
      assert.deepEqual(controller.get('foo'), [1, 2]);
      this.assertCurrentPath('/home');
      await this.setAndFlush(controller, 'foo', null);
      this.assertCurrentPath('/home', 'Setting property to null');
      await this.setAndFlush(controller, 'foo', (0, _array.A)([1, 3]));
      this.assertCurrentPath('/home?foo=%5B1%2C3%5D');
      await this.setAndFlush(controller, 'foo', undefined);
      this.assertCurrentPath('/home', 'Setting property to undefined');
    }
    async ['@test <LinkTo> with null or undefined QPs does not get serialized into url'](assert) {
      this.addTemplate('home', "\n        <LinkTo @route='home' @query={{hash foo=this.nullValue}} id='null-link'>Home</LinkTo>\n        <LinkTo @route='home' @query={{hash foo=this.undefinedValue}} id='undefined-link'>Home</LinkTo>\n        ");
      this.router.map(function () {
        this.route('home');
      });
      this.setSingleQPController('home', 'foo', [], {
        nullValue: null,
        undefinedValue: undefined
      });
      await this.visitAndAssert('/home');
      assert.equal(this.$('#null-link').attr('href'), '/home');
      assert.equal(this.$('#undefined-link').attr('href'), '/home');
    }
    ["@test A child of a resource route still defaults to parent route's model even if the child route has a query param"](assert) {
      assert.expect(2);
      this.setSingleQPController('index', 'woot', undefined, {
        woot: undefined
      });
      this.add('route:application', _route.default.extend({
        model( /* p, trans */
        ) {
          return {
            woot: true
          };
        }
      }));
      this.add('route:index', _route.default.extend({
        setupController(controller, model) {
          assert.deepEqual(model, {
            woot: true
          }, 'index route inherited model route from parent route');
        }
      }));
      return this.visitAndAssert('/');
    }
    async ['@test opting into replace does not affect transitions between routes']() {
      this.addTemplate('application', "\n        <LinkTo @route='foo' id='foo-link'>Foo</LinkTo>\n        <LinkTo @route='bar' id='bar-no-qp-link'>Bar</LinkTo>\n        <LinkTo @route='bar' @query={{hash raytiley='isthebest'}} id='bar-link'>Bar</LinkTo>\n        {{outlet}}\n        ");
      this.router.map(function () {
        this.route('foo');
        this.route('bar');
      });
      this.setSingleQPController('bar', 'raytiley', 'israd');
      this.add('route:bar', class extends _route.default {
        constructor() {
          super(...arguments);
          this.queryParams = {
            raytiley: {
              replace: true
            }
          };
        }
      });
      await this.visit('/');
      let controller = this.getController('bar');
      this.expectedPushURL = '/foo';
      (0, _runloop.run)(document.getElementById('foo-link'), 'click');
      this.expectedPushURL = '/bar';
      (0, _runloop.run)(document.getElementById('bar-no-qp-link'), 'click');
      this.expectedReplaceURL = '/bar?raytiley=woot';
      await this.setAndFlush(controller, 'raytiley', 'woot');
      this.expectedPushURL = '/foo';
      (0, _runloop.run)(document.getElementById('foo-link'), 'click');
      this.expectedPushURL = '/bar?raytiley=isthebest';
      (0, _runloop.run)(document.getElementById('bar-link'), 'click');
    }
    async ["@test undefined isn't serialized or deserialized into a string"](assert) {
      this.router.map(function () {
        this.route('example');
      });
      this.addTemplate('application', "<LinkTo @route='example' @query={{hash foo=undefined}} id='the-link'>Example</LinkTo>");
      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });
      let entered = 0;
      this.add('route:example', class extends _route.default {
        model(params) {
          entered++;
          assert.deepEqual(params, {
            foo: undefined
          });
        }
      });
      await this.visitAndAssert('/');
      assert.equal(this.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');
      await this.transitionTo('example', {
        queryParams: {
          foo: undefined
        }
      });
      assert.equal(entered, 1, 'Should have entered example route');
      this.assertCurrentPath('/example');
    }
    ['@test when refreshModel is true and loading hook is undefined, model hook will rerun when QPs change even if previous did not finish']() {
      return this.refreshModelWhileLoadingTest();
    }
    ['@test when refreshModel is true and loading hook returns false, model hook will rerun when QPs change even if previous did not finish']() {
      return this.refreshModelWhileLoadingTest(false);
    }
    ['@test when refreshModel is true and loading hook returns true, model hook will rerun when QPs change even if previous did not finish']() {
      return this.refreshModelWhileLoadingTest(true);
    }
    async ["@test warn user that Route's queryParams configuration must be an Object, not an Array"](assert) {
      assert.expect(1);
      this.add('route:application', _route.default.extend({
        queryParams: [{
          commitBy: {
            replace: true
          }
        }]
      }));
      await assert.rejectsAssertion(this.visit('/'), 'You passed in `[{"commitBy":{"replace":true}}]` as the value for `queryParams` but `queryParams` cannot be an Array');
    }
    async ['@test handle route names that clash with Object.prototype properties'](assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('constructor');
      });
      this.add('route:constructor', _route.default.extend({
        queryParams: {
          foo: {
            defaultValue: '123'
          }
        }
      }));
      await this.visit('/');
      await this.transitionTo('constructor', {
        queryParams: {
          foo: '999'
        }
      });
      let controller = this.getController('constructor');
      assert.equal((0, _object.get)(controller, 'foo'), '999');
    }
    async ['@test Single query params defined with tracked properties can be on the controller and reflected in the url'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add("controller:home", _controller.default.extend({
        queryParams: ['foo'],
        foo: (0, _metal.tracked)()
      }));
      await this.visitAndAssert('/');
      let controller = this.getController('home');
      controller.foo = '456';
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=456');
      controller.foo = '987';
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=987');
    }
    async ['@test Single query params defined with tracked properties can be linked to (and log is present)'](assert) {
      var _class3, _descriptor, _descriptor2;
      assert.expect(3);
      this.addTemplate('application', "\n          <LinkTo @route=\"application\" id=\"the-link\">\n            Home\n          </LinkTo>\n          <LinkTo @route=\"application\" @query={{hash foo=(array 123)}} id=\"the-link-with-params\">\n            'Home (with params)'\n          </LinkTo>\n\n          <!-- this log caused a failure previously, so we leave it to make sure this case is tested -->\n          {{log this.foo}}\n        ");
      this.add("controller:application", (_class3 = class _class3 extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['foo', 'bar'];
          _initializerDefineProperty(this, "foo", _descriptor, this);
          _initializerDefineProperty(this, "bar", _descriptor2, this);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class3.prototype, "foo", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "bar", [_metal.tracked], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      })), _class3));
      await this.visitAndAssert('/');
      document.getElementById('the-link').click();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/');
      document.getElementById('the-link-with-params').click();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=%5B123%5D');
    }
    async ['@test Single query params defined with native getters and tracked properties can be on the controller and reflected in the url'](assert) {
      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add("controller:home", _controller.default.extend({
        queryParams: ['foo'],
        get foo() {
          return this.bar;
        },
        set foo(value) {
          this.bar = value;
        },
        bar: (0, _metal.tracked)()
      }));
      await this.visitAndAssert('/');
      let controller = this.getController('home');
      controller.bar = '456';
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=456');
      controller.bar = '987';
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/?foo=987');
    }
    async ["@test Updating single query parameter doesn't affect other query parameters. Issue #14438"](assert) {
      assert.expect(5);
      this.router.map(function () {
        this.route('grandparent', {
          path: 'grandparent/:foo'
        }, function () {
          this.route('parent', function () {
            this.route('child');
          });
        });
      });
      this.addTemplate('grandparent.parent.loading', 'Loading...');
      this.add('route:index', _route.default.extend({
        router: (0, _service.service)(),
        redirect() {
          this.router.transitionTo('grandparent.parent.child', 1);
        }
      }));
      this.add('route:grandparent.parent.child', _route.default.extend({
        model() {
          return Promise.resolve();
        }
      }));
      this.add('controller:grandparent.parent', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: 'FOO',
        bar: 'BAR'
      }));
      await this.visit('/');
      this.assertCurrentPath('/grandparent/1/parent/child');
      let parentController = this.getController('grandparent.parent');
      await this.setAndFlush(parentController, 'foo', 'NEW_FOO');
      assert.equal(parentController.foo, 'NEW_FOO');
      this.assertCurrentPath('/grandparent/1/parent/child?foo=NEW_FOO');
      await this.setAndFlush(parentController, 'bar', 'NEW_BAR');
      assert.equal(parentController.bar, 'NEW_BAR');
      this.assertCurrentPath('/grandparent/1/parent/child?bar=NEW_BAR&foo=NEW_FOO');
    }
  });
});
define("ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test", ["@ember/controller", "@ember/array", "@ember/routing/route", "@ember/object", "internal-test-helpers"], function (_controller, _array, _route, _object, _internalTestHelpers) {
  "use strict";

  class ModelDependentQPTestCase extends _internalTestHelpers.QueryParamTestCase {
    boot() {
      this.setupApplication();
      return this.visitApplication();
    }
    teardown() {
      super.teardown(...arguments);
      this.assert.ok(!this.expectedModelHookParams, 'there should be no pending expectation of expected model hook params');
    }
    reopenController(name, options) {
      this.application.resolveRegistration("controller:" + name).reopen(options);
    }
    reopenRoute(name, options) {
      this.application.resolveRegistration("route:" + name).reopen(options);
    }
    async queryParamsStickyTest1(urlPrefix) {
      let assert = this.assert;
      assert.expect(14);
      await this.boot();
      this.$link1.click();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath(urlPrefix + "/a-1");
      await this.setAndFlush(this.controller, 'q', 'lol');
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
      this.$link2.click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(this.controller.get('q'), 'wat');
      assert.equal(this.controller.get('z'), 0);
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
    }
    async queryParamsStickyTest2(urlPrefix) {
      let assert = this.assert;
      assert.expect(24);
      await this.boot();
      this.expectedModelHookParams = {
        id: 'a-1',
        q: 'lol',
        z: 0
      };
      await this.transitionTo(urlPrefix + "/a-1?q=lol");
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-1'
      });
      assert.equal(this.controller.get('q'), 'lol');
      assert.equal(this.controller.get('z'), 0);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
      this.expectedModelHookParams = {
        id: 'a-2',
        q: 'lol',
        z: 0
      };
      await this.transitionTo(urlPrefix + "/a-2?q=lol");
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-2'
      }, "controller's model changed to a-2");
      assert.equal(this.controller.get('q'), 'lol');
      assert.equal(this.controller.get('z'), 0);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
      this.expectedModelHookParams = {
        id: 'a-3',
        q: 'lol',
        z: 123
      };
      await this.transitionTo(urlPrefix + "/a-3?q=lol&z=123");
      assert.equal(this.controller.get('q'), 'lol');
      assert.equal(this.controller.get('z'), 123);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol&z=123");
    }
    async queryParamsStickyTest3(urlPrefix, articleLookup) {
      let assert = this.assert;
      assert.expect(32);
      this.addTemplate('application', "\n      {{#each articles as |a|}}\n        <LinkTo @route='" + articleLookup + "' @model={{a.id}} id={{a.id}}>Article</LinkTo>\n      {{/each}}\n      ");
      await this.boot();
      this.expectedModelHookParams = {
        id: 'a-1',
        q: 'wat',
        z: 0
      };
      await this.transitionTo(articleLookup, 'a-1');
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-1'
      });
      assert.equal(this.controller.get('q'), 'wat');
      assert.equal(this.controller.get('z'), 0);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
      this.expectedModelHookParams = {
        id: 'a-2',
        q: 'lol',
        z: 0
      };
      await this.transitionTo(articleLookup, 'a-2', {
        queryParams: {
          q: 'lol'
        }
      });
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.controller.get('q'), 'lol');
      assert.equal(this.controller.get('z'), 0);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
      this.expectedModelHookParams = {
        id: 'a-3',
        q: 'hay',
        z: 0
      };
      await this.transitionTo(articleLookup, 'a-3', {
        queryParams: {
          q: 'hay'
        }
      });
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-3'
      });
      assert.equal(this.controller.get('q'), 'hay');
      assert.equal(this.controller.get('z'), 0);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=hay");
      this.expectedModelHookParams = {
        id: 'a-2',
        q: 'lol',
        z: 1
      };
      await this.transitionTo(articleLookup, 'a-2', {
        queryParams: {
          z: 1
        }
      });
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.controller.get('q'), 'lol');
      assert.equal(this.controller.get('z'), 1);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol&z=1");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=hay");
    }
    async queryParamsStickyTest4(urlPrefix, articleLookup) {
      let assert = this.assert;
      assert.expect(24);
      this.setupApplication();
      this.reopenController(articleLookup, {
        queryParams: {
          q: {
            scope: 'controller'
          }
        }
      });
      await this.visitApplication();
      this.$link1.click();
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath(urlPrefix + "/a-1");
      await this.setAndFlush(this.controller, 'q', 'lol');
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol");
      this.$link2.click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(this.controller.get('q'), 'lol');
      assert.equal(this.controller.get('z'), 0);
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol");
      this.expectedModelHookParams = {
        id: 'a-3',
        q: 'haha',
        z: 123
      };
      await this.transitionTo(urlPrefix + "/a-3?q=haha&z=123");
      assert.deepEqual(this.controller.get('model'), {
        id: 'a-3'
      });
      assert.equal(this.controller.get('q'), 'haha');
      assert.equal(this.controller.get('z'), 123);
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=haha");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=haha");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=haha&z=123");
      await this.setAndFlush(this.controller, 'q', 'woot');
      assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=woot");
      assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=woot");
      assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=woot&z=123");
    }
    async queryParamsStickyTest5(urlPrefix, commentsLookupKey) {
      let assert = this.assert;
      assert.expect(12);
      await this.boot();
      await this.transitionTo(commentsLookupKey, 'a-1');
      let commentsCtrl = this.getController(commentsLookupKey);
      assert.equal(commentsCtrl.get('page'), 1);
      this.assertCurrentPath(urlPrefix + "/a-1/comments");
      await this.setAndFlush(commentsCtrl, 'page', 2);
      this.assertCurrentPath(urlPrefix + "/a-1/comments?page=2");
      await this.setAndFlush(commentsCtrl, 'page', 3);
      this.assertCurrentPath(urlPrefix + "/a-1/comments?page=3");
      await this.transitionTo(commentsLookupKey, 'a-2');
      assert.equal(commentsCtrl.get('page'), 1);
      this.assertCurrentPath(urlPrefix + "/a-2/comments");
      await this.transitionTo(commentsLookupKey, 'a-1');
      assert.equal(commentsCtrl.get('page'), 3);
      this.assertCurrentPath(urlPrefix + "/a-1/comments?page=3");
    }
    async queryParamsStickyTest6(urlPrefix, articleLookup, commentsLookup) {
      let assert = this.assert;
      assert.expect(13);
      this.setupApplication();
      this.reopenRoute(articleLookup, {
        resetController(controller, isExiting) {
          this.controllerFor(commentsLookup).set('page', 1);
          if (isExiting) {
            controller.set('q', 'imdone');
          }
        }
      });
      this.addTemplate('about', "\n      <LinkTo @route='" + commentsLookup + "' @model='a-1' id='one'>A</LinkTo>\n      <LinkTo @route='" + commentsLookup + "' @model='a-2' id='two'>B</LinkTo>\n      ");
      await this.visitApplication();
      await this.transitionTo(commentsLookup, 'a-1');
      let commentsCtrl = this.getController(commentsLookup);
      assert.equal(commentsCtrl.get('page'), 1);
      this.assertCurrentPath(urlPrefix + "/a-1/comments");
      await this.setAndFlush(commentsCtrl, 'page', 2);
      this.assertCurrentPath(urlPrefix + "/a-1/comments?page=2");
      await this.transitionTo(commentsLookup, 'a-2');
      assert.equal(commentsCtrl.get('page'), 1);
      assert.equal(this.controller.get('q'), 'wat');
      await this.transitionTo(commentsLookup, 'a-1');
      this.assertCurrentPath(urlPrefix + "/a-1/comments");
      assert.equal(commentsCtrl.get('page'), 1);
      await this.transitionTo('about');
      assert.equal(document.getElementById('one').getAttribute('href'), urlPrefix + "/a-1/comments?q=imdone");
      assert.equal(document.getElementById('two').getAttribute('href'), urlPrefix + "/a-2/comments");
    }
  }
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state', class extends ModelDependentQPTestCase {
    setupApplication() {
      this.router.map(function () {
        this.route('article', {
          path: '/a/:id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          });
        });
        this.route('about');
      });
      let articles = (0, _array.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        articles
      }));
      let self = this;
      let assert = this.assert;
      this.add('route:article', _route.default.extend({
        model(params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }
          return articles.findBy('id', params.id);
        }
      }));
      this.add('controller:article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:comments', _controller.default.extend({
        queryParams: 'page',
        page: 1
      }));
      this.addTemplate('application', "\n        {{#each this.articles as |a|}}\n          <LinkTo @route='article' @model={{a}} id={{a.id}}>Article</LinkTo>\n        {{/each}}\n        {{outlet}}\n        ");
    }
    visitApplication() {
      return this.visit('/').then(() => {
        let assert = this.assert;
        this.$link1 = document.getElementById('a-1');
        this.$link2 = document.getElementById('a-2');
        this.$link3 = document.getElementById('a-3');
        assert.equal(this.$link1.getAttribute('href'), '/a/a-1');
        assert.equal(this.$link2.getAttribute('href'), '/a/a-2');
        assert.equal(this.$link3.getAttribute('href'), '/a/a-3');
        this.controller = this.getController('article');
      });
    }
    ["@test query params have 'model' stickiness by default"]() {
      return this.queryParamsStickyTest1('/a');
    }
    ["@test query params have 'model' stickiness by default (url changes)"]() {
      return this.queryParamsStickyTest2('/a');
    }
    ["@test query params have 'model' stickiness by default (params-based transitions)"]() {
      return this.queryParamsStickyTest3('/a', 'article');
    }
    ["@test 'controller' stickiness shares QP state between models"]() {
      return this.queryParamsStickyTest4('/a', 'article');
    }
    ["@test 'model' stickiness is scoped to current or first dynamic parent route"]() {
      return this.queryParamsStickyTest5('/a', 'comments');
    }
    ['@test can reset query params using the resetController hook']() {
      return this.queryParamsStickyTest6('/a', 'article', 'comments');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state (nested)', class extends ModelDependentQPTestCase {
    setupApplication() {
      this.router.map(function () {
        this.route('site', function () {
          this.route('article', {
            path: '/a/:id'
          }, function () {
            this.route('comments');
          });
        });
        this.route('about');
      });
      let site_articles = (0, _array.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        articles: site_articles
      }));
      let self = this;
      let assert = this.assert;
      this.add('route:site.article', _route.default.extend({
        model(params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }
          return site_articles.findBy('id', params.id);
        }
      }));
      this.add('controller:site.article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:site.article.comments', _controller.default.extend({
        queryParams: 'page',
        page: 1
      }));
      this.addTemplate('application', "\n        {{#each this.articles as |a|}}\n          <LinkTo @route='site.article' @model={{a}} id={{a.id}}>Article</LinkTo>\n        {{/each}}\n        {{outlet}}\n        ");
    }
    visitApplication() {
      return this.visit('/').then(() => {
        let assert = this.assert;
        this.$link1 = document.getElementById('a-1');
        this.$link2 = document.getElementById('a-2');
        this.$link3 = document.getElementById('a-3');
        assert.equal(this.$link1.getAttribute('href'), '/site/a/a-1');
        assert.equal(this.$link2.getAttribute('href'), '/site/a/a-2');
        assert.equal(this.$link3.getAttribute('href'), '/site/a/a-3');
        this.controller = this.getController('site.article');
      });
    }
    ["@test query params have 'model' stickiness by default"]() {
      return this.queryParamsStickyTest1('/site/a');
    }
    ["@test query params have 'model' stickiness by default (url changes)"]() {
      return this.queryParamsStickyTest2('/site/a');
    }
    ["@test query params have 'model' stickiness by default (params-based transitions)"]() {
      return this.queryParamsStickyTest3('/site/a', 'site.article');
    }
    ["@test 'controller' stickiness shares QP state between models"]() {
      return this.queryParamsStickyTest4('/site/a', 'site.article');
    }
    ["@test 'model' stickiness is scoped to current or first dynamic parent route"]() {
      return this.queryParamsStickyTest5('/site/a', 'site.article.comments');
    }
    ['@test can reset query params using the resetController hook']() {
      return this.queryParamsStickyTest6('/site/a', 'site.article', 'site.article.comments');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state (nested & more than 1 dynamic segment)', class extends ModelDependentQPTestCase {
    setupApplication() {
      this.router.map(function () {
        this.route('site', {
          path: '/site/:site_id'
        }, function () {
          this.route('article', {
            path: '/a/:article_id'
          }, function () {
            this.route('comments');
          });
        });
      });
      let sites = (0, _array.A)([{
        id: 's-1'
      }, {
        id: 's-2'
      }, {
        id: 's-3'
      }]);
      let site_articles = (0, _array.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        siteArticles: site_articles,
        sites,
        allSitesAllArticles: (0, _object.computed)({
          get() {
            let ret = [];
            let siteArticles = this.siteArticles;
            let sites = this.sites;
            sites.forEach(site => {
              ret = ret.concat(siteArticles.map(article => {
                return {
                  id: site.id + "-" + article.id,
                  site_id: site.id,
                  article_id: article.id
                };
              }));
            });
            return ret;
          }
        })
      }));
      let self = this;
      let assert = this.assert;
      this.add('route:site', _route.default.extend({
        model(params) {
          if (self.expectedSiteModelHookParams) {
            assert.deepEqual(params, self.expectedSiteModelHookParams, 'the SiteRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedSiteModelHookParams = null;
          }
          return sites.findBy('id', params.site_id);
        }
      }));
      this.add('route:site.article', _route.default.extend({
        model(params) {
          if (self.expectedArticleModelHookParams) {
            assert.deepEqual(params, self.expectedArticleModelHookParams, 'the SiteArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedArticleModelHookParams = null;
          }
          return site_articles.findBy('id', params.article_id);
        }
      }));
      this.add('controller:site', _controller.default.extend({
        queryParams: ['country'],
        country: 'au'
      }));
      this.add('controller:site.article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:site.article.comments', _controller.default.extend({
        queryParams: ['page'],
        page: 1
      }));
      this.addTemplate('application', "\n        {{#each this.allSitesAllArticles as |a|}}\n          <LinkTo @route='site.article' @models={{array a.site_id a.article_id}} id={{a.id}}>\n            Article [{{a.site_id}}] [{{a.article_id}}]\n          </LinkTo>\n        {{/each}}\n        {{outlet}}\n        ");
    }
    visitApplication() {
      return this.visit('/').then(() => {
        let assert = this.assert;
        this.links = {};
        this.links['s-1-a-1'] = document.getElementById('s-1-a-1');
        this.links['s-1-a-2'] = document.getElementById('s-1-a-2');
        this.links['s-1-a-3'] = document.getElementById('s-1-a-3');
        this.links['s-2-a-1'] = document.getElementById('s-2-a-1');
        this.links['s-2-a-2'] = document.getElementById('s-2-a-2');
        this.links['s-2-a-3'] = document.getElementById('s-2-a-3');
        this.links['s-3-a-1'] = document.getElementById('s-3-a-1');
        this.links['s-3-a-2'] = document.getElementById('s-3-a-2');
        this.links['s-3-a-3'] = document.getElementById('s-3-a-3');
        assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        this.site_controller = this.getController('site');
        this.article_controller = this.getController('site.article');
      });
    }
    async ["@test query params have 'model' stickiness by default"](assert) {
      assert.expect(59);
      await this.boot();
      this.links['s-1-a-1'].click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-1'
      });
      this.assertCurrentPath('/site/s-1/a/a-1');
      await this.setAndFlush(this.article_controller, 'q', 'lol');
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      await this.setAndFlush(this.site_controller, 'country', 'us');
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.links['s-1-a-2'].click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(this.site_controller.get('country'), 'us');
      assert.equal(this.article_controller.get('q'), 'wat');
      assert.equal(this.article_controller.get('z'), 0);
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.links['s-2-a-2'].click();
      await (0, _internalTestHelpers.runLoopSettled)();
      assert.equal(this.site_controller.get('country'), 'au');
      assert.equal(this.article_controller.get('q'), 'wat');
      assert.equal(this.article_controller.get('z'), 0);
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-2'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
    }
    async ["@test query params have 'model' stickiness by default (url changes)"](assert) {
      assert.expect(88);
      await this.boot();
      this.expectedSiteModelHookParams = {
        site_id: 's-1',
        country: 'au'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-1',
        q: 'lol',
        z: 0
      };
      await this.transitionTo('/site/s-1/a/a-1?q=lol');
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      }, "site controller's model is s-1");
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-1'
      }, "article controller's model is a-1");
      assert.equal(this.site_controller.get('country'), 'au');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.expectedSiteModelHookParams = {
        site_id: 's-2',
        country: 'us'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-1',
        q: 'lol',
        z: 0
      };
      await this.transitionTo('/site/s-2/a/a-1?country=us&q=lol');
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-2'
      }, "site controller's model is s-2");
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-1'
      }, "article controller's model is a-1");
      assert.equal(this.site_controller.get('country'), 'us');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.expectedSiteModelHookParams = {
        site_id: 's-2',
        country: 'us'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-2',
        q: 'lol',
        z: 0
      };
      await this.transitionTo('/site/s-2/a/a-2?country=us&q=lol');
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-2'
      }, "site controller's model is s-2");
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-2'
      }, "article controller's model is a-2");
      assert.equal(this.site_controller.get('country'), 'us');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.expectedSiteModelHookParams = {
        site_id: 's-2',
        country: 'us'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-3',
        q: 'lol',
        z: 123
      };
      await this.transitionTo('/site/s-2/a/a-3?country=us&q=lol&z=123');
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-2'
      }, "site controller's model is s-2");
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-3'
      }, "article controller's model is a-3");
      assert.equal(this.site_controller.get('country'), 'us');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 123);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=lol&z=123');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=lol&z=123');
      this.expectedSiteModelHookParams = {
        site_id: 's-3',
        country: 'nz'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-3',
        q: 'lol',
        z: 123
      };
      await this.transitionTo('/site/s-3/a/a-3?country=nz&q=lol&z=123');
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-3'
      }, "site controller's model is s-3");
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-3'
      }, "article controller's model is a-3");
      assert.equal(this.site_controller.get('country'), 'nz');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 123);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=lol&z=123');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?country=nz&q=lol');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?country=nz&q=lol');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?country=nz&q=lol&z=123');
    }
    async ["@test query params have 'model' stickiness by default (params-based transitions)"](assert) {
      assert.expect(118);
      await this.boot();
      this.expectedSiteModelHookParams = {
        site_id: 's-1',
        country: 'au'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-1',
        q: 'wat',
        z: 0
      };
      await this.transitionTo('site.article', 's-1', 'a-1');
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-1'
      });
      assert.equal(this.site_controller.get('country'), 'au');
      assert.equal(this.article_controller.get('q'), 'wat');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.expectedSiteModelHookParams = {
        site_id: 's-1',
        country: 'au'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-2',
        q: 'lol',
        z: 0
      };
      await this.transitionTo('site.article', 's-1', 'a-2', {
        queryParams: {
          q: 'lol'
        }
      });
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.site_controller.get('country'), 'au');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      this.expectedSiteModelHookParams = {
        site_id: 's-1',
        country: 'au'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-3',
        q: 'hay',
        z: 0
      };
      await this.transitionTo('site.article', 's-1', 'a-3', {
        queryParams: {
          q: 'hay'
        }
      });
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-3'
      });
      assert.equal(this.site_controller.get('country'), 'au');
      assert.equal(this.article_controller.get('q'), 'hay');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?q=hay');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
      this.expectedSiteModelHookParams = {
        site_id: 's-1',
        country: 'au'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-2',
        q: 'lol',
        z: 1
      };
      await this.transitionTo('site.article', 's-1', 'a-2', {
        queryParams: {
          z: 1
        }
      });
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-1'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.site_controller.get('country'), 'au');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 1);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?q=hay');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
      this.expectedSiteModelHookParams = {
        site_id: 's-2',
        country: 'us'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-2',
        q: 'lol',
        z: 1
      };
      await this.transitionTo('site.article', 's-2', 'a-2', {
        queryParams: {
          country: 'us'
        }
      });
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-2'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-2'
      });
      assert.equal(this.site_controller.get('country'), 'us');
      assert.equal(this.article_controller.get('q'), 'lol');
      assert.equal(this.article_controller.get('z'), 1);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
      this.expectedSiteModelHookParams = {
        site_id: 's-2',
        country: 'us'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-1',
        q: 'yeah',
        z: 0
      };
      await this.transitionTo('site.article', 's-2', 'a-1', {
        queryParams: {
          q: 'yeah'
        }
      });
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-2'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-1'
      });
      assert.equal(this.site_controller.get('country'), 'us');
      assert.equal(this.article_controller.get('q'), 'yeah');
      assert.equal(this.article_controller.get('z'), 0);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=yeah');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=yeah');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=yeah');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
      this.expectedSiteModelHookParams = {
        site_id: 's-3',
        country: 'nz'
      };
      this.expectedArticleModelHookParams = {
        article_id: 'a-3',
        q: 'hay',
        z: 3
      };
      await this.transitionTo('site.article', 's-3', 'a-3', {
        queryParams: {
          country: 'nz',
          z: 3
        }
      });
      assert.deepEqual(this.site_controller.get('model'), {
        id: 's-3'
      });
      assert.deepEqual(this.article_controller.get('model'), {
        id: 'a-3'
      });
      assert.equal(this.site_controller.get('country'), 'nz');
      assert.equal(this.article_controller.get('q'), 'hay');
      assert.equal(this.article_controller.get('z'), 3);
      assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=yeah');
      assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
      assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay&z=3');
      assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=yeah');
      assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
      assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay&z=3');
      assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?country=nz&q=yeah');
      assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?country=nz&q=lol&z=1');
      assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?country=nz&q=hay&z=3');
    }
  });
});
define("ember/tests/routing/query_params_test/overlapping_query_params_test", ["@ember/controller", "@ember/routing/route", "@ember/object/mixin", "internal-test-helpers"], function (_controller, _route, _mixin, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - overlapping query param property names', class extends _internalTestHelpers.QueryParamTestCase {
    setupBase() {
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      return this.visit('/parent/child');
    }
    async ['@test can remap same-named qp props'](assert) {
      assert.expect(7);
      this.setMappedQPController('parent');
      this.setMappedQPController('parent.child', 'page', 'childPage');
      await this.setupBase();
      this.assertCurrentPath('/parent/child');
      let parentController = this.getController('parent');
      let parentChildController = this.getController('parent.child');
      await this.setAndFlush(parentController, 'page', 2);
      this.assertCurrentPath('/parent/child?parentPage=2');
      await this.setAndFlush(parentController, 'page', 1);
      this.assertCurrentPath('/parent/child');
      await this.setAndFlush(parentChildController, 'page', 2);
      this.assertCurrentPath('/parent/child?childPage=2');
      await this.setAndFlush(parentChildController, 'page', 1);
      this.assertCurrentPath('/parent/child');
      parentController.set('page', 2);
      parentChildController.set('page', 2);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/parent/child?childPage=2&parentPage=2');
      parentController.set('page', 1);
      parentChildController.set('page', 1);
      await (0, _internalTestHelpers.runLoopSettled)();
      this.assertCurrentPath('/parent/child');
    }
    async ['@test query params can be either controller property or url key'](assert) {
      assert.expect(3);
      this.setMappedQPController('parent');
      await this.setupBase();
      this.assertCurrentPath('/parent/child');
      await this.transitionTo('parent.child', {
        queryParams: {
          page: 2
        }
      });
      this.assertCurrentPath('/parent/child?parentPage=2');
      await this.transitionTo('parent.child', {
        queryParams: {
          parentPage: 3
        }
      });
      this.assertCurrentPath('/parent/child?parentPage=3');
    }
    async ['@test query param matching a url key and controller property'](assert) {
      assert.expect(3);
      this.setMappedQPController('parent', 'page', 'parentPage');
      this.setMappedQPController('parent.child', 'index', 'page');
      await this.setupBase();
      await this.transitionTo('parent.child', {
        queryParams: {
          page: 2
        }
      });
      this.assertCurrentPath('/parent/child?parentPage=2');
      await this.transitionTo('parent.child', {
        queryParams: {
          parentPage: 3
        }
      });
      this.assertCurrentPath('/parent/child?parentPage=3');
      await this.transitionTo('parent.child', {
        queryParams: {
          index: 2,
          page: 2
        }
      });
      this.assertCurrentPath('/parent/child?page=2&parentPage=2');
    }
    async ['@test query param matching same property on two controllers use the urlKey higher in the chain'](assert) {
      assert.expect(4);
      this.setMappedQPController('parent', 'page', 'parentPage');
      this.setMappedQPController('parent.child', 'page', 'childPage');
      await this.setupBase();
      await this.transitionTo('parent.child', {
        queryParams: {
          page: 2
        }
      });
      this.assertCurrentPath('/parent/child?parentPage=2');
      await this.transitionTo('parent.child', {
        queryParams: {
          parentPage: 3
        }
      });
      this.assertCurrentPath('/parent/child?parentPage=3');
      await this.transitionTo('parent.child', {
        queryParams: {
          childPage: 2,
          page: 2
        }
      });
      this.assertCurrentPath('/parent/child?childPage=2&parentPage=2');
      await this.transitionTo('parent.child', {
        queryParams: {
          childPage: 3,
          parentPage: 4
        }
      });
      this.assertCurrentPath('/parent/child?childPage=3&parentPage=4');
    }
    async ['@test query params does not error when a query parameter exists for route instances that share a controller'](assert) {
      assert.expect(1);
      let parentController = _controller.default.extend({
        queryParams: {
          page: 'page'
        }
      });
      this.add('controller:parent', parentController);
      this.add('route:parent.child', _route.default.extend({
        controllerName: 'parent'
      }));
      await this.setupBase('/parent');
      await this.transitionTo('parent.child', {
        queryParams: {
          page: 2
        }
      });
      this.assertCurrentPath('/parent/child?page=2');
    }
    async ['@test query params in the same route hierarchy with the same url key get auto-scoped'](assert) {
      assert.expect(1);
      this.setMappedQPController('parent');
      this.setMappedQPController('parent.child');
      await assert.rejectsAssertion(this.setupBase(), "You're not allowed to have more than one controller property map to the same query param key, but both `parent:page` and `parent.child:page` map to `parentPage`. You can fix this by mapping one of the controller properties to a different query param key via the `as` config option, e.g. `page: { as: 'other-page' }`");
    }
    async ['@test Support shared but overridable mixin pattern'](assert) {
      assert.expect(7);
      let HasPage = _mixin.default.create({
        queryParams: 'page',
        page: 1
      });
      this.add('controller:parent', _controller.default.extend(HasPage, {
        queryParams: {
          page: 'yespage'
        }
      }));
      this.add('controller:parent.child', _controller.default.extend(HasPage));
      await this.setupBase();
      this.assertCurrentPath('/parent/child');
      let parentController = this.getController('parent');
      let parentChildController = this.getController('parent.child');
      await this.setAndFlush(parentChildController, 'page', 2);
      this.assertCurrentPath('/parent/child?page=2');
      assert.equal(parentController.get('page'), 1);
      assert.equal(parentChildController.get('page'), 2);
      await this.setAndFlush(parentController, 'page', 2);
      this.assertCurrentPath('/parent/child?page=2&yespage=2');
      assert.equal(parentController.get('page'), 2);
      assert.equal(parentChildController.get('page'), 2);
    }
  });
});
define("ember/tests/routing/query_params_test/query_param_async_get_handler_test", ["@ember/object", "@ember/-internals/runtime", "@ember/routing/route", "internal-test-helpers"], function (_object, _runtime, _route, _internalTestHelpers) {
  "use strict";

  // These tests mimic what happens with lazily loaded Engines.
  (0, _internalTestHelpers.moduleFor)('Query Params - async get handler', class extends _internalTestHelpers.QueryParamTestCase {
    get routerOptions() {
      let fetchedHandlers = this.fetchedHandlers = [];
      return {
        location: 'test',
        init() {
          this._super(...arguments);
          this._seenHandlers = Object.create(null);
          this._handlerPromises = Object.create(null);
        },
        setupRouter() {
          let isNewSetup = this._super(...arguments);
          if (isNewSetup) {
            let {
              _handlerPromises: handlerPromises,
              _seenHandlers: seenHandlers
            } = this;
            let getRoute = this._routerMicrolib.getRoute;
            this._routerMicrolib.getRoute = function (routeName) {
              fetchedHandlers.push(routeName);

              // Cache the returns so we don't have more than one Promise for a
              // given handler.
              return handlerPromises[routeName] || (handlerPromises[routeName] = new _runtime.RSVP.Promise(resolve => {
                setTimeout(() => {
                  let handler = getRoute(routeName);
                  seenHandlers[routeName] = handler;
                  resolve(handler);
                }, 10);
              }));
            };
          }
          return isNewSetup;
        },
        _getQPMeta(routeInfo) {
          let handler = this._seenHandlers[routeInfo.name];
          if (handler) {
            return (0, _object.get)(handler, '_qp');
          }
        }
      };
    }
    async ['@test can render a link to an asynchronously loaded route without fetching the route'](assert) {
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.setSingleQPController('post');
      let setupAppTemplate = () => {
        this.addTemplate('application', "\n          <LinkTo @route='post' @model={{1337}} @query={{hash foo='bar'}} class='post-link is-1337'>Post</LinkTo>\n          <LinkTo @route='post' @model={{7331}} @query={{hash foo='boo'}} class='post-link is-7331'>Post</LinkTo>\n          {{outlet}}\n          ");
      };
      setupAppTemplate();
      await this.visitAndAssert('/');
      assert.equal(this.$('.post-link.is-1337').attr('href'), '/post/1337?foo=bar', 'renders correctly with default QP value');
      assert.equal(this.$('.post-link.is-7331').attr('href'), '/post/7331?foo=boo', 'renders correctly with non-default QP value');
      assert.deepEqual(this.fetchedHandlers, ['application', 'index'], "only fetched the handlers for the route we're on");
    }
    ['@test can transitionTo to an asynchronously loaded route with simple query params'](assert) {
      assert.expect(6);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
        this.route('posts');
      });
      this.setSingleQPController('post');
      let postController;
      return this.visitAndAssert('/').then(() => {
        postController = this.getController('post');
        return this.transitionTo('posts').then(() => {
          this.assertCurrentPath('/posts');
        });
      }).then(() => {
        return this.transitionTo('post', 1337, {
          queryParams: {
            foo: 'boo'
          }
        }).then(() => {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');
          this.assertCurrentPath('/post/1337?foo=boo');
        });
      }).then(() => {
        return this.transitionTo('post', 1337, {
          queryParams: {
            foo: 'bar'
          }
        }).then(() => {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');
          this.assertCurrentPath('/post/1337');
        });
      });
    }
    ['@test can transitionTo to an asynchronously loaded route with array query params'](assert) {
      assert.expect(5);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.setSingleQPController('post', 'comments', []);
      let postController;
      return this.visitAndAssert('/').then(() => {
        postController = this.getController('post');
        return this.transitionTo('post', 1337, {
          queryParams: {
            comments: [1, 2]
          }
        }).then(() => {
          assert.deepEqual(postController.get('comments'), [1, 2], 'array QP is correctly set with default value');
          this.assertCurrentPath('/post/1337?comments=%5B1%2C2%5D');
        });
      }).then(() => {
        return this.transitionTo('post', 1338).then(() => {
          assert.deepEqual(postController.get('comments'), [], 'array QP is correctly set on controller');
          this.assertCurrentPath('/post/1338');
        });
      });
    }
    ['@test can transitionTo to an asynchronously loaded route with mapped query params'](assert) {
      assert.expect(7);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');
      let postController;
      let postIndexController;
      return this.visitAndAssert('/').then(() => {
        postController = this.getController('post');
        postIndexController = this.getController('post.index');
        return this.transitionTo('post.index', 1337, {
          queryParams: {
            note: 6,
            foo: 'boo'
          }
        }).then(() => {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly set on controller');
          this.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(() => {
        return this.transitionTo('post', 1337, {
          queryParams: {
            foo: 'bar'
          }
        }).then(() => {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');
          this.assertCurrentPath('/post/1337?note=6');
        });
      });
    }
    ['@test can transitionTo with a URL'](assert) {
      assert.expect(7);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');
      let postController;
      let postIndexController;
      return this.visitAndAssert('/').then(() => {
        postController = this.getController('post');
        postIndexController = this.getController('post.index');
        return this.transitionTo('/post/1337?foo=boo&note=6').then(() => {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly deserialized on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly deserialized on controller');
          this.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(() => {
        return this.transitionTo('/post/1337?note=6').then(() => {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly deserialized with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');
          this.assertCurrentPath('/post/1337?note=6');
        });
      });
    }
    ["@test undefined isn't serialized or deserialized into a string"](assert) {
      assert.expect(4);
      this.router.map(function () {
        this.route('example');
      });
      this.addTemplate('application', "<LinkTo @route='example' @query={{hash foo=undefined}} id='the-link'>Example</LinkTo>");
      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });
      this.add('route:example', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            foo: undefined
          });
        }
      }));
      return this.visitAndAssert('/').then(() => {
        assert.equal(this.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');
        return this.transitionTo('example', {
          queryParams: {
            foo: undefined
          }
        }).then(() => {
          this.assertCurrentPath('/example');
        });
      });
    }
  });
});
define("ember/tests/routing/query_params_test/query_params_paramless_link_to_test", ["@ember/controller", "internal-test-helpers"], function (_controller, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - paramless link-to', class extends _internalTestHelpers.QueryParamTestCase {
    testParamlessLinks(assert, routeName) {
      assert.expect(1);
      this.addTemplate(routeName, "<LinkTo @route=\"index\" id=\"index-link\">index</LinkTo>");
      this.add("controller:" + routeName, _controller.default.extend({
        queryParams: ['foo'],
        foo: 'wat'
      }));
      return this.visit('/?foo=YEAH').then(() => {
        assert.equal(document.getElementById('index-link').getAttribute('href'), '/?foo=YEAH');
      });
    }
    ["@test param-less links in an app booted with query params in the URL don't reset the query params: application"](assert) {
      return this.testParamlessLinks(assert, 'application');
    }
    ["@test param-less links in an app booted with query params in the URL don't reset the query params: index"](assert) {
      return this.testParamlessLinks(assert, 'index');
    }
  });
});
define("ember/tests/routing/query_params_test/shared_state_test", ["@ember/controller", "@ember/service", "@ember/runloop", "internal-test-helpers"], function (_controller, _service, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - shared service state', class extends _internalTestHelpers.QueryParamTestCase {
    boot() {
      this.setupApplication();
      return this.visitApplication();
    }
    setupApplication() {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('dashboard');
      });
      this.add('service:filters', _service.default.extend({
        shared: true
      }));
      this.add('controller:home', _controller.default.extend({
        filters: (0, _service.service)()
      }));
      this.add('controller:dashboard', _controller.default.extend({
        filters: (0, _service.service)(),
        queryParams: [{
          'filters.shared': 'shared'
        }]
      }));
      this.addTemplate('application', "<LinkTo @route=\"home\">Home</LinkTo> <div> {{outlet}} </div>");
      this.addTemplate('home', "<LinkTo @route='dashboard'>Dashboard</LinkTo><Input @type=\"checkbox\" id='filters-checkbox' checked={{mut this.filters.shared}} />");
      this.addTemplate('dashboard', "<LinkTo @route=\"home\">Home</LinkTo>");
    }
    visitApplication() {
      return this.visit('/');
    }
    ['@test can modify shared state before transition'](assert) {
      assert.expect(1);
      return this.boot().then(() => {
        this.$input = document.getElementById('filters-checkbox');

        // click the checkbox once to set filters.shared to false
        (0, _runloop.run)(this.$input, 'click');
        return this.visit('/dashboard').then(() => {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    }
    ['@test can modify shared state back to the default value before transition'](assert) {
      assert.expect(1);
      return this.boot().then(() => {
        this.$input = document.getElementById('filters-checkbox');

        // click the checkbox twice to set filters.shared to false and back to true
        (0, _runloop.run)(this.$input, 'click');
        (0, _runloop.run)(this.$input, 'click');
        return this.visit('/dashboard').then(() => {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    }
  });
});
define("ember/tests/routing/router_map_test", ["internal-test-helpers", "@ember/runloop", "@ember/routing/router"], function (_internalTestHelpers, _runloop, _router) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router.map', class extends _internalTestHelpers.ApplicationTestCase {
    ['@test Router.map returns an Ember Router class'](assert) {
      assert.expect(1);
      let ret = this.router.map(function () {
        this.route('hello');
      });
      assert.ok(_router.default.detect(ret));
    }
    ['@test Router.map can be called multiple times'](assert) {
      assert.expect(2);
      this.addTemplate('hello', 'Hello!');
      this.addTemplate('goodbye', 'Goodbye!');
      this.router.map(function () {
        this.route('hello');
      });
      this.router.map(function () {
        this.route('goodbye');
      });
      return (0, _runloop.run)(() => {
        return this.visit('/hello').then(() => {
          this.assertText('Hello!');
        }).then(() => {
          return this.visit('/goodbye');
        }).then(() => {
          this.assertText('Goodbye!');
        });
      });
    }
  });
});
define("ember/tests/routing/router_service_test/basic_test", ["@ember/routing/route", "@ember/routing/none-location", "@ember/object", "internal-test-helpers", "@ember/service"], function (_route, _noneLocation, _object, _internalTestHelpers, _service) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - main', class extends _internalTestHelpers.RouterTestCase {
    ['@test RouterService#currentRouteName is correctly set for top level route'](assert) {
      assert.expect(6);
      return this.visit('/').then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName,
          params,
          paramNames,
          queryParams
        } = currentRoute;
        assert.equal(name, 'parent.index');
        assert.equal(localName, 'index');
        assert.deepEqual(params, {});
        assert.deepEqual(queryParams, {});
        assert.deepEqual(paramNames, []);
        assert.equal(this.routerService.get('currentRouteName'), 'parent.index');
      });
    }
    ['@test RouterService#currentRouteName is correctly set for child route'](assert) {
      assert.expect(6);
      return this.visit('/child').then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName,
          params,
          paramNames,
          queryParams
        } = currentRoute;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.deepEqual(params, {});
        assert.deepEqual(queryParams, {});
        assert.deepEqual(paramNames, []);
        assert.equal(this.routerService.get('currentRouteName'), 'parent.child');
      });
    }
    ['@test RouterService#currentRouteName is correctly set after transition'](assert) {
      assert.expect(5);
      return this.visit('/child').then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName
        } = currentRoute;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName
        } = currentRoute;
        assert.equal(name, 'parent.sister');
        assert.equal(localName, 'sister');
        assert.equal(this.routerService.get('currentRouteName'), 'parent.sister');
      });
    }
    '@test substates survive aborts GH#17430'(assert) {
      assert.expect(2);
      this.add("route:parent.child", _route.default.extend({
        beforeModel(transition) {
          transition.abort();
          this.intermediateTransitionTo('parent.sister');
        }
      }));
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('/child');
      }).catch(e => {
        assert.equal(this.routerService.currentRouteName, 'parent.sister');
        assert.equal(e.message, 'TransitionAborted');
      });
    }
    ['@test RouterService#currentRouteName is correctly set on each transition'](assert) {
      assert.expect(9);
      return this.visit('/child').then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName
        } = currentRoute;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.equal(this.routerService.get('currentRouteName'), 'parent.child');
        return this.visit('/sister');
      }).then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName
        } = currentRoute;
        assert.equal(name, 'parent.sister');
        assert.equal(localName, 'sister');
        assert.equal(this.routerService.get('currentRouteName'), 'parent.sister');
        return this.visit('/brother');
      }).then(() => {
        let currentRoute = this.routerService.currentRoute;
        let {
          name,
          localName
        } = currentRoute;
        assert.equal(name, 'parent.brother');
        assert.equal(localName, 'brother');
        assert.equal(this.routerService.get('currentRouteName'), 'parent.brother');
      });
    }
    ['@test RouterService#rootURL is correctly set to the default value'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        assert.equal(this.routerService.get('rootURL'), '/');
      });
    }
    ['@test RouterService#rootURL is correctly set to a custom value'](assert) {
      assert.expect(1);
      this.add('route:parent.index', _route.default.extend({
        init() {
          this._super();
          (0, _object.set)(this._router, 'rootURL', '/homepage');
        }
      }));
      return this.visit('/').then(() => {
        assert.equal(this.routerService.get('rootURL'), '/homepage');
      });
    }
    ['@test RouterService#location is correctly delegated from router:main'](assert) {
      assert.expect(2);
      return this.visit('/').then(() => {
        let location = this.routerService.get('location');
        assert.ok(location);
        assert.ok(location instanceof _noneLocation.default);
      });
    }
    ['@test RouterService can be injected into router and accessed on init'](assert) {
      assert.expect(1);
      this.router.reopen({
        routerService: (0, _service.service)('router'),
        init() {
          this.routerService.one('routeDidChange', () => {
            assert.ok(true, 'routeDidChange event listener called');
          });
        }
      });
      return this.visit('/');
    }
  });
});
define("ember/tests/routing/router_service_test/build_routeinfo_metadata_test", ["internal-test-helpers", "@ember/service", "@ember/routing/route"], function (_internalTestHelpers, _service, _route) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('buildRouteInfoMetadata', class extends _internalTestHelpers.RouterTestCase {
    '@test basic metadata'(assert) {
      assert.expect(4);
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.metadata, 'parent-index-page');
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.metadata, 'parent-index-page');
          });
        }
      }));
      this.add("route:parent.index", _route.default.extend({
        buildRouteInfoMetadata() {
          return 'parent-index-page';
        }
      }));
      return this.visit('/');
    }
    '@test hierarchical metadata'(assert) {
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        buildRouteInfoMetadata() {
          return 'application-shell';
        },
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.metadata, 'parent-index-page');
            assert.equal(transition.to.parent.name, 'parent');
            assert.equal(transition.to.parent.metadata, 'parent-page');
            assert.equal(transition.to.parent.parent.name, 'application');
            assert.equal(transition.to.parent.parent.metadata, 'application-shell');
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.metadata, 'parent-index-page');
            assert.equal(transition.to.parent.name, 'parent');
            assert.equal(transition.to.parent.metadata, 'parent-page');
            assert.equal(transition.to.parent.parent.name, 'application');
            assert.equal(transition.to.parent.parent.metadata, 'application-shell');
          });
        }
      }));
      this.add("route:parent", _route.default.extend({
        buildRouteInfoMetadata() {
          return 'parent-page';
        }
      }));
      this.add("route:parent.index", _route.default.extend({
        buildRouteInfoMetadata() {
          return 'parent-index-page';
        }
      }));
      return this.visit('/');
    }
    '@test metadata can be complex objects'(assert) {
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.metadata.name, 'parent-index-page');
            assert.equal(transition.to.metadata.title('PARENT'), 'My Name is PARENT');
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.metadata.name, 'parent-index-page');
            assert.equal(transition.to.metadata.title('PARENT'), 'My Name is PARENT');
          });
        }
      }));
      this.add("route:parent", _route.default.extend({}));
      this.add("route:parent.index", _route.default.extend({
        buildRouteInfoMetadata() {
          return {
            name: 'parent-index-page',
            title: name => "My Name is " + name
          };
        }
      }));
      return this.visit('/');
    }
    '@test metadata is placed on the `from`'(assert) {
      assert.expect(12);
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (transition.to.name === 'parent.index') {
              assert.equal(transition.to.metadata.name, 'parent-index-page');
              assert.equal(transition.to.metadata.title('INDEX'), 'My Name is INDEX');
            } else {
              assert.equal(transition.from.metadata.name, 'parent-index-page');
              assert.equal(transition.from.metadata.title('INDEX'), 'My Name is INDEX');
              assert.equal(transition.to.metadata.name, 'parent-child-page');
              assert.equal(transition.to.metadata.title('CHILD'), 'My Name is CHILD!!');
            }
          });
          this.router.on('routeDidChange', transition => {
            if (transition.to.name === 'parent.index') {
              assert.equal(transition.to.metadata.name, 'parent-index-page');
              assert.equal(transition.to.metadata.title('INDEX'), 'My Name is INDEX');
            } else {
              assert.equal(transition.from.metadata.name, 'parent-index-page');
              assert.equal(transition.from.metadata.title('INDEX'), 'My Name is INDEX');
              assert.equal(transition.to.metadata.name, 'parent-child-page');
              assert.equal(transition.to.metadata.title('CHILD'), 'My Name is CHILD!!');
            }
          });
        }
      }));
      this.add("route:parent", _route.default.extend({}));
      this.add("route:parent.index", _route.default.extend({
        buildRouteInfoMetadata() {
          return {
            name: 'parent-index-page',
            title: name => "My Name is " + name
          };
        }
      }));
      this.add("route:parent.child", _route.default.extend({
        buildRouteInfoMetadata() {
          return {
            name: 'parent-child-page',
            title: name => "My Name is " + name + "!!"
          };
        }
      }));
      return this.visit('/').then(() => {
        return this.visit('/child');
      });
    }
    '@test can be used with model data from `attributes`'(assert) {
      assert.expect(6);
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeDidChange', transition => {
            if (transition.to.name === 'parent.index') {
              assert.equal(transition.to.metadata.name, 'parent-index-page');
              assert.equal(transition.to.metadata.title(transition.to.attributes), 'My Name is INDEX');
            } else {
              assert.equal(transition.from.metadata.name, 'parent-index-page');
              assert.equal(transition.from.metadata.title(transition.from.attributes), 'My Name is INDEX');
              assert.equal(transition.to.metadata.name, 'parent-child-page');
              assert.equal(transition.to.metadata.title(transition.to.attributes), 'My Name is CHILD!!');
            }
          });
        }
      }));
      this.add("route:parent", _route.default.extend({}));
      this.add("route:parent.index", _route.default.extend({
        model() {
          return {
            name: 'INDEX'
          };
        },
        buildRouteInfoMetadata() {
          return {
            name: 'parent-index-page',
            title: model => "My Name is " + model.name
          };
        }
      }));
      this.add("route:parent.child", _route.default.extend({
        model() {
          return {
            name: 'CHILD'
          };
        },
        buildRouteInfoMetadata() {
          return {
            name: 'parent-child-page',
            title: model => "My Name is " + model.name + "!!"
          };
        }
      }));
      return this.visit('/').then(() => {
        return this.visit('/child');
      });
    }
  });
});
define("ember/tests/routing/router_service_test/currenturl_lifecycle_test", ["@ember/service", "@ember/object/computed", "@ember/-internals/glimmer", "@ember/routing/route", "@ember/object", "internal-test-helpers", "@ember/-internals/runtime"], function (_service, _computed, _glimmer, _route, _object, _internalTestHelpers, _runtime) {
  "use strict";

  let results = [];
  let ROUTE_NAMES = ['index', 'child', 'sister', 'brother', 'loading'];
  let InstrumentedRoute = _route.default.extend({
    routerService: (0, _service.service)('router'),
    init() {
      this._super(...arguments);
      let service = (0, _object.get)(this, 'routerService');
      service.on('routeWillChange', transition => {
        results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " routeWillChange: " + (transition.from && transition.from.name) + " - " + transition.to.name, service.get('currentURL')]);
      });
      service.on('routeDidChange', transition => {
        results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " routeDidChange: " + (transition.from && transition.from.name) + " - " + transition.to.name, service.get('currentURL')]);
      });
    },
    activate() {
      let service = (0, _object.get)(this, 'routerService');
      results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " activate", service.get('currentURL')]);
    },
    redirect() {
      let service = (0, _object.get)(this, 'routerService');
      results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " redirect", service.get('currentURL')]);
    },
    beforeModel() {
      let service = (0, _object.get)(this, 'routerService');
      results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " beforeModel", service.get('currentURL')]);
    },
    model() {
      let service = (0, _object.get)(this, 'routerService');
      results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " model", service.get('currentURL')]);
      return new _runtime.RSVP.Promise(resolve => {
        setTimeout(resolve, 200);
      });
    },
    afterModel() {
      let service = (0, _object.get)(this, 'routerService');
      results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " afterModel", service.get('currentURL')]);
    },
    actions: {
      willTransition(transition) {
        let service = (0, _object.get)(this, 'routerService');
        results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " willTransition: " + (transition.from && transition.from.name) + " - " + transition.to.name, service.get('currentURL')]);
        return true;
      },
      didTransition() {
        let service = (0, _object.get)(this, 'routerService');
        results.push([service.get('currentRouteName') + " - " + service.get('currentRoute.name'), this.routeName + " didTransition", service.get('currentURL')]);
        return true;
      }
    }
  });
  (0, _internalTestHelpers.moduleFor)('Router Service - currentURL | currentRouteName | currentRoute.name', class extends _internalTestHelpers.RouterTestCase {
    constructor() {
      super(...arguments);
      results = [];
      ROUTE_NAMES.forEach(name => {
        let routeName = "parent." + name;
        this.add("route:" + routeName, InstrumentedRoute.extend());
        this.addTemplate(routeName, '{{current-url}}');
      });
      let CurrenURLComponent = _glimmer.Component.extend({
        routerService: (0, _service.service)('router'),
        currentURL: (0, _computed.readOnly)('routerService.currentURL'),
        currentRouteName: (0, _computed.readOnly)('routerService.currentRouteName'),
        currentRoute: (0, _computed.readOnly)('routerService.currentRoute')
      });
      this.addComponent('current-url', {
        ComponentClass: CurrenURLComponent,
        template: '{{this.currentURL}}-{{this.currentRouteName}}-{{this.currentRoute.name}}'
      });
    }
    ['@test RouterService#currentURL is correctly set for top level route'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        assert.equal(this.routerService.get('currentURL'), '/');
      });
    }
    ['@test RouterService#currentURL is correctly set for child route'](assert) {
      assert.expect(1);
      return this.visit('/child').then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child');
      });
    }
    ['@test RouterService#currentURL is correctly set after transition'](assert) {
      assert.expect(1);
      return this.visit('/child').then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/sister');
      });
    }
    ['@test RouterService#currentURL is correctly set on each transition'](assert) {
      assert.expect(3);
      return this.visit('/child').then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child');
        return this.visit('/sister');
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/sister');
        return this.visit('/brother');
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/brother');
      });
    }
    ['@test RouterService#currentURL is not set during model lifecycle hooks until routeDidChange'](assert) {
      assert.expect(2);
      return this.visit('/').then(() => {
        assert.deepEqual(results, [['null - undefined', 'parent.index routeWillChange: null - parent.index', null], ['null - undefined', 'parent.index beforeModel', null], ['null - undefined', 'parent.index model', null], ['null - undefined', 'parent.loading activate', null], ['null - undefined', 'parent.loading routeWillChange: null - parent.loading', null], ['null - undefined', 'parent.index routeWillChange: null - parent.loading', null], ['parent.loading - parent.loading', 'parent.index afterModel', '/'], ['parent.loading - parent.loading', 'parent.index redirect', '/'], ['parent.loading - parent.loading', 'parent.index activate', '/'], ['parent.loading - parent.loading', 'parent.index didTransition', '/'], ['parent.index - parent.index', 'parent.loading routeDidChange: null - parent.index', '/'], ['parent.index - parent.index', 'parent.index routeDidChange: null - parent.index', '/']]);
        results = [];
        return this.visit('/child');
      }).then(() => {
        assert.deepEqual(results, [['parent.index - parent.index', 'parent.index willTransition: parent.index - parent.child', '/'], ['parent.index - parent.index', 'parent.child routeWillChange: parent.index - parent.child', '/'], ['parent.index - parent.index', 'parent.loading routeWillChange: parent.index - parent.child', '/'], ['parent.index - parent.index', 'parent.index routeWillChange: parent.index - parent.child', '/'], ['parent.index - parent.index', 'parent.child beforeModel', '/'], ['parent.index - parent.index', 'parent.child model', '/'], ['parent.index - parent.index', 'parent.loading activate', '/'], ['parent.index - parent.index', 'parent.child routeWillChange: parent.index - parent.loading', '/'], ['parent.index - parent.index', 'parent.loading routeWillChange: parent.index - parent.loading', '/'], ['parent.index - parent.index', 'parent.index routeWillChange: parent.index - parent.loading', '/'], ['parent.loading - parent.loading', 'parent.child afterModel', '/child'], ['parent.loading - parent.loading', 'parent.child redirect', '/child'], ['parent.loading - parent.loading', 'parent.child activate', '/child'], ['parent.loading - parent.loading', 'parent.child didTransition', '/child'], ['parent.child - parent.child', 'parent.child routeDidChange: parent.index - parent.child', '/child'], ['parent.child - parent.child', 'parent.loading routeDidChange: parent.index - parent.child', '/child'], ['parent.child - parent.child', 'parent.index routeDidChange: parent.index - parent.child', '/child']]);
      });
    }
    ['@test RouterService#currentURL is correctly set with component after consecutive visits'](assert) {
      assert.expect(3);
      return this.visit('/').then(() => {
        this.assertText('/-parent.index-parent.index');
        return this.visit('/child');
      }).then(() => {
        this.assertText('/child-parent.child-parent.child');
        return this.visit('/');
      }).then(() => {
        this.assertText('/-parent.index-parent.index');
      });
    }
  });
});
define("ember/tests/routing/router_service_test/events_test", ["internal-test-helpers", "@ember/service", "@ember/routing/route", "@ember/runloop"], function (_internalTestHelpers, _service, _route, _runloop) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - events', class extends _internalTestHelpers.RouterTestCase {
    '@test initial render'(assert) {
      assert.expect(12);
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.ok(transition);
            assert.equal(transition.from, undefined);
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.localName, 'index');
          });
          this.router.on('routeDidChange', transition => {
            assert.ok(transition);
            assert.ok(this.router.currentURL, "has URL " + this.router.currentURL);
            assert.equal(this.router.currentURL, '/');
            assert.ok(this.router.currentRouteName, "has route name " + this.router.currentRouteName);
            assert.equal(this.router.currentRouteName, 'parent.index');
            assert.equal(transition.from, undefined);
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.localName, 'index');
          });
        }
      }));
      return this.visit('/');
    }
    '@test subsequent visits'(assert) {
      assert.expect(24);
      let toParent = true;
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (toParent) {
              assert.equal(this.router.currentURL, null, 'starts as null');
              assert.equal(transition.from, undefined);
              assert.equal(transition.to.name, 'parent.child');
              assert.equal(transition.to.localName, 'child');
              assert.equal(transition.to.parent.name, 'parent', 'parent node');
              assert.equal(transition.to.parent.child, transition.to, 'parents child node is the `to`');
              assert.equal(transition.to.parent.parent.name, 'application', 'top level');
              assert.equal(transition.to.parent.parent.parent, null, 'top level');
            } else {
              assert.equal(this.router.currentURL, '/child', 'not changed until transition');
              assert.notEqual(transition.from, undefined);
              assert.equal(transition.from.name, 'parent.child');
              assert.equal(transition.from.localName, 'child');
              assert.equal(transition.to.localName, 'sister');
              assert.equal(transition.to.name, 'parent.sister');
            }
          });
          this.router.on('routeDidChange', transition => {
            if (toParent) {
              assert.equal(this.router.currentURL, '/child');
              assert.equal(transition.from, undefined);
              assert.equal(transition.to.name, 'parent.child');
              assert.equal(transition.to.localName, 'child');
            } else {
              assert.equal(this.router.currentURL, '/sister');
              assert.notEqual(transition.from, undefined);
              assert.equal(transition.from.name, 'parent.child');
              assert.equal(transition.from.localName, 'child');
              assert.equal(transition.to.localName, 'sister');
              assert.equal(transition.to.name, 'parent.sister');
            }
          });
        }
      }));
      return this.visit('/child').then(() => {
        toParent = false;
        return this.routerService.transitionTo('parent.sister');
      });
    }
    '@test transitions can be retried async'(assert) {
      let done = assert.async();
      this.add("route:parent.child", _route.default.extend({
        actions: {
          willTransition(transition) {
            transition.abort();
            this.intermediateTransitionTo('parent.sister');
            (0, _runloop.later)(() => {
              transition.retry();
              done();
            }, 500);
          }
        }
      }));
      return this.visit('/child').then(() => {
        return this.visit('/');
      }).catch(e => {
        assert.equal(e.message, 'TransitionAborted');
      });
    }
    '@test redirection with `transitionTo`'(assert) {
      assert.expect(8);
      let toChild = false;
      let toSister = false;
      this.add("route:parent", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          this.router.transitionTo('parent.child');
        }
      }));
      this.add("route:parent.child", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          this.router.transitionTo('parent.sister');
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.from, undefined, 'initial');
            if (toChild) {
              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              toChild = true;
            }
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.from, undefined, 'initial');
            assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
          });
        }
      }));
      return this.visit('/');
    }
    '@test redirection with `replaceWith`'(assert) {
      assert.expect(8);
      let toChild = false;
      let toSister = false;
      this.add("route:parent", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          this.router.replaceWith('parent.child');
        }
      }));
      this.add("route:parent.child", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          this.router.replaceWith('parent.sister');
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.from, undefined, 'initial');
            if (toChild) {
              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              toChild = true;
            }
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.from, undefined, 'initial');
            assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
          });
        }
      }));
      return this.visit('/');
    }
    '@test nested redirection with `transitionTo`'(assert) {
      assert.expect(11);
      let toChild = false;
      let toSister = false;
      this.add("route:parent.child", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          this.router.transitionTo('parent.sister');
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (toChild) {
              assert.equal(transition.from.name, 'parent.index');
              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              assert.equal(transition.from, undefined, 'initial');
            }
          });
          this.router.on('routeDidChange', transition => {
            if (toSister) {
              assert.equal(transition.from.name, 'parent.index', 'initial');
              assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
            } else {
              assert.equal(transition.from, undefined, 'initial');
              assert.equal(transition.to.name, 'parent.index', 'landed on /');
            }
          });
        }
      }));
      return this.visit('/').then(() => {
        toChild = true;
        return this.routerService.transitionTo('/child').catch(e => {
          assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
        });
      });
    }
    '@test nested redirection with `replaceWith`'(assert) {
      assert.expect(11);
      let toChild = false;
      let toSister = false;
      this.add("route:parent.child", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          this.router.replaceWith('parent.sister');
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (toChild) {
              assert.equal(transition.from.name, 'parent.index');
              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              assert.equal(transition.from, undefined, 'initial');
            }
          });
          this.router.on('routeDidChange', transition => {
            if (toSister) {
              assert.equal(transition.from.name, 'parent.index', 'initial');
              assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
            } else {
              assert.equal(transition.from, undefined, 'initial');
              assert.equal(transition.to.name, 'parent.index', 'landed on /');
            }
          });
        }
      }));
      return this.visit('/').then(() => {
        toChild = true;
        return this.routerService.transitionTo('/child').catch(e => {
          assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
        });
      });
    }
    '@test aborted transition'(assert) {
      assert.expect(11);
      let didAbort = false;
      let toChild = false;
      this.add("route:parent.child", _route.default.extend({
        model(_model, transition) {
          didAbort = true;
          transition.abort();
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (didAbort) {
              assert.equal(transition.to.name, 'parent.index', 'transition aborted');
              assert.equal(transition.from.name, 'parent.index', 'transition aborted');
            } else if (toChild) {
              assert.equal(transition.from.name, 'parent.index', 'from /');
              assert.equal(transition.to.name, 'parent.child', 'to /child');
            } else {
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              assert.equal(transition.from, undefined, 'initial');
            }
          });
          this.router.on('routeDidChange', transition => {
            if (didAbort) {
              assert.equal(transition.to.name, 'parent.index', 'landed on /');
              assert.equal(transition.from.name, 'parent.index', 'initial');
            } else {
              assert.equal(transition.to.name, 'parent.index', 'transition aborted');
              assert.equal(transition.from, undefined, 'transition aborted');
            }
          });
        }
      }));
      return this.visit('/').then(() => {
        toChild = true;
        return this.routerService.transitionTo('/child').catch(e => {
          assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
        });
      });
    }
    '@test query param transitions'(assert) {
      assert.expect(15);
      let initial = true;
      let addQP = false;
      let removeQP = false;
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.to.name, 'parent.index');
            if (initial) {
              assert.equal(transition.from, null);
              assert.deepEqual(transition.to.queryParams, {
                a: 'true'
              });
            } else if (addQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'true'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false',
                b: 'b'
              });
            } else if (removeQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'false',
                b: 'b'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false'
              });
            } else {
              assert.ok(false, 'never');
            }
          });
          this.router.on('routeDidChange', transition => {
            if (initial) {
              assert.equal(transition.from, null);
              assert.deepEqual(transition.to.queryParams, {
                a: 'true'
              });
            } else if (addQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'true'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false',
                b: 'b'
              });
            } else if (removeQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'false',
                b: 'b'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false'
              });
            } else {
              assert.ok(false, 'never');
            }
          });
        }
      }));
      return this.visit('/?a=true').then(() => {
        addQP = true;
        initial = false;
        return this.routerService.transitionTo('/?a=false&b=b');
      }).then(() => {
        removeQP = true;
        addQP = false;
        return this.routerService.transitionTo('/?a=false');
      });
    }
    '@test query param redirects with `transitionTo`'(assert) {
      assert.expect(6);
      let toSister = false;
      this.add("route:parent.child", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          toSister = true;
          this.router.transitionTo('/sister?a=a');
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (toSister) {
              assert.equal(transition.to.name, 'parent.sister');
              assert.deepEqual(transition.to.queryParams, {
                a: 'a'
              });
            } else {
              assert.equal(transition.to.name, 'parent.child');
              assert.deepEqual(transition.to.queryParams, {});
            }
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'parent.sister');
            assert.deepEqual(transition.to.queryParams, {
              a: 'a'
            });
          });
        }
      }));
      return this.visit('/child');
    }
    '@test query param redirects with `replaceWith`'(assert) {
      assert.expect(6);
      let toSister = false;
      this.add("route:parent.child", _route.default.extend({
        router: (0, _service.service)(),
        model() {
          toSister = true;
          this.router.replaceWith('/sister?a=a');
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            if (toSister) {
              assert.equal(transition.to.name, 'parent.sister');
              assert.deepEqual(transition.to.queryParams, {
                a: 'a'
              });
            } else {
              assert.equal(transition.to.name, 'parent.child');
              assert.deepEqual(transition.to.queryParams, {});
            }
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'parent.sister');
            assert.deepEqual(transition.to.queryParams, {
              a: 'a'
            });
          });
        }
      }));
      return this.visit('/child');
    }
    '@test params'(assert) {
      assert.expect(14);
      let initial = true;
      this.add('route:dynamic', _route.default.extend({
        model(params) {
          if (initial) {
            assert.deepEqual(params, {
              dynamic_id: '123'
            });
          } else {
            assert.deepEqual(params, {
              dynamic_id: '1'
            });
          }
          return params;
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.to.name, 'dynamic');
            if (initial) {
              assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
              assert.deepEqual(transition.to.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
              assert.deepEqual(transition.to.params, {
                dynamic_id: '1'
              });
            }
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'dynamic');
            assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
            if (initial) {
              assert.deepEqual(transition.to.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.to.params, {
                dynamic_id: '1'
              });
            }
          });
        }
      }));
      return this.visit('/dynamic/123').then(() => {
        initial = false;
        return this.routerService.transitionTo('dynamic', 1);
      });
    }
    '@test nested params'(assert) {
      assert.expect(30);
      let initial = true;
      this.add('route:dynamicWithChild', _route.default.extend({
        model(params) {
          if (initial) {
            assert.deepEqual(params, {
              dynamic_id: '123'
            });
          } else {
            assert.deepEqual(params, {
              dynamic_id: '456'
            });
          }
          return params.dynamic_id;
        }
      }));
      this.add('route:dynamicWithChild.child', _route.default.extend({
        model(params) {
          assert.deepEqual(params, {
            child_id: '456'
          });
          return params.child_id;
        }
      }));
      this.add("route:application", _route.default.extend({
        router: (0, _service.service)('router'),
        init() {
          this._super(...arguments);
          this.router.on('routeWillChange', transition => {
            assert.equal(transition.to.name, 'dynamicWithChild.child');
            assert.deepEqual(transition.to.paramNames, ['child_id']);
            assert.deepEqual(transition.to.params, {
              child_id: '456'
            });
            assert.deepEqual(transition.to.parent.paramNames, ['dynamic_id']);
            if (initial) {
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.from.attributes, '456');
              assert.deepEqual(transition.from.parent.attributes, '123');
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '456'
              });
            }
          });
          this.router.on('routeDidChange', transition => {
            assert.equal(transition.to.name, 'dynamicWithChild.child');
            assert.deepEqual(transition.to.paramNames, ['child_id']);
            assert.deepEqual(transition.to.params, {
              child_id: '456'
            });
            assert.deepEqual(transition.to.parent.paramNames, ['dynamic_id']);
            if (initial) {
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.from.attributes, '456');
              assert.deepEqual(transition.from.parent.attributes, '123');
              assert.deepEqual(transition.to.attributes, '456');
              assert.deepEqual(transition.to.parent.attributes, '456');
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '456'
              });
            }
          });
        }
      }));
      return this.visit('/dynamic-with-child/123/456').then(() => {
        initial = false;
        return this.routerService.transitionTo('/dynamic-with-child/456/456');
      });
    }
  });
});
define("ember/tests/routing/router_service_test/isActive_test", ["@ember/controller", "internal-test-helpers", "@ember/service"], function (_controller, _internalTestHelpers, _service) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }
    return desc;
  }
  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');
  }
  (0, _internalTestHelpers.moduleFor)('Router Service - isActive', class extends _internalTestHelpers.RouterTestCase {
    ['@test RouterService#isActive returns true for simple route'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child');
      }).then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        assert.ok(this.routerService.isActive('parent.sister'));
      });
    }
    ['@test RouterService#isActive returns true for simple route with dynamic segments'](assert) {
      assert.expect(1);
      let dynamicModel = {
        id: 1
      };
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('dynamic', dynamicModel);
      }).then(() => {
        assert.ok(this.routerService.isActive('dynamic', dynamicModel));
      });
    }
    async ['@test RouterService#isActive entangles with route transitions'](assert) {
      var _class, _descriptor;
      assert.expect(6);
      this.add("service:foo", (_class = class _class extends _service.default {
        constructor() {
          super(...arguments);
          _initializerDefineProperty(this, "router", _descriptor, this);
        }
        get isChildActive() {
          return this.router.isActive('parent.child');
        }
        get isSisterActive() {
          return this.router.isActive('parent.sister');
        }
      }, _descriptor = _applyDecoratedDescriptor(_class.prototype, "router", [_service.service], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _class));
      await this.visit('/');
      let fooService = this.applicationInstance.lookup('service:foo');
      assert.equal(fooService.isChildActive, false);
      assert.equal(fooService.isSisterActive, false);
      await this.routerService.transitionTo('parent.child');
      assert.equal(fooService.isChildActive, true);
      assert.equal(fooService.isSisterActive, false);
      await this.routerService.transitionTo('parent.sister');
      assert.equal(fooService.isChildActive, false);
      assert.equal(fooService.isSisterActive, true);
    }
    ['@test RouterService#isActive does not eagerly instantiate controller for query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      this.add('controller:parent.sister', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC',
        init() {
          assert.ok(false, 'should never create');
          this._super(...arguments);
        }
      }));
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.brother');
      }).then(() => {
        assert.notOk(this.routerService.isActive('parent.sister', queryParams));
      });
    }
    ['@test RouterService#isActive is correct for simple route with basic query params'](assert) {
      assert.expect(2);
      let queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child', queryParams);
      }).then(() => {
        assert.ok(this.routerService.isActive('parent.child', queryParams), 'route is active');
        assert.notOk(this.routerService.isActive('parent.child', this.buildQueryParams({
          sort: 'DESC'
        })), 'route with QPs is not active');
      });
    }
    ['@test RouterService#isActive for simple route with array as query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        sort: ['ascending']
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child', queryParams);
      }).then(() => {
        assert.notOk(this.routerService.isActive('parent.child', this.buildQueryParams({
          sort: 'descending'
        })));
      });
    }
    ['@test RouterService#isActive does not alter query params hash'](assert) {
      assert.expect(3);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'page'],
        sort: 'ASC',
        page: 1
      }));
      let qp = this.buildQueryParams({
        sort: 'ascending'
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child', qp);
      }).then(() => {
        assert.ok(this.routerService.isActive('parent.child', qp));
        assert.ok(this.routerService.isActive('parent.child', qp)); // using same qp second time should not fail
        assert.deepEqual(qp.queryParams, {
          sort: 'ascending'
        });
      });
    }
  });
});
define("ember/tests/routing/router_service_test/non_application_test_test", ["@ember/service", "@ember/routing/router", "@ember/routing/none-location", "@ember/object", "@ember/runloop", "@ember/-internals/glimmer", "internal-test-helpers"], function (_service, _router, _noneLocation, _object, _runloop, _glimmer, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - non application test', class extends _internalTestHelpers.RouterNonApplicationTestCase {
    constructor() {
      super(...arguments);
      this.resolver.add('router:main', _router.default.extend(this.routerOptions));
      this.router.map(function () {
        this.route('parent', {
          path: '/'
        }, function () {
          this.route('child');
          this.route('sister');
          this.route('brother');
        });
        this.route('dynamic', {
          path: '/dynamic/:dynamic_id'
        });
        this.route('dynamicWithChild', {
          path: '/dynamic-with-child/:dynamic_id'
        }, function () {
          this.route('child', {
            path: '/:child_id'
          });
        });
      });
    }
    get routerOptions() {
      return {
        location: 'none'
      };
    }
    get router() {
      return this.owner.resolveRegistration('router:main');
    }
    get routerService() {
      return this.owner.lookup('service:router');
    }
    ['@test RouterService can be instantiated in non application test'](assert) {
      assert.ok(this.routerService);
    }
    ['@test RouterService properties can be accessed with default'](assert) {
      assert.expect(5);
      assert.equal(this.routerService.get('currentRouteName'), null);
      assert.equal(this.routerService.get('currentURL'), null);
      assert.equal(this.routerService.get('location'), 'none');
      assert.equal(this.routerService.get('rootURL'), '/');
      assert.equal(this.routerService.get('currentRoute'), null);
    }
    ['@test RouterService properties of router can be accessed with default when router is present'](assert) {
      assert.expect(5);
      let router = this.owner.lookup('router:main');
      router.setupRouter();
      assert.equal(this.routerService.get('currentRouteName'), null);
      assert.equal(this.routerService.get('currentURL'), null);
      assert.ok(this.routerService.get('location') instanceof _noneLocation.default);
      assert.equal(this.routerService.get('rootURL'), '/');
      assert.equal(this.routerService.get('currentRoute'), null);
    }
    ['@test RouterService#urlFor returns url'](assert) {
      assert.equal(this.routerService.urlFor('parent.child'), '/child');
    }
    ['@test RouterService#transitionTo with basic route'](assert) {
      assert.expect(2);

      // Callers who want to actually execute a transition in a non-application
      // test are doing something weird and therefore should do
      // `owner.setupRouter()` explicitly in their tests.
      let componentInstance;
      let router = this.owner.lookup('router:main');
      router.setupRouter();
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.service)('router'),
          init() {
            this._super(...arguments);
            componentInstance = this;
          },
          actions: {
            transitionToSister() {
              (0, _object.get)(this, 'routerService').transitionTo('parent.sister');
            }
          }
        }),
        template: "foo-bar"
      });
      this.render('{{foo-bar}}');
      (0, _runloop.run)(function () {
        componentInstance.send('transitionToSister');
      });
      assert.equal(this.routerService.get('currentRouteName'), 'parent.sister');
      assert.ok(this.routerService.isActive('parent.sister'));
    }
    ['@test RouterService#recognize recognize returns routeInfo'](assert) {
      let routeInfo = this.routerService.recognize('/dynamic-with-child/123/1?a=b');
      assert.ok(routeInfo);
      let {
        name,
        localName,
        parent,
        child,
        params,
        queryParams,
        paramNames
      } = routeInfo;
      assert.equal(name, 'dynamicWithChild.child');
      assert.equal(localName, 'child');
      assert.ok(parent);
      assert.equal(parent.name, 'dynamicWithChild');
      assert.notOk(child);
      assert.deepEqual(params, {
        child_id: '1'
      });
      assert.deepEqual(queryParams, {
        a: 'b'
      });
      assert.deepEqual(paramNames, ['child_id']);
    }
  });
});
define("ember/tests/routing/router_service_test/recognize_test", ["internal-test-helpers", "@ember/routing/route"], function (_internalTestHelpers, _route) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - recognize', class extends _internalTestHelpers.RouterTestCase {
    '@test returns a RouteInfo for recognized URL'(assert) {
      return this.visit('/').then(() => {
        let routeInfo = this.routerService.recognize('/dynamic-with-child/123/1?a=b');
        assert.ok(routeInfo);
        let {
          name,
          localName,
          parent,
          child,
          params,
          queryParams,
          paramNames
        } = routeInfo;
        assert.equal(name, 'dynamicWithChild.child');
        assert.equal(localName, 'child');
        assert.ok(parent);
        assert.equal(parent.name, 'dynamicWithChild');
        assert.notOk(child);
        assert.deepEqual(params, {
          child_id: '1'
        });
        assert.deepEqual(queryParams, {
          a: 'b'
        });
        assert.deepEqual(paramNames, ['child_id']);
      });
    }
    '@test does not transition'(assert) {
      this.addTemplate('parent', 'Parent');
      this.addTemplate('dynamic-with-child.child', 'Dynamic Child');
      return this.visit('/').then(() => {
        this.routerService.recognize('/dynamic-with-child/123/1?a=b');
        this.assertText('Parent', 'Did not transition and cause render');
        assert.equal(this.routerService.currentURL, '/', 'Did not transition');
      });
    }
    '@test respects the usage of a different rootURL'(assert) {
      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(() => {
        let routeInfo = this.routerService.recognize('/app/child/');
        assert.ok(routeInfo);
        let {
          name,
          localName,
          parent
        } = routeInfo;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.equal(parent.name, 'parent');
      });
    }
    '@test must include rootURL'() {
      this.addTemplate('parent', 'Parent');
      this.addTemplate('dynamic-with-child.child', 'Dynamic Child');
      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(() => {
        expectAssertion(() => {
          this.routerService.recognize('/dynamic-with-child/123/1?a=b');
        }, 'You must pass a url that begins with the application\'s rootURL "/app/"');
      });
    }
    '@test returns `null` if URL is not recognized'(assert) {
      return this.visit('/').then(() => {
        let routeInfo = this.routerService.recognize('/foo');
        assert.equal(routeInfo, null);
      });
    }
  });
  (0, _internalTestHelpers.moduleFor)('Router Service - recognizeAndLoad', class extends _internalTestHelpers.RouterTestCase {
    '@test returns a RouteInfoWithAttributes for recognized URL'(assert) {
      this.add('route:dynamicWithChild', _route.default.extend({
        model(params) {
          return {
            name: 'dynamicWithChild',
            data: params.dynamic_id
          };
        }
      }));
      this.add('route:dynamicWithChild.child', _route.default.extend({
        model(params) {
          return {
            name: 'dynamicWithChild.child',
            data: params.child_id
          };
        }
      }));
      return this.visit('/').then(() => {
        return this.routerService.recognizeAndLoad('/dynamic-with-child/123/1?a=b');
      }).then(routeInfoWithAttributes => {
        assert.ok(routeInfoWithAttributes);
        let {
          name,
          localName,
          parent,
          attributes,
          paramNames,
          params,
          queryParams
        } = routeInfoWithAttributes;
        assert.equal(name, 'dynamicWithChild.child');
        assert.equal(localName, 'child');
        assert.equal(parent.name, 'dynamicWithChild');
        assert.deepEqual(params, {
          child_id: '1'
        });
        assert.deepEqual(queryParams, {
          a: 'b'
        });
        assert.deepEqual(paramNames, ['child_id']);
        assert.deepEqual(attributes, {
          name: 'dynamicWithChild.child',
          data: '1'
        });
        assert.deepEqual(parent.attributes, {
          name: 'dynamicWithChild',
          data: '123'
        });
        assert.deepEqual(parent.paramNames, ['dynamic_id']);
        assert.deepEqual(parent.params, {
          dynamic_id: '123'
        });
      });
    }
    '@test does not transition'(assert) {
      this.addTemplate('parent', 'Parent{{outlet}}');
      this.addTemplate('parent.child', 'Child');
      this.add('route:parent.child', _route.default.extend({
        model() {
          return {
            name: 'child',
            data: ['stuff']
          };
        }
      }));
      return this.visit('/').then(() => {
        this.routerService.on('routeWillChange', () => assert.ok(false));
        this.routerService.on('routeDidChange', () => assert.ok(false));
        return this.routerService.recognizeAndLoad('/child');
      }).then(() => {
        assert.equal(this.routerService.currentURL, '/');
        this.assertText('Parent');
      });
    }
    '@test respects the usage of a different rootURL'(assert) {
      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(() => {
        return this.routerService.recognizeAndLoad('/app/child/');
      }).then(routeInfoWithAttributes => {
        assert.ok(routeInfoWithAttributes);
        let {
          name,
          localName,
          parent
        } = routeInfoWithAttributes;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.equal(parent.name, 'parent');
      });
    }
    '@test must include rootURL'() {
      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(() => {
        expectAssertion(() => {
          this.routerService.recognizeAndLoad('/dynamic-with-child/123/1?a=b');
        }, 'You must pass a url that begins with the application\'s rootURL "/app/"');
      });
    }
    '@test rejects if url is not recognized'(assert) {
      this.addTemplate('parent', 'Parent{{outlet}}');
      this.addTemplate('parent.child', 'Child');
      this.add('route:parent.child', _route.default.extend({
        model() {
          return {
            name: 'child',
            data: ['stuff']
          };
        }
      }));
      return this.visit('/').then(() => {
        return this.routerService.recognizeAndLoad('/foo');
      }).then(() => {
        assert.ok(false, 'never');
      }, reason => {
        assert.equal(reason, 'URL /foo was not recognized');
      });
    }
    '@test rejects if there is an unhandled error'(assert) {
      this.addTemplate('parent', 'Parent{{outlet}}');
      this.addTemplate('parent.child', 'Child');
      this.add('route:parent.child', _route.default.extend({
        model() {
          throw Error('Unhandled');
        }
      }));
      return this.visit('/').then(() => {
        return this.routerService.recognizeAndLoad('/child');
      }).then(() => {
        assert.ok(false, 'never');
      }, err => {
        assert.equal(err.message, 'Unhandled');
      });
    }
  });
});
define("ember/tests/routing/router_service_test/refresh_test", ["@ember/routing/route", "internal-test-helpers"], function (_route, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - refresh', class extends _internalTestHelpers.RouterTestCase {
    async ['@test RouterService#refresh can be used to re-run the model hooks of active routes'](assert) {
      let parentCounter = 0;
      this.add('route:parent', class extends _route.default {
        model() {
          ++parentCounter;
        }
      });
      let childCounter = 0;
      this.add('route:parent.child', class extends _route.default {
        model() {
          ++childCounter;
        }
      });
      let sisterCounter = 0;
      this.add('route:parent.sister', class extends _route.default {
        model() {
          ++sisterCounter;
        }
      });
      await this.visit('/');
      assert.equal(parentCounter, 1);
      assert.equal(childCounter, 0);
      assert.equal(sisterCounter, 0);
      await this.routerService.refresh();
      assert.equal(parentCounter, 2);
      assert.equal(childCounter, 0);
      assert.equal(sisterCounter, 0);
      await this.routerService.refresh('application');
      assert.equal(parentCounter, 3);
      assert.equal(childCounter, 0);
      assert.equal(sisterCounter, 0);
      await this.routerService.transitionTo('parent.child');
      assert.equal(parentCounter, 3);
      assert.equal(childCounter, 1);
      assert.equal(sisterCounter, 0);
      await this.routerService.refresh('parent.child');
      assert.equal(parentCounter, 3);
      assert.equal(childCounter, 2);
      assert.equal(sisterCounter, 0);
      await this.routerService.refresh('parent');
      assert.equal(parentCounter, 4);
      assert.equal(childCounter, 3);
      assert.equal(sisterCounter, 0);
      await this.routerService.transitionTo('parent.sister');
      assert.equal(parentCounter, 4);
      assert.equal(childCounter, 3);
      assert.equal(sisterCounter, 1);
      await this.routerService.refresh();
      assert.equal(parentCounter, 5);
      assert.equal(childCounter, 3);
      assert.equal(sisterCounter, 2);
    }
    async ['@test RouterService#refresh verifies that the provided route exists']() {
      await this.visit('/');
      expectAssertion(() => {
        this.routerService.refresh('this-route-does-not-exist');
      }, 'The route "this-route-does-not-exist" was not found');
    }
    async ['@test RouterService#refresh verifies that the provided route is active']() {
      await this.visit('/');
      expectAssertion(() => {
        this.routerService.refresh('parent.child');
      }, 'The route "parent.child" is currently not active');
    }
  });
});
define("ember/tests/routing/router_service_test/replaceWith_test", ["@ember/routing/none-location", "internal-test-helpers", "router_js", "@ember/controller"], function (_noneLocation, _internalTestHelpers, _router_js, _controller) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - replaceWith', class extends _internalTestHelpers.RouterTestCase {
    constructor() {
      super(...arguments);
      let testCase = this;
      testCase.state = [];
      this.add('location:test', _noneLocation.default.extend({
        setURL(path) {
          testCase.state.push(path);
          this.set('path', path);
        },
        replaceURL(path) {
          testCase.state.splice(testCase.state.length - 1, 1, path);
          this.set('path', path);
        }
      }));
    }
    get routerOptions() {
      return {
        location: 'test'
      };
    }
    ['@test RouterService#replaceWith returns a Transition'](assert) {
      assert.expect(1);
      let transition;
      return this.visit('/').then(() => {
        transition = this.routerService.replaceWith('parent.child');
        assert.ok(transition instanceof _router_js.InternalTransition);
        return transition;
      });
    }
    ['@test RouterService#replaceWith with basic route replaces location'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child');
      }).then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        return this.routerService.replaceWith('parent.brother');
      }).then(() => {
        assert.deepEqual(this.state, ['/', '/child', '/brother']);
      });
    }
    ['@test RouterService#replaceWith with basic route using URLs replaces location'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('/child');
      }).then(() => {
        return this.routerService.transitionTo('/sister');
      }).then(() => {
        return this.routerService.replaceWith('/brother');
      }).then(() => {
        assert.deepEqual(this.state, ['/', '/child', '/brother']);
      });
    }
    ['@test RouterService#replaceWith transitioning back to previously visited route replaces location'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child');
      }).then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        return this.routerService.transitionTo('parent.brother');
      }).then(() => {
        return this.routerService.replaceWith('parent.sister');
      }).then(() => {
        assert.deepEqual(this.state, ['/', '/child', '/sister', '/sister']);
      });
    }
    ['@test RouterService#replaceWith with basic query params removes query param defaults'](assert) {
      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      let queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.brother');
      }).then(() => {
        return this.routerService.replaceWith('parent.sister');
      }).then(() => {
        return this.routerService.replaceWith('parent.child', queryParams);
      }).then(() => {
        assert.deepEqual(this.state, ['/', '/child']);
      });
    }
  });
});
define("ember/tests/routing/router_service_test/transitionTo_test", ["@ember/service", "@ember/-internals/glimmer", "@ember/routing/route", "@ember/routing/none-location", "@ember/controller", "@ember/runloop", "@ember/object", "internal-test-helpers", "router_js"], function (_service, _glimmer, _route, _noneLocation, _controller, _runloop, _object, _internalTestHelpers, _router_js) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - transitionTo', class extends _internalTestHelpers.RouterTestCase {
    constructor() {
      super(...arguments);
      let testCase = this;
      testCase.state = [];
      this.add('location:test', _noneLocation.default.extend({
        setURL(path) {
          testCase.state.push(path);
          this.set('path', path);
        },
        replaceURL(path) {
          testCase.state.splice(testCase.state.length - 1, 1, path);
          this.set('path', path);
        }
      }));
    }
    get routerOptions() {
      return {
        location: 'test'
      };
    }
    ['@test RouterService#transitionTo returns a Transition'](assert) {
      assert.expect(1);
      let transition;
      return this.visit('/').then(() => {
        transition = this.routerService.transitionTo('parent.child');
        assert.ok(transition instanceof _router_js.InternalTransition);
        return transition;
      });
    }
    ['@test RouterService#transitionTo with basic route updates location'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child');
      }).then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        return this.routerService.transitionTo('parent.brother');
      }).then(() => {
        assert.deepEqual(this.state, ['/', '/child', '/sister', '/brother']);
      });
    }
    ['@test RouterService#transitionTo transitioning back to previously visited route updates location'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child');
      }).then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        return this.routerService.transitionTo('parent.brother');
      }).then(() => {
        return this.routerService.transitionTo('parent.sister');
      }).then(() => {
        assert.deepEqual(this.state, ['/', '/child', '/sister', '/brother', '/sister']);
      });
    }
    ['@test RouterService#transitionTo with basic route'](assert) {
      assert.expect(1);
      let componentInstance;
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.service)('router'),
          init() {
            this._super();
            componentInstance = this;
          },
          actions: {
            transitionToSister() {
              (0, _object.get)(this, 'routerService').transitionTo('parent.sister');
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(() => {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToSister');
        });
        assert.equal(this.routerService.get('currentRouteName'), 'parent.sister');
      });
    }
    ['@test RouterService#transitionTo with basic route using URL'](assert) {
      assert.expect(1);
      let componentInstance;
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.service)('router'),
          init() {
            this._super();
            componentInstance = this;
          },
          actions: {
            transitionToSister() {
              (0, _object.get)(this, 'routerService').transitionTo('/sister');
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(() => {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToSister');
        });
        assert.equal(this.routerService.get('currentRouteName'), 'parent.sister');
      });
    }
    async ['@test RouterService#transitionTo with dynamic segment'](assert) {
      assert.expect(3);
      let componentInstance;
      let dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addTemplate('dynamic', '{{@model.contents}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.service)('router'),
          init() {
            this._super();
            componentInstance = this;
          },
          actions: {
            transitionToDynamic() {
              (0, _object.get)(this, 'routerService').transitionTo('dynamic', dynamicModel);
            }
          }
        }),
        template: "foo-bar"
      });
      await this.visit('/');
      (0, _runloop.run)(function () {
        componentInstance.send('transitionToDynamic');
      });
      assert.equal(this.routerService.get('currentRouteName'), 'dynamic');
      assert.equal(this.routerService.get('currentURL'), '/dynamic/1');
      this.assertText('much dynamicism');
    }
    async ['@test RouterService#transitionTo with dynamic segment and model hook'](assert) {
      assert.expect(3);
      let componentInstance;
      let dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      this.add('route:dynamic', _route.default.extend({
        model() {
          return dynamicModel;
        }
      }));
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addTemplate('dynamic', '{{@model.contents}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.service)('router'),
          init() {
            this._super();
            componentInstance = this;
          },
          actions: {
            transitionToDynamic() {
              (0, _object.get)(this, 'routerService').transitionTo('dynamic', 1);
            }
          }
        }),
        template: "foo-bar"
      });
      await this.visit('/');
      (0, _runloop.run)(function () {
        componentInstance.send('transitionToDynamic');
      });
      assert.equal(this.routerService.get('currentRouteName'), 'dynamic');
      assert.equal(this.routerService.get('currentURL'), '/dynamic/1');
      this.assertText('much dynamicism');
    }
    ['@test RouterService#transitionTo with basic query params removes query param defaults'](assert) {
      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      let queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child', queryParams);
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child');
      });
    }
    ['@test RouterService#transitionTo passing only queryParams works'](assert) {
      assert.expect(2);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort']
      }));
      let queryParams = this.buildQueryParams({
        sort: 'DESC'
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child');
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child');
      }).then(() => {
        return this.routerService.transitionTo(queryParams);
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child?sort=DESC');
      });
    }
    ['@test RouterService#transitionTo with unspecified query params'](assert) {
      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'page', 'category', 'extra'],
        sort: 'ASC',
        page: null,
        category: undefined
      }));
      let queryParams = this.buildQueryParams({
        sort: 'DESC'
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child', queryParams);
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child?sort=DESC');
      });
    }
    ['@test RouterService#transitionTo with aliased query params uses the original provided key'](assert) {
      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: {
          cont_sort: 'url_sort'
        },
        cont_sort: 'ASC'
      }));
      let queryParams = this.buildQueryParams({
        url_sort: 'DESC'
      });
      return this.visit('/').then(() => {
        return this.routerService.transitionTo('parent.child', queryParams);
      }).then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child?url_sort=DESC');
      });
    }
    ['@test RouterService#transitionTo with aliased query params uses the original provided key when controller property name'](assert) {
      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: {
          cont_sort: 'url_sort'
        },
        cont_sort: 'ASC'
      }));
      let queryParams = this.buildQueryParams({
        cont_sort: 'ASC'
      });
      return this.visit('/').then(() => {
        expectAssertion(() => {
          return this.routerService.transitionTo('parent.child', queryParams);
        }, 'You passed the `cont_sort` query parameter during a transition into parent.child, please update to url_sort');
      });
    }
    ['@test RouterService#transitionTo with aliased query params uses the original provided key also when scoped'](assert) {
      assert.expect(1);
      this.add('route:parent', _route.default.extend({
        router: (0, _service.service)(),
        beforeModel() {
          // in this call `url_sort` will be scoped (`parent.child:url_sort`)
          // when passed into `_hydrateUnsuppliedQueryParams`
          this.router.transitionTo('parent.child', {
            queryParams: {
              url_sort: 'ASC'
            }
          });
        }
      }));
      this.add('route:parent.child', _route.default.extend({
        queryParams: {
          cont_sort: {
            as: 'url_sort'
          }
        },
        cont_sort: 'ASC'
      }));
      return this.visit('/').then(() => {
        assert.equal(this.routerService.get('currentURL'), '/child?url_sort=ASC');
      });
    }
    ['@test RouterService#transitionTo with application query params when redirecting form a different route'](assert) {
      assert.expect(1);
      this.add('route:parent.child', _route.default.extend({
        router: (0, _service.service)(),
        beforeModel() {
          this.router.transitionTo('parent');
        }
      }));
      this.add('controller:parent', _controller.default.extend({
        queryParams: ['url_sort']
      }));
      return this.visit('/child?url_sort=a').then(() => {
        assert.equal(this.routerService.get('currentURL'), '/?url_sort=a');
      });
    }
  });
});
define("ember/tests/routing/router_service_test/urlFor_test", ["@ember/controller", "@ember/routing/route", "@ember/object", "internal-test-helpers"], function (_controller, _route, _object, _internalTestHelpers) {
  "use strict";

  function setupController(app, name) {
    let controllerName = name + "Controller";
    Object.defineProperty(app, controllerName, {
      get() {
        throw new Error("Generating a URL should not require instantiation of a " + controllerName + ".");
      }
    });
  }
  (0, _internalTestHelpers.moduleFor)('Router Service - urlFor', class extends _internalTestHelpers.RouterTestCase {
    ['@test RouterService#urlFor returns URL for simple route'](assert) {
      assert.expect(1);
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('parent.child');
        assert.equal('/child', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with dynamic segments'](assert) {
      assert.expect(1);
      setupController(this.application, 'Dynamic');
      let dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('dynamic', dynamicModel);
        assert.equal('/dynamic/1', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with basic query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('parent.child', queryParams);
        assert.equal('/child?foo=bar', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with basic query params and default value'](assert) {
      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      let queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('parent.child', queryParams);
        assert.equal('/child?sort=ASC', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with basic query params and default value with stickyness'](assert) {
      assert.expect(2);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'foo'],
        sort: 'ASC'
      }));
      return this.visit('/child/?sort=DESC').then(() => {
        let controller = this.applicationInstance.lookup('controller:parent.child');
        assert.equal((0, _object.get)(controller, 'sort'), 'DESC', 'sticky is set');
        let queryParams = this.buildQueryParams({
          foo: 'derp'
        });
        let actual = this.routerService.urlFor('parent.child', queryParams);
        assert.equal(actual, '/child?foo=derp', 'does not use "stickiness"');
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with array as query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        selectedItems: ['a', 'b', 'c']
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('parent.child', queryParams);
        assert.equal('/child?selectedItems[]=a&selectedItems[]=b&selectedItems[]=c', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with null query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        foo: null
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('parent.child', queryParams);
        assert.equal('/child', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with undefined query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        foo: undefined
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('parent.child', queryParams);
        assert.equal('/child', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with dynamic segments and basic query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);
        assert.equal('/dynamic/1?foo=bar', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with dynamic segments and array as query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        selectedItems: ['a', 'b', 'c']
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);
        assert.equal('/dynamic/1?selectedItems[]=a&selectedItems[]=b&selectedItems[]=c', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with dynamic segments and null query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        foo: null
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);
        assert.equal('/dynamic/1', expectedURL);
      });
    }
    ['@test RouterService#urlFor returns URL for simple route with dynamic segments and undefined query params'](assert) {
      assert.expect(1);
      let queryParams = this.buildQueryParams({
        foo: undefined
      });
      return this.visit('/').then(() => {
        let expectedURL = this.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);
        assert.equal('/dynamic/1', expectedURL);
      });
    }
    ['@test RouterService#urlFor correctly transitions to route via generated path'](assert) {
      assert.expect(1);
      let expectedURL;
      return this.visit('/').then(() => {
        expectedURL = this.routerService.urlFor('parent.child');
        return this.routerService.transitionTo(expectedURL);
      }).then(() => {
        assert.equal(expectedURL, this.routerService.get('currentURL'));
      });
    }
    ['@test RouterService#urlFor correctly transitions to route via generated path with dynamic segments'](assert) {
      assert.expect(1);
      let expectedURL;
      let dynamicModel = {
        id: 1
      };
      this.add('route:dynamic', _route.default.extend({
        model() {
          return dynamicModel;
        }
      }));
      return this.visit('/').then(() => {
        expectedURL = this.routerService.urlFor('dynamic', dynamicModel);
        return this.routerService.transitionTo(expectedURL);
      }).then(() => {
        assert.equal(expectedURL, this.routerService.get('currentURL'));
      });
    }
    ['@test RouterService#urlFor correctly transitions to route via generated path with query params'](assert) {
      assert.expect(1);
      let expectedURL;
      let actualURL;
      let queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(() => {
        expectedURL = this.routerService.urlFor('parent.child', queryParams);
        return this.routerService.transitionTo(expectedURL);
      }).then(() => {
        actualURL = this.routerService.get('currentURL') + "?foo=bar";
        assert.equal(expectedURL, actualURL);
      });
    }
    ['@test RouterService#urlFor correctly transitions to route via generated path with dynamic segments and query params'](assert) {
      assert.expect(1);
      let expectedURL;
      let actualURL;
      let queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      let dynamicModel = {
        id: 1
      };
      this.add('route:dynamic', _route.default.extend({
        model() {
          return dynamicModel;
        }
      }));
      return this.visit('/').then(() => {
        expectedURL = this.routerService.urlFor('dynamic', dynamicModel, queryParams);
        return this.routerService.transitionTo(expectedURL);
      }).then(() => {
        actualURL = this.routerService.get('currentURL') + "?foo=bar";
        assert.equal(expectedURL, actualURL);
      });
    }
  });
});
define("ember/tests/routing/substates_test", ["@ember/-internals/runtime", "@ember/routing/route", "@ember/controller", "@ember/service", "internal-test-helpers"], function (_runtime, _route, _controller, _service, _internalTestHelpers) {
  "use strict";

  let counter;
  function step(assert, expectedValue, description) {
    assert.equal(counter, expectedValue, 'Step ' + expectedValue + ': ' + description);
    counter++;
  }
  (0, _internalTestHelpers.moduleFor)('Loading/Error Substates', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      counter = 1;
      this.addTemplate('application', "<div id=\"app\">{{outlet}}</div>");
      this.addTemplate('index', 'INDEX');
    }
    visit() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (0, _internalTestHelpers.runTask)(() => super.visit(...args));
    }
    getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    }
    get currentPath() {
      let currentPath;
      expectDeprecation(() => {
        currentPath = this.getController('application').get('currentPath');
      }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
      return currentPath;
    }
    ['@test Slow promise from a child route of application enters nested loading state'](assert) {
      let turtleDeferred = _runtime.RSVP.defer();
      this.router.map(function () {
        this.route('turtle');
      });
      this.add('route:application', _route.default.extend({
        setupController() {
          step(assert, 2, 'ApplicationRoute#setupController');
        }
      }));
      this.add('route:turtle', _route.default.extend({
        model() {
          step(assert, 1, 'TurtleRoute#model');
          return turtleDeferred.promise;
        }
      }));
      this.addTemplate('turtle', 'TURTLE');
      this.addTemplate('loading', 'LOADING');
      let promise = this.visit('/turtle').then(() => {
        text = this.$('#app').text();
        assert.equal(text, 'TURTLE', "turtle template has loaded and replaced the loading template");
      });
      let text = this.$('#app').text();
      assert.equal(text, 'LOADING', "The Loading template is nested in application template's outlet");
      turtleDeferred.resolve();
      return promise;
    }
    ["@test Slow promises returned from ApplicationRoute#model don't enter LoadingRoute"](assert) {
      let appDeferred = _runtime.RSVP.defer();
      this.add('route:application', _route.default.extend({
        model() {
          return appDeferred.promise;
        }
      }));
      this.add('route:loading', _route.default.extend({
        setupController() {
          assert.ok(false, "shouldn't get here");
        }
      }));
      let promise = this.visit('/').then(() => {
        let text = this.$('#app').text();
        assert.equal(text, 'INDEX', "index template has been rendered");
      });
      if (this.element) {
        assert.equal(this.element.textContent, '');
      }
      appDeferred.resolve();
      return promise;
    }
    ["@test Don't enter loading route unless either route or template defined"](assert) {
      let deferred = _runtime.RSVP.defer();
      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/').then(() => {
        let promise = this.visit('/dummy').then(() => {
          let text = this.$('#app').text();
          assert.equal(text, 'DUMMY', "dummy template has been rendered");
        });
        assert.ok(this.appRouter.currentPath !== 'loading', "\n        loading state not entered\n      ");
        deferred.resolve();
        return promise;
      });
    }
    ['@test Enter loading route only if loadingRoute is defined'](assert) {
      let deferred = _runtime.RSVP.defer();
      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _route.default.extend({
        model() {
          step(assert, 1, 'DummyRoute#model');
          return deferred.promise;
        }
      }));
      this.add('route:loading', _route.default.extend({
        setupController() {
          step(assert, 2, 'LoadingRoute#setupController');
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/').then(() => {
        let promise = this.visit('/dummy').then(() => {
          let text = this.$('#app').text();
          assert.equal(text, 'DUMMY', "dummy template has been rendered");
        });
        assert.equal(this.appRouter.currentPath, 'loading', "loading state entered");
        deferred.resolve();
        return promise;
      });
    }
    ['@test Enter loading route with correct query parameters'](assert) {
      let deferred = _runtime.RSVP.defer();
      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _route.default.extend({
        model() {
          step(assert, 1, 'DummyRoute#model');
          return deferred.promise;
        }
      }));
      this.add('controller:application', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['qux'];
          this.qux = 'initial';
        }
      });
      this.add('route:loading', _route.default.extend({
        setupController() {
          step(assert, 2, 'LoadingRoute#setupController');
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/?qux=updated').then(() => {
        assert.equal(this.getController('application').qux, 'updated', 'the application controller has the correct qp value');
        let promise = this.visit('/dummy?qux=updated').then(() => {
          let text = this.$('#app').text();
          assert.equal(text, 'DUMMY', "dummy template has been rendered");
          assert.equal(this.getController('application').qux, 'updated', 'the application controller has the correct qp value');
        });
        assert.equal(this.appRouter.currentPath, 'loading', "loading state entered");
        assert.equal(this.currentURL, '/dummy?qux=updated', "during loading url reflect the correct state");
        assert.equal(this.getController('application').qux, 'updated', 'the application controller has the correct qp value');
        deferred.resolve();
        return promise;
      });
    }
    ['@test Enter child-loading route with correct query parameters'](assert) {
      assert.expect(8);
      let deferred = _runtime.RSVP.defer();
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.add('route:parent.child', _route.default.extend({
        model() {
          step(assert, 1, 'ChildRoute#model');
          return deferred.promise;
        }
      }));
      this.add('controller:parent', class extends _controller.default {
        constructor() {
          super(...arguments);
          this.queryParams = ['qux'];
          this.qux = 'initial';
        }
      });
      this.add('route:parent.child_loading', _route.default.extend({
        setupController() {
          step(assert, 2, 'ChildLoadingRoute#setupController');
        }
      }));
      this.addTemplate('parent', 'PARENT {{outlet}}');
      this.addTemplate('parent.child', 'CHILD');
      return this.visit('/parent?qux=updated').then(() => {
        assert.equal(this.getController('parent').qux, 'updated', 'in the parent route, the parent controller has the correct qp value');
        let promise = this.visit('/parent/child?qux=updated').then(() => {
          let text = this.$('#app').text();
          assert.equal(text, 'PARENT CHILD', "child template has been rendered");
          assert.equal(this.getController('parent').qux, 'updated', 'after entered in the parent.child route, the parent controller has the correct qp value');
        });
        assert.equal(this.appRouter.currentPath, 'parent.child_loading', "child loading state entered");
        assert.equal(this.currentURL, '/parent/child?qux=updated', "during child loading, url reflect the correct state");
        assert.equal(this.getController('parent').qux, 'updated', 'in the child_loading route, the parent controller has the correct qp value');
        deferred.resolve();
        return promise;
      });
    }
    ['@test Slow promises returned from ApplicationRoute#model enter ApplicationLoadingRoute if present'](assert) {
      let appDeferred = _runtime.RSVP.defer();
      this.add('route:application', _route.default.extend({
        model() {
          return appDeferred.promise;
        }
      }));
      let loadingRouteEntered = false;
      this.add('route:application_loading', _route.default.extend({
        setupController() {
          loadingRouteEntered = true;
        }
      }));
      let promise = this.visit('/').then(() => {
        assert.equal(this.$('#app').text(), 'INDEX', 'index route loaded');
      });
      assert.ok(loadingRouteEntered, 'ApplicationLoadingRoute was entered');
      appDeferred.resolve();
      return promise;
    }
    ['@test Slow promises returned from ApplicationRoute#model enter application_loading if template present'](assert) {
      let appDeferred = _runtime.RSVP.defer();
      this.addTemplate('application_loading', "\n      <div id=\"toplevel-loading\">TOPLEVEL LOADING</div>\n    ");
      this.add('route:application', _route.default.extend({
        model() {
          return appDeferred.promise;
        }
      }));
      let promise = this.visit('/').then(() => {
        let length = this.$('#toplevel-loading').length;
        text = this.$('#app').text();
        assert.equal(length, 0, "top-level loading view has been entirely removed from the DOM");
        assert.equal(text, 'INDEX', 'index has fully rendered');
      });
      let text = this.$('#toplevel-loading').text();
      assert.equal(text, 'TOPLEVEL LOADING', 'still loading the top level');
      appDeferred.resolve();
      return promise;
    }
    ['@test Prioritized substate entry works with preserved-namespace nested routes'](assert) {
      let deferred = _runtime.RSVP.defer();
      this.addTemplate('foo.bar_loading', 'FOOBAR LOADING');
      this.addTemplate('foo.bar.index', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            path: '/bar'
          }, function () {});
        });
      });
      this.add('route:foo.bar', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      return this.visit('/').then(() => {
        let promise = this.visit('/foo/bar').then(() => {
          text = this.$('#app').text();
          assert.equal(text, 'YAY', 'foo.bar.index fully loaded');
        });
        let text = this.$('#app').text();
        assert.equal(text, 'FOOBAR LOADING', "foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)");
        deferred.resolve();
        return promise;
      });
    }
    ['@test Prioritized substate entry works with reset-namespace nested routes'](assert) {
      let deferred = _runtime.RSVP.defer();
      this.addTemplate('bar_loading', 'BAR LOADING');
      this.addTemplate('bar.index', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            path: '/bar',
            resetNamespace: true
          }, function () {});
        });
      });
      this.add('route:bar', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      return this.visit('/').then(() => {
        let promise = this.visit('/foo/bar').then(() => {
          text = this.$('#app').text();
          assert.equal(text, 'YAY', 'bar.index fully loaded');
        });
        let text = this.$('#app').text();
        assert.equal(text, 'BAR LOADING', "foo.bar_loading was entered (as opposed to something likefoo/foo/bar_loading)");
        deferred.resolve();
        return promise;
      });
    }
    ['@test Prioritized loading substate entry works with preserved-namespace nested routes'](assert) {
      let deferred = _runtime.RSVP.defer();
      this.addTemplate('foo.bar_loading', 'FOOBAR LOADING');
      this.addTemplate('foo.bar', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.bar', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      let promise = this.visit('/foo/bar').then(() => {
        text = this.$('#app').text();
        assert.equal(text, 'YAY', 'foo.bar has rendered');
      });
      let text = this.$('#app').text();
      assert.equal(text, 'FOOBAR LOADING', "foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)");
      deferred.resolve();
      return promise;
    }
    async ['@test Prioritized error substate entry works with preserved-namespace nested routes'](assert) {
      this.addTemplate('foo.bar_error', 'FOOBAR ERROR: {{@model.msg}}');
      this.addTemplate('foo.bar', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.bar', _route.default.extend({
        model() {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        }
      }));
      await this.visit('/');
      await this.visit('/foo/bar');
      assert.equal(this.$('#app').text(), 'FOOBAR ERROR: did it broke?', "foo.bar_error was entered (as opposed to something like foo/foo/bar_error)");
    }
    ['@test Prioritized loading substate entry works with auto-generated index routes'](assert) {
      let deferred = _runtime.RSVP.defer();
      this.addTemplate('foo.index_loading', 'FOO LOADING');
      this.addTemplate('foo.index', 'YAY');
      this.addTemplate('foo', '{{outlet}}');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.index', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      this.add('route:foo', _route.default.extend({
        model() {
          return true;
        }
      }));
      let promise = this.visit('/foo').then(() => {
        text = this.$('#app').text();
        assert.equal(text, 'YAY', 'foo.index was rendered');
      });
      let text = this.$('#app').text();
      assert.equal(text, 'FOO LOADING', 'foo.index_loading was entered');
      deferred.resolve();
      return promise;
    }
    async ['@test Prioritized error substate entry works with auto-generated index routes'](assert) {
      this.addTemplate('foo.index_error', 'FOO ERROR: {{@model.msg}}');
      this.addTemplate('foo.index', 'YAY');
      this.addTemplate('foo', '{{outlet}}');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.index', _route.default.extend({
        model() {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        }
      }));
      this.add('route:foo', _route.default.extend({
        model() {
          return true;
        }
      }));
      await this.visit('/');
      await this.visit('/foo');
      assert.equal(this.$('#app').text(), 'FOO ERROR: did it broke?', 'foo.index_error was entered');
    }
    async ['@test Rejected promises returned from ApplicationRoute transition into top-level application_error'](assert) {
      let reject = true;
      this.addTemplate('index', '<div id="index">INDEX</div>');
      this.add('route:application', _route.default.extend({
        init() {
          this._super(...arguments);
        },
        model() {
          if (reject) {
            return _runtime.RSVP.reject({
              msg: 'BAD NEWS BEARS'
            });
          } else {
            return {};
          }
        }
      }));
      this.addTemplate('application_error', "<p id=\"toplevel-error\">TOPLEVEL ERROR: {{@model.msg}}</p>");
      await this.visit('/');
      assert.equal(this.$('#toplevel-error').text(), 'TOPLEVEL ERROR: BAD NEWS BEARS', 'toplevel error rendered');
      reject = false;
      await this.visit('/');
      assert.equal(this.$('#index').text(), 'INDEX', 'the index route resolved');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Loading/Error Substates - nested routes', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      counter = 1;
      this.addTemplate('application', "<div id=\"app\">{{outlet}}</div>");
      this.addTemplate('index', 'INDEX');
      this.addTemplate('grandma', 'GRANDMA {{outlet}}');
      this.addTemplate('mom', 'MOM');
      this.router.map(function () {
        this.route('grandma', function () {
          this.route('mom', {
            resetNamespace: true
          }, function () {
            this.route('sally');
            this.route('this-route-throws');
          });
          this.route('puppies');
        });
        this.route('memere', {
          path: '/memere/:seg'
        }, function () {});
      });
    }
    getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    }
    async ['@test ApplicationRoute#currentPath reflects loading state path'](assert) {
      await this.visit('/');
      let momDeferred = _runtime.RSVP.defer();
      this.addTemplate('grandma.loading', 'GRANDMALOADING');
      this.add('route:mom', _route.default.extend({
        model() {
          return momDeferred.promise;
        }
      }));
      let promise = (0, _internalTestHelpers.runTask)(() => this.visit('/grandma/mom')).then(() => {
        text = this.$('#app').text();
        assert.equal(text, 'GRANDMA MOM', "Grandma.mom loaded text is displayed");
        assert.equal(this.appRouter.currentPath, 'grandma.mom.index', "currentPath reflects final state");
      });
      let text = this.$('#app').text();
      assert.equal(text, 'GRANDMA GRANDMALOADING', "Grandma.mom loading text displayed");
      assert.equal(this.appRouter.currentPath, 'grandma.loading', "currentPath reflects loading state");
      momDeferred.resolve();
      return promise;
    }
    async ["@test Loading actions bubble to root but don't enter substates above pivot "](assert) {
      await this.visit('/');
      let sallyDeferred = _runtime.RSVP.defer();
      let puppiesDeferred = _runtime.RSVP.defer();
      this.add('route:application', _route.default.extend({
        actions: {
          loading() {
            assert.ok(true, 'loading action received on ApplicationRoute');
          }
        }
      }));
      this.add('route:mom.sally', _route.default.extend({
        model() {
          return sallyDeferred.promise;
        }
      }));
      this.add('route:grandma.puppies', _route.default.extend({
        model() {
          return puppiesDeferred.promise;
        }
      }));
      let promise = this.visit('/grandma/mom/sally');
      assert.equal(this.appRouter.currentPath, 'index', 'Initial route fully loaded');
      sallyDeferred.resolve();
      promise.then(() => {
        assert.equal(this.appRouter.currentPath, 'grandma.mom.sally', 'transition completed');
        let visit = this.visit('/grandma/puppies');
        assert.equal(this.appRouter.currentPath, 'grandma.mom.sally', 'still in initial state because the only loading state is above the pivot route');
        return visit;
      }).then(() => {
        (0, _internalTestHelpers.runTask)(() => puppiesDeferred.resolve());
        assert.equal(this.appRouter.currentPath, 'grandma.puppies', 'Finished transition');
      });
      return promise;
    }
    async ['@test Default error event moves into nested route'](assert) {
      await this.visit('/');
      this.addTemplate('grandma.error', 'ERROR: {{@model.msg}}');
      this.add('route:mom.sally', _route.default.extend({
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error() {
            step(assert, 2, 'MomSallyRoute#actions.error');
            return true;
          }
        }
      }));
      await this.visit('/grandma/mom/sally');
      step(assert, 3, 'App finished loading');
      assert.equal(this.$('#app').text(), 'GRANDMA ERROR: did it broke?', 'error bubbles');
      assert.equal(this.appRouter.currentPath, 'grandma.error', 'Initial route fully loaded');
    }
    async ["@test Non-bubbled errors that re-throw aren't swallowed"](assert) {
      await this.visit('/');
      this.add('route:mom.sally', _route.default.extend({
        model() {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error(err) {
            // returns undefined which is falsey
            throw err;
          }
        }
      }));
      await assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
        return err.msg === 'did it broke?';
      }, 'it broke');
    }
    async ["@test Handled errors that re-throw aren't swallowed"](assert) {
      await this.visit('/');
      let handledError;
      this.add('route:mom.sally', _route.default.extend({
        router: (0, _service.service)(),
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error(err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            this.router.transitionTo('mom.this-route-throws');
            return false;
          }
        }
      }));
      this.add('route:mom.this-route-throws', _route.default.extend({
        model() {
          step(assert, 3, 'MomThisRouteThrows#model');
          throw handledError;
        }
      }));
      await assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
        return err.msg === 'did it broke?';
      }, "it broke");
    }
    async ['@test errors that are bubbled are thrown at a higher level if not handled'](assert) {
      await this.visit('/');
      this.add('route:mom.sally', _route.default.extend({
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error() {
            step(assert, 2, 'MomSallyRoute#actions.error');
            return true;
          }
        }
      }));
      await assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
        return err.msg == 'did it broke?';
      }, 'Correct error was thrown');
    }
    async ["@test Handled errors that are thrown through rejection aren't swallowed"](assert) {
      await this.visit('/');
      let handledError;
      this.add('route:mom.sally', _route.default.extend({
        router: (0, _service.service)(),
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error(err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            this.router.transitionTo('mom.this-route-throws');
            return false;
          }
        }
      }));
      this.add('route:mom.this-route-throws', _route.default.extend({
        model() {
          step(assert, 3, 'MomThisRouteThrows#model');
          return _runtime.RSVP.reject(handledError);
        }
      }));
      await assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
        return err.msg === 'did it broke?';
      }, 'it broke');
    }
    async ['@test Default error events move into nested route, prioritizing more specifically named error routes - NEW'](assert) {
      await this.visit('/');
      this.addTemplate('grandma.error', 'ERROR: {{@model.msg}}');
      this.addTemplate('mom_error', 'MOM ERROR: {{@model.msg}}');
      this.add('route:mom.sally', _route.default.extend({
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error() {
            step(assert, 2, 'MomSallyRoute#actions.error');
            return true;
          }
        }
      }));
      await this.visit('/grandma/mom/sally');
      step(assert, 3, 'Application finished booting');
      assert.equal(this.$('#app').text(), 'GRANDMA MOM ERROR: did it broke?', 'the more specifically named mome error substate was entered over the other error route');
      assert.equal(this.appRouter.currentPath, 'grandma.mom_error', 'Initial route fully loaded');
    }
    async ['@test Slow promises waterfall on startup'](assert) {
      await this.visit('/');
      let grandmaDeferred = _runtime.RSVP.defer();
      let sallyDeferred = _runtime.RSVP.defer();
      this.addTemplate('loading', 'LOADING');
      this.addTemplate('mom', 'MOM {{outlet}}');
      this.addTemplate('mom.loading', 'MOMLOADING');
      this.addTemplate('mom.sally', 'SALLY');
      this.add('route:grandma', _route.default.extend({
        model() {
          step(assert, 1, 'GrandmaRoute#model');
          return grandmaDeferred.promise;
        }
      }));
      this.add('route:mom', _route.default.extend({
        model() {
          step(assert, 2, 'MomRoute#model');
          return {};
        }
      }));
      this.add('route:mom.sally', _route.default.extend({
        model() {
          step(assert, 3, 'SallyRoute#model');
          return sallyDeferred.promise;
        },
        setupController() {
          step(assert, 4, 'SallyRoute#setupController');
        }
      }));
      let promise = (0, _internalTestHelpers.runTask)(() => this.visit('/grandma/mom/sally')).then(() => {
        text = this.$('#app').text();
        assert.equal(text, 'GRANDMA MOM SALLY', "Sally template displayed");
      });
      let text = this.$('#app').text();
      assert.equal(text, 'LOADING', "The loading template is nested in application template's outlet");
      (0, _internalTestHelpers.runTask)(() => grandmaDeferred.resolve());
      text = this.$('#app').text();
      assert.equal(text, 'GRANDMA MOM MOMLOADING', "Mom's child loading route is displayed due to sally's slow promise");
      sallyDeferred.resolve();
      return promise;
    }
    async ['@test Enter child loading state of pivot route'](assert) {
      await this.visit('/');
      let deferred = _runtime.RSVP.defer();
      this.addTemplate('grandma.loading', 'GMONEYLOADING');
      this.add('route:mom.sally', _route.default.extend({
        setupController() {
          step(assert, 1, 'SallyRoute#setupController');
        }
      }));
      this.add('route:grandma.puppies', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      await this.visit('/grandma/mom/sally');
      assert.equal(this.appRouter.currentPath, 'grandma.mom.sally', 'Initial route fully loaded');
      let promise = (0, _internalTestHelpers.runTask)(() => this.visit('/grandma/puppies')).then(() => {
        assert.equal(this.appRouter.currentPath, 'grandma.puppies', 'Finished transition');
      });
      assert.equal(this.appRouter.currentPath, 'grandma.loading', "in pivot route's child loading state");
      deferred.resolve();
      return promise;
    }
    async ["@test Error events that aren't bubbled don't throw application assertions"](assert) {
      await this.visit('/');
      this.add('route:mom.sally', _route.default.extend({
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error(err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            assert.equal(err.msg, 'did it broke?', "it didn't break");
            return false;
          }
        }
      }));
      return this.visit('/grandma/mom/sally');
    }
    ['@test Handled errors that bubble can be handled at a higher level'](assert) {
      let handledError;
      this.add('route:mom', _route.default.extend({
        actions: {
          error(err) {
            step(assert, 3, 'MomRoute#actions.error');
            assert.equal(err, handledError, "error handled and rebubbled is handleable at higher route");
          }
        }
      }));
      this.add('route:mom.sally', _route.default.extend({
        model() {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error(err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            return true;
          }
        }
      }));
      return this.visit('/grandma/mom/sally');
    }
    async ['@test Setting a query param during a slow transition should work'](assert) {
      await this.visit('/');
      let deferred = _runtime.RSVP.defer();
      this.addTemplate('memere.loading', 'MMONEYLOADING');
      this.add('route:grandma', _route.default.extend({
        router: (0, _service.service)(),
        beforeModel: function () {
          this.router.transitionTo('memere', 1);
        }
      }));
      this.add('route:memere', _route.default.extend({
        queryParams: {
          test: {
            defaultValue: 1
          }
        }
      }));
      this.add('route:memere.index', _route.default.extend({
        model() {
          return deferred.promise;
        }
      }));
      let promise = (0, _internalTestHelpers.runTask)(() => this.visit('/grandma')).then(() => {
        assert.equal(this.appRouter.currentPath, 'memere.index', 'Transition should be complete');
      });
      let memereController = this.getController('memere');
      assert.equal(this.appRouter.currentPath, 'memere.loading', 'Initial route should be loading');
      memereController.set('test', 3);
      assert.equal(this.appRouter.currentPath, 'memere.loading', 'Initial route should still be loading');
      assert.equal(memereController.get('test'), 3, 'Controller query param value should have changed');
      deferred.resolve();
      return promise;
    }
  });
});
define("ember/tests/routing/template_rendering_test", ["@ember/routing/route", "@ember/controller", "@ember/object", "@ember/array", "internal-test-helpers", "@ember/runloop", "@ember/-internals/glimmer", "@ember/service"], function (_route, _controller, _object, _array, _internalTestHelpers, _runloop, _glimmer, _service) {
  "use strict";

  /* eslint-disable no-console */

  let originalConsoleError;
  (0, _internalTestHelpers.moduleFor)('Route - template rendering', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this.addTemplate('home', '<h3 class="hours">Hours</h3>');
      this.addTemplate('camelot', '<section id="camelot"><h3>Is a silly place</h3></section>');
      this.addTemplate('homepage', '<h3 id="troll">Megatroll</h3><p>{{this.name}}</p>');
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      originalConsoleError = console.error;
    }
    teardown() {
      super.teardown();
      console.error = originalConsoleError;
    }
    get currentPath() {
      let currentPath;
      expectDeprecation(() => {
        currentPath = this.applicationInstance.lookup('controller:application').get('currentPath');
      }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
      return currentPath;
    }
    async ['@test warn on URLs not included in the route set'](assert) {
      await this.visit('/');
      await assert.rejects(this.visit('/what-is-this-i-dont-even'), /\/what-is-this-i-dont-even/);
    }
    ['@test render uses templateName from route'](assert) {
      this.addTemplate('the_real_home_template', '<p>THIS IS THE REAL HOME</p>');
      this.add('route:home', _route.default.extend({
        templateName: 'the_real_home_template'
      }));
      return this.visit('/').then(() => {
        let text = this.$('p').text();
        assert.equal(text, 'THIS IS THE REAL HOME', 'the homepage template was rendered');
      });
    }
    ['@test Generated names can be customized when providing routes with dot notation'](assert) {
      assert.expect(4);
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('foo', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('bar', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('bar.baz', '<p>{{this.name}}Bottom!</p>');
      this.router.map(function () {
        this.route('foo', {
          path: '/top'
        }, function () {
          this.route('bar', {
            path: '/middle',
            resetNamespace: true
          }, function () {
            this.route('baz', {
              path: '/bottom'
            });
          });
        });
      });
      this.add('route:foo', _route.default.extend({
        setupController() {
          assert.ok(true, 'FooBarRoute was called');
          return this._super(...arguments);
        }
      }));
      this.add('route:bar.baz', _route.default.extend({
        setupController() {
          assert.ok(true, 'BarBazRoute was called');
          return this._super(...arguments);
        }
      }));
      this.add('controller:bar', _controller.default.extend({
        name: 'Bar'
      }));
      this.add('controller:bar.baz', _controller.default.extend({
        name: 'BarBaz'
      }));
      return this.visit('/top/middle/bottom').then(() => {
        assert.ok(true, '/top/middle/bottom has been handled');
        let rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle .bottom p')), 'BarBazBottom!', 'The templates were rendered into their appropriate parents');
      });
    }
    ["@test Child routes render into their parent route's template by default"](assert) {
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('top', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('middle', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('middle.bottom', '<p>Bottom!</p>');
      this.router.map(function () {
        this.route('top', function () {
          this.route('middle', {
            resetNamespace: true
          }, function () {
            this.route('bottom');
          });
        });
      });
      return this.visit('/top/middle/bottom').then(() => {
        assert.ok(true, '/top/middle/bottom has been handled');
        let rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle .bottom p')), 'Bottom!', 'The templates were rendered into their appropriate parents');
      });
    }
    ['@test Application template does not duplicate when re-rendered'](assert) {
      this.addTemplate('application', '<h3 class="render-once">I render once</h3>{{outlet}}');
      this.router.map(function () {
        this.route('posts');
      });
      this.add('route:application', _route.default.extend({
        model() {
          return (0, _array.A)();
        }
      }));
      return this.visit('/posts').then(() => {
        assert.ok(true, '/posts has been handled');
        let rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('h3.render-once')), 'I render once');
      });
    }
    ['@test Child routes should render inside the application template if the application template causes a redirect'](assert) {
      this.addTemplate('application', '<h3>App</h3> {{outlet}}');
      this.addTemplate('posts', 'posts');
      this.router.map(function () {
        this.route('posts');
        this.route('photos');
      });
      this.add('route:application', _route.default.extend({
        router: (0, _service.service)(),
        afterModel() {
          this.router.transitionTo('posts');
        }
      }));
      return this.visit('/posts').then(() => {
        let rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'App posts');
      });
    }
    async ["@test The template is not re-rendered when the route's model changes"](assert) {
      this.router.map(function () {
        this.route('page', {
          path: '/page/:name'
        });
      });
      this.add('route:page', _route.default.extend({
        model(params) {
          return _object.default.create({
            name: params.name
          });
        }
      }));
      let insertionCount = 0;
      this.add('component:foo-bar', _glimmer.Component.extend({
        didInsertElement() {
          insertionCount += 1;
        }
      }));
      this.addTemplate('page', '<p>{{@model.name}}{{foo-bar}}</p>');
      let rootElement = document.getElementById('qunit-fixture');
      await this.visit('/page/first');
      assert.ok(true, '/page/first has been handled');
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'first');
      assert.equal(insertionCount, 1);
      await this.visit('/page/second');
      assert.ok(true, '/page/second has been handled');
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'second');
      assert.equal(insertionCount, 1, 'view should have inserted only once');
      let router = this.applicationInstance.lookup('router:main');
      await (0, _runloop.run)(() => router.transitionTo('page', _object.default.create({
        name: 'third'
      })));
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'third');
      assert.equal(insertionCount, 1, 'view should still have inserted only once');
    }
    ['@test {{outlet}} works when created after initial render'](assert) {
      this.addTemplate('sample', 'Hi{{#if this.showTheThing}}{{outlet}}{{/if}}Bye');
      this.addTemplate('sample.inner', 'Yay');
      this.addTemplate('sample.inner2', 'Boo');
      this.router.map(function () {
        this.route('sample', {
          path: '/'
        }, function () {
          this.route('inner', {
            path: '/'
          });
          this.route('inner2', {
            path: '/2'
          });
        });
      });
      let rootElement;
      return this.visit('/').then(() => {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'HiBye', 'initial render');
        (0, _runloop.run)(() => this.applicationInstance.lookup('controller:sample').set('showTheThing', true));
        assert.equal(rootElement.textContent.trim(), 'HiYayBye', 'second render');
        return this.visit('/2');
      }).then(() => {
        assert.equal(rootElement.textContent.trim(), 'HiBooBye', 'third render');
      });
    }
    ['@test Components inside an outlet have their didInsertElement hook invoked when the route is displayed'](assert) {
      this.addTemplate('index', '{{#if this.showFirst}}{{my-component}}{{else}}{{other-component}}{{/if}}');
      let myComponentCounter = 0;
      let otherComponentCounter = 0;
      let indexController;
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('controller:index', _controller.default.extend({
        showFirst: true
      }));
      this.add('route:index', _route.default.extend({
        setupController(controller) {
          indexController = controller;
        }
      }));
      this.add('component:my-component', _glimmer.Component.extend({
        didInsertElement() {
          myComponentCounter++;
        }
      }));
      this.add('component:other-component', _glimmer.Component.extend({
        didInsertElement() {
          otherComponentCounter++;
        }
      }));
      return this.visit('/').then(() => {
        assert.strictEqual(myComponentCounter, 1, 'didInsertElement invoked on displayed component');
        assert.strictEqual(otherComponentCounter, 0, 'didInsertElement not invoked on displayed component');
        (0, _runloop.run)(() => indexController.set('showFirst', false));
        assert.strictEqual(myComponentCounter, 1, 'didInsertElement not invoked on displayed component');
        assert.strictEqual(otherComponentCounter, 1, 'didInsertElement invoked on displayed component');
      });
    }
  });
});
define("ember/tests/routing/toplevel_dom_test", ["@ember/-internals/environment", "internal-test-helpers"], function (_environment, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Top Level DOM Structure', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super(...arguments);
      this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
    }
    teardown() {
      super.teardown();
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
    }
    ['@test topmost template with wrapper']() {
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = true;
      this.addTemplate('application', 'hello world');
      return this.visit('/').then(() => {
        this.assertComponentElement(this.element, {
          content: 'hello world'
        });
      });
    }
    ['@test topmost template without wrapper']() {
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      this.addTemplate('application', 'hello world');
      return this.visit('/').then(() => {
        this.assertInnerHTML('hello world');
      });
    }
  });
});
define("ember/tests/service_injection_test", ["@ember/-internals/owner", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "internal-test-helpers", "@ember/object"], function (_owner, _controller, _service, _runtime, _internalTestHelpers, _object) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Service Injection', class extends _internalTestHelpers.ApplicationTestCase {
    async ['@test Service can be injected and is resolved'](assert) {
      this.add('controller:application', _controller.default.extend({
        myService: (0, _service.service)('my-service')
      }));
      let MyService = _service.default.extend();
      this.add('service:my-service', MyService);
      this.addTemplate('application', '');
      await this.visit('/');
      let controller = this.applicationInstance.lookup('controller:application');
      assert.ok(controller.get('myService') instanceof MyService);
    }
    async ['@test Service can be an object proxy and access owner in init GH#16484'](assert) {
      let serviceOwner;
      this.add('controller:application', _controller.default.extend({
        myService: (0, _service.service)('my-service')
      }));
      let MyService = _service.default.extend(_runtime._ProxyMixin, {
        init() {
          this._super(...arguments);
          serviceOwner = (0, _owner.getOwner)(this);
        }
      });
      this.add('service:my-service', MyService);
      this.addTemplate('application', '');
      let instance = await this.visit('/');
      let controller = this.applicationInstance.lookup('controller:application');
      assert.ok(controller.get('myService') instanceof MyService);
      assert.equal(serviceOwner, instance, 'should be able to `getOwner` in init');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Service Injection with ES5 Getters', class extends _internalTestHelpers.ApplicationTestCase {
    async ['@test Service can be injected and is resolved without calling `get`'](assert) {
      this.add('controller:application', _controller.default.extend({
        myService: (0, _service.service)('my-service')
      }));
      let MyService = _service.default.extend({
        name: (0, _object.computed)(function () {
          return 'The service name';
        })
      });
      this.add('service:my-service', MyService);
      this.addTemplate('application', '');
      await this.visit('/');
      let controller = this.applicationInstance.lookup('controller:application');
      assert.ok(controller.myService instanceof MyService);
      assert.equal(controller.myService.name, 'The service name', 'service property accessible');
    }
  });
});
define("ember/tests/view_instrumentation_test", ["@ember/instrumentation", "internal-test-helpers"], function (_instrumentation, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View Instrumentation', class extends _internalTestHelpers.ApplicationTestCase {
    constructor() {
      super();
      this.addTemplate('application', "{{outlet}}");
      this.addTemplate('index', "<h1>Index</h1>");
      this.addTemplate('posts', "<h1>Posts</h1>");
      this.router.map(function () {
        this.route('posts');
      });
    }
    teardown() {
      (0, _instrumentation.reset)();
      super.teardown();
    }
    ['@test Nodes without view instances are instrumented'](assert) {
      let called = false;
      (0, _instrumentation.subscribe)('render', {
        before() {
          called = true;
        },
        after() {}
      });
      return this.visit('/').then(() => {
        assert.equal(this.textValue(), 'Index', 'It rendered the correct template');
        assert.ok(called, 'Instrumentation called on first render');
        called = false;
        return this.visit('/posts');
      }).then(() => {
        assert.equal(this.textValue(), 'Posts', 'It rendered the correct template');
        assert.ok(called, 'Instrumentation called on transition to non-view backed route');
      });
    }
  });
});
define("internal-test-helpers/index", ["exports", "internal-test-helpers/lib/factory", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/confirm-export", "internal-test-helpers/lib/equal-inner-html", "internal-test-helpers/lib/equal-tokens", "internal-test-helpers/lib/module-for", "internal-test-helpers/lib/strip", "internal-test-helpers/lib/apply-mixins", "internal-test-helpers/lib/get-text-of", "internal-test-helpers/lib/ember-dev/deprecation", "internal-test-helpers/lib/define-template-values", "internal-test-helpers/lib/compile", "internal-test-helpers/lib/matchers", "internal-test-helpers/lib/run", "internal-test-helpers/lib/test-context", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/test-cases/abstract-application", "internal-test-helpers/lib/test-cases/application", "internal-test-helpers/lib/test-cases/query-param", "internal-test-helpers/lib/test-cases/rendering", "internal-test-helpers/lib/test-cases/router-non-application", "internal-test-helpers/lib/test-cases/router", "internal-test-helpers/lib/test-cases/autoboot-application", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/browser-detect", "internal-test-helpers/lib/registry-check"], function (_exports, _factory, _buildOwner, _confirmExport, _equalInnerHtml, _equalTokens, _moduleFor, _strip, _applyMixins, _getTextOf, _deprecation, _defineTemplateValues, _compile, _matchers, _run, _testContext, _abstract, _abstractApplication, _application, _queryParam, _rendering, _routerNonApplication, _router, _autobootApplication, _testResolver, _browserDetect, _registryCheck) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "AbstractApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _abstractApplication.default;
    }
  });
  Object.defineProperty(_exports, "AbstractTestCase", {
    enumerable: true,
    get: function () {
      return _abstract.default;
    }
  });
  Object.defineProperty(_exports, "ApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _application.default;
    }
  });
  Object.defineProperty(_exports, "AutobootApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _autobootApplication.default;
    }
  });
  Object.defineProperty(_exports, "ModuleBasedTestResolver", {
    enumerable: true,
    get: function () {
      return _testResolver.ModuleBasedResolver;
    }
  });
  Object.defineProperty(_exports, "QueryParamTestCase", {
    enumerable: true,
    get: function () {
      return _queryParam.default;
    }
  });
  Object.defineProperty(_exports, "RenderingTestCase", {
    enumerable: true,
    get: function () {
      return _rendering.default;
    }
  });
  Object.defineProperty(_exports, "RouterNonApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _routerNonApplication.default;
    }
  });
  Object.defineProperty(_exports, "RouterTestCase", {
    enumerable: true,
    get: function () {
      return _router.default;
    }
  });
  Object.defineProperty(_exports, "TestResolver", {
    enumerable: true,
    get: function () {
      return _testResolver.default;
    }
  });
  Object.defineProperty(_exports, "applyMixins", {
    enumerable: true,
    get: function () {
      return _applyMixins.default;
    }
  });
  Object.defineProperty(_exports, "buildOwner", {
    enumerable: true,
    get: function () {
      return _buildOwner.default;
    }
  });
  Object.defineProperty(_exports, "classes", {
    enumerable: true,
    get: function () {
      return _matchers.classes;
    }
  });
  Object.defineProperty(_exports, "compile", {
    enumerable: true,
    get: function () {
      return _compile.default;
    }
  });
  Object.defineProperty(_exports, "confirmExport", {
    enumerable: true,
    get: function () {
      return _confirmExport.default;
    }
  });
  Object.defineProperty(_exports, "defineComponent", {
    enumerable: true,
    get: function () {
      return _defineTemplateValues.defineComponent;
    }
  });
  Object.defineProperty(_exports, "defineSimpleHelper", {
    enumerable: true,
    get: function () {
      return _defineTemplateValues.defineSimpleHelper;
    }
  });
  Object.defineProperty(_exports, "defineSimpleModifier", {
    enumerable: true,
    get: function () {
      return _defineTemplateValues.defineSimpleModifier;
    }
  });
  Object.defineProperty(_exports, "equalInnerHTML", {
    enumerable: true,
    get: function () {
      return _equalInnerHtml.default;
    }
  });
  Object.defineProperty(_exports, "equalTokens", {
    enumerable: true,
    get: function () {
      return _equalTokens.default;
    }
  });
  Object.defineProperty(_exports, "equalsElement", {
    enumerable: true,
    get: function () {
      return _matchers.equalsElement;
    }
  });
  Object.defineProperty(_exports, "expectDeprecation", {
    enumerable: true,
    get: function () {
      return _deprecation.expectDeprecation;
    }
  });
  Object.defineProperty(_exports, "expectDeprecationAsync", {
    enumerable: true,
    get: function () {
      return _deprecation.expectDeprecationAsync;
    }
  });
  Object.defineProperty(_exports, "expectNoDeprecation", {
    enumerable: true,
    get: function () {
      return _deprecation.expectNoDeprecation;
    }
  });
  Object.defineProperty(_exports, "factory", {
    enumerable: true,
    get: function () {
      return _factory.default;
    }
  });
  Object.defineProperty(_exports, "getContext", {
    enumerable: true,
    get: function () {
      return _testContext.getContext;
    }
  });
  Object.defineProperty(_exports, "getTextOf", {
    enumerable: true,
    get: function () {
      return _getTextOf.default;
    }
  });
  Object.defineProperty(_exports, "ignoreDeprecation", {
    enumerable: true,
    get: function () {
      return _deprecation.ignoreDeprecation;
    }
  });
  Object.defineProperty(_exports, "isEdge", {
    enumerable: true,
    get: function () {
      return _browserDetect.isEdge;
    }
  });
  Object.defineProperty(_exports, "moduleFor", {
    enumerable: true,
    get: function () {
      return _moduleFor.default;
    }
  });
  Object.defineProperty(_exports, "regex", {
    enumerable: true,
    get: function () {
      return _matchers.regex;
    }
  });
  Object.defineProperty(_exports, "runAppend", {
    enumerable: true,
    get: function () {
      return _run.runAppend;
    }
  });
  Object.defineProperty(_exports, "runDestroy", {
    enumerable: true,
    get: function () {
      return _run.runDestroy;
    }
  });
  Object.defineProperty(_exports, "runLoopSettled", {
    enumerable: true,
    get: function () {
      return _run.runLoopSettled;
    }
  });
  Object.defineProperty(_exports, "runTask", {
    enumerable: true,
    get: function () {
      return _run.runTask;
    }
  });
  Object.defineProperty(_exports, "runTaskNext", {
    enumerable: true,
    get: function () {
      return _run.runTaskNext;
    }
  });
  Object.defineProperty(_exports, "setContext", {
    enumerable: true,
    get: function () {
      return _testContext.setContext;
    }
  });
  Object.defineProperty(_exports, "setupTestClass", {
    enumerable: true,
    get: function () {
      return _moduleFor.setupTestClass;
    }
  });
  Object.defineProperty(_exports, "strip", {
    enumerable: true,
    get: function () {
      return _strip.default;
    }
  });
  Object.defineProperty(_exports, "styles", {
    enumerable: true,
    get: function () {
      return _matchers.styles;
    }
  });
  Object.defineProperty(_exports, "unsetContext", {
    enumerable: true,
    get: function () {
      return _testContext.unsetContext;
    }
  });
  Object.defineProperty(_exports, "verifyRegistration", {
    enumerable: true,
    get: function () {
      return _registryCheck.verifyRegistration;
    }
  });
});
define("internal-test-helpers/lib/apply-mixins", ["exports", "internal-test-helpers/lib/get-all-property-names"], function (_exports, _getAllPropertyNames) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = applyMixins;
  function isGenerator(mixin) {
    if (mixin && typeof mixin === 'object') {
      let cast = mixin;
      return Array.isArray(cast.cases) && typeof cast.generate === 'function';
    }
    return false;
  }
  function isGeneratorClass(mixin) {
    return typeof mixin === 'function';
  }
  function applyMixins(TestClass) {
    for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      mixins[_key - 1] = arguments[_key];
    }
    mixins.forEach(mixinOrGenerator => {
      let mixin;
      if (isGenerator(mixinOrGenerator)) {
        let generator = mixinOrGenerator;
        mixin = {};
        generator.cases.forEach((value, idx) => {
          Object.assign(mixin, generator.generate(value, idx));
        });
        Object.assign(TestClass.prototype, mixin);
      } else if (isGeneratorClass(mixinOrGenerator)) {
        let properties = (0, _getAllPropertyNames.default)(mixinOrGenerator);
        let mOG = new mixinOrGenerator();
        mixin = mOG;
        properties.forEach(name => {
          TestClass.prototype[name] = function () {
            return mOG[name].apply(mixin, arguments);
          };
        });
      } else {
        mixin = mixinOrGenerator;
        Object.assign(TestClass.prototype, mixin);
      }
    });
    return TestClass;
  }
});
define("internal-test-helpers/lib/browser-detect", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.isEdge = void 0;
  const isEdge = _exports.isEdge = /Edge/.test(navigator.userAgent);
});
define("internal-test-helpers/lib/build-owner", ["exports", "@ember/application", "@ember/application/instance", "@ember/engine", "@ember/destroyable"], function (_exports, _application, _instance, _engine, _destroyable) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = buildOwner;
  class ResolverWrapper {
    constructor(resolver) {
      this.resolver = resolver;
    }
    create() {
      return this.resolver;
    }
  }
  function buildOwner(options) {
    if (options === void 0) {
      options = {};
    }
    let ownerType = options.ownerType || 'application';
    let ownerOptions = options.ownerOptions || {};
    // TODO(SAFETY): this is a lie, and we should use the error thrown below.
    // At the moment, though, some *tests* pass no resolver, and expect this to
    // work anyway. The fix is to have those tests pass a test-friendly resolver
    // and then this will work as expected.
    let resolver = options.resolver;
    // if (!resolver) {
    //   throw new Error('You must provide a resolver to buildOwner');
    // }
    let bootOptions = options.bootOptions || {};
    let namespace;
    if (ownerType === 'application') {
      namespace = _application.default.create({
        autoboot: false,
        Resolver: new ResolverWrapper(resolver)
      });
    } else {
      namespace = _engine.default.create({
        buildRegistry() {
          // SAFETY: This cast isn't that safe, but it should be ok for tests.
          return this.__registry__ = _application.default.buildRegistry(this);
        },
        Resolver: new ResolverWrapper(resolver)
      });
    }
    let owner = namespace.buildInstance(ownerOptions);
    _instance.default.setupRegistry(owner.__registry__, bootOptions);
    (0, _destroyable.registerDestructor)(owner, () => namespace.destroy());
    return owner;
  }
});
define("internal-test-helpers/lib/compile", ["exports", "@glimmer/compiler", "@glimmer/opcode-compiler", "ember-template-compiler"], function (_exports, _compiler, _opcodeCompiler, _emberTemplateCompiler) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = compile;
  /**
  @module ember
  */

  /**
    Uses HTMLBars `compile` function to process a string into a compiled template.
  
    This is not present in production builds.
  
    @private
    @method compile
    @param {String} templateString This is the string to be compiled by HTMLBars.
    @param {Object} options This is an options hash to augment the compiler options.
  */
  function compile(templateSource, options, scopeValues) {
    var _options$locals, _scopeValues, _ref, _options$moduleName, _options$meta, _options$strictMode;
    if (options === void 0) {
      options = {};
    }
    if (scopeValues === void 0) {
      scopeValues = {};
    }
    options.locals = (_options$locals = options.locals) != null ? _options$locals : Object.keys((_scopeValues = scopeValues) != null ? _scopeValues : {});
    let [block, usedLocals] = (0, _compiler.precompileJSON)(templateSource, (0, _emberTemplateCompiler.compileOptions)(options));
    let reifiedScopeValues = usedLocals.map(key => scopeValues[key]);
    let templateBlock = {
      block: JSON.stringify(block),
      moduleName: (_ref = (_options$moduleName = options.moduleName) != null ? _options$moduleName : (_options$meta = options.meta) == null ? void 0 : _options$meta.moduleName) != null ? _ref : '(unknown template module)',
      scope: reifiedScopeValues.length > 0 ? () => reifiedScopeValues : null,
      isStrictMode: (_options$strictMode = options.strictMode) != null ? _options$strictMode : false
    };
    return (0, _opcodeCompiler.templateFactory)(templateBlock);
  }
});
define("internal-test-helpers/lib/confirm-export", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = confirmExport;
  function getDescriptor(obj, path) {
    let parts = path.split('.');
    let value = obj;
    for (let i = 0; i < parts.length - 1; i++) {
      let part = parts[i];
      // NOTE: This isn't entirely safe since we could have a null!
      value = value[part];
      if (!value) {
        return undefined;
      }
    }
    let last = parts[parts.length - 1];
    return Object.getOwnPropertyDescriptor(value, last);
  }
  function confirmExport(Ember, assert, path, moduleId, exportName, mod) {
    try {
      let desc;
      if (path !== null) {
        desc = getDescriptor(Ember, path);
        assert.ok(desc, "the " + path + " property exists on the Ember global");
      } else {
        desc = null;
      }
      if (desc == null) {
        assert.notEqual(mod[exportName], undefined, moduleId + "#" + exportName + " is not `undefined`");
      } else if (typeof exportName === 'string') {
        let value = 'value' in desc ? desc.value : desc.get.call(Ember);
        assert.equal(value, mod[exportName], "Ember." + path + " is exported correctly");
        assert.notEqual(mod[exportName], undefined, "Ember." + path + " is not `undefined`");
      } else if ('value' in desc) {
        assert.equal(desc.value, exportName.value, "Ember." + path + " is exported correctly");
      } else {
        assert.equal(desc.get, mod[exportName.get], "Ember." + path + " getter is exported correctly");
        assert.notEqual(desc.get, undefined, "Ember." + path + " getter is not undefined");
        if (exportName.set) {
          assert.equal(desc.set, mod[exportName.set], "Ember." + path + " setter is exported correctly");
          assert.notEqual(desc.set, undefined, "Ember." + path + " setter is not undefined");
        }
      }
    } catch (error) {
      assert.pushResult({
        result: false,
        message: "An error occurred while testing " + path + " is exported from " + moduleId,
        actual: error,
        expected: undefined
      });
    }
  }
});
define("internal-test-helpers/lib/define-template-values", ["exports", "@glimmer/manager", "@glimmer/runtime", "internal-test-helpers/lib/compile"], function (_exports, _manager, _runtime, _compile) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.defineComponent = defineComponent;
  _exports.defineSimpleHelper = defineSimpleHelper;
  _exports.defineSimpleModifier = defineSimpleModifier;
  class FunctionalHelperManager {
    constructor() {
      this.capabilities = (0, _manager.helperCapabilities)('3.23', {
        hasValue: true
      });
    }
    createHelper(fn, args) {
      return {
        fn,
        args
      };
    }
    getValue(_ref) {
      let {
        fn,
        args
      } = _ref;
      return fn(...args.positional);
    }
    getDebugName(fn) {
      return fn.name || '(anonymous function)';
    }
  }
  const FUNCTIONAL_HELPER_MANAGER = new FunctionalHelperManager();
  const FUNCTIONAL_HELPER_MANAGER_FACTORY = () => FUNCTIONAL_HELPER_MANAGER;
  class FunctionalModifierManager {
    constructor() {
      this.capabilities = (0, _manager.modifierCapabilities)('3.22');
    }
    createModifier(fn, args) {
      return {
        fn,
        args,
        element: undefined,
        destructor: undefined
      };
    }
    installModifier(state, element) {
      state.element = element;
      this.setupModifier(state);
    }
    updateModifier(state) {
      this.destroyModifier(state);
      this.setupModifier(state);
    }
    setupModifier(state) {
      let {
        fn,
        args,
        element
      } = state;
      state.destructor = fn(element, args.positional, args.named);
    }
    destroyModifier(state) {
      if (typeof state.destructor === 'function') {
        state.destructor();
      }
    }
    getDebugName(fn) {
      return fn.name || '(anonymous function)';
    }
  }
  const FUNCTIONAL_MODIFIER_MANAGER = new FunctionalModifierManager();
  const FUNCTIONAL_MODIFIER_MANAGER_FACTORY = () => FUNCTIONAL_MODIFIER_MANAGER;
  function defineComponent(scopeValues, templateSource, definition) {
    if (definition === void 0) {
      definition = (0, _runtime.templateOnlyComponent)();
    }
    let templateFactory = (0, _compile.default)(templateSource, {
      strictMode: scopeValues !== null
    }, scopeValues != null ? scopeValues : {});
    (0, _manager.setComponentTemplate)(templateFactory, definition);
    return definition;
  }
  function defineSimpleHelper(helperFn) {
    return (0, _manager.setHelperManager)(FUNCTIONAL_HELPER_MANAGER_FACTORY, helperFn);
  }
  function defineSimpleModifier(modifierFn) {
    return (0, _manager.setModifierManager)(FUNCTIONAL_MODIFIER_MANAGER_FACTORY, modifierFn);
  }
});
define("internal-test-helpers/lib/element-helpers", ["exports", "internal-test-helpers/lib/test-context"], function (_exports, _testContext) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.getElement = getElement;
  function getElement() {
    let context = (0, _testContext.getContext)();
    if (!context) {
      throw new Error('Test context is not set up.');
    }
    let element = context['element'];
    if (!element) {
      throw new Error('`element` property on test context is not set up.');
    }
    return element;
  }
});
define("internal-test-helpers/lib/ember-dev/assertion", ["exports", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.setupAssertionHelpers = setupAssertionHelpers;
  const BREAK = {};
  /*
    This assertion helper is used to test assertions made using Ember.assert.
    It injects two helpers onto `window`:
  
    - expectAssertion(func: Function, [expectedMessage: String | RegExp])
  
    This function calls `func` and asserts that `Ember.assert` is invoked during
    the execution. Moreover, it takes a String or a RegExp as a second optional
    argument that can be used to test if a specific assertion message was
    generated.
  
    - ignoreAssertion(func: Function)
  
    This function calls `func` and disables `Ember.assert` during the execution.
    In particular, this prevents `Ember.assert` from throw errors that would
    disrupt the control flow.
  */
  function setupAssertionHelpers(hooks, env) {
    let originalAssertFunc = env.getDebugFunction('assert');
    hooks.beforeEach(function (assert) {
      let expectAssertion = (func, expectedMessage) => {
        if (!false /* DEBUG */) {
          assert.ok(true, 'Assertions disabled in production builds.');
          return;
        }
        let sawCall = false;
        let actualMessage = undefined;
        // The try-catch statement is used to "exit" `func` as soon as
        // the first useful assertion has been produced.
        try {
          (0, _utils.callWithStub)(env, 'assert', func, (message, test) => {
            sawCall = true;
            if ((0, _utils.checkTest)(test)) {
              return;
            }
            actualMessage = message;
            throw BREAK;
          });
        } catch (e) {
          if (e !== BREAK) {
            throw e;
          }
        }
        check(assert, sawCall, actualMessage, expectedMessage);
      };
      let ignoreAssertion = func => {
        (0, _utils.callWithStub)(env, 'assert', func);
      };
      let w = window;
      w.expectAssertion = expectAssertion;
      w.ignoreAssertion = ignoreAssertion;
    });
    hooks.afterEach(function () {
      // Edge will occasionally not run finally blocks, so we have to be extra
      // sure we restore the original assert function
      env.setDebugFunction('assert', originalAssertFunc);
      let w = window;
      w.expectAssertion = null;
      w.ignoreAssertion = null;
    });
  }
  function check(assert, sawCall, actualMessage, expectedMessage) {
    // Run assertions in an order that is useful when debugging a test failure.
    if (!sawCall) {
      assert.ok(false, "Expected Ember.assert to be called (Not called with any value).");
    } else if (!actualMessage) {
      assert.ok(false, "Expected a failing Ember.assert (Ember.assert called, but without a failing test).");
    } else {
      if (expectedMessage) {
        if (expectedMessage instanceof RegExp) {
          assert.ok(expectedMessage.test(actualMessage), "Expected failing Ember.assert: '" + expectedMessage + "', but got '" + actualMessage + "'.");
        } else {
          assert.equal(actualMessage, expectedMessage, "Expected failing Ember.assert: '" + expectedMessage + "', but got '" + actualMessage + "'.");
        }
      } else {
        // Positive assertion that assert was called
        assert.ok(true, 'Expected a failing Ember.assert.');
      }
    }
  }
});
define("internal-test-helpers/lib/ember-dev/containers", ["exports", "@ember/-internals/container"], function (_exports, _container) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.setupContainersCheck = setupContainersCheck;
  const {
    _leakTracking: containerLeakTracking
  } = _container.Container;
  function setupContainersCheck(hooks) {
    hooks.afterEach(function () {
      if (containerLeakTracking === undefined) return;
      let {
        config
      } = QUnit;
      let {
        testName,
        testId,
        module: {
          name: moduleName
        },
        finish: originalFinish
      } = config.current;
      config.current.finish = function () {
        originalFinish.call(this);
        originalFinish = undefined;
        config.queue.unshift(function () {
          if (containerLeakTracking.hasContainers()) {
            containerLeakTracking.reset();
            // eslint-disable-next-line no-console
            console.assert(false, "Leaked container after test " + moduleName + ": " + testName + " testId=" + testId);
          }
        });
      };
    });
  }
});
define("internal-test-helpers/lib/ember-dev/debug", ["exports", "internal-test-helpers/lib/ember-dev/method-call-tracker"], function (_exports, _methodCallTracker) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class DebugAssert {
    constructor(methodName, env) {
      this.methodName = methodName;
      this.env = env;
      this.tracker = null;
    }
    inject() {}
    restore() {
      this.reset();
    }
    reset() {
      if (this.tracker) {
        this.tracker.restoreMethod();
      }
      this.tracker = null;
    }
    assert() {
      if (this.tracker) {
        this.tracker.assert();
      }
    }
    runExpectation(func, callback, async) {
      if (async === void 0) {
        async = false;
      }
      let originalTracker = null;
      // When helpers are passed a callback, they get a new tracker context
      if (func) {
        originalTracker = this.tracker;
        this.tracker = null;
      }
      if (!this.tracker) {
        this.tracker = new _methodCallTracker.default(this.env, this.methodName);
      }
      // Yield to caller with tracker instance
      callback(this.tracker);
      // Once the given callback is invoked, the pending assertions should be
      // flushed immediately
      if (func) {
        if (async) {
          return (async () => {
            try {
              await func();
            } finally {
              this.assert();
              this.reset();
              this.tracker = originalTracker;
            }
          })();
        } else {
          try {
            func();
          } finally {
            this.assert();
            this.reset();
            this.tracker = originalTracker;
          }
        }
      }
    }
  }
  var _default = _exports.default = DebugAssert;
});
define("internal-test-helpers/lib/ember-dev/deprecation", ["exports", "@ember/debug", "internal-test-helpers/lib/ember-dev/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _debug, _debug2, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ignoreDeprecation = _exports.expectNoDeprecationAsync = _exports.expectNoDeprecation = _exports.expectDeprecationAsync = _exports.expectDeprecation = _exports.default = void 0;
  _exports.setupDeprecationHelpers = setupDeprecationHelpers;
  function setupDeprecationHelpers(hooks, env) {
    let assertion = new DeprecationAssert(env);
    hooks.beforeEach(function () {
      assertion.reset();
      assertion.inject();
    });
    hooks.afterEach(function () {
      assertion.assert();
      assertion.restore();
    });
  }
  let expectDeprecation = () => {
    throw new Error('DeprecationAssert: To use `expectDeprecation` in a test you must call `setupDeprecationHelpers` first');
  };
  _exports.expectDeprecation = expectDeprecation;
  let ignoreDeprecation = () => {
    throw new Error('DeprecationAssert: To use `ignoreDeprecation` in a test you must call `setupDeprecationHelpers` first');
  };
  _exports.ignoreDeprecation = ignoreDeprecation;
  let expectDeprecationAsync = () => {
    throw new Error('DeprecationAssert: To use `expectDeprecationAsync` in a test you must call `setupDeprecationHelpers` first');
  };
  _exports.expectDeprecationAsync = expectDeprecationAsync;
  let expectNoDeprecation = () => {
    throw new Error('DeprecationAssert: To use `expectNoDeprecation` in a test you must call `setupDeprecationHelpers` first');
  };
  _exports.expectNoDeprecation = expectNoDeprecation;
  let expectNoDeprecationAsync = () => {
    throw new Error('DeprecationAssert: To use `expectNoDeprecationAsync` in a test you must call `setupDeprecationHelpers` first');
  };
  _exports.expectNoDeprecationAsync = expectNoDeprecationAsync;
  class DeprecationAssert extends _debug2.default {
    constructor(env) {
      super('deprecate', env);
    }
    inject() {
      let w = window;
      w.expectNoDeprecation = _exports.expectNoDeprecation = expectNoDeprecation = this.expectNoDeprecation.bind(this);
      w.expectNoDeprecationAsync = _exports.expectNoDeprecationAsync = expectNoDeprecationAsync = this.expectNoDeprecationAsync.bind(this);
      w.expectDeprecation = _exports.expectDeprecation = expectDeprecation = this.expectDeprecation.bind(this);
      w.expectDeprecationAsync = _exports.expectDeprecationAsync = expectDeprecationAsync = this.expectDeprecationAsync.bind(this);
      w.ignoreDeprecation = _exports.ignoreDeprecation = ignoreDeprecation = this.ignoreDeprecation.bind(this);
      super.inject();
    }
    restore() {
      super.restore();
      let w = window;
      w.expectNoDeprecation = undefined;
      w.expectNoDeprecationAsync = undefined;
      w.expectDeprecation = undefined;
      w.expectDeprecationAsync = undefined;
      w.ignoreDeprecation = undefined;
    }
    // Expects no deprecation to happen within a function, or if no function is
    // passed, from the time of calling until the end of the test.
    //
    // expectNoDeprecation(function() {
    //   fancyNewThing();
    // });
    //
    // expectNoDeprecation();
    // Ember.deprecate("Old And Busted");
    //
    expectNoDeprecation(func) {
      this.runExpectation(func, tracker => {
        if (tracker.isExpectingCalls()) {
          throw new Error('expectNoDeprecation was called after expectDeprecation was called!');
        }
        tracker.expectNoCalls();
      });
    }
    // Expects no deprecation to happen within an async function.
    //
    // expectNoDeprecationAsync(async function() {
    //   await fancyAsyncThing();
    // });
    //
    async expectNoDeprecationAsync(func) {
      await this.runExpectation(func, tracker => {
        if (tracker.isExpectingCalls()) {
          throw new Error('expectNoDeprecation was called after expectDeprecation was called!');
        }
        tracker.expectNoCalls();
      }, true);
    }
    expectDeprecation(messageOrFuncOrIsEnabled, messageOrIsEnabled, isEnabled) {
      if (messageOrFuncOrIsEnabled === void 0) {
        messageOrFuncOrIsEnabled = true;
      }
      if (messageOrIsEnabled === void 0) {
        messageOrIsEnabled = true;
      }
      if (isEnabled === void 0) {
        isEnabled = true;
      }
      let func;
      let message;
      if (typeof messageOrFuncOrIsEnabled === 'boolean') {
        func = undefined;
        isEnabled = messageOrFuncOrIsEnabled;
      } else if (typeof messageOrFuncOrIsEnabled === 'function') {
        func = messageOrFuncOrIsEnabled;
        if (typeof messageOrIsEnabled === 'boolean') {
          isEnabled = messageOrIsEnabled;
        } else {
          message = messageOrIsEnabled;
        }
      } else {
        (false && !(typeof messageOrIsEnabled === 'boolean') && (0, _debug.assert)("second argument must be isEnabled flag, got " + messageOrIsEnabled, typeof messageOrIsEnabled === 'boolean'));
        message = messageOrFuncOrIsEnabled;
        isEnabled = messageOrIsEnabled;
      }
      if (isEnabled) {
        this.runExpectation(func, tracker => {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectDeprecation was called after expectNoDeprecation was called!');
          }
          tracker.expectCall(message, ['id', 'until']);
        });
      } else {
        this.expectNoDeprecation(func);
      }
    }
    async expectDeprecationAsync(func, messageOrIsEnabled, isEnabled) {
      if (messageOrIsEnabled === void 0) {
        messageOrIsEnabled = true;
      }
      if (isEnabled === void 0) {
        isEnabled = true;
      }
      let message;
      if (typeof messageOrIsEnabled === 'boolean') {
        isEnabled = messageOrIsEnabled;
      } else {
        message = messageOrIsEnabled;
      }
      if (isEnabled) {
        await this.runExpectation(func, tracker => {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectDeprecation was called after expectNoDeprecation was called!');
          }
          tracker.expectCall(message, ['id', 'until']);
        }, true);
      } else {
        await this.expectNoDeprecationAsync(func);
      }
    }
    ignoreDeprecation(func) {
      (0, _utils.callWithStub)(this.env, 'deprecate', func);
    }
  }
  var _default = _exports.default = DeprecationAssert;
});
define("internal-test-helpers/lib/ember-dev/method-call-tracker", ["exports", "@ember/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _debug, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class MethodCallTracker {
    constructor(env, methodName) {
      this._env = env;
      this._methodName = methodName;
      this._isExpectingNoCalls = false;
      this._expectedMessages = [];
      this._expectedOptionLists = [];
      this._actuals = [];
      this._originalMethod = undefined;
    }
    stubMethod() {
      if (this._originalMethod) {
        // Method is already stubbed
        return;
      }
      let env = this._env;
      let methodName = this._methodName;
      this._originalMethod = env.getDebugFunction(methodName);
      env.setDebugFunction(methodName, (message, test, options) => {
        let resultOfTest = (0, _utils.checkTest)(test);
        this._actuals.push([message, resultOfTest, options]);
      });
    }
    restoreMethod() {
      if (this._originalMethod) {
        this._env.setDebugFunction(this._methodName, this._originalMethod);
      }
    }
    expectCall(message, options) {
      this.stubMethod();
      this._expectedMessages.push(message || /.*/);
      this._expectedOptionLists.push(options);
    }
    expectNoCalls() {
      this.stubMethod();
      this._isExpectingNoCalls = true;
    }
    isExpectingNoCalls() {
      return this._isExpectingNoCalls;
    }
    isExpectingCalls() {
      return !this._isExpectingNoCalls && this._expectedMessages.length;
    }
    assert() {
      let {
        assert
      } = QUnit.config.current;
      let methodName = this._methodName;
      let isExpectingNoCalls = this._isExpectingNoCalls;
      let expectedMessages = this._expectedMessages;
      let expectedOptionLists = this._expectedOptionLists;
      let actuals = this._actuals;
      let o, i;
      if (!isExpectingNoCalls && expectedMessages.length === 0 && actuals.length === 0) {
        return;
      }
      if (!false /* DEBUG */) {
        assert.ok(true, "calls to Ember." + methodName + " disabled in production builds.");
        return;
      }
      if (isExpectingNoCalls) {
        let actualMessages = [];
        for (let actual in actuals) {
          if (!actual[1]) {
            actualMessages.push(actual[0]);
          }
        }
        assert.ok(actualMessages.length === 0, "Expected no Ember." + methodName + " calls, got " + actuals.length + ": " + actualMessages.join(', '));
        return;
      }
      let actual;
      let match = undefined;
      let matched = new Set();
      for (o = 0; o < expectedMessages.length; o++) {
        const expectedMessage = expectedMessages[o];
        const expectedOptionList = expectedOptionLists[o];
        for (i = 0; i < actuals.length; i++) {
          let matchesMessage = false;
          let matchesOptionList = false;
          actual = actuals[i];
          (false && !(actual) && (0, _debug.assert)('has actual', actual)); // We just checked the array
          if (actual[1] === true) {
            continue;
          }
          if (expectedMessage instanceof RegExp && expectedMessage.test(actual[0])) {
            matchesMessage = true;
          } else if (expectedMessage === actual[0]) {
            matchesMessage = true;
          }
          if (expectedOptionList === undefined) {
            matchesOptionList = true;
          } else if (actual[2]) {
            matchesOptionList = true;
            for (let expectedOption of expectedOptionList) {
              matchesOptionList = matchesOptionList && Object.prototype.hasOwnProperty.call(actual[2], expectedOption);
            }
          }
          if (matchesMessage && matchesOptionList) {
            match = actual;
            matched.add(i);
            continue;
          }
        }
        const expectedOptionsMessage = expectedOptionList ? "and options: { " + expectedOptionList.join(', ') + " }" : 'and no options';
        const actualOptionsMessage = actual && actual[2] ? "and options: { " + Object.keys(actual[2]).join(', ') + " }" : 'and no options';
        if (!actual) {
          assert.ok(false, "Received no Ember." + methodName + " calls at all, expecting: " + expectedMessage);
        } else if (match && !match[1]) {
          assert.ok(true, "Received failing Ember." + methodName + " call with message: " + match[0]);
        } else if (match && match[1]) {
          assert.ok(false, "Expected failing Ember." + methodName + " call, got succeeding with message: " + match[0]);
        } else if (actual[1]) {
          assert.ok(false, "Did not receive failing Ember." + methodName + " call matching '" + expectedMessage + "' " + expectedOptionsMessage + ", last was success with '" + actual[0] + "' " + actualOptionsMessage);
        } else if (!actual[1]) {
          assert.ok(false, "Did not receive failing Ember." + methodName + " call matching '" + expectedMessage + "' " + expectedOptionsMessage + ", last was failure with '" + actual[0] + "' " + actualOptionsMessage);
        }
      }
      for (i = 0; i < actuals.length; i++) {
        if (!matched.has(i) && actuals[i][1] !== true) {
          assert.ok(false, "Unexpected Ember." + methodName + " call: " + actuals[i][0]);
        }
      }
    }
  }
  _exports.default = MethodCallTracker;
});
define("internal-test-helpers/lib/ember-dev/namespaces", ["exports", "@ember/-internals/metal", "@ember/runloop"], function (_exports, _metal, _runloop) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.setupNamespacesCheck = setupNamespacesCheck;
  function setupNamespacesCheck(hooks) {
    hooks.afterEach(function () {
      let {
        assert
      } = QUnit.config.current;
      if (_metal.NAMESPACES.length > 0) {
        assert.ok(false, 'Should not have any NAMESPACES after tests');
        (0, _runloop.run)(() => {
          let namespaces = _metal.NAMESPACES.slice();
          for (let namespace of namespaces) {
            namespace.destroy();
          }
        });
      }
      let keys = Object.keys(_metal.NAMESPACES_BY_ID);
      if (keys.length > 0) {
        assert.ok(false, 'Should not have any NAMESPACES_BY_ID after tests');
        for (let key of keys) {
          delete _metal.NAMESPACES_BY_ID[key];
        }
      }
    });
  }
});
define("internal-test-helpers/lib/ember-dev/observers", ["exports", "@ember/-internals/metal", "@ember/runloop"], function (_exports, _metal, _runloop) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.setupObserversCheck = setupObserversCheck;
  function setupObserversCheck(hooks) {
    hooks.afterEach(function () {
      let {
        assert
      } = QUnit.config.current;
      if (_metal.ASYNC_OBSERVERS.size > 0) {
        assert.ok(false, 'Should not have any ASYNC_OBSERVERS after tests');
        (0, _runloop.run)(() => {
          _metal.ASYNC_OBSERVERS.forEach((_, target) => {
            _metal.ASYNC_OBSERVERS.delete(target);
            if (isDestroyable(target)) {
              try {
                target.destroy();
              } catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
              }
            }
          });
        });
      }
      if (_metal.SYNC_OBSERVERS.size > 0) {
        assert.ok(false, 'Should not have any SYNC_OBSERVERS after tests');
        (0, _runloop.run)(() => {
          _metal.SYNC_OBSERVERS.forEach((_, target) => {
            _metal.SYNC_OBSERVERS.delete(target);
            if (isDestroyable(target)) {
              try {
                target.destroy();
              } catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
              }
            }
          });
        });
      }
    });
  }
  function isDestroyable(obj) {
    return 'destroy' in obj && typeof obj['destroy'] === 'function';
  }
});
define("internal-test-helpers/lib/ember-dev/run-loop", ["exports", "@ember/runloop"], function (_exports, _runloop) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.setupRunLoopCheck = setupRunLoopCheck;
  function setupRunLoopCheck(hooks) {
    hooks.afterEach(function (assert) {
      if ((0, _runloop._getCurrentRunLoop)() || (0, _runloop._hasScheduledTimers)()) {
        let done = assert.async();
        // use a setTimeout to allow the current run loop to flush via autorun
        setTimeout(() => {
          // increment expected assertion count for the assertions just below
          let test = assert['test'];
          if (test.expected !== null) {
            test.expected += 2;
          }
          // if it is _still_ not completed, we have a problem and the test should be fixed
          assert.ok(!(0, _runloop._hasScheduledTimers)(), 'Ember run should not have scheduled timers at end of test');
          assert.ok(!(0, _runloop._getCurrentRunLoop)(), 'Should not be in a run loop at end of test');
          // attempt to recover so the rest of the tests can run
          while ((0, _runloop._getCurrentRunLoop)()) {
            (0, _runloop.end)();
          }
          (0, _runloop._cancelTimers)();
          done();
        }, 0);
      }
    });
  }
});
define("internal-test-helpers/lib/ember-dev/setup-qunit", ["exports", "ember", "@ember/debug", "internal-test-helpers/lib/ember-dev/assertion", "internal-test-helpers/lib/ember-dev/containers", "internal-test-helpers/lib/ember-dev/deprecation", "internal-test-helpers/lib/ember-dev/namespaces", "internal-test-helpers/lib/ember-dev/observers", "internal-test-helpers/lib/ember-dev/run-loop", "internal-test-helpers/lib/ember-dev/warning"], function (_exports, _ember, _debug, _assertion, _containers, _deprecation, _namespaces, _observers, _runLoop, _warning) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = setupQUnit;
  function setupQUnit() {
    let env = {
      getDebugFunction: _debug.getDebugFunction,
      setDebugFunction: _debug.setDebugFunction
    };
    let originalModule = QUnit.module;
    QUnit.module = function (name, callback) {
      return originalModule(name, function (hooks) {
        (0, _containers.setupContainersCheck)(hooks);
        (0, _namespaces.setupNamespacesCheck)(hooks);
        (0, _observers.setupObserversCheck)(hooks);
        (0, _runLoop.setupRunLoopCheck)(hooks);
        (0, _assertion.setupAssertionHelpers)(hooks, env);
        (0, _deprecation.setupDeprecationHelpers)(hooks, env);
        (0, _warning.setupWarningHelpers)(hooks, env);
        callback(hooks);
      });
    };
    QUnit.assert.rejects = async function (promise, expected, message) {
      let error;
      let prevOnError = _ember.default.onerror;
      _ember.default.onerror = e => {
        error = e;
      };
      try {
        await promise;
      } catch (e) {
        error = e;
      }
      QUnit.assert.throws(() => {
        if (error) {
          throw error;
        }
      }, expected, message);
      _ember.default.onerror = prevOnError;
    };
    QUnit.assert.throwsAssertion = function (block, expected, message) {
      if (!false /* DEBUG */) {
        QUnit.assert.ok(true, 'Assertions disabled in production builds.');
        return;
      }
      return QUnit.assert.throws(block, expected, message);
    };
    QUnit.assert.rejectsAssertion = async function (promise, expected, message) {
      if (!false /* DEBUG */) {
        QUnit.assert.ok(true, 'Assertions disabled in production builds.');
        return promise;
      }
      await QUnit.assert.rejects(promise, expected, message);
    };
  }
});
define("internal-test-helpers/lib/ember-dev/utils", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.callWithStub = callWithStub;
  _exports.checkTest = checkTest;
  function noop() {}
  function callWithStub(env, name, func, debugStub) {
    if (debugStub === void 0) {
      debugStub = noop;
    }
    let originalFunc = env.getDebugFunction(name);
    try {
      env.setDebugFunction(name, debugStub);
      func();
    } finally {
      env.setDebugFunction(name, originalFunc);
    }
  }
  function checkTest(test) {
    return typeof test === 'function' ? test() : test;
  }
});
define("internal-test-helpers/lib/ember-dev/warning", ["exports", "internal-test-helpers/lib/ember-dev/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _debug, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _exports.setupWarningHelpers = setupWarningHelpers;
  function setupWarningHelpers(hooks, env) {
    let assertion = new WarningAssert(env);
    hooks.beforeEach(function () {
      assertion.reset();
      assertion.inject();
    });
    hooks.afterEach(function () {
      assertion.assert();
      assertion.restore();
    });
  }
  class WarningAssert extends _debug.default {
    constructor(env) {
      super('warn', env);
    }
    inject() {
      // Expects no warning to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test.
      //
      // expectNoWarning(function() {
      //   fancyNewThing();
      // });
      //
      // expectNoWarning();
      // Ember.warn("Oh snap, didn't expect that");
      //
      let expectNoWarning = func => {
        if (typeof func !== 'function') {
          func = undefined;
        }
        this.runExpectation(func, tracker => {
          if (tracker.isExpectingCalls()) {
            throw new Error('expectNoWarning was called after expectWarning was called!');
          }
          tracker.expectNoCalls();
        });
      };
      // Expect a warning to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test. Can be called
      // multiple times to assert warnings with different specific messages
      // happened.
      //
      // expectWarning(function() {
      //   Ember.warn("Times they are a-changin'");
      // }, /* optionalStringOrRegex */);
      //
      // expectWarning(/* optionalStringOrRegex */);
      // Ember.warn("Times definitely be changin'");
      //
      let expectWarning = (func, message) => {
        let actualFunc;
        if (typeof func !== 'function') {
          message = func;
          actualFunc = undefined;
        } else {
          actualFunc = func;
        }
        this.runExpectation(actualFunc, tracker => {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectWarning was called after expectNoWarning was called!');
          }
          tracker.expectCall(message);
        });
      };
      let ignoreWarning = func => {
        (0, _utils.callWithStub)(this.env, 'warn', func);
      };
      let w = window;
      w.expectNoWarning = expectNoWarning;
      w.expectWarning = expectWarning;
      w.ignoreWarning = ignoreWarning;
    }
    restore() {
      super.restore();
      let w = window;
      w.expectWarning = null;
      w.expectNoWarning = null;
      w.ignoreWarning = null;
    }
  }
  var _default = _exports.default = WarningAssert;
});
define("internal-test-helpers/lib/equal-inner-html", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = equalInnerHTML;
  // detect side-effects of cloning svg elements in IE9-11
  let ieSVGInnerHTML = (() => {
    if (!document.createElementNS) {
      return false;
    }
    let div = document.createElement('div');
    let node = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    div.appendChild(node);
    let clone = div.cloneNode(true);
    return clone.innerHTML === '<svg xmlns="http://www.w3.org/2000/svg" />';
  })();
  function normalizeInnerHTML(actualHTML) {
    if (ieSVGInnerHTML) {
      // Replace `<svg xmlns="http://www.w3.org/2000/svg" height="50%" />` with `<svg height="50%"></svg>`, etc.
      // drop namespace attribute
      // replace self-closing elements
      actualHTML = actualHTML.replace(/ xmlns="[^"]+"/, '').replace(/<([^ >]+) [^/>]*\/>/gi, (tag, tagName) => tag.slice(0, tag.length - 3) + "></" + tagName + ">");
    }
    return actualHTML;
  }
  function equalInnerHTML(assert, fragment, html) {
    let actualHTML = normalizeInnerHTML(fragment.innerHTML);
    assert.pushResult({
      result: actualHTML === html,
      actual: actualHTML,
      expected: html,
      message: "innerHTML doesn't match"
    });
  }
});
define("internal-test-helpers/lib/equal-tokens", ["exports", "simple-html-tokenizer"], function (_exports, _simpleHtmlTokenizer) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = equalTokens;
  function generateTokens(containerOrHTML) {
    if (typeof containerOrHTML === 'string') {
      return {
        tokens: (0, _simpleHtmlTokenizer.tokenize)(containerOrHTML),
        html: containerOrHTML
      };
    } else {
      return {
        tokens: (0, _simpleHtmlTokenizer.tokenize)(containerOrHTML.innerHTML),
        html: containerOrHTML.innerHTML
      };
    }
  }
  function normalizeTokens(tokens) {
    tokens.forEach(token => {
      if (token.type === 'StartTag') {
        token.attributes = token.attributes.sort((a, b) => {
          if (a[0] > b[0]) {
            return 1;
          }
          if (a[0] < b[0]) {
            return -1;
          }
          return 0;
        });
      }
    });
  }
  function equalTokens(actualContainer, expectedHTML, message) {
    if (message === void 0) {
      message = null;
    }
    let actual = generateTokens(actualContainer);
    let expected = generateTokens(expectedHTML);
    normalizeTokens(actual.tokens);
    normalizeTokens(expected.tokens);
    let {
      assert
    } = QUnit.config.current;
    let equiv = QUnit.equiv(actual.tokens, expected.tokens);
    if (equiv && expected.html !== actual.html) {
      assert.deepEqual(actual.tokens, expected.tokens, message);
    } else {
      assert.pushResult({
        result: QUnit.equiv(actual.tokens, expected.tokens),
        actual: actual.html,
        expected: expected.html,
        message
      });
    }
  }
});
define("internal-test-helpers/lib/factory", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = factory;
  function setProperties(object, properties) {
    for (let key in properties) {
      if (Object.prototype.hasOwnProperty.call(properties, key)) {
        // SAFETY: we know that the property exists on `properties` because we
        // just checked as much with `hasOwnProperty`.
        object[key] = properties[key];
      }
    }
  }
  let guids = 0;
  function factory() {
    class TestFactory {
      constructor(options) {
        setProperties(this, options);
        this._guid = guids++;
        this.isDestroyed = false;
      }
      destroy() {
        this.isDestroyed = true;
      }
      toString() {
        return '<Factory:' + this._guid + '>';
      }
      static create(options) {
        return new TestFactory(options);
      }
      static reopenClass(options) {
        setProperties(this, options);
      }
      static extend(options) {
        class ChildTestFactory extends TestFactory {}
        setProperties(ChildTestFactory, options);
        return ChildTestFactory;
      }
    }
    return TestFactory;
  }
});
define("internal-test-helpers/lib/get-all-property-names", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = getAllPropertyNames;
  // The `& string` here is to enforce that the propreties are strings since this is expected
  // to be the case elsewhere.
  function getAllPropertyNames(Klass) {
    let proto = Klass.prototype;
    let properties = new Set();
    while (proto !== Object.prototype) {
      // SAFETY: Using `getOwnPropertyNames` should only be returning us properties that are `keyof T`.
      // Additionally, this will only return strings, which is what we're also expecting to work with here.
      let names = Object.getOwnPropertyNames(proto);
      names.forEach(name => properties.add(name));
      proto = Object.getPrototypeOf(proto);
    }
    return properties;
  }
});
define("internal-test-helpers/lib/get-text-of", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = getTextOf;
  function getTextOf(elem) {
    return elem.textContent.trim();
  }
});
define("internal-test-helpers/lib/matchers", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.classes = classes;
  _exports.equalsElement = equalsElement;
  _exports.regex = regex;
  _exports.styles = styles;
  const HTMLElement = window.HTMLElement;
  const MATCHER_BRAND = '3d4ef194-13be-4ccf-8dc7-862eea02c93e';
  function isMatcher(obj) {
    return typeof obj === 'object' && obj !== null && MATCHER_BRAND in obj;
  }
  function equalsAttr(expected) {
    return {
      [MATCHER_BRAND]: true,
      match(actual) {
        return expected === actual;
      },
      expected() {
        return expected;
      },
      message() {
        return "should equal " + this.expected();
      }
    };
  }
  function regex(r) {
    return {
      [MATCHER_BRAND]: true,
      match(v) {
        return r.test(v);
      },
      expected() {
        return r.toString();
      },
      message() {
        return "should match " + this.expected();
      }
    };
  }
  function classes(expected) {
    return {
      [MATCHER_BRAND]: true,
      match(actual) {
        actual = actual.trim();
        return actual && expected.split(/\s+/).sort().join(' ') === actual.trim().split(/\s+/).sort().join(' ');
      },
      expected() {
        return expected;
      },
      message() {
        return "should match " + this.expected();
      }
    };
  }
  function styles(expected) {
    return {
      [MATCHER_BRAND]: true,
      match(actual) {
        // coerce `null` or `undefined` to an empty string
        // needed for matching empty styles on IE9 - IE11
        actual = actual || '';
        actual = actual.trim();
        return expected.split(';').map(s => s.trim()).filter(s => s).sort().join('; ') === actual.split(';').map(s => s.trim()).filter(s => s).sort().join('; ');
      },
      expected() {
        return expected;
      },
      message() {
        return "should match " + this.expected();
      }
    };
  }
  function equalsElement(assert, element, tagName, attributes, content) {
    assert.pushResult({
      result: element.tagName === tagName.toUpperCase(),
      actual: element.tagName.toLowerCase(),
      expected: tagName,
      message: "expect tagName to be " + tagName
    });
    let expectedAttrs = {};
    let expectedCount = 0;
    for (let name in attributes) {
      let expected = attributes[name];
      if (expected !== null) {
        expectedCount++;
      }
      let matcher = isMatcher(expected) ? expected : equalsAttr(expected);
      expectedAttrs[name] = matcher;
      assert.pushResult({
        result: expectedAttrs[name].match(element.getAttribute(name)),
        actual: element.getAttribute(name),
        expected: matcher.expected(),
        message: "Element's " + name + " attribute " + matcher.message()
      });
    }
    let actualAttributes = {};
    for (let attribute of element.attributes) {
      actualAttributes[attribute.name] = attribute.value;
    }
    if (!(element instanceof HTMLElement)) {
      assert.pushResult({
        result: element instanceof HTMLElement,
        actual: element,
        expected: typeof HTMLElement,
        message: 'Element must be an HTML Element, not an SVG Element'
      });
    } else {
      assert.pushResult({
        result: element.attributes.length === expectedCount || !attributes,
        actual: element.attributes.length,
        expected: expectedCount,
        message: "Expected " + expectedCount + " attributes; got " + element.outerHTML
      });
      if (content !== null) {
        assert.pushResult({
          result: element.innerHTML === content,
          actual: element.innerHTML,
          expected: content,
          message: "The element had '" + content + "' as its content"
        });
      }
    }
  }
});
define("internal-test-helpers/lib/module-for", ["exports", "@ember/canary-features", "internal-test-helpers/lib/apply-mixins", "internal-test-helpers/lib/get-all-property-names", "internal-test-helpers/lib/test-context", "rsvp", "@glimmer/destroyable"], function (_exports, _canaryFeatures, _applyMixins, _getAllPropertyNames, _testContext, _rsvp, _destroyable) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = moduleFor;
  _exports.setupTestClass = setupTestClass;
  /* globals URLSearchParams */

  const ASSERT_DESTROYABLES = (() => {
    if (typeof URLSearchParams === 'undefined' || typeof document !== 'object') {
      return false;
    }
    let queryParams = new URLSearchParams(document.location.search.substring(1));
    let assertDestroyables = queryParams.get('assertDestroyables');
    return assertDestroyables !== null;
  })();
  function moduleFor(description, TestClass) {
    for (var _len = arguments.length, mixins = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      mixins[_key - 2] = arguments[_key];
    }
    QUnit.module(description, function (hooks) {
      setupTestClass(hooks, TestClass, ...mixins);
    });
  }
  function afterEachFinally() {
    (0, _testContext.unsetContext)();
    if (false /* DEBUG */ && ASSERT_DESTROYABLES) {
      (0, _destroyable.assertDestroyablesDestroyed)();
    }
  }
  function setupTestClass(hooks, TestClass) {
    hooks.beforeEach(function (assert) {
      if (false /* DEBUG */ && ASSERT_DESTROYABLES) {
        (0, _destroyable.enableDestroyableTracking)();
      }
      let instance = new TestClass(assert);
      this.instance = instance;
      (0, _testContext.setContext)(instance);
      if (instance.beforeEach) {
        return instance.beforeEach(assert);
      }
    });
    hooks.afterEach(function () {
      let promises = [];
      let instance = this.instance;
      this.instance = null;
      if (instance != null && instance.teardown) {
        promises.push(instance.teardown());
      }
      if (instance != null && instance.afterEach) {
        promises.push(instance.afterEach());
      }
      // this seems odd, but actually saves significant time
      // in the test suite
      //
      // returning a promise from a QUnit test always adds a 13ms
      // delay to the test, this filtering prevents returning a
      // promise when it is not needed
      let filteredPromises = promises.filter(Boolean);
      if (filteredPromises.length > 0) {
        return (0, _rsvp.all)(filteredPromises).finally(afterEachFinally).then(() => {});
      }
      afterEachFinally();
      return;
    });
    for (var _len2 = arguments.length, mixins = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      mixins[_key2 - 2] = arguments[_key2];
    }
    if (mixins.length > 0) {
      (0, _applyMixins.default)(TestClass, ...mixins);
    }
    let properties = (0, _getAllPropertyNames.default)(TestClass);
    properties.forEach(name => generateTest(name));
    function shouldTest(features) {
      return features.every(feature => {
        if (feature[0] === '!') {
          return !(0, _canaryFeatures.isEnabled)(feature.slice(1));
        } else {
          return (0, _canaryFeatures.isEnabled)(feature);
        }
      });
    }
    function generateTest(name) {
      if (name.indexOf('@test ') === 0) {
        QUnit.test(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else if (name.indexOf('@only ') === 0) {
        // eslint-disable-next-line qunit/no-only
        QUnit.only(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else if (name.indexOf('@skip ') === 0) {
        QUnit.skip(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else {
        let match = /^@feature\(([A-Z_a-z-! ,]+)\) /.exec(name);
        if (match) {
          let features = match[1].replace(/ /g, '').split(',');
          if (shouldTest(features)) {
            QUnit.test(name.slice(match[0].length), function (assert) {
              return this.instance[name](assert);
            });
          }
        }
      }
    }
  }
});
define("internal-test-helpers/lib/node-query", ["exports", "@ember/debug", "internal-test-helpers/lib/system/synthetic-events"], function (_exports, _debug, _syntheticEvents) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  /* global Node */

  class NodeQuery {
    static query(selector, context) {
      if (context === void 0) {
        context = document;
      }
      // TODO: Can we remove this?
      (false && !(context && context instanceof Node) && (0, _debug.assert)("Invalid second parameter to NodeQuery.query", context && context instanceof Node));
      return new NodeQuery(Array.from(context.querySelectorAll(selector)));
    }
    static element(element) {
      return new NodeQuery([element]);
    }
    constructor(nodes) {
      (false && !(Array.isArray(nodes)) && (0, _debug.assert)('NodeQuery must be initialized with a literal array', Array.isArray(nodes)));
      this.nodes = nodes;
      for (let i = 0; i < nodes.length; i++) {
        this[i] = nodes[i];
      }
      this.length = nodes.length;
      Object.freeze(this);
    }
    find(selector) {
      assertSingle(this);
      return this[0].querySelector(selector);
    }
    findAll(selector) {
      let nodes = [];
      this.nodes.forEach(node => {
        nodes.push(...node.querySelectorAll(selector));
      });
      return new NodeQuery(nodes);
    }
    trigger(eventName, options) {
      if (options === void 0) {
        options = {};
      }
      return this.nodes.map(node => (0, _syntheticEvents.fireEvent)(node, eventName, options));
    }
    click() {
      return this.trigger('click');
    }
    focus() {
      this.nodes.forEach(_syntheticEvents.focus);
    }
    blur() {
      this.nodes.forEach(_syntheticEvents.blur);
    }
    text() {
      return this.nodes.map(node => node.textContent).join('');
    }
    attr(name) {
      if (arguments.length !== 1) {
        throw new Error('not implemented');
      }
      assertSingle(this);
      return this.nodes[0].getAttribute(name);
    }
    prop(name, value) {
      if (arguments.length > 1) {
        return this.setProp(name, value);
      }
      assertSingle(this);
      // SAFETY: This is not safe. We don't know that the node accepts this key.
      return this.nodes[0][name];
    }
    setProp(name, value) {
      // SAFETY: This is not safe. We don't know that the node accepts this key.
      this.nodes.forEach(node => node[name] = value);
      return this;
    }
    val(value) {
      if (arguments.length === 1) {
        return this.setProp('value', value);
      }
      return this.prop('value');
    }
    is(selector) {
      return this.nodes.every(node => (0, _syntheticEvents.matches)(node, selector));
    }
    hasClass(className) {
      return this.is("." + className);
    }
  }
  _exports.default = NodeQuery;
  function assertSingle(nodeQuery) {
    if (nodeQuery.length !== 1) {
      throw new Error("attr(name) called on a NodeQuery with " + nodeQuery.length + " elements. Expected one element.");
    }
  }
});
define("internal-test-helpers/lib/registry-check", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.verifyRegistration = verifyRegistration;
  function verifyRegistration(assert, owner, fullName) {
    assert.ok(owner.resolveRegistration(fullName), "has registration: " + fullName);
  }
});
define("internal-test-helpers/lib/run", ["exports", "@ember/runloop", "@glimmer/destroyable", "rsvp"], function (_exports, _runloop, _destroyable, _rsvp) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.runAppend = runAppend;
  _exports.runDestroy = runDestroy;
  _exports.runLoopSettled = runLoopSettled;
  _exports.runTask = runTask;
  _exports.runTaskNext = runTaskNext;
  function runAppend(view) {
    (0, _runloop.run)(view, 'appendTo', document.getElementById('qunit-fixture'));
  }
  function runDestroy(toDestroy) {
    if (toDestroy) {
      (0, _runloop.run)(_destroyable.destroy, toDestroy);
    }
  }
  function runTask(callback) {
    return (0, _runloop.run)(callback);
  }
  function runTaskNext() {
    return new _rsvp.Promise(resolve => {
      return (0, _runloop.next)(resolve);
    });
  }
  // TODO: Find a better name 
  function runLoopSettled(event) {
    return new _rsvp.Promise(function (resolve) {
      // Every 5ms, poll for the async thing to have finished
      let watcher = setInterval(() => {
        // If there are scheduled timers or we are inside of a run loop, keep polling
        if ((0, _runloop._hasScheduledTimers)() || (0, _runloop._getCurrentRunLoop)()) {
          return;
        }
        // Stop polling
        clearInterval(watcher);
        // Synchronously resolve the promise
        resolve(event);
      }, 5);
    });
  }
});
define("internal-test-helpers/lib/strip", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = strip;
  function strip(_ref) {
    let [...strings] = _ref;
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    let str = strings.map((string, index) => {
      let interpolated = values[index];
      return string + (interpolated !== undefined ? interpolated : '');
    }).join('');
    return str.split('\n').map(s => s.trim()).join('');
  }
});
define("internal-test-helpers/lib/system/synthetic-events", ["exports", "@ember/runloop"], function (_exports, _runloop) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MOUSE_EVENT_TYPES = _exports.KEYBOARD_EVENT_TYPES = _exports.DEFAULT_EVENT_OPTIONS = void 0;
  _exports.blur = blur;
  _exports.click = click;
  _exports.fireEvent = fireEvent;
  _exports.focus = focus;
  _exports.matches = matches;
  /* globals Element */
  const DEFAULT_EVENT_OPTIONS = _exports.DEFAULT_EVENT_OPTIONS = {
    bubbles: true,
    cancelable: true
  };
  const KEYBOARD_EVENT_TYPES = _exports.KEYBOARD_EVENT_TYPES = ['keydown', 'keypress', 'keyup'];
  const MOUSE_EVENT_TYPES = _exports.MOUSE_EVENT_TYPES = ['click', 'mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover'];
  function matches(el, selector) {
    return el.matches(selector);
  }
  function isFocusable(el) {
    let focusableTags = ['INPUT', 'BUTTON', 'LINK', 'SELECT', 'A', 'TEXTAREA'];
    let {
      tagName,
      type
    } = el;
    if (type === 'hidden') {
      return false;
    }
    return focusableTags.indexOf(tagName) > -1 || el.contentEditable === 'true';
  }
  function click(el, options) {
    if (options === void 0) {
      options = {};
    }
    (0, _runloop.run)(() => fireEvent(el, 'mousedown', options));
    focus(el);
    (0, _runloop.run)(() => fireEvent(el, 'mouseup', options));
    (0, _runloop.run)(() => fireEvent(el, 'click', options));
  }
  function focus(el) {
    if (!el) {
      return;
    }
    if (isFocusable(el)) {
      (0, _runloop.run)(null, function () {
        let browserIsNotFocused = document.hasFocus && !document.hasFocus();
        // Firefox does not trigger the `focusin` event if the window
        // does not have focus. If the document doesn't have focus just
        // use trigger('focusin') instead.
        if (browserIsNotFocused) {
          fireEvent(el, 'focusin');
        }
        // makes `document.activeElement` be `el`. If the browser is focused, it also fires a focus event
        el.focus();
        // if the browser is not focused the previous `el.focus()` didn't fire an event, so we simulate it
        if (browserIsNotFocused) {
          fireEvent(el, 'focus');
        }
      });
    }
  }
  function blur(el) {
    if (isFocusable(el)) {
      (0, _runloop.run)(null, function () {
        let browserIsNotFocused = document.hasFocus && !document.hasFocus();
        fireEvent(el, 'focusout');
        // makes `document.activeElement` be `body`.
        // If the browser is focused, it also fires a blur event
        el.blur();
        // Chrome/Firefox does not trigger the `blur` event if the window
        // does not have focus. If the document does not have focus then
        // fire `blur` event via native event.
        if (browserIsNotFocused) {
          fireEvent(el, 'blur');
        }
      });
    }
  }
  function fireEvent(element, type, options) {
    if (options === void 0) {
      options = {};
    }
    if (!element) {
      return;
    }
    let event;
    if (KEYBOARD_EVENT_TYPES.indexOf(type) > -1) {
      event = buildKeyboardEvent(type, options);
    } else if (MOUSE_EVENT_TYPES.indexOf(type) > -1) {
      let rect = element.getBoundingClientRect();
      let x = rect.left + 1;
      let y = rect.top + 1;
      let simulatedCoordinates = {
        screenX: x + 5,
        screenY: y + 95,
        clientX: x,
        clientY: y
      };
      event = buildMouseEvent(type, Object.assign(simulatedCoordinates, options));
    } else {
      event = buildBasicEvent(type, options);
    }
    element.dispatchEvent(event);
    return event;
  }
  function buildBasicEvent(type, options) {
    if (options === void 0) {
      options = {};
    }
    return new Event(type, {
      ...DEFAULT_EVENT_OPTIONS,
      ...options
    });
  }
  function buildMouseEvent(type, options) {
    if (options === void 0) {
      options = {};
    }
    let event;
    try {
      event = new MouseEvent(type, {
        ...DEFAULT_EVENT_OPTIONS,
        ...options
      });
    } catch (e) {
      event = buildBasicEvent(type, options);
    }
    return event;
  }
  function buildKeyboardEvent(type, options) {
    if (options === void 0) {
      options = {};
    }
    let event;
    try {
      event = new KeyboardEvent(type, {
        ...DEFAULT_EVENT_OPTIONS,
        ...options
      });
    } catch (e) {
      event = buildBasicEvent(type, options);
    }
    return event;
  }
});
define("internal-test-helpers/lib/test-cases/abstract-application", ["exports", "ember-template-compiler", "@ember/-internals/environment", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/run"], function (_exports, _emberTemplateCompiler, _environment, _abstract, _run) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class AbstractApplicationTestCase extends _abstract.default {
    constructor() {
      super(...arguments);
      this._element = null;
    }
    _ensureInstance(bootOptions) {
      if (this._applicationInstancePromise) {
        return this._applicationInstancePromise;
      }
      return this._applicationInstancePromise = (0, _run.runTask)(() => this.application.boot()).then(app => {
        this.applicationInstance = app.buildInstance();
        return this.applicationInstance.boot(bootOptions);
      });
    }
    async visit(url, options) {
      // Create the instance
      let instance = await this._ensureInstance(options).then(instance => (0, _run.runTask)(() => instance.visit(url)));
      // Await all asynchronous actions
      await (0, _run.runLoopSettled)();
      return instance;
    }
    get element() {
      if (this._element) {
        return this._element;
      }
      let element = document.querySelector(_environment.ENV._APPLICATION_TEMPLATE_WRAPPER ? '#qunit-fixture > div.ember-view' : '#qunit-fixture');
      return this._element = element;
    }
    set element(element) {
      this._element = element;
    }
    afterEach() {
      (0, _run.runDestroy)(this.applicationInstance);
      (0, _run.runDestroy)(this.application);
      super.teardown();
    }
    get applicationOptions() {
      return {
        rootElement: '#qunit-fixture'
      };
    }
    get routerOptions() {
      return {
        location: 'none'
      };
    }
    get router() {
      return this.application.resolveRegistration('router:main');
    }
    compile(templateString, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, _emberTemplateCompiler.compile)(templateString, options);
    }
  }
  _exports.default = AbstractApplicationTestCase;
});
define("internal-test-helpers/lib/test-cases/abstract", ["exports", "internal-test-helpers/lib/node-query", "internal-test-helpers/lib/equal-inner-html", "internal-test-helpers/lib/equal-tokens", "internal-test-helpers/lib/element-helpers", "internal-test-helpers/lib/matchers", "internal-test-helpers/lib/run", "@ember/debug"], function (_exports, _nodeQuery, _equalInnerHtml, _equalTokens, _elementHelpers, _matchers, _run, _debug) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  /* global Element */

  const TextNode = window.Text;
  const HTMLElement = window.HTMLElement;
  const Comment = window.Comment;
  function isMarker(node) {
    if (node instanceof Comment && node.textContent === '') {
      return true;
    }
    if (node instanceof TextNode && node.textContent === '') {
      return true;
    }
    return false;
  }
  class AbstractTestCase {
    get fixture() {
      return undefined;
    }
    constructor(assert) {
      this.snapshot = null;
      this.assert = assert;
      let {
        fixture
      } = this;
      if (fixture) {
        this.setupFixture(fixture);
      }
    }
    teardown() {}
    beforeEach(_assert) {}
    afterEach() {}
    setupFixture(innerHTML) {
      let fixture = document.getElementById('qunit-fixture');
      fixture.innerHTML = innerHTML;
    }
    // The following methods require `this.element` to work
    get firstChild() {
      return this.nthChild(0);
    }
    nthChild(n) {
      let i = 0;
      let node = (0, _elementHelpers.getElement)().firstChild;
      while (node) {
        if (!isMarker(node)) {
          i++;
        }
        if (i > n) {
          break;
        } else {
          node = node.nextSibling;
        }
      }
      return node;
    }
    get nodesCount() {
      let count = 0;
      let node = (0, _elementHelpers.getElement)().firstChild;
      while (node) {
        if (!isMarker(node)) {
          count++;
        }
        node = node.nextSibling;
      }
      return count;
    }
    $(sel) {
      if (sel instanceof HTMLElement) {
        return _nodeQuery.default.element(sel);
      } else if (typeof sel === 'string') {
        return _nodeQuery.default.query(sel, (0, _elementHelpers.getElement)());
      } else if (sel !== undefined) {
        throw new Error("Invalid this.$(" + sel + ")");
      } else {
        return _nodeQuery.default.element((0, _elementHelpers.getElement)());
      }
    }
    wrap(element) {
      return _nodeQuery.default.element(element);
    }
    click(selector) {
      let element;
      if (typeof selector === 'string') {
        element = (0, _elementHelpers.getElement)().querySelector(selector);
      } else {
        element = selector;
      }
      let event = element.click();
      return (0, _run.runLoopSettled)(event);
    }
    textValue() {
      return (0, _elementHelpers.getElement)().textContent;
    }
    takeSnapshot() {
      let snapshot = this.snapshot = [];
      let node = (0, _elementHelpers.getElement)().firstChild;
      while (node) {
        if (!isMarker(node)) {
          snapshot.push(node);
        }
        node = node.nextSibling;
      }
      return snapshot;
    }
    assertText(text) {
      this.assert.strictEqual(this.textValue(), text, "#qunit-fixture content should be: `" + text + "`");
    }
    assertInnerHTML(html) {
      (0, _equalInnerHtml.default)(this.assert, (0, _elementHelpers.getElement)(), html);
    }
    assertHTML(html) {
      (0, _equalTokens.default)((0, _elementHelpers.getElement)(), html, "#qunit-fixture content should be: `" + html + "`");
    }
    assertElement(node, _ref) {
      let {
        ElementType = HTMLElement,
        tagName,
        attrs = null,
        content = null
      } = _ref;
      if (!(node instanceof ElementType)) {
        throw new Error("Expecting a " + ElementType.name + ", but got " + String(node));
      }
      (0, _matchers.equalsElement)(this.assert, node, tagName, attrs, content);
    }
    assertComponentElement(node, _ref2) {
      let {
        ElementType = HTMLElement,
        tagName = 'div',
        attrs = {},
        content = null
      } = _ref2;
      attrs = Object.assign({}, {
        id: (0, _matchers.regex)(/^ember\d*$/),
        class: (0, _matchers.classes)('ember-view')
      }, attrs || {});
      this.assertElement(node, {
        ElementType,
        tagName,
        attrs,
        content
      });
    }
    assertSameNode(actual, expected) {
      this.assert.strictEqual(actual, expected, 'DOM node stability');
    }
    assertInvariants(oldSnapshot, newSnapshot) {
      if (!oldSnapshot) {
        (false && !(this.snapshot) && (0, _debug.assert)('expected an existing snapshot', this.snapshot));
        oldSnapshot = this.snapshot;
      }
      newSnapshot = newSnapshot || this.takeSnapshot();
      this.assert.strictEqual(newSnapshot.length, oldSnapshot.length, 'Same number of nodes');
      for (let i = 0; i < oldSnapshot.length; i++) {
        this.assertSameNode(newSnapshot[i], oldSnapshot[i]);
      }
    }
    assertPartialInvariants(start, end) {
      (false && !(this.snapshot) && (0, _debug.assert)('expected an existing snapshot', this.snapshot));
      this.assertInvariants(this.snapshot, this.takeSnapshot().slice(start, end));
    }
  }
  _exports.default = AbstractTestCase;
});
define("internal-test-helpers/lib/test-cases/application", ["exports", "internal-test-helpers/lib/test-cases/test-resolver-application", "@ember/application", "@ember/routing/router", "internal-test-helpers/lib/run", "internal-test-helpers/lib/test-resolver", "@ember/debug"], function (_exports, _testResolverApplication, _application, _router, _run, _testResolver, _debug) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class ApplicationTestCase extends _testResolverApplication.default {
    constructor(assert) {
      super(assert);
      let {
        applicationOptions
      } = this;
      this.application = (0, _run.runTask)(this.createApplication.bind(this, applicationOptions));
      // TODO: Review this cast
      let resolver = this.application.__registry__.resolver;
      (false && !(resolver instanceof _testResolver.default) && (0, _debug.assert)('expected a resolver', resolver instanceof _testResolver.default));
      this.resolver = resolver;
      resolver.add('router:main', _router.default.extend(this.routerOptions));
    }
    createApplication(myOptions, MyApplication) {
      if (myOptions === void 0) {
        myOptions = {};
      }
      if (MyApplication === void 0) {
        MyApplication = _application.default;
      }
      return MyApplication.create(myOptions);
    }
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        autoboot: false
      });
    }
    get appRouter() {
      return this.applicationInstance.lookup('router:main');
    }
    get currentURL() {
      return this.appRouter.get('currentURL');
    }
    async transitionTo() {
      await this.appRouter.transitionTo(...arguments);
      await (0, _run.runLoopSettled)();
    }
    controllerFor(name) {
      return this.applicationInstance.lookup("controller:" + name);
    }
  }
  _exports.default = ApplicationTestCase;
});
define("internal-test-helpers/lib/test-cases/autoboot-application", ["exports", "internal-test-helpers/lib/test-cases/test-resolver-application", "@ember/application", "@ember/routing/router", "internal-test-helpers/lib/test-resolver", "@ember/debug"], function (_exports, _testResolverApplication, _application, _router, _testResolver, _debug) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class AutobootApplicationTestCase extends _testResolverApplication.default {
    createApplication(options, MyApplication) {
      if (MyApplication === void 0) {
        MyApplication = _application.default;
      }
      // SAFETY: Types for `create` are a bit flaky
      let application = this.application = MyApplication.create({
        ...this.applicationOptions,
        ...options
      });
      let resolver = application.__registry__.resolver;
      (false && !(resolver instanceof _testResolver.default) && (0, _debug.assert)('expected a resolver', resolver instanceof _testResolver.default));
      this.resolver = resolver;
      resolver.add('router:main', _router.default.extend(this.routerOptions));
      return application;
    }
    visit(url) {
      return this.application.boot().then(() => {
        return this.applicationInstance.visit(url);
      });
    }
    get applicationInstance() {
      let {
        application
      } = this;
      if (!application) {
        return undefined;
      }
      return application.__deprecatedInstance__;
    }
  }
  _exports.default = AutobootApplicationTestCase;
});
define("internal-test-helpers/lib/test-cases/query-param", ["exports", "@ember/controller", "@ember/routing/none-location", "internal-test-helpers/lib/test-cases/application", "internal-test-helpers/lib/run"], function (_exports, _controller, _noneLocation, _application, _run) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class QueryParamTestCase extends _application.default {
    constructor(assert) {
      super(assert);
      let testCase = this;
      testCase.expectedPushURL = null;
      testCase.expectedReplaceURL = null;
      this.add('location:test', class extends _noneLocation.default {
        setURL(path) {
          if (testCase.expectedReplaceURL) {
            testCase.assert.ok(false, 'pushState occurred but a replaceState was expected');
          }
          if (testCase.expectedPushURL) {
            testCase.assert.equal(path, testCase.expectedPushURL, 'an expected pushState occurred');
            testCase.expectedPushURL = null;
          }
          this.set('path', path);
        }
        replaceURL(path) {
          if (testCase.expectedPushURL) {
            testCase.assert.ok(false, 'replaceState occurred but a pushState was expected');
          }
          if (testCase.expectedReplaceURL) {
            testCase.assert.equal(path, testCase.expectedReplaceURL, 'an expected replaceState occurred');
            testCase.expectedReplaceURL = null;
          }
          this.set('path', path);
        }
      });
    }
    visitAndAssert(path, options) {
      return this.visit(path, options).then(() => {
        this.assertCurrentPath(path);
      });
    }
    getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    }
    getRoute(name) {
      return this.applicationInstance.lookup("route:" + name);
    }
    get routerOptions() {
      return {
        location: 'test'
      };
    }
    async setAndFlush(obj, prop, value) {
      if (typeof prop === 'object') {
        obj.setProperties(prop);
      } else {
        obj.set(prop, value);
      }
      await (0, _run.runLoopSettled)();
    }
    assertCurrentPath(path, message) {
      if (message === void 0) {
        message = "current path equals '" + path + "'";
      }
      this.assert.equal(this.appRouter.get('location.path'), path, message);
    }
    /**
      Sets up a Controller for a given route with a single query param and default
      value. Can optionally extend the controller with an object.
         @public
      @method setSingleQPController
    */
    setSingleQPController(routeName, param, defaultValue, options) {
      if (param === void 0) {
        param = 'foo';
      }
      if (defaultValue === void 0) {
        defaultValue = 'bar';
      }
      if (options === void 0) {
        options = {};
      }
      this.add("controller:" + routeName, _controller.default.extend({
        queryParams: [param],
        [param]: defaultValue
      }, options));
    }
    /**
      Sets up a Controller for a given route with a custom property/url key mapping.
         @public
      @method setMappedQPController
    */
    setMappedQPController(routeName, prop, urlKey, defaultValue, options) {
      if (prop === void 0) {
        prop = 'page';
      }
      if (urlKey === void 0) {
        urlKey = 'parentPage';
      }
      if (defaultValue === void 0) {
        defaultValue = 1;
      }
      if (options === void 0) {
        options = {};
      }
      this.add("controller:" + routeName, _controller.default.extend({
        queryParams: {
          [prop]: urlKey
        },
        [prop]: defaultValue
      }, options));
    }
  }
  _exports.default = QueryParamTestCase;
});
define("internal-test-helpers/lib/test-cases/rendering", ["exports", "ember-template-compiler", "@ember/-internals/views", "@ember/component", "@ember/-internals/glimmer", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/run"], function (_exports, _emberTemplateCompiler, _views, _component, _glimmer, _testResolver, _abstract, _buildOwner, _run) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  const TextNode = window.Text;
  class RenderingTestCase extends _abstract.default {
    constructor(assert) {
      super(assert);
      let bootOptions = this.getBootOptions();
      let owner = this.owner = (0, _buildOwner.default)({
        ownerOptions: this.getOwnerOptions(),
        resolver: this.getResolver(),
        bootOptions
      });
      owner.register('-view-registry:main', Object.create(null), {
        instantiate: false
      });
      owner.register('event_dispatcher:main', _views.EventDispatcher);
      this.renderer = this.owner.lookup('renderer:-dom');
      this.element = document.querySelector('#qunit-fixture');
      this.component = null;
      if (!bootOptions || bootOptions.isInteractive !== false && bootOptions.skipEventDispatcher !== true) {
        owner.lookup('event_dispatcher:main').setup(this.getCustomDispatcherEvents(), this.element);
      }
    }
    compile(templateString, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, _emberTemplateCompiler.compile)(templateString, options);
    }
    getCustomDispatcherEvents() {
      return {};
    }
    getOwnerOptions() {
      return undefined;
    }
    getBootOptions() {
      return undefined;
    }
    get resolver() {
      return this.owner.__registry__.fallback.resolver;
    }
    getResolver() {
      return new _testResolver.ModuleBasedResolver();
    }
    add(specifier, factory) {
      this.resolver.add(specifier, factory);
    }
    addTemplate(templateName, templateString) {
      if (typeof templateName === 'string') {
        this.resolver.add("template:" + templateName, this.compile(templateString, {
          moduleName: templateName
        }));
      } else {
        this.resolver.add(templateName, this.compile(templateString, {
          moduleName: templateName.moduleName
        }));
      }
    }
    addComponent(name, _ref) {
      let {
        ComponentClass = null,
        template = null
      } = _ref;
      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }
      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "components/" + name
        }));
      }
    }
    afterEach() {
      try {
        if (this.component) {
          (0, _run.runDestroy)(this.component);
        }
        if (this.owner) {
          (0, _run.runDestroy)(this.owner);
        }
      } finally {
        (0, _glimmer._resetRenderers)();
      }
    }
    get context() {
      return this.component;
    }
    render(templateStr, context) {
      if (context === void 0) {
        context = {};
      }
      let {
        owner
      } = this;
      owner.register('template:-top-level', this.compile(templateStr, {
        moduleName: '-top-level'
      }));
      let attrs = Object.assign({}, context, {
        tagName: '',
        layoutName: '-top-level'
      });
      owner.register('component:-top-level', _component.default.extend(attrs));
      this.component = owner.lookup('component:-top-level');
      (0, _run.runAppend)(this.component);
    }
    rerender() {
      this.component.rerender();
    }
    registerHelper(name, funcOrClassBody) {
      if (typeof funcOrClassBody === 'function') {
        this.owner.register("helper:" + name, (0, _glimmer.helper)(funcOrClassBody));
      } else if (typeof funcOrClassBody === 'object' && funcOrClassBody !== null) {
        this.owner.register("helper:" + name, _glimmer.Helper.extend(funcOrClassBody));
      } else {
        throw new Error("Cannot register " + funcOrClassBody + " as a helper");
      }
    }
    registerCustomHelper(name, definition) {
      this.owner.register("helper:" + name, definition);
    }
    registerComponent(name, _ref2) {
      let {
        ComponentClass = _component.default,
        template = null
      } = _ref2;
      let {
        owner
      } = this;
      if (ComponentClass) {
        owner.register("component:" + name, ComponentClass);
      }
      if (typeof template === 'string') {
        owner.register("template:components/" + name, this.compile(template, {
          moduleName: "my-app/templates/components/" + name + ".hbs"
        }));
      }
    }
    registerModifier(name, ModifierClass) {
      let {
        owner
      } = this;
      owner.register("modifier:" + name, ModifierClass);
    }
    registerComponentManager(name, manager) {
      let owner = this.owner;
      owner.register("component-manager:" + name, manager);
    }
    registerTemplate(name, template) {
      let {
        owner
      } = this;
      if (typeof template === 'string') {
        owner.register("template:" + name, this.compile(template, {
          moduleName: "my-app/templates/" + name + ".hbs"
        }));
      } else {
        throw new Error("Registered template \"" + name + "\" must be a string");
      }
    }
    registerService(name, klass) {
      this.owner.register("service:" + name, klass);
    }
    assertTextNode(node, text) {
      if (!(node instanceof TextNode)) {
        throw new Error("Expecting a text node, but got " + node);
      }
      this.assert.strictEqual(node.textContent, text, 'node.textContent');
    }
    assertStableRerender() {
      this.takeSnapshot();
      (0, _run.runTask)(() => this.rerender());
      this.assertInvariants();
    }
  }
  _exports.default = RenderingTestCase;
});
define("internal-test-helpers/lib/test-cases/router-non-application", ["exports", "ember-template-compiler", "@ember/-internals/views", "@ember/component", "@ember/-internals/glimmer", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/run"], function (_exports, _emberTemplateCompiler, _views, _component, _glimmer, _testResolver, _abstract, _buildOwner, _run) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class RouterNonApplicationTestCase extends _abstract.default {
    constructor(assert) {
      super(assert);
      let bootOptions = this.getBootOptions();
      let owner = this.owner = (0, _buildOwner.default)({
        ownerType: 'engine',
        ownerOptions: this.getOwnerOptions(),
        resolver: this.getResolver(),
        bootOptions
      });
      owner.register('-view-registry:main', Object.create(null), {
        instantiate: false
      });
      owner.register('event_dispatcher:main', _views.EventDispatcher);
      this.renderer = this.owner.lookup('renderer:-dom');
      this.element = document.querySelector('#qunit-fixture');
      this.component = null;
    }
    compile(templateString, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, _emberTemplateCompiler.compile)(templateString, options);
    }
    getOwnerOptions() {
      return undefined;
    }
    getBootOptions() {
      return undefined;
    }
    get resolver() {
      return this.owner.__registry__.fallback.resolver;
    }
    getResolver() {
      return new _testResolver.ModuleBasedResolver();
    }
    add(specifier, factory) {
      this.resolver.add(specifier, factory);
    }
    addTemplate(templateName, templateString) {
      if (typeof templateName === 'string') {
        this.resolver.add("template:" + templateName, this.compile(templateString, {
          moduleName: templateName
        }));
      } else {
        this.resolver.add(templateName, this.compile(templateString, {
          moduleName: templateName.moduleName
        }));
      }
    }
    addComponent(name, _ref) {
      let {
        ComponentClass = null,
        template = null
      } = _ref;
      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }
      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "components/" + name
        }));
      }
    }
    afterEach() {
      try {
        if (this.component) {
          (0, _run.runDestroy)(this.component);
        }
        if (this.owner) {
          (0, _run.runDestroy)(this.owner);
        }
      } finally {
        (0, _glimmer._resetRenderers)();
      }
    }
    render(templateStr, context) {
      if (context === void 0) {
        context = {};
      }
      let {
        owner
      } = this;
      owner.register('template:-top-level', this.compile(templateStr, {
        moduleName: '-top-level'
      }));
      let attrs = Object.assign({}, context, {
        tagName: '',
        layoutName: '-top-level'
      });
      owner.register('component:-top-level', _component.default.extend(attrs));
      this.component = owner.lookup('component:-top-level');
      (0, _run.runAppend)(this.component);
    }
  }
  _exports.default = RouterNonApplicationTestCase;
});
define("internal-test-helpers/lib/test-cases/router", ["exports", "internal-test-helpers/lib/test-cases/application"], function (_exports, _application) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class RouterTestCase extends _application.default {
    constructor(assert) {
      super(assert);
      this.router.map(function () {
        this.route('parent', {
          path: '/'
        }, function () {
          this.route('child');
          this.route('sister');
          this.route('brother');
        });
        this.route('dynamic', {
          path: '/dynamic/:dynamic_id'
        });
        this.route('dynamicWithChild', {
          path: '/dynamic-with-child/:dynamic_id'
        }, function () {
          this.route('child', {
            path: '/:child_id'
          });
        });
      });
    }
    get routerService() {
      return this.applicationInstance.lookup('service:router');
    }
    buildQueryParams(queryParams) {
      return {
        queryParams
      };
    }
  }
  _exports.default = RouterTestCase;
});
define("internal-test-helpers/lib/test-cases/test-resolver-application", ["exports", "internal-test-helpers/lib/test-cases/abstract-application", "internal-test-helpers/lib/test-resolver", "@ember/component"], function (_exports, _abstractApplication, _testResolver, _component) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  class TestResolverApplicationTestCase extends _abstractApplication.default {
    get applicationOptions() {
      return Object.assign(super.applicationOptions, {
        Resolver: _testResolver.ModuleBasedResolver
      });
    }
    add(specifier, factory) {
      this.resolver.add(specifier, factory);
    }
    addTemplate(templateName, templateString) {
      this.resolver.add("template:" + templateName, this.compile(templateString, {
        moduleName: "my-app/templates/" + templateName.replace(/\./g, '/') + ".hbs"
      }));
    }
    addComponent(name, _ref) {
      let {
        ComponentClass = _component.default,
        template = null
      } = _ref;
      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }
      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "my-app/templates/components/" + name + ".hbs"
        }));
      }
    }
  }
  _exports.default = TestResolverApplicationTestCase;
});
define("internal-test-helpers/lib/test-context", ["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.getContext = getContext;
  _exports.setContext = setContext;
  _exports.unsetContext = unsetContext;
  let __test_context__;
  /**
   * Stores the provided context as the "global testing context".
   *
   * @param {Object} context the context to use
   */
  function setContext(context) {
    __test_context__ = context;
  }
  /**
   * Retrive the "global testing context" as stored by `setContext`.
   *
   * @returns {Object} the previously stored testing context
   */
  function getContext() {
    return __test_context__;
  }
  /**
   * Clear the "global testing context".
   */
  function unsetContext() {
    __test_context__ = undefined;
  }
});
define("internal-test-helpers/lib/test-resolver", ["exports", "ember-template-compiler"], function (_exports, _emberTemplateCompiler) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.ModuleBasedResolver = void 0;
  const DELIMITER = '%';
  function serializeKey(specifier, source, namespace) {
    let [type, name] = specifier.split(':');
    return type + "://" + [name, namespace ? '[source invalid due to namespace]' : source, namespace].join(DELIMITER);
  }
  class Resolver {
    constructor() {
      this._registered = {};
    }
    resolve(specifier) {
      return this._registered[specifier] || this._registered[serializeKey(specifier)];
    }
    add(lookup, factory) {
      let key;
      switch (typeof lookup) {
        case 'string':
          if (lookup.indexOf(':') === -1) {
            throw new Error('Specifiers added to the resolver must be in the format of type:name');
          }
          key = serializeKey(lookup);
          break;
        case 'object':
          key = serializeKey(lookup.specifier, lookup.source, lookup.namespace);
          break;
        default:
          throw new Error('Specifier string has an unknown type');
      }
      return this._registered[key] = factory;
    }
    addTemplate(templateName, template) {
      let templateType = typeof template;
      if (templateType !== 'string') {
        throw new Error("You called addTemplate for \"" + templateName + "\" with a template argument of type of '" + templateType + "'. addTemplate expects an argument of an uncompiled template as a string.");
      }
      return this._registered[serializeKey("template:" + templateName)] = (0, _emberTemplateCompiler.compile)(template, {
        moduleName: "my-app/templates/" + templateName + ".hbs"
      });
    }
    static create() {
      return new this();
    }
  }
  var _default = _exports.default = Resolver;
  /*
   * A resolver with moduleBasedResolver = true handles error and loading
   * substates differently than a standard resolver.
   */
  class ModuleBasedResolver extends Resolver {
    get moduleBasedResolver() {
      return true;
    }
  }
  _exports.ModuleBasedResolver = ModuleBasedResolver;
});
define("internal-test-helpers/tests/index-test", ["internal-test-helpers"], function (_internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('internal-test-helpers', class extends _internalTestHelpers.AbstractTestCase {
    ['@test module present'](assert) {
      assert.ok(true, 'each package needs at least one test to be able to run through `npm test`');
    }
  });
});

}());
//# sourceMappingURL=ember-tests.map
