import { isSmallInt, encodeImmediate, EMPTY_STRING_ARRAY, unwrap, encodeBoolean, reverse, Stack, isPresentArray, encodeHandle, expect, EMPTY_ARRAY, IS_COMPILABLE_TEMPLATE, assert as assert$1, dict, enumerate, assign, debugToString } from '@glimmer/util';
import '@glimmer/debug';
import { Op, $v0, $fp, $sp, InternalComponentCapabilities, $s0, TYPE_SIZE, isMachineOp, MACHINE_MASK, ARG_SHIFT, COMPONENT_CONTENT, HELPER_CONTENT, $s1, STRING_CONTENT, SAFE_STRING_CONTENT, FRAGMENT_CONTENT, NODE_CONTENT } from '@glimmer/vm';
import { DEBUG } from '@glimmer/env';
import { InstructionEncoderImpl } from '@glimmer/encoder';
import { SexpOpcodes } from '@glimmer/wire-format';
import { hasCapability } from '@glimmer/manager';
import { assert, deprecate } from '@glimmer/global-context';

function labelOperand(value){return {type:HighLevelOperands.Label,value:value}}function isStrictMode(){return {type:HighLevelOperands.IsStrictMode,value:void 0}}function stdlibOperand(value){return {type:HighLevelOperands.StdLib,value:value}}function nonSmallIntOperand(value){assert$1(!isSmallInt(value),"Attempted to make a operand for an int that was not a small int, you should encode this as an immediate");return {type:HighLevelOperands.NonSmallInt,value:value}}function symbolTableOperand(value){return {type:HighLevelOperands.SymbolTable,value:value}}function layoutOperand(value){return {type:HighLevelOperands.Layout,value:value}}function definePushOp(fn){function op(...op){fn(...op);}op.label=name=>{op(HighLevelBuilderOpcodes.Label,name);};op.labels=block=>{op(HighLevelBuilderOpcodes.StartLabels);block();op(HighLevelBuilderOpcodes.StopLabels);};op.target=target=>labelOperand(target);return op}function isGetLikeTuple(opcode){return Array.isArray(opcode)&&opcode.length===2}function makeResolutionTypeVerifier(typeToVerify){return opcode=>{if(!isGetLikeTuple(opcode))return false;let type=opcode[0];return type===SexpOpcodes.GetStrictKeyword||type===SexpOpcodes.GetLexicalSymbol||type===typeToVerify}}function assertResolverInvariants(meta){if(DEBUG){if(!meta.upvars)throw new Error("Attempted to resolve a component, helper, or modifier, but no free vars were found");if(!meta.owner)throw new Error("Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from")}return meta}function resolveComponent(resolver,constants,meta,[,expr,then]){assert$1(isGetFreeComponent(expr),"Attempted to resolve a component with incorrect opcode");let type=expr[0];if(DEBUG&&expr[0]===SexpOpcodes.GetStrictKeyword)throw new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${meta.upvars[expr[1]]??"{unknown variable}"}`);if(type===SexpOpcodes.GetLexicalSymbol){let{scopeValues:scopeValues,owner:owner}=meta;let definition=expect(scopeValues,"BUG: scopeValues must exist if template symbol is used")[expr[1]];then(constants.component(definition,expect(owner,"BUG: expected owner when resolving component definition")));}else {let{upvars:upvars,owner:owner}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let definition=resolver.lookupComponent(name,owner);if(DEBUG&&(typeof definition!=="object"||definition===null))throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component, but nothing was found.`);then(constants.resolvedComponent(definition,name));}}function resolveHelper(resolver,constants,meta,[,expr,then]){assert$1(isGetFreeHelper(expr),"Attempted to resolve a helper with incorrect opcode");let type=expr[0];if(type===SexpOpcodes.GetLexicalSymbol){let{scopeValues:scopeValues}=meta;let definition=expect(scopeValues,"BUG: scopeValues must exist if template symbol is used")[expr[1]];then(constants.helper(definition));}else if(type===SexpOpcodes.GetStrictKeyword)then(lookupBuiltInHelper(expr,resolver,meta,constants,"helper"));else {let{upvars:upvars,owner:owner}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let helper=resolver.lookupHelper(name,owner);if(DEBUG&&helper===null)throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a helper, but nothing was found.`);then(constants.helper(helper,name));}}function resolveModifier(resolver,constants,meta,[,expr,then]){assert$1(isGetFreeModifier(expr),"Attempted to resolve a modifier with incorrect opcode");let type=expr[0];if(type===SexpOpcodes.GetLexicalSymbol){let{scopeValues:scopeValues}=meta;let definition=expect(scopeValues,"BUG: scopeValues must exist if template symbol is used")[expr[1]];then(constants.modifier(definition));}else if(type===SexpOpcodes.GetStrictKeyword){let{upvars:upvars}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let modifier=resolver.lookupBuiltInModifier(name);if(DEBUG&&modifier===null)throw new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`);then(constants.modifier(modifier,name));}else {let{upvars:upvars,owner:owner}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let modifier=resolver.lookupModifier(name,owner);if(DEBUG&&modifier===null)throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a modifier, but nothing was found.`);then(constants.modifier(modifier,name));}}function resolveComponentOrHelper(resolver,constants,meta,[,expr,{ifComponent:ifComponent,ifHelper:ifHelper}]){assert$1(isGetFreeComponentOrHelper(expr),"Attempted to resolve a component or helper with incorrect opcode");let type=expr[0];if(type===SexpOpcodes.GetLexicalSymbol){let{scopeValues:scopeValues,owner:owner}=meta;let definition=expect(scopeValues,"BUG: scopeValues must exist if template symbol is used")[expr[1]];let component=constants.component(definition,expect(owner,"BUG: expected owner when resolving component definition"),true);if(component!==null){ifComponent(component);return}let helper=constants.helper(definition,null,true);if(DEBUG&&helper===null)throw new Error(`Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString(definition)}`);ifHelper(expect(helper,"BUG: helper must exist"));}else if(type===SexpOpcodes.GetStrictKeyword)ifHelper(lookupBuiltInHelper(expr,resolver,meta,constants,"component or helper"));else {let{upvars:upvars,owner:owner}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let definition=resolver.lookupComponent(name,owner);if(definition!==null)ifComponent(constants.resolvedComponent(definition,name));else {let helper=resolver.lookupHelper(name,owner);if(DEBUG&&helper===null)throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component or helper, but nothing was found.`);ifHelper(constants.helper(helper,name));}}}function resolveOptionalHelper(resolver,constants,meta,[,expr,{ifHelper:ifHelper}]){assert$1(isGetFreeOptionalHelper(expr)||(opcode=expr,Array.isArray(opcode)&&opcode[0]===SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback),"Attempted to resolve a helper with incorrect opcode");var opcode;let{upvars:upvars,owner:owner}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let helper=resolver.lookupHelper(name,owner);helper&&ifHelper(constants.helper(helper,name),name,meta.moduleName);}function resolveOptionalComponentOrHelper(resolver,constants,meta,[,expr,{ifComponent:ifComponent,ifHelper:ifHelper,ifValue:ifValue}]){assert$1(isGetFreeOptionalComponentOrHelper(expr),"Attempted to resolve an optional component or helper with incorrect opcode");let type=expr[0];if(type===SexpOpcodes.GetLexicalSymbol){let{scopeValues:scopeValues,owner:owner}=meta;let definition=expect(scopeValues,"BUG: scopeValues must exist if template symbol is used")[expr[1]];if(typeof definition!=="function"&&(typeof definition!=="object"||definition===null)){ifValue(constants.value(definition));return}let component=constants.component(definition,expect(owner,"BUG: expected owner when resolving component definition"),true);if(component!==null){ifComponent(component);return}let helper=constants.helper(definition,null,true);if(helper!==null){ifHelper(helper);return}ifValue(constants.value(definition));}else if(type===SexpOpcodes.GetStrictKeyword)ifHelper(lookupBuiltInHelper(expr,resolver,meta,constants,"value"));else {let{upvars:upvars,owner:owner}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let definition=resolver.lookupComponent(name,owner);if(definition!==null){ifComponent(constants.resolvedComponent(definition,name));return}let helper=resolver.lookupHelper(name,owner);helper!==null&&ifHelper(constants.helper(helper,name));}}function lookupBuiltInHelper(expr,resolver,meta,constants,type){let{upvars:upvars}=assertResolverInvariants(meta);let name=unwrap(upvars[expr[1]]);let helper=resolver.lookupBuiltInHelper(name);if(DEBUG&&helper===null)throw new Error(`Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${meta.upvars[expr[1]]??"{unknown variable}"}`);return constants.helper(helper,name)}function encodeOp(encoder,constants,resolver,meta,op){if(isBuilderOpcode(op[0])){let[type,...operands]=op;encoder.push(constants,type,...operands);}else switch(op[0]){case HighLevelBuilderOpcodes.Label:return encoder.label(op[1]);case HighLevelBuilderOpcodes.StartLabels:return encoder.startLabels();case HighLevelBuilderOpcodes.StopLabels:return encoder.stopLabels();case HighLevelResolutionOpcodes.Component:return resolveComponent(resolver,constants,meta,op);case HighLevelResolutionOpcodes.Modifier:return resolveModifier(resolver,constants,meta,op);case HighLevelResolutionOpcodes.Helper:return resolveHelper(resolver,constants,meta,op);case HighLevelResolutionOpcodes.ComponentOrHelper:return resolveComponentOrHelper(resolver,constants,meta,op);case HighLevelResolutionOpcodes.OptionalHelper:return resolveOptionalHelper(resolver,constants,meta,op);case HighLevelResolutionOpcodes.OptionalComponentOrHelper:return resolveOptionalComponentOrHelper(resolver,constants,meta,op);case HighLevelResolutionOpcodes.Local:{let freeVar=op[1];let name=expect(meta.upvars,"BUG: attempted to resolve value but no upvars found")[freeVar];let andThen=op[2];andThen(name,meta.moduleName);break}case HighLevelResolutionOpcodes.TemplateLocal:{let[,valueIndex,then]=op;let value=expect(meta.scopeValues,"BUG: Attempted to gect a template local, but template does not have any")[valueIndex];then(constants.value(value));break}case HighLevelResolutionOpcodes.Free:if(DEBUG){let[,upvarIndex]=op;let freeName=expect(meta.upvars,"BUG: attempted to resolve value but no upvars found")[upvarIndex];throw new Error(`Attempted to resolve a value in a strict mode template, but that value was not in scope: ${freeName}`)}break;default:throw new Error(`Unexpected high level opcode ${op[0]}`)}}function isBuilderOpcode(op){return op<HighLevelBuilderOpcodes.Start}function namedBlocks(blocks){if(blocks===null)return EMPTY_BLOCKS;let out=dict();let[keys,values]=blocks;for(const[i,key]of enumerate(keys))out[key]=unwrap(values[i]);return new NamedBlocksImpl(out)}function PushPrimitiveReference(op,value){PushPrimitive(op,value);op(Op.PrimitiveReference);}function PushPrimitive(op,primitive){let p=primitive;typeof p==="number"&&(p=isSmallInt(p)?encodeImmediate(p):nonSmallIntOperand(p));op(Op.Primitive,p);}function Call(op,handle,positional,named){op(Op.PushFrame);SimpleArgs(op,positional,named,false);op(Op.Helper,handle);op(Op.PopFrame);op(Op.Fetch,$v0);}function CallDynamic(op,positional,named,append){op(Op.PushFrame);SimpleArgs(op,positional,named,false);op(Op.Dup,$fp,1);op(Op.DynamicHelper);if(append){op(Op.Fetch,$v0);append();op(Op.PopFrame);op(Op.Pop,1);}else {op(Op.PopFrame);op(Op.Pop,1);op(Op.Fetch,$v0);}}function DynamicScope(op,names,block){op(Op.PushDynamicScope);op(Op.BindDynamicScope,names);block();op(Op.PopDynamicScope);}function Curry(op,type,definition,positional,named){op(Op.PushFrame);SimpleArgs(op,positional,named,false);op(Op.CaptureArgs);expr(op,definition);op(Op.Curry,type,isStrictMode());op(Op.PopFrame);op(Op.Fetch,$v0);}function withPath(op,path){if(path===void 0||path.length===0)return;for(let i=0;i<path.length;i++)op(Op.GetProperty,path[i]);}function expr(op,expression){if(Array.isArray(expression))EXPRESSIONS.compile(op,expression);else {PushPrimitive(op,expression);op(Op.PrimitiveReference);}}function CompileArgs(op,positional,named,blocks,atNames){let blockNames=blocks.names;for(const name of blockNames)PushYieldableBlock(op,blocks.get(name));let count=CompilePositional(op,positional);let flags=count<<4;atNames&&(flags|=8);blocks&&(flags|=7);let names=EMPTY_ARRAY;if(named){names=named[0];let val=named[1];for(let i=0;i<val.length;i++)expr(op,val[i]);}op(Op.PushArgs,names,blockNames,flags);}function SimpleArgs(op,positional,named,atNames){if(positional===null&&named===null){op(Op.PushEmptyArgs);return}let count=CompilePositional(op,positional);let flags=count<<4;atNames&&(flags|=8);let names=EMPTY_STRING_ARRAY;if(named){names=named[0];let val=named[1];for(let i=0;i<val.length;i++)expr(op,val[i]);}op(Op.PushArgs,names,EMPTY_STRING_ARRAY,flags);}function CompilePositional(op,positional){if(positional===null)return 0;for(let i=0;i<positional.length;i++)expr(op,positional[i]);return positional.length}function meta(layout){let[,symbols,,upvars]=layout.block;return {debugSymbols:debugSymbols(layout),upvars:upvars,scopeValues:layout.scope?.()??null,isStrictMode:layout.isStrictMode,moduleName:layout.moduleName,owner:layout.owner,size:symbols.length}}function debugSymbols(layout){let{block:block}=layout;let[,symbols,hasDebug]=block;return DEBUG||hasDebug?symbols:null}function YieldBlock(op,to,positional){SimpleArgs(op,positional,null,true);op(Op.GetBlock,to);op(Op.SpreadBlock);op(Op.CompileBlock);op(Op.InvokeYield);op(Op.PopScope);op(Op.PopFrame);}function PushYieldableBlock(op,block){PushSymbolTable(op,block&&block[1]);op(Op.PushBlockScope);PushCompilable(op,block);}function InvokeStaticBlock(op,block){op(Op.PushFrame);PushCompilable(op,block);op(Op.CompileBlock);op(Op.InvokeVirtual);op(Op.PopFrame);}function InvokeStaticBlockWithStack(op,block,callerCount){let parameters=block[1];let calleeCount=parameters.length;let count=Math.min(callerCount,calleeCount);if(count===0){InvokeStaticBlock(op,block);return}op(Op.PushFrame);if(count){op(Op.ChildScope);for(let i=0;i<count;i++){op(Op.Dup,$fp,callerCount-i);op(Op.SetVariable,parameters[i]);}}PushCompilable(op,block);op(Op.CompileBlock);op(Op.InvokeVirtual);count&&op(Op.PopScope);op(Op.PopFrame);}function PushSymbolTable(op,parameters){parameters!==null?op(Op.PushSymbolTable,symbolTableOperand({parameters:parameters})):PushPrimitive(op,null);}function PushCompilable(op,_block){_block===null?PushPrimitive(op,null):op(Op.Constant,(value=_block,{type:HighLevelOperands.Block,value:value}));var value;}function SwitchCases(op,bootstrap,matcher){let clauses=[];let count=0;matcher((function(match,callback){clauses.push({match:match,callback:callback,label:"CLAUSE"+count++});}));op(Op.Enter,1,false);bootstrap();op(HighLevelBuilderOpcodes.StartLabels);for(let clause of clauses.slice(0,-1))op(Op.JumpEq,labelOperand(clause.label),clause.match);for(let i=clauses.length-1;i>=0;i--){let clause=unwrap(clauses[i]);op(HighLevelBuilderOpcodes.Label,clause.label);op(Op.Pop,1);clause.callback();i!==0&&op(Op.Jump,labelOperand("END"));}op(HighLevelBuilderOpcodes.Label,"END");op(HighLevelBuilderOpcodes.StopLabels);op(Op.Exit);}function Replayable(op,{begin:begin=false,args:args,body:body}){op(HighLevelBuilderOpcodes.StartLabels);op(Op.PushFrame);op(Op.ReturnTo,labelOperand("ENDINITIAL"));let count=args();op(Op.Enter,count,begin);body();op(HighLevelBuilderOpcodes.Label,"FINALLY");op(Op.Exit);op(Op.Return);op(HighLevelBuilderOpcodes.Label,"ENDINITIAL");op(Op.PopFrame);op(HighLevelBuilderOpcodes.StopLabels);}function ReplayableIf(op,args,ifTrue,ifFalse){return Replayable(op,{args:args,body:()=>{op(Op.JumpUnless,labelOperand("ELSE"));ifTrue();op(Op.Jump,labelOperand("FINALLY"));op(HighLevelBuilderOpcodes.Label,"ELSE");ifFalse!==void 0&&ifFalse();}})}function InvokeComponent(op,component,_elementBlock,positional,named,_blocks){let{compilable:compilable,capabilities:capabilities,handle:handle}=component;let elementBlock=_elementBlock?[_elementBlock,[]]:null;let blocks=Array.isArray(_blocks)||_blocks===null?namedBlocks(_blocks):_blocks;if(compilable){op(Op.PushComponentDefinition,handle);InvokeStaticComponent(op,{capabilities:capabilities,layout:compilable,elementBlock:elementBlock,positional:positional,named:named,blocks:blocks});}else {op(Op.PushComponentDefinition,handle);InvokeNonStaticComponent(op,{capabilities:capabilities,elementBlock:elementBlock,positional:positional,named:named,atNames:true,blocks:blocks});}}function InvokeDynamicComponent(op,definition,_elementBlock,positional,named,_blocks,atNames,curried){let elementBlock=_elementBlock?[_elementBlock,[]]:null;let blocks=Array.isArray(_blocks)||_blocks===null?namedBlocks(_blocks):_blocks;Replayable(op,{args:()=>{expr(op,definition);op(Op.Dup,$sp,0);return 2},body:()=>{op(Op.JumpUnless,labelOperand("ELSE"));curried?op(Op.ResolveCurriedComponent):op(Op.ResolveDynamicComponent,isStrictMode());op(Op.PushDynamicComponentInstance);InvokeNonStaticComponent(op,{capabilities:true,elementBlock:elementBlock,positional:positional,named:named,atNames:atNames,blocks:blocks});op(HighLevelBuilderOpcodes.Label,"ELSE");}});}function InvokeStaticComponent(op,{capabilities:capabilities,layout:layout,elementBlock:elementBlock,positional:positional,named:named,blocks:blocks}){let{symbolTable:symbolTable}=layout;let bailOut=symbolTable.hasDebug||hasCapability(capabilities,InternalComponentCapabilities.prepareArgs);if(bailOut){InvokeNonStaticComponent(op,{capabilities:capabilities,elementBlock:elementBlock,positional:positional,named:named,atNames:true,blocks:blocks,layout:layout});return}op(Op.Fetch,$s0);op(Op.Dup,$sp,1);op(Op.Load,$s0);op(Op.PushFrame);let{symbols:symbols}=symbolTable;let blockSymbols=[];let argSymbols=[];let argNames=[];let blockNames=blocks.names;if(elementBlock!==null){let symbol=symbols.indexOf(ATTRS_BLOCK);if(symbol!==-1){PushYieldableBlock(op,elementBlock);blockSymbols.push(symbol);}}for(const name of blockNames){let symbol=symbols.indexOf(`&${name}`);if(symbol!==-1){PushYieldableBlock(op,blocks.get(name));blockSymbols.push(symbol);}}if(hasCapability(capabilities,InternalComponentCapabilities.createArgs)){let count=CompilePositional(op,positional);let flags=count<<4;flags|=8;let names=EMPTY_STRING_ARRAY;if(named!==null){names=named[0];let val=named[1];for(let i=0;i<val.length;i++){let symbol=symbols.indexOf(unwrap(names[i]));expr(op,val[i]);argSymbols.push(symbol);}}op(Op.PushArgs,names,EMPTY_STRING_ARRAY,flags);argSymbols.push(-1);}else if(named!==null){let names=named[0];let val=named[1];for(let i=0;i<val.length;i++){let name=unwrap(names[i]);let symbol=symbols.indexOf(name);if(symbol!==-1){expr(op,val[i]);argSymbols.push(symbol);argNames.push(name);}}}op(Op.BeginComponentTransaction,$s0);hasCapability(capabilities,InternalComponentCapabilities.dynamicScope)&&op(Op.PushDynamicScope);hasCapability(capabilities,InternalComponentCapabilities.createInstance)&&op(Op.CreateComponent,encodeBoolean(blocks.has("default"))|0,$s0);op(Op.RegisterComponentDestructor,$s0);hasCapability(capabilities,InternalComponentCapabilities.createArgs)?op(Op.GetComponentSelf,$s0,null):op(Op.GetComponentSelf,$s0,argNames);op(Op.RootScope,symbols.length+1,Object.keys(blocks).length>0?1:0);op(Op.SetVariable,0);for(const symbol of reverse(argSymbols))symbol===-1?op(Op.Pop,1):op(Op.SetVariable,symbol+1);positional!==null&&op(Op.Pop,positional.length);for(const symbol of reverse(blockSymbols))op(Op.SetBlock,symbol+1);op(Op.Constant,layoutOperand(layout));op(Op.CompileBlock);op(Op.InvokeVirtual);op(Op.DidRenderLayout,$s0);op(Op.PopFrame);op(Op.PopScope);hasCapability(capabilities,InternalComponentCapabilities.dynamicScope)&&op(Op.PopDynamicScope);op(Op.CommitComponentTransaction);op(Op.Load,$s0);}function InvokeNonStaticComponent(op,{capabilities:capabilities,elementBlock:elementBlock,positional:positional,named:named,atNames:atNames,blocks:namedBlocks,layout:layout}){let bindableBlocks=!!namedBlocks;let bindableAtNames=capabilities===true||hasCapability(capabilities,InternalComponentCapabilities.prepareArgs)||!!(named&&named[0].length!==0);let blocks=namedBlocks.with("attrs",elementBlock);op(Op.Fetch,$s0);op(Op.Dup,$sp,1);op(Op.Load,$s0);op(Op.PushFrame);CompileArgs(op,positional,named,blocks,atNames);op(Op.PrepareArgs,$s0);invokePreparedComponent(op,blocks.has("default"),bindableBlocks,bindableAtNames,(()=>{if(layout){op(Op.PushSymbolTable,symbolTableOperand(layout.symbolTable));op(Op.Constant,layoutOperand(layout));op(Op.CompileBlock);}else op(Op.GetComponentLayout,$s0);op(Op.PopulateLayout,$s0);}));op(Op.Load,$s0);}function WrappedComponent(op,layout,attrsBlockNumber){op(HighLevelBuilderOpcodes.StartLabels);WithSavedRegister(op,$s1,(()=>{op(Op.GetComponentTagName,$s0);op(Op.PrimitiveReference);op(Op.Dup,$sp,0);}));op(Op.JumpUnless,labelOperand("BODY"));op(Op.Fetch,$s1);op(Op.PutComponentOperations);op(Op.OpenDynamicElement);op(Op.DidCreateElement,$s0);YieldBlock(op,attrsBlockNumber,null);op(Op.FlushElement);op(HighLevelBuilderOpcodes.Label,"BODY");InvokeStaticBlock(op,[layout.block[0],[]]);op(Op.Fetch,$s1);op(Op.JumpUnless,labelOperand("END"));op(Op.CloseElement);op(HighLevelBuilderOpcodes.Label,"END");op(Op.Load,$s1);op(HighLevelBuilderOpcodes.StopLabels);}function invokePreparedComponent(op,hasBlock,bindableBlocks,bindableAtNames,populateLayout=null){op(Op.BeginComponentTransaction,$s0);op(Op.PushDynamicScope);op(Op.CreateComponent,encodeBoolean(hasBlock),$s0);populateLayout&&populateLayout();op(Op.RegisterComponentDestructor,$s0);op(Op.GetComponentSelf,$s0,null);op(Op.VirtualRootScope,$s0);op(Op.SetVariable,0);op(Op.SetupForEval,$s0);bindableAtNames&&op(Op.SetNamedVariables,$s0);bindableBlocks&&op(Op.SetBlocks,$s0);op(Op.Pop,1);op(Op.InvokeComponentLayout,$s0);op(Op.DidRenderLayout,$s0);op(Op.PopFrame);op(Op.PopScope);op(Op.PopDynamicScope);op(Op.CommitComponentTransaction);}function InvokeBareComponent(op){op(Op.Fetch,$s0);op(Op.Dup,$sp,1);op(Op.Load,$s0);op(Op.PushFrame);op(Op.PushEmptyArgs);op(Op.PrepareArgs,$s0);invokePreparedComponent(op,false,false,true,(()=>{op(Op.GetComponentLayout,$s0);op(Op.PopulateLayout,$s0);}));op(Op.Load,$s0);}function WithSavedRegister(op,register,block){op(Op.Fetch,register);block();op(Op.Load,register);}function main(op){op(Op.Main,$s0);invokePreparedComponent(op,false,false,true);}function StdAppend(op,trusting,nonDynamicAppend){SwitchCases(op,(()=>op(Op.ContentType)),(when=>{when(STRING_CONTENT,(()=>{if(trusting){op(Op.AssertSame);op(Op.AppendHTML);}else op(Op.AppendText);}));if(typeof nonDynamicAppend==="number"){when(COMPONENT_CONTENT,(()=>{op(Op.ResolveCurriedComponent);op(Op.PushDynamicComponentInstance);InvokeBareComponent(op);}));when(HELPER_CONTENT,(()=>{CallDynamic(op,null,null,(()=>{op(Op.InvokeStatic,nonDynamicAppend);}));}));}else {when(COMPONENT_CONTENT,(()=>{op(Op.AppendText);}));when(HELPER_CONTENT,(()=>{op(Op.AppendText);}));}when(SAFE_STRING_CONTENT,(()=>{op(Op.AssertSame);op(Op.AppendSafeHTML);}));when(FRAGMENT_CONTENT,(()=>{op(Op.AssertSame);op(Op.AppendDocumentFragment);}));when(NODE_CONTENT,(()=>{op(Op.AssertSame);op(Op.AppendNode);}));}));}function compileStd(context){let mainHandle=build(context,(op=>main(op)));let trustingGuardedNonDynamicAppend=build(context,(op=>StdAppend(op,true,null)));let cautiousGuardedNonDynamicAppend=build(context,(op=>StdAppend(op,false,null)));let trustingGuardedDynamicAppend=build(context,(op=>StdAppend(op,true,trustingGuardedNonDynamicAppend)));let cautiousGuardedDynamicAppend=build(context,(op=>StdAppend(op,false,cautiousGuardedNonDynamicAppend)));return new StdLib(mainHandle,trustingGuardedDynamicAppend,cautiousGuardedDynamicAppend,trustingGuardedNonDynamicAppend,cautiousGuardedNonDynamicAppend)}function build(program,builder){let{constants:constants,heap:heap,resolver:resolver}=program;let encoder=new EncoderImpl(heap,STDLIB_META);builder(definePushOp((function(...op){encodeOp(encoder,constants,resolver,STDLIB_META,op);})));let result=encoder.commit(0);if(typeof result!=="number")throw new Error("Unexpected errors compiling std");return result}function programCompilationContext(artifacts,resolver,createOp){return new CompileTimeCompilationContextImpl(artifacts,resolver,createOp)}function templateCompilationContext(program,meta){let encoder=new EncoderImpl(program.heap,meta,program.stdlib);return {program:program,encoder:encoder,meta:meta}}function hashToArgs(hash){if(hash===null)return null;let names=hash[0].map((key=>`@${key}`));return [names,hash[1]]}function inflateTagName(tagName){return typeof tagName==="string"?tagName:INFLATE_TAG_TABLE[tagName]}function inflateAttrName(attrName){return typeof attrName==="string"?attrName:INFLATE_ATTR_TABLE[attrName]}function isCompilable(value){return !!(value&&value instanceof CompilableTemplateImpl)}function compilable(layout,moduleName){let[statements,symbols,hasDebug]=layout.block;return new CompilableTemplateImpl(statements,meta(layout),{symbols:symbols,hasDebug:hasDebug},moduleName)}function maybeCompile(compilable,context){if(compilable.compiled!==null)return compilable.compiled;compilable.compiled=-1;let{statements:statements,meta:meta}=compilable;let result=compileStatements(statements,meta,context);compilable.compiled=result;return result}function compileStatements(statements,meta,syntaxContext){let sCompiler=STATEMENTS;let context=templateCompilationContext(syntaxContext,meta);let{encoder:encoder,program:{constants:constants,resolver:resolver}}=context;const op=definePushOp((function(...op){encodeOp(encoder,constants,resolver,meta,op);}));for(const statement of statements)sCompiler.compile(op,statement);let handle=context.encoder.commit(meta.size);return handle}function templateFactory({id:templateId,moduleName:moduleName,block:block,scope:scope,isStrictMode:isStrictMode}){let id=templateId||"client-"+clientId++;let parsedBlock;let ownerlessTemplate=null;let templateCache=new WeakMap;let factory=owner=>{parsedBlock===void 0&&(parsedBlock=JSON.parse(block));if(owner===void 0){if(ownerlessTemplate===null){templateCacheCounters.cacheMiss++;ownerlessTemplate=new TemplateImpl({id:id,block:parsedBlock,moduleName:moduleName,owner:null,scope:scope,isStrictMode:isStrictMode});}else templateCacheCounters.cacheHit++;return ownerlessTemplate}let result=templateCache.get(owner);if(result===void 0){templateCacheCounters.cacheMiss++;result=new TemplateImpl({id:id,block:parsedBlock,moduleName:moduleName,owner:owner,scope:scope,isStrictMode:isStrictMode});templateCache.set(owner,result);}else templateCacheCounters.cacheHit++;return result};factory.__id=id;factory.__meta={moduleName:moduleName};return factory}let debugCompiler;const HighLevelResolutionOpcodes={Modifier:1003,Component:1004,Helper:1005,OptionalHelper:1006,ComponentOrHelper:1007,OptionalComponentOrHelper:1008,Free:1009,Local:1010,TemplateLocal:1011};const HighLevelBuilderOpcodes={Label:1e3,StartLabels:1001,StopLabels:1002,Start:1e3,End:1002};const HighLevelOperands={Label:1,IsStrictMode:2,DebugSymbols:3,Block:4,StdLib:5,NonSmallInt:6,SymbolTable:7,Layout:8};class Compilers{#names={};#funcs=[];add(name,func){this.#names[name]=this.#funcs.push(func)-1;}compile(op,sexp){let name=sexp[0];let index=unwrap(this.#names[name]);let func=this.#funcs[index];assert$1(!!func,`expected an implementation for ${sexp[0]}`);func(op,sexp);}}const isGetFreeComponent=makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentHead);const isGetFreeModifier=makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsModifierHead);const isGetFreeHelper=makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHead);const isGetFreeComponentOrHelper=makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentOrHelperHead);const isGetFreeOptionalHelper=makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHeadOrThisFallback);const isGetFreeOptionalComponentOrHelper=makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback);class Labels{labels=dict();targets=[];label(name,index){this.labels[name]=index;}target(at,target){this.targets.push({at:at,target:target});}patch(heap){let{targets:targets,labels:labels}=this;for(const{at:at,target:target}of targets){let address=labels[target]-at;assert$1(heap.getbyaddr(at)===-1,"Expected heap to contain a placeholder, but it did not");heap.setbyaddr(at,address);}}}class EncoderImpl{labelsStack=Stack.empty();encoder=new InstructionEncoderImpl([]);errors=[];handle;constructor(heap,meta,stdlib){this.heap=heap;this.meta=meta;this.stdlib=stdlib;this.handle=heap.malloc();}error(error){this.encoder.encode(Op.Primitive,0);this.errors.push(error);}commit(size){let handle=this.handle;this.heap.pushOp(Op.Return);this.heap.finishMalloc(handle,size);return isPresentArray(this.errors)?{errors:this.errors,handle:handle}:handle}push(constants,type,...args){let{heap:heap}=this;if(DEBUG&&type>TYPE_SIZE)throw new Error(`Opcode type over 8-bits. Got ${type}.`);let machine=isMachineOp(type)?MACHINE_MASK:0;let first=type|machine|args.length<<ARG_SHIFT;heap.pushRaw(first);for(let i=0;i<args.length;i++){let op=args[i];heap.pushRaw(this.operand(constants,op));}}operand(constants,operand){if(typeof operand==="number")return operand;if(typeof operand==="object"&&operand!==null){if(Array.isArray(operand))return encodeHandle(constants.array(operand));switch(operand.type){case HighLevelOperands.Label:this.currentLabels.target(this.heap.offset,operand.value);return -1;case HighLevelOperands.IsStrictMode:return encodeHandle(constants.value(this.meta.isStrictMode));case HighLevelOperands.DebugSymbols:return encodeHandle(constants.array(this.meta.debugSymbols||EMPTY_STRING_ARRAY));case HighLevelOperands.Block:return encodeHandle(constants.value((block=operand.value,containing=this.meta,new CompilableTemplateImpl(block[0],containing,{parameters:block[1]||EMPTY_ARRAY}))));case HighLevelOperands.StdLib:return expect(this.stdlib,"attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?")[operand.value];case HighLevelOperands.NonSmallInt:case HighLevelOperands.SymbolTable:case HighLevelOperands.Layout:return constants.value(operand.value)}}var block,containing;return encodeHandle(constants.value(operand))}get currentLabels(){return expect(this.labelsStack.current,"bug: not in a label stack")}label(name){this.currentLabels.label(name,this.heap.offset+1);}startLabels(){this.labelsStack.push(new Labels);}stopLabels(){let label=expect(this.labelsStack.pop(),"unbalanced push and pop labels");label.patch(this.heap);}}class StdLib{constructor(main,trustingGuardedAppend,cautiousGuardedAppend,trustingNonDynamicAppend,cautiousNonDynamicAppend){this.main=main;this.trustingGuardedAppend=trustingGuardedAppend;this.cautiousGuardedAppend=cautiousGuardedAppend;this.trustingNonDynamicAppend=trustingNonDynamicAppend;this.cautiousNonDynamicAppend=cautiousNonDynamicAppend;}get"trusting-append"(){return this.trustingGuardedAppend}get"cautious-append"(){return this.cautiousGuardedAppend}get"trusting-non-dynamic-append"(){return this.trustingNonDynamicAppend}get"cautious-non-dynamic-append"(){return this.cautiousNonDynamicAppend}getAppend(trusting){return trusting?this.trustingGuardedAppend:this.cautiousGuardedAppend}}class NamedBlocksImpl{names;constructor(blocks){this.blocks=blocks;this.names=blocks?Object.keys(blocks):[];}get(name){if(!this.blocks)return null;return this.blocks[name]||null}has(name){let{blocks:blocks}=this;return blocks!==null&&name in blocks}with(name,block){let{blocks:blocks}=this;return new NamedBlocksImpl(blocks?assign({},blocks,{[name]:block}):{[name]:block})}get hasAny(){return this.blocks!==null}}const EMPTY_BLOCKS=new NamedBlocksImpl(null);const EXPRESSIONS=new Compilers;EXPRESSIONS.add(SexpOpcodes.Concat,((op,[,parts])=>{for(let part of parts)expr(op,part);op(Op.Concat,parts.length);}));EXPRESSIONS.add(SexpOpcodes.Call,((op,[,expression,positional,named])=>{if(isGetFreeHelper(expression))op(HighLevelResolutionOpcodes.Helper,expression,(handle=>{Call(op,handle,positional,named);}));else {expr(op,expression);CallDynamic(op,positional,named);}}));EXPRESSIONS.add(SexpOpcodes.Curry,((op,[,expr,type,positional,named])=>{Curry(op,type,expr,positional,named);}));EXPRESSIONS.add(SexpOpcodes.GetSymbol,((op,[,sym,path])=>{op(Op.GetVariable,sym);withPath(op,path);}));EXPRESSIONS.add(SexpOpcodes.GetLexicalSymbol,((op,[,sym,path])=>{op(HighLevelResolutionOpcodes.TemplateLocal,sym,(handle=>{op(Op.ConstantReference,handle);withPath(op,path);}));}));EXPRESSIONS.add(SexpOpcodes.GetStrictKeyword,((op,[,sym,_path])=>{op(HighLevelResolutionOpcodes.Free,sym,(_handle=>{}));}));EXPRESSIONS.add(SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback,(()=>{throw new Error("unimplemented opcode")}));EXPRESSIONS.add(SexpOpcodes.GetFreeAsHelperHeadOrThisFallback,((op,expr)=>{op(HighLevelResolutionOpcodes.Local,expr[1],(_name=>{op(HighLevelResolutionOpcodes.OptionalHelper,expr,{ifHelper:handle=>{Call(op,handle,null,null);}});}));}));EXPRESSIONS.add(SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback,((op,expr)=>{op(HighLevelResolutionOpcodes.Local,expr[1],(_name=>{op(HighLevelResolutionOpcodes.OptionalHelper,expr,{ifHelper:(handle,name,moduleName)=>{assert(expr[2]&&expr[2].length===1,"[BUG] Missing argument name");let arg=expr[2][0];deprecate(`The \`${name}\` helper was used in the \`${moduleName}\` template as \`${arg}={{${name}}}\`. This is ambigious between wanting the \`${arg}\` argument to be the \`${name}\` helper itself, or the result of invoking the \`${name}\` helper (current behavior). This implicit invocation behavior has been deprecated.\n\nInstead, please explicitly invoke the helper with parenthesis, i.e. \`${arg}={{(${name})}}\`.\n\nNote: the parenthesis are only required in this exact scenario where an ambiguity is present – where \`${name}\` referes to a global helper (as opposed to a local variable), AND the \`${name}\` helper invocation does not take any arguments, AND this occurs in a named argument position of a component invocation.\n\nWe expect this combination to be quite rare, as most helpers require at least one argument. There is no need to refactor helper invocations in cases where this deprecation was not triggered.`,false,{id:"argument-less-helper-paren-less-invocation"});Call(op,handle,null,null);}});}));}));EXPRESSIONS.add(SexpOpcodes.Undefined,(op=>PushPrimitiveReference(op,void 0)));EXPRESSIONS.add(SexpOpcodes.HasBlock,((op,[,block])=>{expr(op,block);op(Op.HasBlock);}));EXPRESSIONS.add(SexpOpcodes.HasBlockParams,((op,[,block])=>{expr(op,block);op(Op.SpreadBlock);op(Op.CompileBlock);op(Op.HasBlockParams);}));EXPRESSIONS.add(SexpOpcodes.IfInline,((op,[,condition,truthy,falsy])=>{expr(op,falsy);expr(op,truthy);expr(op,condition);op(Op.IfInline);}));EXPRESSIONS.add(SexpOpcodes.Not,((op,[,value])=>{expr(op,value);op(Op.Not);}));EXPRESSIONS.add(SexpOpcodes.GetDynamicVar,((op,[,expression])=>{expr(op,expression);op(Op.GetDynamicVar);}));EXPRESSIONS.add(SexpOpcodes.Log,((op,[,positional])=>{op(Op.PushFrame);SimpleArgs(op,positional,null,false);op(Op.Log);op(Op.PopFrame);op(Op.Fetch,$v0);}));const ATTRS_BLOCK="&attrs";const STDLIB_META={debugSymbols:null,upvars:null,moduleName:"stdlib",scopeValues:null,isStrictMode:true,owner:null,size:0};class CompileTimeCompilationContextImpl{constants;heap;stdlib;constructor({constants:constants,heap:heap},resolver,createOp){this.resolver=resolver;this.createOp=createOp;this.constants=constants;this.heap=heap;this.stdlib=compileStd(this);}}const INFLATE_ATTR_TABLE=["class","id","value","name","type","style","href"];const INFLATE_TAG_TABLE=["div","span","p","a"];const STATEMENTS=new Compilers;(function(statements){statements.add(SexpOpcodes.Comment,((op,sexp)=>op(Op.Comment,sexp[1])));statements.add(SexpOpcodes.CloseElement,(op=>op(Op.CloseElement)));statements.add(SexpOpcodes.FlushElement,(op=>op(Op.FlushElement)));statements.add(SexpOpcodes.Modifier,((op,[,expression,positional,named])=>{if(isGetFreeModifier(expression))op(HighLevelResolutionOpcodes.Modifier,expression,(handle=>{op(Op.PushFrame);SimpleArgs(op,positional,named,false);op(Op.Modifier,handle);op(Op.PopFrame);}));else {expr(op,expression);op(Op.PushFrame);SimpleArgs(op,positional,named,false);op(Op.Dup,$fp,1);op(Op.DynamicModifier);op(Op.PopFrame);}}));statements.add(SexpOpcodes.StaticAttr,((op,[,name,value,namespace])=>{op(Op.StaticAttr,inflateAttrName(name),value,namespace??null);}));statements.add(SexpOpcodes.StaticComponentAttr,((op,[,name,value,namespace])=>{op(Op.StaticComponentAttr,inflateAttrName(name),value,namespace??null);}));statements.add(SexpOpcodes.DynamicAttr,((op,[,name,value,namespace])=>{expr(op,value);op(Op.DynamicAttr,inflateAttrName(name),false,namespace??null);}));statements.add(SexpOpcodes.TrustingDynamicAttr,((op,[,name,value,namespace])=>{expr(op,value);op(Op.DynamicAttr,inflateAttrName(name),true,namespace??null);}));statements.add(SexpOpcodes.ComponentAttr,((op,[,name,value,namespace])=>{expr(op,value);op(Op.ComponentAttr,inflateAttrName(name),false,namespace??null);}));statements.add(SexpOpcodes.TrustingComponentAttr,((op,[,name,value,namespace])=>{expr(op,value);op(Op.ComponentAttr,inflateAttrName(name),true,namespace??null);}));statements.add(SexpOpcodes.OpenElement,((op,[,tag])=>{op(Op.OpenElement,inflateTagName(tag));}));statements.add(SexpOpcodes.OpenElementWithSplat,((op,[,tag])=>{op(Op.PutComponentOperations);op(Op.OpenElement,inflateTagName(tag));}));statements.add(SexpOpcodes.Component,((op,[,expr,elementBlock,named,blocks])=>{isGetFreeComponent(expr)?op(HighLevelResolutionOpcodes.Component,expr,(component=>{InvokeComponent(op,component,elementBlock,null,named,blocks);})):InvokeDynamicComponent(op,expr,elementBlock,null,named,blocks,true,true);}));})(STATEMENTS);(function(statements){statements.add(SexpOpcodes.Yield,((op,[,to,params])=>YieldBlock(op,to,params)));statements.add(SexpOpcodes.AttrSplat,((op,[,to])=>YieldBlock(op,to,null)));statements.add(SexpOpcodes.Debugger,((op,[,debugInfo])=>op(Op.Debugger,{type:HighLevelOperands.DebugSymbols,value:void 0},debugInfo)));statements.add(SexpOpcodes.Append,((op,[,value])=>{if(Array.isArray(value))if(isGetFreeOptionalComponentOrHelper(value))op(HighLevelResolutionOpcodes.OptionalComponentOrHelper,value,{ifComponent(component){InvokeComponent(op,component,null,null,null,null);},ifHelper(handle){op(Op.PushFrame);Call(op,handle,null,null);op(Op.InvokeStatic,stdlibOperand("cautious-non-dynamic-append"));op(Op.PopFrame);},ifValue(handle){op(Op.PushFrame);op(Op.ConstantReference,handle);op(Op.InvokeStatic,stdlibOperand("cautious-non-dynamic-append"));op(Op.PopFrame);}});else if(value[0]===SexpOpcodes.Call){let[,expression,positional,named]=value;isGetFreeComponentOrHelper(expression)?op(HighLevelResolutionOpcodes.ComponentOrHelper,expression,{ifComponent(component){InvokeComponent(op,component,null,positional,hashToArgs(named),null);},ifHelper(handle){op(Op.PushFrame);Call(op,handle,positional,named);op(Op.InvokeStatic,stdlibOperand("cautious-non-dynamic-append"));op(Op.PopFrame);}}):SwitchCases(op,(()=>{expr(op,expression);op(Op.DynamicContentType);}),(when=>{when(COMPONENT_CONTENT,(()=>{op(Op.ResolveCurriedComponent);op(Op.PushDynamicComponentInstance);InvokeNonStaticComponent(op,{capabilities:true,elementBlock:null,positional:positional,named:named,atNames:false,blocks:namedBlocks(null)});}));when(HELPER_CONTENT,(()=>{CallDynamic(op,positional,named,(()=>{op(Op.InvokeStatic,stdlibOperand("cautious-non-dynamic-append"));}));}));}));}else {op(Op.PushFrame);expr(op,value);op(Op.InvokeStatic,stdlibOperand("cautious-append"));op(Op.PopFrame);}else op(Op.Text,value===null||value===void 0?"":String(value));}));statements.add(SexpOpcodes.TrustingAppend,((op,[,value])=>{if(Array.isArray(value)){op(Op.PushFrame);expr(op,value);op(Op.InvokeStatic,stdlibOperand("trusting-append"));op(Op.PopFrame);}else op(Op.Text,value===null||value===void 0?"":String(value));}));statements.add(SexpOpcodes.Block,((op,[,expr,positional,named,blocks])=>{isGetFreeComponent(expr)?op(HighLevelResolutionOpcodes.Component,expr,(component=>{InvokeComponent(op,component,null,positional,hashToArgs(named),blocks);})):InvokeDynamicComponent(op,expr,null,positional,named,blocks,false,false);}));statements.add(SexpOpcodes.InElement,((op,[,block,guid,destination,insertBefore])=>{ReplayableIf(op,(()=>{expr(op,guid);insertBefore===void 0?PushPrimitiveReference(op,void 0):expr(op,insertBefore);expr(op,destination);op(Op.Dup,$sp,0);return 4}),(()=>{op(Op.PushRemoteElement);InvokeStaticBlock(op,block);op(Op.PopRemoteElement);}));}));statements.add(SexpOpcodes.HandleError,((op,[,handler,block,_inverse])=>{op.labels((()=>{Replayable(op,{begin:true,args:()=>{expr(op,handler);op(Op.PushBegin,op.target("CATCH"));return 2},body:()=>{op(Op.AssertSame);op(Op.Begin);InvokeStaticBlock(op,block);op(Op.Finally);op(Op.Jump,op.target("FINALLY"));op.label("CATCH");op.label("FINALLY");}});}));}));statements.add(SexpOpcodes.If,((op,[,condition,block,inverse])=>ReplayableIf(op,(()=>{expr(op,condition);op(Op.ToBoolean);return 1}),(()=>{InvokeStaticBlock(op,block);}),inverse?()=>{InvokeStaticBlock(op,inverse);}:void 0)));statements.add(SexpOpcodes.Each,((op,[,value,key,block,inverse])=>Replayable(op,{args:()=>{key?expr(op,key):PushPrimitiveReference(op,null);expr(op,value);return 2},body:()=>{op(Op.EnterList,labelOperand("BODY"),labelOperand("ELSE"));op(Op.PushFrame);op(Op.Dup,$fp,1);op(Op.ReturnTo,labelOperand("ITER"));op(HighLevelBuilderOpcodes.Label,"ITER");op(Op.Iterate,labelOperand("BREAK"));op(HighLevelBuilderOpcodes.Label,"BODY");InvokeStaticBlockWithStack(op,block,2);op(Op.Pop,2);op(Op.Jump,labelOperand("FINALLY"));op(HighLevelBuilderOpcodes.Label,"BREAK");op(Op.PopFrame);op(Op.ExitList);op(Op.Jump,labelOperand("FINALLY"));op(HighLevelBuilderOpcodes.Label,"ELSE");inverse&&InvokeStaticBlock(op,inverse);}})));statements.add(SexpOpcodes.With,((op,[,value,block,inverse])=>{ReplayableIf(op,(()=>{expr(op,value);op(Op.Dup,$sp,0);op(Op.ToBoolean);return 2}),(()=>{InvokeStaticBlockWithStack(op,block,1);}),(()=>{inverse&&InvokeStaticBlock(op,inverse);}));}));statements.add(SexpOpcodes.Let,((op,[,positional,block])=>{let count=CompilePositional(op,positional);InvokeStaticBlockWithStack(op,block,count);}));statements.add(SexpOpcodes.WithDynamicVars,((op,[,named,block])=>{if(named){let[names,expressions]=named;CompilePositional(op,expressions);DynamicScope(op,names,(()=>{InvokeStaticBlock(op,block);}));}else InvokeStaticBlock(op,block);}));statements.add(SexpOpcodes.InvokeComponent,((op,[,expr,positional,named,blocks])=>{isGetFreeComponent(expr)?op(HighLevelResolutionOpcodes.Component,expr,(component=>{InvokeComponent(op,component,null,positional,hashToArgs(named),blocks);})):InvokeDynamicComponent(op,expr,null,positional,named,blocks,false,false);}));})(STATEMENTS);class CompilableTemplateImpl{compiled=null;[IS_COMPILABLE_TEMPLATE]=true;constructor(statements,meta,symbolTable,moduleName="plain block"){this.statements=statements;this.meta=meta;this.symbolTable=symbolTable;this.moduleName=moduleName;}compile(context){return maybeCompile(this,context)}}const DEFAULT_CAPABILITIES={dynamicLayout:true,dynamicTag:true,prepareArgs:true,createArgs:true,attributeHook:false,elementHook:false,dynamicScope:true,createCaller:false,updateHook:true,createInstance:true,wrapped:false,willDestroy:false,hasSubOwner:false};const MINIMAL_CAPABILITIES={dynamicLayout:false,dynamicTag:false,prepareArgs:false,createArgs:false,attributeHook:false,elementHook:false,dynamicScope:false,createCaller:false,updateHook:false,createInstance:false,wrapped:false,willDestroy:false,hasSubOwner:false};class WrappedBuilder{symbolTable;compiled=null;attrsBlockNumber;meta;[IS_COMPILABLE_TEMPLATE]=true;constructor(layout,moduleName){this.layout=layout;this.moduleName=moduleName;let{block:block}=layout;let[,symbols,hasDebug]=block;this.meta=meta(layout);symbols=symbols.slice();let attrsBlockIndex=symbols.indexOf(ATTRS_BLOCK);this.attrsBlockNumber=attrsBlockIndex===-1?symbols.push(ATTRS_BLOCK):attrsBlockIndex+1;this.symbolTable={hasDebug:hasDebug,symbols:symbols};}compile(syntax){if(this.compiled!==null)return this.compiled;let m=meta(this.layout);let context=templateCompilationContext(syntax,m);let{encoder:encoder,program:{constants:constants,resolver:resolver}}=context;WrappedComponent(definePushOp((function(...op){encodeOp(encoder,constants,resolver,m,op);})),this.layout,this.attrsBlockNumber);let handle=context.encoder.commit(m.size);if(typeof handle!=="number")return handle;this.compiled=handle;return handle}}let clientId=0;let templateCacheCounters={cacheHit:0,cacheMiss:0};class TemplateImpl{result="ok";layout=null;wrappedLayout=null;constructor(parsedLayout){this.parsedLayout=parsedLayout;}get moduleName(){return this.parsedLayout.moduleName}get id(){return this.parsedLayout.id}get referrer(){return {moduleName:this.parsedLayout.moduleName,owner:this.parsedLayout.owner}}asLayout(){if(this.layout)return this.layout;return this.layout=compilable(assign({},this.parsedLayout),this.moduleName)}asWrappedLayout(){if(this.wrappedLayout)return this.wrappedLayout;return this.wrappedLayout=new WrappedBuilder(assign({},this.parsedLayout),this.moduleName)}}

export { CompileTimeCompilationContextImpl, DEFAULT_CAPABILITIES, EMPTY_BLOCKS, MINIMAL_CAPABILITIES, StdLib, WrappedBuilder, compilable, compileStatements, compileStd, debugCompiler, InvokeStaticBlock as invokeStaticBlock, InvokeStaticBlockWithStack as invokeStaticBlockWithStack, isCompilable, meta, programCompilationContext, templateCacheCounters, templateCompilationContext, templateFactory };
