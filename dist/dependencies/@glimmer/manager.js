import { DEBUG } from '@glimmer/env';
import { debugToString, devmode, setDescription, castToBrowser } from '@glimmer/util';
import { associateDestroyableChild, registerDestructor } from '@glimmer/destroyable';
import { Formula, ReadonlyCell, UNDEFINED_REFERENCE, unwrapReactive } from '@glimmer/reference';
import { createUpdatableTag, untrack, track } from '@glimmer/validator';
import { check, CheckNumber } from '@glimmer/debug';
import { InternalComponentCapabilities } from '@glimmer/vm';

function getCustomTagFor(obj){return CUSTOM_TAG_FOR.get(obj)}function setCustomTagFor(obj,customTagFn){CUSTOM_TAG_FOR.set(obj,customTagFn);}function convertToInt(prop){if(typeof prop==="symbol")return null;const num=Number(prop);if(isNaN(num))return null;return num%1===0?num:null}function tagForNamedArg(namedArgs,key){return track((()=>{key in namedArgs&&unwrapReactive(namedArgs[key]);}),devmode((()=>({label:[`@${key}`]}))))}function tagForPositionalArg(positionalArgs,key){return track((()=>{key==="[]"&&positionalArgs.forEach(unwrapReactive);const parsed=convertToInt(key);parsed!==null&&parsed<positionalArgs.length&&unwrapReactive(positionalArgs[parsed]);}),devmode((()=>({label:[`#${key}`]}))))}function buildCapabilities(capabilities){if(DEBUG){FROM_CAPABILITIES.add(capabilities);Object.freeze(capabilities);}return capabilities}function capabilityFlagsFrom(capabilities){return EMPTY|capability(capabilities,"dynamicLayout")|capability(capabilities,"dynamicTag")|capability(capabilities,"prepareArgs")|capability(capabilities,"createArgs")|capability(capabilities,"attributeHook")|capability(capabilities,"elementHook")|capability(capabilities,"dynamicScope")|capability(capabilities,"createCaller")|capability(capabilities,"updateHook")|capability(capabilities,"createInstance")|capability(capabilities,"wrapped")|capability(capabilities,"willDestroy")|capability(capabilities,"hasSubOwner")}function capability(capabilities,capability){return capabilities[capability]?InternalComponentCapabilities[capability]:EMPTY}function managerHasCapability(_manager,capabilities,capability){check(capabilities,CheckNumber);return !!(capabilities&capability)}function hasCapability(capabilities,capability){check(capabilities,CheckNumber);return !!(capabilities&capability)}function helperCapabilities(managerAPI,options={}){if(DEBUG&&managerAPI!=="3.23")throw new Error("Invalid helper manager compatibility specified");if(DEBUG&&(!(options.hasValue||options.hasScheduledEffect)||options.hasValue&&options.hasScheduledEffect))throw new Error("You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.");if(DEBUG&&options.hasScheduledEffect)throw new Error("The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead");return buildCapabilities({hasValue:Boolean(options.hasValue),hasDestroyable:Boolean(options.hasDestroyable),hasScheduledEffect:Boolean(options.hasScheduledEffect)})}function hasValue(manager){return manager.capabilities.hasValue}function hasDestroyable(manager){return manager.capabilities.hasDestroyable}function setManager(map,manager,obj){if(DEBUG&&(typeof obj!=="object"||obj===null)&&typeof obj!=="function")throw new Error(`Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${debugToString(obj)}`);if(DEBUG&&map.has(obj))throw new Error(`Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${debugToString(obj)}`);map.set(obj,manager);return obj}function getManager(map,obj){let pointer=obj;while(pointer!==void 0&&pointer!==null){const manager=map.get(pointer);if(manager!==void 0)return manager;pointer=getPrototypeOf$1(pointer);}return}function setInternalModifierManager(manager,definition){return setManager(MODIFIER_MANAGERS,manager,definition)}function getInternalModifierManager(definition,isOptional){if(DEBUG&&typeof definition!=="function"&&(typeof definition!=="object"||definition===null))throw new Error(`Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`);const manager=getManager(MODIFIER_MANAGERS,definition);if(manager===void 0){if(isOptional===true)return null;if(DEBUG)throw new Error(`Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${debugToString(definition)}`)}return manager}function setInternalHelperManager(manager,definition){return setManager(HELPER_MANAGERS,manager,definition)}function getInternalHelperManager(definition,isOptional){if(DEBUG&&typeof definition!=="function"&&(typeof definition!=="object"||definition===null))throw new Error(`Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`);let manager=getManager(HELPER_MANAGERS,definition);manager===void 0&&typeof definition==="function"&&(manager=DEFAULT_MANAGER);if(manager)return manager;if(isOptional===true)return null;if(DEBUG)throw new Error(`Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${debugToString(definition)}`);return null}function setInternalComponentManager(factory,obj){return setManager(COMPONENT_MANAGERS,factory,obj)}function getInternalComponentManager(definition,isOptional){if(DEBUG&&typeof definition!=="function"&&(typeof definition!=="object"||definition===null))throw new Error(`Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`);const manager=getManager(COMPONENT_MANAGERS,definition);if(manager===void 0){if(isOptional===true)return null;if(DEBUG)throw new Error(`Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${debugToString(definition)}`)}return manager}function hasInternalComponentManager(definition){return getManager(COMPONENT_MANAGERS,definition)!==void 0}function hasInternalHelperManager(definition){return hasDefaultHelperManager(definition)||getManager(HELPER_MANAGERS,definition)!==void 0}function hasInternalModifierManager(definition){return getManager(MODIFIER_MANAGERS,definition)!==void 0}function hasDefaultHelperManager(definition){return typeof definition==="function"}function componentCapabilities(managerAPI,options={}){if(DEBUG&&managerAPI!=="3.13")throw new Error("Invalid component manager compatibility specified");let updateHook=Boolean(options.updateHook);return buildCapabilities({asyncLifeCycleCallbacks:Boolean(options.asyncLifecycleCallbacks),destructor:Boolean(options.destructor),updateHook:updateHook})}function hasAsyncLifeCycleCallbacks(delegate){return delegate.capabilities.asyncLifeCycleCallbacks}function hasUpdateHook(delegate){return delegate.capabilities.updateHook}function hasAsyncUpdateHook(delegate){return hasAsyncLifeCycleCallbacks(delegate)&&hasUpdateHook(delegate)}function hasDestructors(delegate){return delegate.capabilities.destructor}function modifierCapabilities(managerAPI,optionalFeatures={}){if(DEBUG&&managerAPI!=="3.22")throw new Error("Invalid modifier manager compatibility specified");return buildCapabilities({disableAutoTracking:Boolean(optionalFeatures.disableAutoTracking)})}function setComponentManager(factory,obj){return setInternalComponentManager(new CustomComponentManager(factory),obj)}function setModifierManager(factory,obj){return setInternalModifierManager(new CustomModifierManager(factory),obj)}function setHelperManager(factory,obj){return setInternalHelperManager(new CustomHelperManager(factory),obj)}function setComponentTemplate(factory,obj){if(DEBUG&&!(obj!==null&&(typeof obj==="object"||typeof obj==="function")))throw new Error(`Cannot call \`setComponentTemplate\` on \`${debugToString(obj)}\``);if(DEBUG&&TEMPLATES.has(obj))throw new Error(`Cannot call \`setComponentTemplate\` multiple times on the same class (\`${debugToString(obj)}\`)`);TEMPLATES.set(obj,factory);return obj}function getComponentTemplate(obj){let pointer=obj;while(pointer!==null){let template=TEMPLATES.get(pointer);if(template!==void 0)return template;pointer=getPrototypeOf(pointer);}return}const CUSTOM_TAG_FOR=new WeakMap;class NamedArgsProxy{constructor(named){this.named=named;}get(_target,prop){const ref=this.named[prop];if(ref!==void 0)return unwrapReactive(ref)}has(_target,prop){return prop in this.named}ownKeys(){return Object.keys(this.named)}isExtensible(){return false}getOwnPropertyDescriptor(_target,prop){if(DEBUG&&!(prop in this.named))throw new Error(`args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \`${String(prop)}\``);return {enumerable:true,configurable:true}}}class PositionalArgsProxy{constructor(positional){this.positional=positional;}get(target,prop){let{positional:positional}=this;if(prop==="length")return positional.length;const parsed=convertToInt(prop);if(parsed!==null&&parsed<positional.length)return unwrapReactive(positional[parsed]);return target[prop]}isExtensible(){return false}has(_target,prop){const parsed=convertToInt(prop);return parsed!==null&&parsed<this.positional.length}}const argsProxyFor=(capturedArgs,type)=>{const{named:named,positional:positional}=capturedArgs;const namedHandler=new NamedArgsProxy(named);const positionalHandler=new PositionalArgsProxy(positional);const namedTarget=Object.create(null);if(DEBUG){const setHandler=function(_target,prop){throw new Error(`You attempted to set ${String(prop)} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`)};const forInDebugHandler=()=>{throw new Error(`Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`)};namedHandler.set=setHandler;positionalHandler.set=setHandler;positionalHandler.ownKeys=forInDebugHandler;}const namedProxy=new Proxy(namedTarget,namedHandler);const positionalProxy=new Proxy([],positionalHandler);setCustomTagFor(namedProxy,((_obj,key)=>tagForNamedArg(named,key)));setCustomTagFor(positionalProxy,((_obj,key)=>tagForPositionalArg(positional,key)));return {named:namedProxy,positional:positionalProxy}};const FROM_CAPABILITIES=DEBUG?new WeakSet:void 0;const EMPTY=InternalComponentCapabilities.Empty;class CustomHelperManager{constructor(factory){this.factory=factory;}helperManagerDelegates=new WeakMap;undefinedDelegate=null;getDelegateForOwner(owner){let delegate=this.helperManagerDelegates.get(owner);if(delegate===void 0){let{factory:factory}=this;delegate=factory(owner);if(DEBUG&&!FROM_CAPABILITIES.has(delegate.capabilities))throw new Error(`Custom helper managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.23')\` (imported via \`import { capabilities } from '@ember/helper';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);this.helperManagerDelegates.set(owner,delegate);}return delegate}getDelegateFor(owner){if(owner===void 0){let{undefinedDelegate:undefinedDelegate}=this;if(undefinedDelegate===null){let{factory:factory}=this;this.undefinedDelegate=undefinedDelegate=factory(void 0);}return undefinedDelegate}return this.getDelegateForOwner(owner)}getHelper(definition){return (capturedArgs,owner)=>{let manager=this.getDelegateFor(owner);const args=argsProxyFor(capturedArgs,"helper");const bucket=manager.createHelper(definition,args);if(hasValue(manager)){let cache=Formula((()=>manager.getValue(bucket)),DEBUG&&manager.getDebugName&&manager.getDebugName(definition));hasDestroyable(manager)&&associateDestroyableChild(cache,manager.getDestroyable(bucket));return cache}if(hasDestroyable(manager)){let ref=ReadonlyCell(void 0,DEBUG&&(manager.getDebugName?.(definition)??"unknown helper"));associateDestroyableChild(ref,manager.getDestroyable(bucket));return ref}return UNDEFINED_REFERENCE}}}class FunctionHelperManager{capabilities=buildCapabilities({hasValue:true,hasDestroyable:false,hasScheduledEffect:false});createHelper(fn,args){return {fn:fn,args:args}}getValue({fn:fn,args:args}){if(Object.keys(args.named).length>0){let argsForFn=[...args.positional,args.named];return fn(...argsForFn)}return fn(...args.positional)}getDebugName(fn){if(fn.name)return `(helper function ${fn.name})`;return "(anonymous helper function)"}}const COMPONENT_MANAGERS=new WeakMap;const MODIFIER_MANAGERS=new WeakMap;const HELPER_MANAGERS=new WeakMap;const getPrototypeOf$1=Object.getPrototypeOf;const DEFAULT_MANAGER=new CustomHelperManager((()=>new FunctionHelperManager));const CAPABILITIES={dynamicLayout:false,dynamicTag:false,prepareArgs:false,createArgs:true,attributeHook:false,elementHook:false,createCaller:false,dynamicScope:true,updateHook:true,createInstance:true,wrapped:false,willDestroy:false,hasSubOwner:false};class CustomComponentManager{componentManagerDelegates=new WeakMap;constructor(factory){this.factory=factory;}getDelegateFor(owner){let{componentManagerDelegates:componentManagerDelegates}=this;let delegate=componentManagerDelegates.get(owner);if(delegate===void 0){let{factory:factory}=this;delegate=factory(owner);if(DEBUG&&!FROM_CAPABILITIES.has(delegate.capabilities))throw new Error(`Custom component managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.13')\` (imported via \`import { capabilities } from '@ember/component';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);componentManagerDelegates.set(owner,delegate);}return delegate}create(owner,definition,vmArgs){let delegate=this.getDelegateFor(owner);let args=argsProxyFor(vmArgs.capture(),"component");let component=delegate.createComponent(definition,args);return new CustomComponentState(component,delegate,args)}getDebugName(definition){return typeof definition==="function"?definition.name:definition.toString()}update(bucket){let{delegate:delegate}=bucket;if(hasUpdateHook(delegate)){let{component:component,args:args}=bucket;delegate.updateComponent(component,args);}}didCreate({component:component,delegate:delegate}){hasAsyncLifeCycleCallbacks(delegate)&&delegate.didCreateComponent(component);}didUpdate({component:component,delegate:delegate}){hasAsyncUpdateHook(delegate)&&delegate.didUpdateComponent(component);}didRenderLayout(){}didUpdateLayout(){}getSelf({component:component,delegate:delegate}){return ReadonlyCell(delegate.getContext(component),"this")}getDestroyable(bucket){const{delegate:delegate}=bucket;if(hasDestructors(delegate)){const{component:component}=bucket;registerDestructor(bucket,(()=>delegate.destroyComponent(component)));return bucket}return null}getCapabilities(){return CAPABILITIES}}class CustomComponentState{constructor(component,delegate,args){this.component=component;this.delegate=delegate;this.args=args;}}class CustomModifierManager{componentManagerDelegates=new WeakMap;constructor(factory){this.factory=factory;}getDelegateFor(owner){let{componentManagerDelegates:componentManagerDelegates}=this;let delegate=componentManagerDelegates.get(owner);if(delegate===void 0){let{factory:factory}=this;delegate=factory(owner);if(DEBUG&&!FROM_CAPABILITIES.has(delegate.capabilities))throw new Error(`Custom modifier managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.22')\` (imported via \`import { capabilities } from '@ember/modifier';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);componentManagerDelegates.set(owner,delegate);}return delegate}create(owner,element,definition,capturedArgs){let delegate=this.getDelegateFor(owner);let args=argsProxyFor(capturedArgs,"modifier");let instance=delegate.createModifier(definition,args);const description=devmode((()=>({reason:"modifier",label:typeof definition==="function"?[definition.name]:[`${definition}`]})));let tag=createUpdatableTag(description);const state={tag:tag,element:element,delegate:delegate,args:args,modifier:instance};setDescription(state,description);registerDestructor(state,(()=>delegate.destroyModifier(instance,args)));return state}getDebugName(_definition){return "TODO modifier"}getTag({tag:tag}){return tag}install({element:element,args:args,modifier:modifier,delegate:delegate}){let{capabilities:capabilities}=delegate;capabilities.disableAutoTracking===true?untrack((()=>delegate.installModifier(modifier,castToBrowser(element,"ELEMENT"),args))):delegate.installModifier(modifier,castToBrowser(element,"ELEMENT"),args);}update({args:args,modifier:modifier,delegate:delegate}){let{capabilities:capabilities}=delegate;capabilities.disableAutoTracking===true?untrack((()=>delegate.updateModifier(modifier,args))):delegate.updateModifier(modifier,args);}getDestroyable(state){return state}}const TEMPLATES=new WeakMap;const getPrototypeOf=Object.getPrototypeOf;

export { CustomComponentManager, CustomHelperManager, CustomModifierManager, capabilityFlagsFrom, componentCapabilities, getComponentTemplate, getCustomTagFor, getInternalComponentManager, getInternalHelperManager, getInternalModifierManager, hasCapability, hasDestroyable, hasInternalComponentManager, hasInternalHelperManager, hasInternalModifierManager, hasValue, helperCapabilities, managerHasCapability, modifierCapabilities, setComponentManager, setComponentTemplate, setCustomTagFor, setHelperManager, setInternalComponentManager, setInternalHelperManager, setInternalModifierManager, setModifierManager };
