import { DEBUG } from '@glimmer/env';
import { assert, scheduleRevalidate } from '@glimmer/global-context';
import { setDescription, devmode, expect, inDevmode, toValidatableDescription, getDescription, stringifyDebugLabel, getLast, asPresentArray, createWithDescription, mapDevmode } from '@glimmer/util';

function unwrap(val){if(val===null||val===void 0)throw new Error("Expected value to be present");return val}function bump(){$REVISION++;}function valueForTag(tag){return tag[COMPUTE]()}function validateTag(tag,snapshot){return snapshot>=tag[COMPUTE]()}function createTag(label){return createTagWithId(0,label??devmode((()=>({reason:"cell",label:["(dirtyable)"]}))))}function createUpdatableTag(label){return createTagWithId(UPDATABLE_TAG_ID,label??devmode((()=>({reason:"cell",label:["(updatable)"]}))))}function updateSubtag(tag,subtag){tag.subtags=subtag;setDescription(tag,devmode((()=>mapDevmode((()=>tag.description),(desc=>({...desc,subtags:[inDevmode(subtag.description)]}))))));}function updateSubtags(tag,subtags){tag.subtags=subtags;DEBUG&&applyComboLabel(tag,subtags);}function emptySubtag(tag){tag.subtags=null;DEBUG&&delete inDevmode(tag.description).subtags;}function createTagWithId(id,label){expect(label,"Expected a tag description");if(DEBUG&&label){const tag=new MonomorphicTagImpl(id);setDescription(tag,label);return tag}return new MonomorphicTagImpl(id)}function applyComboLabel(parent,tags){const debug=inDevmode(parent.description);Array.isArray(tags)?parent.description=devmode((()=>({...debug,subtags:tags.map((tag=>inDevmode(tag.description)))}))):parent.description=devmode((()=>({...debug,subtags:[inDevmode(tags.description)]})));}function isConstTag(tag){return tag===CONSTANT_TAG}function dirtyTagFor(obj,key,meta){if(DEBUG&&!(u=obj,typeof u==="object"&&u!==null||typeof u==="function"))throw new Error("BUG: Can't update a tag for a primitive");var u;let tags=meta===void 0?TRACKED_TAGS.get(obj):meta;if(tags===void 0)return;let propertyTag=tags.get(key);if(propertyTag!==void 0){DEBUG&&unwrap(debug.assertTagNotConsumed)(propertyTag,obj,key);DIRTY_TAG(propertyTag,true);}}function tagMetaFor(obj){let tags=TRACKED_TAGS.get(obj);if(tags===void 0){tags=new Map;TRACKED_TAGS.set(obj,tags);}return tags}function tagFor(obj,key,meta){let tags=meta===void 0?tagMetaFor(obj):meta;let tag=tags.get(key);if(tag===void 0){tag=createUpdatableTag(devmode((()=>({reason:"property",label:["(object)",key]}))));tags.set(key,tag);}return tag}function beginTrackFrame(context=devmode((()=>({reason:"formula",label:["(tracking frame)"]})))){OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);CURRENT_TRACKER=new Tracker;setDescription(CURRENT_TRACKER,context);DEBUG&&unwrap(debug.beginTrackingTransaction)(inDevmode(context));}function endTrackFrame(){let current=CURRENT_TRACKER;if(DEBUG){if(OPEN_TRACK_FRAMES.length===0)throw new Error("attempted to close a tracking frame, but one was not open");unwrap(debug.endTrackingTransaction)();}CURRENT_TRACKER=OPEN_TRACK_FRAMES.pop()||null;return unwrap(current).combine()}function beginUntrackFrame(){OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);CURRENT_TRACKER=null;}function endUntrackFrame(){if(DEBUG&&OPEN_TRACK_FRAMES.length===0)throw new Error("attempted to close a tracking frame, but one was not open");CURRENT_TRACKER=OPEN_TRACK_FRAMES.pop()||null;}function resetTracking(){while(OPEN_TRACK_FRAMES.length>0)OPEN_TRACK_FRAMES.pop();CURRENT_TRACKER=null;if(DEBUG)return unwrap(debug.resetTrackingTransaction)()}function isTracking(){return CURRENT_TRACKER!==null}function consumeTag(tag){CURRENT_TRACKER!==null&&CURRENT_TRACKER.add(tag);}function createCache(fn,debuggingLabel){if(DEBUG&&!(typeof fn==="function"))throw new Error(`createCache() must be passed a function as its first parameter. Called with: ${String(fn)}`);let cache={[FN]:fn,[LAST_VALUE]:void 0,[TAG]:void 0,[SNAPSHOT]:-1};setDescription(cache,devmode((()=>toValidatableDescription(debuggingLabel,CACHE_DEFAULTS))));return cache}function getValue(cache){assertCache(cache,"getValue");let fn=cache[FN];let tag=cache[TAG];let snapshot=cache[SNAPSHOT];if(tag!==void 0&&validateTag(tag,snapshot))consumeTag(tag);else {beginTrackFrame(getDescription(cache));try{cache[LAST_VALUE]=fn();}finally{tag=endTrackFrame();cache[TAG]=tag;cache[SNAPSHOT]=valueForTag(tag);consumeTag(tag);}}return cache[LAST_VALUE]}function isConst(cache){assertCache(cache,"isConst");let tag=cache[TAG];assertTag(tag,cache);return isConstTag(tag)}function assertCache(value,fnName){if(DEBUG&&!(typeof value==="object"&&value!==null&&FN in value))throw new Error(`${fnName}() can only be used on an instance of a cache created with createCache(). Called with: ${String(value)}`)}function assertTag(tag,cache){if(DEBUG&&tag===void 0)throw new Error(`isConst() can only be used on a cache once getValue() has been called at least once. Called with cache function:\n\n${String(cache[FN])}`)}function track(block,description=devmode((()=>({reason:"tracking",label:["(track)"]})))){beginTrackFrame(description);let tag;try{block();}finally{tag=endTrackFrame();}return tag}function untrack(callback){beginUntrackFrame();try{return callback()}finally{endUntrackFrame();}}function trackedData(key,initializer){let values=new WeakMap;let hasInitializer=typeof initializer==="function";return {getter:function(self){consumeTag(tagFor(self,key));let value;if(hasInitializer&&!values.has(self)){value=initializer.call(self);values.set(self,value);}else value=values.get(self);return value},setter:function(self,value){dirtyTagFor(self,key);values.set(self,value);}}}const debug={};if(DEBUG){let CONSUMED_TAGS=null;const TRANSACTION_STACK=[];const TRANSACTION_ENV={debugMessage(obj,keyName){let objName;if(typeof obj==="function")objName=obj.name;else if(typeof obj==="object"&&obj!==null){let className=obj.constructor&&obj.constructor.name||"(unknown class)";objName=`(an instance of ${className})`;}else objName=obj===void 0?"(an unknown tag)":String(obj);let dirtyString=keyName?`\`${keyName}\` on \`${objName}\``:`\`${objName}\``;return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`}};debug.setTrackingTransactionEnv=env=>Object.assign(TRANSACTION_ENV,env);debug.beginTrackingTransaction=description=>{CONSUMED_TAGS=CONSUMED_TAGS||new WeakMap;let parent=TRANSACTION_STACK[TRANSACTION_STACK.length-1]??null;TRANSACTION_STACK.push({parent:parent,description:devmode((()=>description))});};debug.endTrackingTransaction=()=>{if(TRANSACTION_STACK.length===0)throw new Error("attempted to close a tracking transaction, but one was not open");TRANSACTION_STACK.pop();TRANSACTION_STACK.length===0&&(CONSUMED_TAGS=null);};debug.resetTrackingTransaction=()=>{let stack="";TRANSACTION_STACK.length>0&&(stack=debug.logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length-1]));TRANSACTION_STACK.splice(0,TRANSACTION_STACK.length);CONSUMED_TAGS=null;return stack};debug.runInTrackingTransaction=(fn,description={reason:"tracking",label:["(tracking)"]})=>{debug.beginTrackingTransaction(description);let didError=true;try{let value=fn();didError=false;return value}finally{didError!==true&&debug.endTrackingTransaction();}};let nthIndex=(str,pattern,n,startingPos=-1)=>{let i=startingPos;while(n-- >0&&i++<str.length){i=str.indexOf(pattern,i);if(i<0)break}return i};let makeTrackingErrorMessage=(transaction,obj,keyName)=>{let message=[TRANSACTION_ENV.debugMessage(obj,keyName&&String(keyName))];message.push(`\`${String(keyName)}\` was first used:`);message.push(debug.logTrackingStack(transaction));message.push("Stack trace for the update:");return message.join("\n\n")};debug.logTrackingStack=transaction=>{let trackingStack=[];let current=transaction||TRANSACTION_STACK[TRANSACTION_STACK.length-1];if(current===void 0)return "";while(current){trackingStack.unshift(current);current=current.parent;}return trackingStack.map(((label,index)=>" ".repeat(2*index)+inDevmode(stringifyDebugLabel(label)))).join("\n")};debug.markTagAsConsumed=_tag=>{if(!CONSUMED_TAGS||CONSUMED_TAGS.has(_tag))return;CONSUMED_TAGS.set(_tag,getLast(asPresentArray(TRANSACTION_STACK)));let subtag=_tag.subtag;if(!subtag||!debug.markTagAsConsumed)return;Array.isArray(subtag)?subtag.forEach(debug.markTagAsConsumed):debug.markTagAsConsumed(subtag);};debug.assertTagNotConsumed=(tag,obj,keyName)=>{if(CONSUMED_TAGS===null)return;let transaction=CONSUMED_TAGS.get(tag);if(!transaction)return;try{assert(false,makeTrackingErrorMessage(transaction,obj,keyName));}catch(e){if(error=e,typeof error==="object"&&error!==null&&"stack"in error&&typeof error.stack==="string"){let updateStackBegin=e.stack.indexOf("Stack trace for the update:");if(updateStackBegin!==-1){let start=nthIndex(e.stack,"\n",1,updateStackBegin);let end=nthIndex(e.stack,"\n",4,updateStackBegin);e.stack=e.stack.substr(0,start)+e.stack.substr(end);}}throw e}var error;};}const INVALID_REVISION=-1;const CONSTANT=0;const INITIAL=1;const VOLATILE=NaN;let $REVISION=1;const DIRYTABLE_TAG_ID=0;const UPDATABLE_TAG_ID=1;const COMBINATOR_TAG_ID=2;const CONSTANT_TAG_ID=3;const COMPUTE=Symbol("TAG_COMPUTE");const TYPE=Symbol("TAG_TYPE");let ALLOW_CYCLES;DEBUG&&(ALLOW_CYCLES=new WeakMap);class MonomorphicTagImpl{static combine(tags,description=devmode((()=>({kind:"tag",label:["(combine)"]})))){switch(tags.length){case 0:return CONSTANT_TAG;case 1:if(!DEBUG)return tags[0];default:{let tag=createWithDescription((()=>new MonomorphicTagImpl(2)),description);updateSubtags(tag,tags);return tag}}}revision=1;lastChecked=1;lastValue=1;isUpdating=false;subtags=null;subtagBufferCache=null;[TYPE];constructor(type){this[TYPE]=type;}[COMPUTE](){let{lastChecked:lastChecked}=this;if(this.isUpdating===true){if(DEBUG&&!(ALLOW_CYCLES===void 0||ALLOW_CYCLES.has(this)))throw new Error("Cycles in tags are not allowed");this.lastChecked=++$REVISION;}else if(lastChecked!==$REVISION){this.isUpdating=true;this.lastChecked=$REVISION;try{let{subtags:subtags,revision:revision}=this;if(subtags!==null)if(Array.isArray(subtags))revision=subtags.reduce(((prev,currentTag)=>{let current=currentTag[COMPUTE]();return current>prev?current:prev}),revision);else {let subtagValue=subtags[COMPUTE]();if(subtagValue===this.subtagBufferCache)revision=revision>this.lastValue?revision:this.lastValue;else {this.subtagBufferCache=null;revision=revision>subtagValue?revision:subtagValue;}}this.lastValue=revision;}finally{this.isUpdating=false;}}return this.lastValue}static updateTag(_tag,_subtag){if(DEBUG&&_tag[TYPE]!==UPDATABLE_TAG_ID)throw new Error("Attempted to update a tag that was not updatable");let tag=_tag;let subtag=_subtag;if(subtag===CONSTANT_TAG)emptySubtag(tag);else {tag.subtagBufferCache=subtag[COMPUTE]();updateSubtag(tag,subtag);}}static dirtyTag(tag,disableConsumptionAssertion){if(DEBUG&&!(tag[TYPE]===UPDATABLE_TAG_ID||tag[TYPE]===0))throw new Error("Attempted to dirty a tag that was not dirtyable");DEBUG&&disableConsumptionAssertion!==true&&unwrap(debug.assertTagNotConsumed)(tag);tag.revision=++$REVISION;scheduleRevalidate();}}const DIRTY_TAG=MonomorphicTagImpl.dirtyTag;const UPDATE_TAG=MonomorphicTagImpl.updateTag;const CONSTANT_TAG=new MonomorphicTagImpl(3);setDescription(CONSTANT_TAG,devmode((()=>({reason:"cell",label:["(constant)"]}))));class VolatileTag{subtag;[TYPE]=100;[COMPUTE](){return NaN}}const VOLATILE_TAG=new VolatileTag;setDescription(VOLATILE_TAG,devmode((()=>({reason:"cell",label:["(volatile)"]}))));class CurrentTag{subtag;[TYPE]=101;[COMPUTE](){return $REVISION}}const CURRENT_TAG=new CurrentTag;setDescription(CURRENT_TAG,devmode((()=>({reason:"cell",label:["(current)"]}))));const combine=MonomorphicTagImpl.combine;const TAG_TYPE=TYPE;const TRACKED_TAGS=new WeakMap;class Tracker{tags=new Set;last=null;add(tag){if(tag===CONSTANT_TAG)return;this.tags.add(tag);DEBUG&&unwrap(debug.markTagAsConsumed)(tag);this.last=tag;}combine(){let{tags:tags}=this;return tags.size===0?CONSTANT_TAG:DEBUG||tags.size!==1?combine(Array.from(tags)):this.last}}let CURRENT_TRACKER=null;const OPEN_TRACK_FRAMES=[];const FN=Symbol("FN");const LAST_VALUE=Symbol("LAST_VALUE");const TAG=Symbol("TAG");const SNAPSHOT=Symbol("SNAPSHOT");const CACHE_DEFAULTS=devmode((()=>({reason:"cache",label:["(cache)"]})));const GLIMMER_VALIDATOR_REGISTRATION=Symbol("GLIMMER_VALIDATOR_REGISTRATION");const globalObj=function(){if(typeof globalThis!=="undefined")return globalThis;if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof global!=="undefined")return global;throw new Error("unable to locate global object")}();if(globalObj[GLIMMER_VALIDATOR_REGISTRATION]===true)throw new Error("The `@glimmer/validator` library has been included twice in this application. It could be different versions of the package, or the same version included twice by mistake. `@glimmer/validator` depends on having a single copy of the package in use at any time in an application, even if they are the same version. You must dedupe your build to remove the duplicate packages in order to prevent this error.");globalObj[GLIMMER_VALIDATOR_REGISTRATION]=true;

export { ALLOW_CYCLES, COMBINATOR_TAG_ID, COMPUTE, CONSTANT, CONSTANT_TAG, CONSTANT_TAG_ID, CURRENT_TAG, CurrentTag, DIRYTABLE_TAG_ID, INITIAL, INVALID_REVISION, TAG_TYPE, UPDATABLE_TAG_ID, VOLATILE, VOLATILE_TAG, VolatileTag, beginTrackFrame, beginUntrackFrame, bump, combine, consumeTag, createCache, createTag, createUpdatableTag, debug, DIRTY_TAG as dirtyTag, dirtyTagFor, endTrackFrame, endUntrackFrame, getValue, isConst, isConstTag, isTracking, resetTracking, tagFor, tagMetaFor, track, trackedData, untrack, UPDATE_TAG as updateTag, validateTag, valueForTag };
