import { enhancedDevmode, inDevmode, stringifyDebugLabel, devmode, setDescription, toValidatableDescription, UserException, devmodeOr, unwrapResult, isDict, stringifyChildLabel, getDescription, Ok, mapDevmode, isObject, isIndexable, Err, EMPTY_ARRAY } from '@glimmer/util';
import { createTag, dirtyTag, CONSTANT_TAG, consumeTag, track, valueForTag, validateTag, tagFor, dirtyTagFor, INITIAL } from '@glimmer/validator';
import { DEBUG } from '@glimmer/env';
import { getProperty, setProperty, toIterator, getPath } from '@glimmer/global-context';

function getChildLabel(parent,child){return DEBUG?stringifyChildLabel(...inDevmode(parent.description).label,child):String(child)}function getValidResult(ref){return ref.error?Err(ref.error):Ok(ref.lastValue)}function readInternalReactive(reactive){const{tag:tag,compute:compute}=reactive;if(validateInternalReactive(reactive)){consumeTag(reactive.tag);return getValidResult(reactive)}if(compute===null){tag&&consumeTag(tag);return getValidResult(reactive)}const newTag=track(compute,getDescription(reactive));reactive.tag=newTag;reactive.lastRevision=valueForTag(newTag);consumeTag(newTag);return getValidResult(reactive)}function validateInternalReactive(reactive){const{tag:tag,lastRevision:lastRevision}=reactive;if(tag===null)return false;return validateTag(tag,lastRevision)}function updateInternalReactive(reactive,value){if(reactive.update)reactive.update(value);else if(DEBUG)throw Error(`cannot update ${describeReactive(reactive)}`);return Ok(void 0)}function setLastValue(reactive,value){reactive.lastValue=value;reactive.error=null;return value}function setError(reactive,error){reactive.lastValue=null;reactive.error=error;reactive.tag=null;}function setResult(internal,result){switch(result.type){case"ok":return setLastValue(internal,result.value);case"err":setError(internal,result.value);}}function setFromFallibleCompute(internal,compute){try{return setLastValue(internal,compute())}catch(e){setError(internal,UserException.from(e,`An error occured while computing ${devmodeOr((()=>stringifyDebugLabel(internal)),"a formula")}`));}}function internalHasError(reactive){return !!reactive.error}function Poison(error,debugLabel){const ref=new InternalReactive(CONSTANT_ERROR);ref.tag=CONSTANT_TAG;ref.error=error;setDescription(ref,devmode((()=>({readonly:true,fallible:true,label:[debugLabel||"(Poison)"],kind:"poisoned"}))));return ref}function ResultAccessor(options,description){return InternalResultAccessor(options,description)}function InternalResultAccessor(options,description,type=ACCESSOR){const{get:get,set:set}=options;const internal=new InternalReactive(type);internal.compute=()=>setResult(internal,get());internal.update=value=>{const setResult=set(value);setResult.type==="ok"?internal.lastValue=value:setError(internal,setResult.value);};setDescription(internal,devmode((()=>toValidatableDescription(description,RESULT_ACCESSOR_DEFAULTS))));return internal}function Accessor(options,description){const{get:get,set:set}=options;const internal=new InternalReactive(ACCESSOR);internal.compute=()=>setFromFallibleCompute(internal,get);internal.update=value=>{try{set(value);return value}catch(e){setError(internal,UserException.from(e,`An error occured setting ${devmodeOr((()=>stringifyDebugLabel(internal)),"an accessor")}`));}};setDescription(internal,devmode((()=>toValidatableDescription(description,ACCESSOR_DEFAULTS))));return internal}function unwrapReactive(reactive){return unwrapResult(readInternalReactive(reactive))}function updateReactive(reactive,value){updateInternalReactive(reactive,value);}function readReactive(reactive){return readInternalReactive(reactive)}function readCell(cell){return unwrapReactive(cell)}function writeCell(cell,value){updateReactive(cell,value);}function MutableCell(value,description){const ref=new InternalReactive(0);const tag=ref.tag=createTag(toValidatableDescription(description,MUTABLE_CELL_DEFAULTS));ref.lastValue=value;ref.update=value=>{ref.lastValue=value;dirtyTag(tag);};setDescription(ref,devmode((()=>toValidatableDescription(description,MUTABLE_CELL_DEFAULTS))));return ref}function ReadonlyCell(value,description){const ref=new InternalReactive(1);ref.tag=CONSTANT_TAG;ref.lastValue=value;setDescription(ref,devmode((()=>toValidatableDescription(description,READONLY_CELL_DEFAULTS))));return ref}function DeeplyReadonlyCell(value,debugLabel){const ref=new InternalReactive(DEEPLY_CONSTANT);ref.tag=CONSTANT_TAG;ref.lastValue=value;DEBUG&&(ref.description=devmode((()=>({type:"DeeplyReadonlyCell",read:"fallible",write:"none",label:[debugLabel||"{deeply readonly cell}"]}))));return ref}function ExternalMarker(debugLabel){const description=toValidatableDescription(debugLabel,devmode((()=>({label:["{external marker}"]}))));const tag=createTag(description);const marker={mark:()=>dirtyTag(tag),consume:()=>consumeTag(tag)};setDescription(marker,description);return marker}function validateReactive(reactive){return validateInternalReactive(reactive)}function hasError(reactive){return internalHasError(reactive)}function Formula(compute,debugLabel){const ref=new InternalReactive(FALLIBLE_FORMULA);ref.compute=()=>setFromFallibleCompute(ref,compute);setDescription(ref,devmode((()=>toValidatableDescription(debugLabel,FALLIBLE_FORMULA_DEFAULTS))));return ref}function ResultFormula(compute,description){const ref=new InternalReactive(FALLIBLE_FORMULA);ref.compute=()=>setResult(ref,compute());setDescription(ref,devmode((()=>toValidatableDescription(description,RESULT_FORMULA_DEFAULTS))));return ref}function ComputedCell(compute,description){const ref=new InternalReactive(4);ref.compute=()=>setLastValue(ref,compute());setDescription(ref,devmode((()=>toValidatableDescription(description,COMPUTED_CELL_DEFAULTS))));return ref}function isFallibleFormula(_ref){return _ref[REFERENCE$1]===FALLIBLE_FORMULA}function isAccessor(_ref){return _ref[REFERENCE$1]===ACCESSOR}function isMutRef(_ref){return _ref[REFERENCE$1]===MUTABLE_REF}function isConstantError(_ref){return _ref[REFERENCE$1]===CONSTANT_ERROR}function isUpdatableRef(_ref){const ref=_ref;return (isAccessor(_ref)||isMutRef(_ref))&&ref.update!==null}function clearError(reactive){const internal=reactive;internal.error=null;internal.tag=null;internal.lastValue=null;}function toReadonly(reactive){return isMutRef(reactive)||isUpdatableRef(reactive)?Formula((()=>unwrapReactive(reactive))):reactive}function toMut(maybeMut){const reactive=maybeMut;if(isMutRef(maybeMut))return maybeMut;return InternalResultAccessor({get:()=>readInternalReactive(maybeMut),set:value=>updateInternalReactive(reactive,value)},void 0,MUTABLE_REF)}function isConstant(reactive){switch(reactive[REFERENCE$1]){case 1:case DEEPLY_CONSTANT:return true;default:return false}}function createPrimitiveCell(value){const ref=new InternalReactive(1);ref.tag=CONSTANT_TAG;ref.lastValue=value;setDescription(ref,devmode((()=>({type:"PrimitiveCell",read:"infallible",write:"none",property:{read:"fallible",write:"none"},label:[value===void 0?"undefined":JSON.stringify(value)]}))));return ref}function getReactivePath(reactive,path){let current=reactive;for(const part of path)current=getReactiveProperty(current,part);return current}function getReactiveProperty(parentReactive,property){const type=parentReactive[REFERENCE$1];const children=initializeChildren(parentReactive);{const child=children.get(property);if(child!==void 0)return child}const initialize=child=>{children.set(property,child);setDescription(child,mapDevmode((()=>parentReactive.description),(desc=>({type:"GetProperty",read:"fallible",write:"fallible",label:[...desc.label,property]}))));return child};if(type===DEEPLY_CONSTANT)try{const parent=readInternalReactive(parentReactive);if(parent.type==="err")return initialize(Poison(parent.value));if(isDict(parent.value))return initialize(DeeplyReadonlyCell(parent.value[property]))}catch(e){return initialize(Poison(UserException.from(e,`An error occured when getting a property from a deeply constant reactive (${getChildLabel(parentReactive,property)})`)))}const child=Accessor({get:()=>{const parent=unwrapReactive(parentReactive);if(isDict(parent)){isObject(parent)&&consumeTag(tagFor(parent,property));return getProperty(parent,property)}},set:value=>{const parentResult=readInternalReactive(parentReactive);if(parentResult.type==="err")return parentResult;{const parent=parentResult.value;if(isIndexable(parent))try{setProperty(parent,property,value);isObject(parentResult.value)&&dirtyTagFor(parentResult.value,property);}catch(e){return Err(UserException.from(e,`An error occured when setting a property on a deeply constant reactive (${getChildLabel(parentReactive,property)})`))}return Ok(void 0)}}});return initialize(child)}function initializeChildren(parent){let children=parent.properties;children===null&&(children=parent.properties=new Map);return children}function keyForPath(path){if(DEBUG){if(path[0]==="@")throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);if(typeof path!=="string")throw new Error("invalid non-string keypath: valid keys: @index, @identity, or a path")}return uniqueKeyFor((item=>getPath(item,path)))}function makeKeyFor(key){switch(key){case"@key":return uniqueKeyFor(KEY);case"@index":return uniqueKeyFor(INDEX);case"@identity":return uniqueKeyFor(IDENTITY);default:return keyForPath(key)}}function identityForNthOccurence(value,count){let identities=IDENTITIES.get(value);if(identities===void 0){identities=[];IDENTITIES.set(value,identities);}let identity=identities[count];if(identity===void 0){identity={value:value,count:count};identities[count]=identity;}return identity}function uniqueKeyFor(keyFor){let seen=new WeakMapWithPrimitives;return (value,memo)=>{let key=keyFor(value,memo);let count=seen.get(key)||0;seen.set(key,count+1);if(count===0)return key;return identityForNthOccurence(key,count)}}function createIteratorRef(listRef,key){return Formula((()=>{let iterable=unwrapReactive(listRef);let keyFor=makeKeyFor(key);if(Array.isArray(iterable))return new ArrayIterator(iterable,keyFor);let maybeIterator=toIterator(iterable);if(maybeIterator===null)return new ArrayIterator(EMPTY_ARRAY,(()=>null));return new IteratorWrapper(maybeIterator,keyFor)}))}function createIteratorItemRef(_value){let value=_value;let tag=createTag(devmode((()=>({reason:"formula",label:["(iterator)"]}))));return Accessor({get:()=>{consumeTag(tag);return value},set:newValue=>{if(value!==newValue){value=newValue;dirtyTag(tag);}}})}const describeReactive=enhancedDevmode((()=>"{reactive value}"),(reactive=>{const description=inDevmode(reactive.description);const types=inDevmode(TYPE_NAMES);const desc=description.type in types?types[description.type]:"reference";return description.label?`${desc} (\`${stringifyDebugLabel(reactive)}\`)`:desc}));const TYPE_NAMES=devmode((()=>({ReadonlyCell:"readonly cell",MutableCell:"mutable cell",DeeplyReadonlyCell:"deeply readonly cell",InfallibleFormula:"infallible formula",FallibleFormula:"fallible formula",Accessor:"accessor",GetProperty:"property reference",ConstantError:"constant error"})));const REFERENCE$1=Symbol("REFERENCE");const DEEPLY_CONSTANT=2;const FALLIBLE_FORMULA=3;const ACCESSOR=5;const MUTABLE_REF=6;const CONSTANT_ERROR=7;class InternalReactive{[REFERENCE$1];tag=null;lastRevision=INITIAL;error=null;lastValue;compute=null;update=null;properties=null;constructor(type){this[REFERENCE$1]=type;}}const RESULT_ACCESSOR_DEFAULTS=devmode((()=>({type:"ResultAccessor",read:"fallible",write:"fallible",label:["(ResultAccessor)"]})));const ACCESSOR_DEFAULTS=devmode((()=>({type:"Accessor",read:"fallible",write:"fallible",label:["(Accessor)"]})));const MUTABLE_CELL_DEFAULTS=devmode((()=>({type:"MutableCell",read:"infallible",write:"infallible",label:["{cell}"]})));const READONLY_CELL_DEFAULTS=devmode((()=>({type:"ReadonlyCell",read:"infallible",write:"none",label:["{readonly cell}"]})));const updateRef=updateReactive;const REFERENCE=REFERENCE$1;const FALLIBLE_FORMULA_DEFAULTS=devmode((()=>({type:"FallibleFormula",read:"fallible",write:"none",label:["(FallibleFormula)"]})));const RESULT_FORMULA_DEFAULTS=devmode((()=>({type:"ResultFormula",read:"fallible",write:"none",label:["{result formula}"]})));const COMPUTED_CELL_DEFAULTS=devmode((()=>({type:"InfallibleFormula",read:"infallible",write:"none",label:["{computed cell}"]})));const createDebugAliasRef=enhancedDevmode((inner=>inner),((inner,debugLabel)=>{const update=isUpdatableRef(inner)?value=>updateReactive(inner,value):null;const ref=update?Accessor({get:()=>unwrapReactive(inner),set:update},debugLabel()):Formula((()=>unwrapReactive(inner)),debugLabel());ref[REFERENCE$1]=inner[REFERENCE$1];const debug=inDevmode(inner.description);ref.description=devmode((()=>({type:"DebugAlias",read:debug.read,write:debug.write,property:debug.property,reason:"alias",label:[`{${inDevmode(stringifyDebugLabel(inner))} as ${debugLabel}}`]})));return ref}));const UNDEFINED_REFERENCE=createPrimitiveCell(void 0);const NULL_REFERENCE=createPrimitiveCell(null);const TRUE_REFERENCE=createPrimitiveCell(true);const FALSE_REFERENCE=createPrimitiveCell(false);const NULL_IDENTITY={};const KEY=(_,index)=>index;const INDEX=(_,index)=>String(index);const IDENTITY=item=>{if(item===null)return NULL_IDENTITY;return item};class WeakMapWithPrimitives{_weakMap;_primitiveMap;get weakMap(){this._weakMap===void 0&&(this._weakMap=new WeakMap);return this._weakMap}get primitiveMap(){this._primitiveMap===void 0&&(this._primitiveMap=new Map);return this._primitiveMap}set(key,value){isObject(key)?this.weakMap.set(key,value):this.primitiveMap.set(key,value);}get(key){return isObject(key)?this.weakMap.get(key):this.primitiveMap.get(key)}}const IDENTITIES=new WeakMapWithPrimitives;class IteratorWrapper{constructor(inner,keyFor){this.inner=inner;this.keyFor=keyFor;}isEmpty(){return this.inner.isEmpty()}next(){let nextValue=this.inner.next();nextValue!==null&&(nextValue.key=this.keyFor(nextValue.value,nextValue.memo));return nextValue}}class ArrayIterator{current;pos=0;constructor(iterator,keyFor){this.iterator=iterator;this.keyFor=keyFor;iterator.length===0?this.current={kind:"empty"}:this.current={kind:"first",value:iterator[this.pos]};}isEmpty(){return this.current.kind==="empty"}next(){let value;let current=this.current;if(current.kind==="first"){this.current={kind:"progress"};value=current.value;}else {if(this.pos>=this.iterator.length-1)return null;value=this.iterator[++this.pos];}let{keyFor:keyFor}=this;let key=keyFor(value,this.pos);let memo=this.pos;return {key:key,value:value,memo:memo}}}

export { Accessor, ComputedCell, DeeplyReadonlyCell, ExternalMarker, FALSE_REFERENCE, Formula, REFERENCE$1 as INTERNAL_REFERENCE, InternalResultAccessor, MutableCell, NULL_REFERENCE, REFERENCE, ReadonlyCell, ResultAccessor, ResultFormula, TRUE_REFERENCE, UNDEFINED_REFERENCE, clearError, createDebugAliasRef, createIteratorItemRef, createIteratorRef, createPrimitiveCell, getReactivePath, getReactiveProperty, hasError, initializeChildren, isAccessor, isConstant, isConstantError, isFallibleFormula, isMutRef, isUpdatableRef, readCell, readReactive, toMut, toReadonly, unwrapReactive, updateReactive, updateRef, validateReactive, writeCell };
