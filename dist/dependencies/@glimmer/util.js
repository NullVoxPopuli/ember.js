import { DEBUG } from '@glimmer/env';

function emptyArray(){return EMPTY_ARRAY}function isEmptyArray(input){return input===EMPTY_ARRAY}function isArray(value){return Array.isArray(value)}function*times(count){for(let i=0;i<count;i++)yield i;}function*range(start,end){for(let i=start;i<=end;i++)yield i;}function*reverse(input){for(let i=input.length-1;i>=0;i--)yield input[i];}function*enumerate(input){let i=0;for(const item of input)yield [i++,item];}function*enumerateReverse(input){for(let i=input.length-1;i>=0;i--)yield [i,input[i]];}function*zip(left,right){for(const[i,item]of enumerate(left))yield [item,right[i]];const excessStart=left.length;for(const item of right.slice(excessStart))yield [void 0,item];}function dict(){return Object.create(null)}function isDict(u){return u!==null&&u!==void 0}function isObject(u){return typeof u==="function"||typeof u==="object"&&u!==null}function isIndexable(u){return isObject(u)}function isCompilable(value){return !!(value&&typeof value==="object"&&IS_COMPILABLE_TEMPLATE in value)}function assertNever(value,desc="unexpected unreachable branch"){LOGGER.log("unreachable",value);LOGGER.log(`${desc} :: ${JSON.stringify(value)} (${value})`);throw new Error("code reached unreachable")}function unwrap(value){assert(value!==null&&value!==void 0,"expected value to be present");return value}function expect(value,message){assert(value!==null&&value!==void 0,message);return value}function assert(condition,msg){if(DEBUG&&!condition)throw new Error(msg||"assertion failure")}function deprecate(desc){LOCAL_LOGGER.warn(`DEPRECATION: ${desc}`);}function devmode(value){if(DEBUG)return intoDevMode(value());return}function enhancedDevmode(prod,dev){return DEBUG?dev:prod}function intoDevMode(devmodeValue){return devmodeValue instanceof DevMode?devmodeValue:new DevMode(devmodeValue)}function mapDevmode(value,map){if(DEBUG){const devmodeValue=inDevmode(value());const innerValue=devmodeValue instanceof DevMode?DevMode.value(devmodeValue):devmodeValue;return intoDevMode(map(innerValue))}return}function devmodeOr(value,inProd){return DEBUG?inDevmode(value()):inProd}function inDevmode(devmode){if(DEBUG){assert(DevMode,"Expected the DevMode class to be present in development mode");assert(devmode&&devmode instanceof DevMode,"Expected value to be present in development mode");return DevMode.value(devmode)}throw Error("You shouldn't use devmode values in production mode. This function should even be present in production mode (it should be stripped due to lack of use), so something is wrong.")}function stringifyDebugLabel(described){return mapDevmode((()=>described.description),(debug=>stringifyChildLabel(...debug.label)))}function stringifyChildLabel(...parts){assert(parts.every((part=>typeof part==="string"||typeof part==="symbol")),"Expected all parts to be strings or symbols");const[first,...rest]=parts;let out=first;for(const part of rest)typeof part==="string"?/^\p{XID_Start}\p{XID_Continue}*$/u.test(part)?out+=`.${part}`:out+=`[${JSON.stringify(part)}]`:out+=`[${String(part)}]`;return out}function getDescription(object){return mapDevmode((()=>object.description),(desc=>desc))}function createWithDescription(create,description){const object=create();setDescription(object,description);return object}function setDescription(object,description){DEBUG&&(object.description=description);}function toLabel(spec,defaultLabel){return devmode((()=>{if(!spec)return defaultLabel;return typeof spec==="string"?[spec]:spec}))}function toValidatableDescription(spec,defaults){return mapDevmode((()=>defaults),(defaults=>!isObject(spec)||isArray(spec)?{...defaults,label:inDevmode(toLabel(spec,defaults.label))}:{...defaults,...spec,label:typeof spec.label==="string"?[spec.label]:spec.label}))}function clearElement(parent){let current=parent.firstChild;while(current){let next=current.nextSibling;parent.removeChild(current);current=next;}}function isUserException(error){return error instanceof UserException}function isError(value){return isObject(value)&&value instanceof Error}function fullMessage(message,reactive){const label=reactive?stringifyDebugLabel(reactive):null;return label&&message.includes("%r")?message.replace("%r",`(${label})`):message}function isHandle(value){return value>=0}function isNonPrimitiveHandle(value){return value>3}function constants(...values){return [false,true,null,void 0,...values]}function isSmallInt(value){return value%1===0&&value<=MAX_INT&&value>=MIN_INT}function encodeNegative(num){return num&SIGN_BIT}function decodeNegative(num){return num|~SIGN_BIT}function encodePositive(num){return ~num}function decodePositive(num){return ~num}function encodeBoolean(bool){return bool|0}function decodeBoolean(num){return !!num}function encodeHandle(num){return num}function decodeHandle(num){return num}function encodeImmediate(num){num|=0;return num<0?encodeNegative(num):encodePositive(num)}function decodeImmediate(num){num|=0;return num>SIGN_BIT?decodePositive(num):decodeNegative(num)}function intern(str){let obj={};obj[str]=1;for(let key in obj)if(key===str)return key;return str}function isSerializationFirstNode(node){return node.nodeValue==="%+b:0%"}function array(){return {allocate:size=>Array(size).fill(null)}}function values(obj){return Object.values(obj)}function entries(dict){return Object.entries(dict)}function mapDict(dict,mapper){return Object.fromEntries(entries(dict).map((([k,v])=>[k,mapper(v)])))}function keys(obj){return Object.keys(obj)}function unreachable(message){if(DEBUG)throw new Error(message??"unreachable")}function exhausted(value){if(DEBUG)throw new Error(`Exhausted ${String(value)}`)}function Never(){return}function isPresent(value){return value!==null&&value!==void 0}function assertPresent(value,message){if(!isPresent(value))throw new Error(`Expected present, got ${typeof value==="string"?value:message}`)}function isPresentArray(list){return list.length>0}function ifPresent(list,ifPresent,otherwise){return isPresentArray(list)?ifPresent(list):otherwise()}function arrayToOption(list){return isPresentArray(list)?list:null}function assertPresentArray(list,message="unexpected empty list"){if(!isPresentArray(list))throw new Error(message)}function asPresentArray(list,message="unexpected empty list"){assertPresentArray(list,message);return list}function getLast(list){return list.length===0?void 0:list[list.length-1]}function getFirst(list){return list.length===0?void 0:list[0]}function mapPresentArray(list,mapper){if(list===null)return null;let out=[];for(let item of list)out.push(mapper(item));return out}function Ok(value){return {type:"ok",value:value}}function Err(value){return {type:"err",value:value}}function Results(results){const values=[];for(const result of results){if(result.type==="err")return result;values.push(result.value);}return {type:"ok",value:values}}function chainResult(value,mapper){return value.type==="ok"?mapper(value.value):value}function flattenResult(value){return value.type==="ok"?value.value:value}function mapResult(value,mapper){return value.type==="ok"?{type:"ok",value:mapper(value.value)}:value}function unwrapResult(value){switch(value.type){case"err":throw value.value;case"ok":return value.value}}function castToSimple(node){if(node===null)return null;return isDocument(node)||isSimpleElement(node),node}function castToBrowser(node,sugaryCheck){if(node===null||node===void 0)return null;if(typeof document==="undefined")throw new Error("Attempted to cast to a browser node in a non-browser context");if(isDocument(node))return node;if(node.ownerDocument!==document)throw new Error("Attempted to cast to a browser node with a node that was not created from this document");return checkBrowserNode(node,sugaryCheck)}function checkError(from,check){return new Error(`cannot cast a ${from} into ${String(check)}`)}function isDocument(node){return node.nodeType===DOCUMENT_NODE}function isSimpleElement(node){return node?.nodeType===ELEMENT_NODE}function isElement(node){return node?.nodeType===ELEMENT_NODE&&node instanceof Element}function checkBrowserNode(node,check){let isMatch=false;if(node!==null)if(typeof check==="string")isMatch=stringCheckNode(node,check);else {if(!Array.isArray(check))throw unreachable();isMatch=check.some((c=>stringCheckNode(node,c)));}if(isMatch&&node instanceof Node)return node;throw checkError(`SimpleElement(${node?.constructor?.name??"null"})`,check)}function stringCheckNode(node,check){switch(check){case"NODE":return true;case"HTML":return node instanceof HTMLElement;case"SVG":return node instanceof SVGElement;case"ELEMENT":return node instanceof Element;default:if(check.toUpperCase()===check)throw new Error("BUG: this code is missing handling for a generic node type");return node instanceof Element&&node.tagName.toLowerCase()===check}}function parentDebugFrames(label,aspects){const record=mapDict(aspects,(v=>unwrap(v.debug).frames));const frames=[];for(const[i,[k,aspectFrames]]of enumerate(entries(record))){i>=frames.length&&frames.push({label:label,aspects:{}});const frame=unwrap(frames[i]);const aspectFrame=aspectFrames[i];aspectFrame?frame.aspects[k]=aspectFrame:LOCAL_LOGGER.warn(`didn't find frames for ${k}`);}return {label:label,frames:frames}}function strip(strings,...args){let out="";for(const[i,string]of enumerate(strings)){let dynamic=args[i]!==void 0?String(args[i]):"";out+=`${string}${dynamic}`;}let lines=out.split("\n");while(isPresentArray(lines)&&/^\s*$/u.test(getFirst(lines)))lines.shift();while(isPresentArray(lines)&&/^\s*$/u.test(getLast(lines)))lines.pop();let min=1/0;for(let line of lines){let leading=/^\s*/u.exec(line)[0].length;min=Math.min(min,leading);}let stripped=[];for(let line of lines)stripped.push(line.slice(min));return stripped.join("\n")}function unwrapHandle(handle){if(typeof handle==="number")return handle;{let error=handle.errors[0];throw new Error(`Compile Error: ${error.problem} @ ${error.span.start}..${error.span.end}`)}}function unwrapTemplate(template){if(template.result==="error")throw new Error(`Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`);return template}function extractHandle(handle){return typeof handle==="number"?handle:handle.handle}function isOkHandle(handle){return typeof handle==="number"}function isErrHandle(handle){return typeof handle==="number"}function buildUntouchableThis(source){let context=null;if(DEBUG){let assertOnProperty=property=>{let access=typeof property==="symbol"||typeof property==="number"?`[${String(property)}]`:`.${property}`;throw new Error(`You accessed \`this${access}\` from a function passed to the ${source}, but the function itself was not bound to a valid \`this\` context. Consider updating to use a bound function (for instance, use an arrow function, \`() => {}\`).`)};context=new Proxy({},{get(_target,property){assertOnProperty(property);},set(_target,property){assertOnProperty(property);return false},has(_target,property){assertOnProperty(property);return false}});}return context}const EMPTY_ARRAY=function(value){if(DEBUG)return Object.freeze(value);return value}([]);const EMPTY_STRING_ARRAY=emptyArray();const EMPTY_NUMBER_ARRAY=emptyArray();const IS_COMPILABLE_TEMPLATE=Symbol("IS_COMPILABLE_TEMPLATE");const LOCAL_LOGGER=console;const LOGGER=console;let DevMode;DEBUG&&(DevMode=class{static value(devmode){expect(devmode,"Expected value to be present in development mode");return devmode.#value}#value;constructor(val){assert(val!==void 0,"You cannot put undefined in a DevMode");this.#value=val;}toString(){return String(this.#value)}});let beginTestSteps;let endTestSteps;let verifySteps;let logStep;let debugToString;if(DEBUG){let getFunctionName=fn=>{let functionName=fn.name;if(functionName===void 0){let match=/function (\w+)\s*\(/u.exec(String(fn));functionName=match&&match[1]||"";}return functionName.replace(/^bound /u,"")};let getObjectName=obj=>{let name;let className;obj.constructor&&typeof obj.constructor==="function"&&(className=getFunctionName(obj.constructor));"toString"in obj&&obj.toString!==Object.prototype.toString&&obj.toString!==Function.prototype.toString&&(name=obj.toString());if(name&&/<.*:ember\d+>/u.test(name)&&className&&className[0]!=="_"&&className.length>2&&className!=="Class")return name.replace(/<.*:/u,`<${className}:`);return name||className};let getPrimitiveName=value=>String(value);debugToString=value=>typeof value==="function"?getFunctionName(value)||"(unknown function)":typeof value==="object"&&value!==null?getObjectName(value)||"(unknown object)":getPrimitiveName(value);}var debugToString$1=debugToString;const RAW_NODE=-1;const ELEMENT_NODE=1;const TEXT_NODE=3;const COMMENT_NODE=8;const DOCUMENT_NODE=9;const DOCUMENT_TYPE_NODE=10;const DOCUMENT_FRAGMENT_NODE=11;const NS_HTML="http://www.w3.org/1999/xhtml";const NS_MATHML="http://www.w3.org/1998/Math/MathML";const NS_SVG="http://www.w3.org/2000/svg";const NS_XLINK="http://www.w3.org/1999/xlink";const NS_XML="http://www.w3.org/XML/1998/namespace";const NS_XMLNS="http://www.w3.org/2000/xmlns/";const INSERT_BEFORE_BEGIN="beforebegin";const INSERT_AFTER_BEGIN="afterbegin";const INSERT_BEFORE_END="beforeend";const INSERT_AFTER_END="afterend";class EarlyError extends Error{static reactive(message,reactive){return new EarlyError(message,reactive)}reactive;constructor(message,reactive=null){super(fullMessage(message,reactive));this.reactive=reactive;}}class UserException extends Error{static from(exception,defaultMessage){return isObject(exception)&&exception instanceof UserException?exception:new UserException(exception,defaultMessage)}#error;#exception;constructor(exception,defaultMessage){const error=isError(exception)?exception:void 0;const message=error?.message??defaultMessage;super(message);if(error){this.#error=error;this.cause=error;}else this.#error=void 0;}get error(){return this.#error}get exception(){return this.#exception}}const MAX_SMI=2**30-1;const MIN_SMI=-1073741824;const SIGN_BIT=~(2**29);const MAX_INT=~SIGN_BIT-1;const MIN_INT=~MAX_INT;const FALSE_HANDLE=0;const TRUE_HANDLE=1;const NULL_HANDLE=2;const UNDEFINED_HANDLE=3;[1,-1].forEach((x=>decodeImmediate(encodeImmediate(x))));const SERIALIZATION_FIRST_NODE_STRING="%+b:0%";let assign=Object.assign;class AbstractStack{#stack;#parent;constructor(stack,parent,label){this.#stack=stack;this.#parent=parent;DEBUG&&(this.label=label);}get debug(){const parentFrames=this.#parent?.debug.frames??[];return {frames:[...parentFrames,{label:this.label??"stack",values:this.#stack}]}}*[Symbol.iterator](){yield*this.#stack;}get current(){if(this.#stack.length===0&&this.#parent)return this.#parent.current;return this.#stack.at(-1)??null}get size(){return this.#stack.length+(this.#parent?this.#parent.size:0)}get hasParent(){return !!this.#parent}get frameHasItems(){return this.#stack.length>0}begin(){return this.child()}catch(){assert(this.#parent,`${this.label??"Stack"}: Expected a parent frame in unwind`);return this.#parent}finally(){assert(this.#stack.length===0,`${this.label??"Stack"}: Expected an empty frame in finally `);assert(this.#parent,`${this.label??"Stack"}: Expected a parent frame in finally`);return this.#parent}push(item){this.#stack.push(item);}pop(){assert(!(!this.frameHasItems&&this.#parent),`BUG: Unbalanced frame in ${this.label??"stack"}: attempted to pop an item but no item was pushed. Call unwind() or finally() first`);assert(this.frameHasItems,`BUG: Unbalanced ${this.label??"stack"}: attempted to pop an item but no item was pushed`);return this.#stack.pop()??null}nth(from){assert(from<this.size,`Index ${from} is out of bounds`);return from<this.#stack.length?this.#stack.at(-from-1):this.#parent?this.#parent.nth(from-this.#stack.length):null}toArray(){const prefix=this.#parent?[...this.#parent.toArray()]:[];return [...prefix,...this.#stack]}}class StackImpl extends AbstractStack{static empty(label){return new StackImpl([],null,label)}child(){return new StackImpl([],this,this.label)}}class BalancedStack extends AbstractStack{static empty(label){return DEBUG?new BalancedStack([],null,label??"balanced stack"):new BalancedStack([],null)}static initial(value,label){return DEBUG?new BalancedStack([value],null,label):new BalancedStack([value],null)}child(){return new BalancedStack([],this,this.label)}get present(){assert(this.current,`BUG: Expected an item in the ${this.label??"stack"}`);return this.current}}class PresentStack extends AbstractStack{static initial(value,label){return DEBUG?new PresentStack([value],null,label??"present stack"):new PresentStack([value],null)}child(){return new PresentStack([],this,this.label)}pop(){try{return super.pop()}finally{assert(super.size>0,`BUG: You should never pop the last item from a ${this.label??"PresentStack"}`);}}}const Stack=StackImpl;const NODE_TYPE={ELEMENT:1,RAW:-1,TEXT:3,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11};

export { BalancedStack, COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, ELEMENT_NODE, EMPTY_ARRAY, EMPTY_NUMBER_ARRAY, EMPTY_STRING_ARRAY, EarlyError, Err, FALSE_HANDLE, INSERT_AFTER_BEGIN, INSERT_AFTER_END, INSERT_BEFORE_BEGIN, INSERT_BEFORE_END, IS_COMPILABLE_TEMPLATE, LOCAL_LOGGER, LOGGER, MAX_INT, MAX_SMI, MIN_INT, MIN_SMI, NODE_TYPE, NS_HTML, NS_MATHML, NS_SVG, NS_XLINK, NS_XML, NS_XMLNS, NULL_HANDLE, Never, Ok, PresentStack, RAW_NODE, Results, SERIALIZATION_FIRST_NODE_STRING, Stack, StackImpl, TEXT_NODE, TRUE_HANDLE, UNDEFINED_HANDLE, UserException, array, arrayToOption, asPresentArray, assert, assertNever, assertPresent, assertPresentArray, assign, beginTestSteps, buildUntouchableThis, castToBrowser, castToSimple, chainResult, checkBrowserNode as checkNode, clearElement, constants, createWithDescription, debugToString$1 as debugToString, decodeBoolean, decodeHandle, decodeImmediate, decodeNegative, decodePositive, deprecate, devmode, devmodeOr, dict, emptyArray, encodeBoolean, encodeHandle, encodeImmediate, encodeNegative, encodePositive, endTestSteps, enhancedDevmode, entries, enumerate, enumerateReverse, exhausted, expect, extractHandle, flattenResult, getDescription, getFirst, getLast, ifPresent, inDevmode, intern, isArray, isCompilable, isDict, isElement, isEmptyArray, isErrHandle, isError, isHandle, isIndexable, isNonPrimitiveHandle, isObject, isOkHandle, isPresent, isPresentArray, isSerializationFirstNode, isSimpleElement, isSmallInt, isUserException, keys, logStep, mapDevmode, mapPresentArray, mapResult, parentDebugFrames, range, reverse, setDescription, stringifyChildLabel, stringifyDebugLabel, strip, times, toLabel, toValidatableDescription, unreachable, unwrap, unwrapHandle, unwrapResult, unwrapTemplate, values, verifySteps, zip };
